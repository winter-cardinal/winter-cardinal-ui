/*
 Winter Cardinal UI v0.450.1
 Copyright (C) 2019 Toshiba Corporation
 SPDX-License-Identifier: Apache-2.0

 Material Design icons by Google
 Apache license version 2.0.
*/
(function (pixi_js) {
    'use strict';

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * Mappings of shape types and deserializers.
     */
    var EShapeDeserializers = {};
    /**
     * Mappings of shape types and `onDeserialized` handlers.
     */
    var EShapeOnDeserializeds = {};

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeType = {
        CIRCLE: 0,
        RECTANGLE: 1,
        RECTANGLE_ROUNDED: 2,
        TRIANGLE: 3,
        TRIANGLE_ROUNDED: 4,
        LINE: 5,
        IMAGE: 6,
        IMAGE_SDF: 7,
        GROUP: 8,
        BAR: 9,
        LABEL: 10,
        NULL: 11,
        GROUP_SHADOWED: 12,
        LINE_OF_CIRCLES: 13,
        LINE_OF_RECTANGLES: 14,
        LINE_OF_RECTANGLE_ROUNDEDS: 15,
        LINE_OF_TRIANGLES: 16,
        LINE_OF_TRIANGLE_ROUNDEDS: 17,
        EMBEDDED: 18,
        EMBEDDED_LAYER: 19,
        BUTTON: 20,
        RECTANGLE_PIVOTED: 21,
        CONNECTOR_LINE: 22,
        CONNECTOR_ELBOW: 23,
        SEMICIRCLE: 24,
        EMBEDDED_ACCEPTOR_EDGE: 25,
        EXTENSION: 1000
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeUploadeds = {};

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeUploadedImpl = /** @class */ (function () {
        function EShapeUploadedImpl(buffer, vertexOffset, indexOffset, vertexCount, indexCount, builders) {
            this._builders = builders;
            this._vertexOffset = vertexOffset;
            this._indexOffset = indexOffset;
            this._vertexCount = vertexCount;
            this._indexCount = indexCount;
        }
        EShapeUploadedImpl.prototype.init = function (shape) {
            shape.uploaded = this;
            var builders = this._builders;
            for (var i = 0, imax = builders.length; i < imax; ++i) {
                builders[i].init();
            }
            this.update(shape);
            return this;
        };
        EShapeUploadedImpl.prototype.reinit = function (buffer, shape, vertexOffset, indexOffset) {
            var builders = this._builders;
            var voffset = vertexOffset;
            var ioffset = indexOffset;
            for (var i = 0, imax = builders.length; i < imax; ++i) {
                var builder = builders[i];
                if (!builder.reinit(buffer, shape, voffset, ioffset)) {
                    return false;
                }
                var vertexCount = builder.vertexCount;
                var indexCount = builder.indexCount;
                voffset += vertexCount;
                ioffset += indexCount;
            }
            this._vertexCount = voffset - vertexOffset;
            this._indexCount = ioffset - indexOffset;
            this.update(shape);
            return true;
        };
        EShapeUploadedImpl.prototype.update = function (shape) {
            var builders = this._builders;
            for (var i = 0, imax = builders.length; i < imax; ++i) {
                builders[i].update(shape);
            }
            return this;
        };
        EShapeUploadedImpl.prototype.isCompatible = function (shape) {
            var builders = this._builders;
            for (var i = 0, imax = builders.length; i < imax; ++i) {
                if (!builders[i].isCompatible(shape)) {
                    return false;
                }
            }
            return true;
        };
        EShapeUploadedImpl.prototype.getVertexOffset = function () {
            return this._vertexOffset;
        };
        EShapeUploadedImpl.prototype.getVertexCount = function () {
            return this._vertexCount;
        };
        EShapeUploadedImpl.prototype.getIndexOffset = function () {
            return this._indexOffset;
        };
        EShapeUploadedImpl.prototype.getIndexCount = function () {
            return this._indexCount;
        };
        EShapeUploadedImpl.prototype.buildUnit = function (builder) {
            var builders = this._builders;
            for (var i = 0, imax = builders.length; i < imax; ++i) {
                builders[i].buildUnit(builder);
            }
        };
        return EShapeUploadedImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var NON_EXPANDING_WIDTH$1 = 2;
    var NON_SHRINKING_WIDTH$1 = 4;
    var NON_SCALING_DOT_AND_DASH$1 = 8;
    var DOTTED$1 = 16;
    var DOTTED_DENSELY$1 = 32;
    var DOTTED_LOOSELY$1 = 64;
    var DASHED$1 = 128;
    var DASHED_DENSELY$1 = 256;
    var DASHED_LOOSELY$1 = 512;
    var EShapeStrokeStyle = {
        NONE: 0,
        NON_EXPANDING_WIDTH: NON_EXPANDING_WIDTH$1,
        NON_SHRINKING_WIDTH: NON_SHRINKING_WIDTH$1,
        NON_SCALING_DOT_AND_DASH: NON_SCALING_DOT_AND_DASH$1,
        NON_SCALING: NON_EXPANDING_WIDTH$1 | NON_SHRINKING_WIDTH$1 | NON_SCALING_DOT_AND_DASH$1,
        NON_SCALING_MASK: NON_EXPANDING_WIDTH$1 | NON_SHRINKING_WIDTH$1 | NON_SCALING_DOT_AND_DASH$1,
        DOTTED: DOTTED$1,
        DOTTED_DENSELY: DOTTED_DENSELY$1,
        DOTTED_LOOSELY: DOTTED_LOOSELY$1,
        DOTTED_MASK: DOTTED$1 | DOTTED_DENSELY$1 | DOTTED_LOOSELY$1,
        DASHED: DASHED$1,
        DASHED_DENSELY: DASHED_DENSELY$1,
        DASHED_LOOSELY: DASHED_LOOSELY$1,
        DASHED_MASK: DASHED$1 | DASHED_DENSELY$1 | DASHED_LOOSELY$1
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var toDash = function (style) {
        if (style & EShapeStrokeStyle.DOTTED_MASK) {
            if (style & EShapeStrokeStyle.DOTTED) {
                return 1;
            }
            else if (style & EShapeStrokeStyle.DOTTED_DENSELY) {
                return 2;
            }
            else {
                return 3;
            }
        }
        else if (style & EShapeStrokeStyle.DASHED_MASK) {
            if (style & EShapeStrokeStyle.DASHED) {
                return 4;
            }
            else if (style & EShapeStrokeStyle.DASHED_DENSELY) {
                return 5;
            }
            else {
                return 6;
            }
        }
        else {
            return 0;
        }
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var toScaleInvariant = function (style) {
        var nonExpandingWidth = style & EShapeStrokeStyle.NON_EXPANDING_WIDTH ? 1 : 0;
        var nonShrinkingWidth = style & EShapeStrokeStyle.NON_SHRINKING_WIDTH ? 2 : 0;
        var nonScalingDotAndDash = style & EShapeStrokeStyle.NON_SCALING_DOT_AND_DASH ? 4 : 0;
        if (style & (EShapeStrokeStyle.DOTTED_MASK || EShapeStrokeStyle.DASHED_MASK)) {
            return nonExpandingWidth | nonShrinkingWidth | nonScalingDotAndDash;
        }
        else {
            return nonExpandingWidth | nonShrinkingWidth;
        }
    };

    var toVector = function (x0, y0, x1, y1, result) {
        result[0] = x1 - x0;
        result[1] = y1 - y0;
        return result;
    };

    var toNormal = function (v, l) {
        if (0.00001 < l) {
            var f = 1 / l;
            var v0 = v[0] * f;
            var v1 = v[1] * f;
            v[0] = -v1;
            v[1] = +v0;
        }
        else {
            v[0] = 0;
            v[1] = 1;
        }
        return v;
    };

    var toNormalPacked = function (n0, n1) {
        var x = Math.round(511.5 * (1 + n0[0]));
        var y = Math.round(511.5 * (1 + n1[0]));
        var z = (0 <= n0[1] ? 1 : 0) + (0 <= n1[1] ? 2 : 0);
        return x + (y << 10) + (z << 20);
    };

    var toPackedI4x64 = function (i0, i1, i2, i3) {
        return i0 + (i1 << 6) + (i2 << 12) + (i3 << 18);
    };
    var toPackedF2x1024 = function (f0, f1) {
        return Math.round(1023 * f0) + (Math.round(1023 * f1) << 10);
    };

    var BAR_VERTEX_COUNT = 4;
    var BAR_INDEX_COUNT = 2;
    var BAR_NPREV = [0, 1];
    var BAR_NNEXT = [0, 1];
    var BAR_FMIN = 0.00001;
    var buildBarIndex = function (indices, voffset, ioffset) {
        var ii = ioffset * 3 - 1;
        indices[++ii] = voffset;
        indices[++ii] = voffset + 2;
        indices[++ii] = voffset + 1;
        indices[++ii] = voffset + 1;
        indices[++ii] = voffset + 2;
        indices[++ii] = voffset + 3;
    };
    var buildBarVertexStep = function (vertices, steps, voffset, pointValues, pointsSize, strokeWidth, strokeStyle, internalTransform) {
        // First point
        var a = internalTransform.a;
        var b = internalTransform.b;
        var c = internalTransform.c;
        var d = internalTransform.d;
        var tx = internalTransform.tx;
        var ty = internalTransform.ty;
        var pv0 = pointValues[0];
        var pv1 = pointValues[1];
        var p1x = a * pv0 + c * pv1 + tx;
        var p1y = b * pv0 + d * pv1 + ty;
        // Last point
        var pv2 = pointValues[2];
        var pv3 = pointValues[3];
        var p2x = a * pv2 + c * pv3 + tx;
        var p2y = b * pv2 + d * pv3 + ty;
        // Normal
        var dx = p2x - p1x;
        var dy = p2y - p1y;
        var distance = Math.sqrt(dx * dx + dy * dy);
        var l = distance;
        if (0 <= pointsSize && BAR_FMIN < distance) {
            var ratio = pointsSize / distance;
            dx *= ratio;
            dy *= ratio;
            p2x = p1x + dx;
            p2y = p1y + dy;
            l = pointsSize;
        }
        var nprev = BAR_NPREV;
        var nnext = BAR_NNEXT;
        toVector(p1x - dx, p1y - dy, p1x, p1y, nprev);
        toVector(p1x, p1y, p2x, p2y, nnext);
        toNormal(nprev, l);
        toNormal(nnext, l);
        var packed = toNormalPacked(nprev, nnext);
        //
        var scaleInvariant = toScaleInvariant(strokeStyle);
        var dash = toDash(strokeStyle);
        var e3 = toPackedI4x64(3, scaleInvariant, dash, 0);
        var e5 = toPackedI4x64(5, scaleInvariant, dash, 0);
        var iv = (voffset << 1) - 1;
        var is = voffset * 6 - 1;
        vertices[++iv] = p1x;
        vertices[++iv] = p1y;
        vertices[++iv] = p1x;
        vertices[++iv] = p1y;
        steps[++is] = strokeWidth;
        steps[++is] = e3;
        steps[++is] = packed;
        steps[++is] = 0;
        steps[++is] = l;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = e5;
        steps[++is] = packed;
        steps[++is] = 0;
        steps[++is] = l;
        steps[++is] = 0;
        vertices[++iv] = p2x;
        vertices[++iv] = p2y;
        vertices[++iv] = p2x;
        vertices[++iv] = p2y;
        steps[++is] = strokeWidth;
        steps[++is] = e3;
        steps[++is] = packed;
        steps[++is] = l;
        steps[++is] = l;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = e5;
        steps[++is] = packed;
        steps[++is] = l;
        steps[++is] = l;
        steps[++is] = 0;
    };
    var buildBarUv = function (uvs, voffset, textureUvs) {
        var iuv = (voffset << 1) - 1;
        uvs[++iuv] = textureUvs.x0;
        uvs[++iuv] = textureUvs.y0;
        uvs[++iuv] = textureUvs.x3;
        uvs[++iuv] = textureUvs.y3;
        uvs[++iuv] = textureUvs.x1;
        uvs[++iuv] = textureUvs.y1;
        uvs[++iuv] = textureUvs.x2;
        uvs[++iuv] = textureUvs.y2;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeTextWeight = {
        NORMAL: 0,
        BOLD: 1
    };
    var EShapeTextStyle = {
        NORMAL: 0,
        ITALIC: 1
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeTextAlignHorizontal = {
        LEFT: 0,
        CENTER: 1,
        RIGHT: 2,
        OUTSIDE_LEFT: 3,
        OUTSIDE_RIGHT: 4
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeTextAlignVertical = {
        TOP: 0,
        MIDDLE: 1,
        BOTTOM: 2,
        OUTSIDE_TOP: 3,
        OUTSIDE_BOTTOM: 4
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeTextDirection = {
        LEFT_TO_RIGHT: 0,
        TOP_TO_BOTTOM: 1,
        BOTTOM_TO_TOP: 2,
        RIGHT_TO_LEFT: 3
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var toLength = function (p0x, p0y, p1x, p1y) {
        var dx01 = p1x - p0x;
        var dy01 = p1y - p0y;
        return Math.sqrt(dx01 * dx01 + dy01 * dy01);
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var Character = {
        ASCII: "!\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~",
        SPACE: " ",
        TAB: "\t",
        SOFT_TAB: "    ",
        DOTS: "...",
        NEW_LINE: "\n"
    };

    var TEXT_VERTEX_COUNT = 4;
    var TEXT_VERTEX_COUNT_SHIFT = 2;
    var TEXT_INDEX_COUNT = 2;
    var TEXT_INDEX_COUNT_SHIFT = 1;
    var TEXT_FMIN = 0.00001;
    var TEXT_WORK_POINT = new pixi_js.Point();
    var toTextBufferCount = function (shape) {
        var l = shape.text.plength;
        return ((l >> 3) + (0 < (l & 0x7) ? 1 : 0)) << 3;
    };
    var buildTextIndex = function (indices, voffset, ioffset, icount) {
        var ii = ioffset * 3 - 1;
        var iimax = (ioffset + icount) * 3 - 1;
        var iv = voffset;
        for (; ii < iimax;) {
            indices[++ii] = iv;
            indices[++ii] = iv + 1;
            indices[++ii] = iv + 3;
            indices[++ii] = iv + 1;
            indices[++ii] = iv + 2;
            indices[++ii] = iv + 3;
            iv += 4;
        }
    };
    var buildTextStep = function (steps, voffset, vcount, textAtlas, textSize, textOutlineWidth, textWeight, scaleX, scaleY) {
        var is = voffset * 6 - 1;
        var ismax = (voffset + vcount) * 6 - 1;
        var scaleInvariant = toScaleInvariant(EShapeStrokeStyle.NONE);
        var e = toPackedI4x64(2, scaleInvariant, 1, 1);
        if (textAtlas != null) {
            var scale = textAtlas.font.size / (textSize * (scaleX + scaleY) * 0.5);
            var position = textWeight === EShapeTextWeight.NORMAL ? 0.0 : 0.05;
            for (; is < ismax;) {
                steps[++is] = textOutlineWidth;
                steps[++is] = e;
                steps[++is] = scale;
                steps[++is] = 0;
                steps[++is] = position;
                steps[++is] = 0;
            }
        }
        else {
            for (; is < ismax;) {
                steps[++is] = 0;
                steps[++is] = e;
                steps[++is] = 0;
                steps[++is] = 0;
                steps[++is] = 0;
                steps[++is] = 0;
            }
        }
    };
    var getTextBBox = function (halign, valign, hoffset, voffset, hpadding, vpadding, width, height, x0, y0, x1, y1, x2, y2, x3, y3, hnx, hny, vnx, vny, result) {
        switch (halign) {
            case EShapeTextAlignHorizontal.LEFT:
                switch (valign) {
                    case EShapeTextAlignVertical.TOP:
                        result.x = x0 + hnx * (hoffset + hpadding) + vnx * (voffset + vpadding);
                        result.y = y0 + hny * (hoffset + hpadding) + vny * (voffset + vpadding);
                        break;
                    case EShapeTextAlignVertical.MIDDLE:
                        result.x =
                            0.5 * (x0 + x3) +
                                hnx * (hoffset + hpadding) +
                                vnx * (voffset - 0.5 * height);
                        result.y =
                            0.5 * (y0 + y3) +
                                hny * (hoffset + hpadding) +
                                vny * (voffset - 0.5 * height);
                        break;
                    case EShapeTextAlignVertical.BOTTOM:
                        result.x =
                            x3 + hnx * (hoffset + hpadding) + vnx * (voffset - vpadding - height);
                        result.y =
                            y3 + hny * (hoffset + hpadding) + vny * (voffset - vpadding - height);
                        break;
                    case EShapeTextAlignVertical.OUTSIDE_TOP:
                        result.x =
                            x0 + hnx * (hoffset + hpadding) + vnx * (voffset - vpadding - height);
                        result.y =
                            y0 + hny * (hoffset + hpadding) + vny * (voffset - vpadding - height);
                        break;
                    case EShapeTextAlignVertical.OUTSIDE_BOTTOM:
                        result.x = x3 + hnx * (hoffset + hpadding) + vnx * (voffset + vpadding);
                        result.y = y3 + hny * (hoffset + hpadding) + vny * (voffset + vpadding);
                        break;
                }
                break;
            case EShapeTextAlignHorizontal.CENTER:
                switch (valign) {
                    case EShapeTextAlignVertical.TOP:
                        result.x =
                            0.5 * (x0 + x1) +
                                hnx * (hoffset - 0.5 * width) +
                                vnx * (voffset + vpadding);
                        result.y =
                            0.5 * (y0 + y1) +
                                hny * (hoffset - 0.5 * width) +
                                vny * (voffset + vpadding);
                        break;
                    case EShapeTextAlignVertical.MIDDLE:
                        result.x =
                            0.5 * (x0 + x2) +
                                hnx * (hoffset - 0.5 * width) +
                                vnx * (voffset - 0.5 * height);
                        result.y =
                            0.5 * (y0 + y2) +
                                hny * (hoffset - 0.5 * width) +
                                vny * (voffset - 0.5 * height);
                        break;
                    case EShapeTextAlignVertical.BOTTOM:
                        result.x =
                            0.5 * (x3 + x2) +
                                hnx * (hoffset - 0.5 * width) +
                                vnx * (voffset - vpadding - height);
                        result.y =
                            0.5 * (y3 + y2) +
                                hny * (hoffset - 0.5 * width) +
                                vny * (voffset - vpadding - height);
                        break;
                    case EShapeTextAlignVertical.OUTSIDE_TOP:
                        result.x =
                            0.5 * (x0 + x1) +
                                hnx * (hoffset - 0.5 * width) +
                                vnx * (voffset - vpadding - height);
                        result.y =
                            0.5 * (y0 + y1) +
                                hny * (hoffset - 0.5 * width) +
                                vny * (voffset - vpadding - height);
                        break;
                    case EShapeTextAlignVertical.OUTSIDE_BOTTOM:
                        result.x =
                            0.5 * (x3 + x2) +
                                hnx * (hoffset - 0.5 * width) +
                                vnx * (voffset + vpadding);
                        result.y =
                            0.5 * (y3 + y2) +
                                hny * (hoffset - 0.5 * width) +
                                vny * (voffset + vpadding);
                        break;
                }
                break;
            case EShapeTextAlignHorizontal.RIGHT:
                switch (valign) {
                    case EShapeTextAlignVertical.TOP:
                        result.x = x1 + hnx * (hoffset - hpadding - width) + vnx * (voffset + vpadding);
                        result.y = y1 + hny * (hoffset - hpadding - width) + vny * (voffset + vpadding);
                        break;
                    case EShapeTextAlignVertical.MIDDLE:
                        result.x =
                            0.5 * (x1 + x2) +
                                hnx * (hoffset - hpadding - width) +
                                vnx * (voffset - 0.5 * height);
                        result.y =
                            0.5 * (y1 + y2) +
                                hny * (hoffset - hpadding - width) +
                                vny * (voffset - 0.5 * height);
                        break;
                    case EShapeTextAlignVertical.BOTTOM:
                        result.x =
                            x2 +
                                hnx * (hoffset - hpadding - width) +
                                vnx * (voffset - vpadding - height);
                        result.y =
                            y2 +
                                hny * (hoffset - hpadding - width) +
                                vny * (voffset - vpadding - height);
                        break;
                    case EShapeTextAlignVertical.OUTSIDE_TOP:
                        result.x =
                            x1 +
                                hnx * (hoffset - hpadding - width) +
                                vnx * (voffset - vpadding - height);
                        result.y =
                            y1 +
                                hny * (hoffset - hpadding - width) +
                                vny * (voffset - vpadding - height);
                        break;
                    case EShapeTextAlignVertical.OUTSIDE_BOTTOM:
                        result.x = x2 + hnx * (hoffset - hpadding - width) + vnx * (voffset + vpadding);
                        result.y = y2 + hny * (hoffset - hpadding - width) + vny * (voffset + vpadding);
                        break;
                }
                break;
            case EShapeTextAlignHorizontal.OUTSIDE_LEFT:
                switch (valign) {
                    case EShapeTextAlignVertical.TOP:
                        result.x = x0 + hnx * (hoffset - hpadding - width) + vnx * (voffset + vpadding);
                        result.y = y0 + hny * (hoffset - hpadding - width) + vny * (voffset + vpadding);
                        break;
                    case EShapeTextAlignVertical.MIDDLE:
                        result.x =
                            0.5 * (x0 + x3) +
                                hnx * (hoffset - hpadding - width) +
                                vnx * (voffset - 0.5 * height);
                        result.y =
                            0.5 * (y0 + y3) +
                                hny * (hoffset - hpadding - width) +
                                vny * (voffset - 0.5 * height);
                        break;
                    case EShapeTextAlignVertical.BOTTOM:
                        result.x =
                            x3 +
                                hnx * (hoffset - hpadding - width) +
                                vnx * (voffset - vpadding - height);
                        result.y =
                            y3 +
                                hny * (hoffset - hpadding - width) +
                                vny * (voffset - vpadding - height);
                        break;
                    case EShapeTextAlignVertical.OUTSIDE_TOP:
                        result.x =
                            x0 +
                                hnx * (hoffset - hpadding - width) +
                                vnx * (voffset - vpadding - height);
                        result.y =
                            y0 +
                                hny * (hoffset - hpadding - width) +
                                vny * (voffset - vpadding - height);
                        break;
                    case EShapeTextAlignVertical.OUTSIDE_BOTTOM:
                        result.x = x3 + hnx * (hoffset - hpadding - width) + vnx * (voffset + vpadding);
                        result.y = y3 + hny * (hoffset - hpadding - width) + vny * (voffset + vpadding);
                        break;
                }
                break;
            case EShapeTextAlignHorizontal.OUTSIDE_RIGHT:
                switch (valign) {
                    case EShapeTextAlignVertical.TOP:
                        result.x = x1 + hnx * (hoffset + hpadding) + vnx * (voffset + vpadding);
                        result.y = y1 + hny * (hoffset + hpadding) + vny * (voffset + vpadding);
                        break;
                    case EShapeTextAlignVertical.MIDDLE:
                        result.x =
                            0.5 * (x1 + x2) +
                                hnx * (hoffset + hpadding) +
                                vnx * (voffset - 0.5 * height);
                        result.y =
                            0.5 * (y1 + y2) +
                                hny * (hoffset + hpadding) +
                                vny * (voffset - 0.5 * height);
                        break;
                    case EShapeTextAlignVertical.BOTTOM:
                        result.x =
                            x2 + hnx * (hoffset + hpadding) + vnx * (voffset - vpadding - height);
                        result.y =
                            y2 + hny * (hoffset + hpadding) + vny * (voffset - vpadding - height);
                        break;
                    case EShapeTextAlignVertical.OUTSIDE_TOP:
                        result.x =
                            x1 + hnx * (hoffset + hpadding) + vnx * (voffset - vpadding - height);
                        result.y =
                            y1 + hny * (hoffset + hpadding) + vny * (voffset - vpadding - height);
                        break;
                    case EShapeTextAlignVertical.OUTSIDE_BOTTOM:
                        result.x = x2 + hnx * (hoffset + hpadding) + vnx * (voffset + vpadding);
                        result.y = y2 + hny * (hoffset + hpadding) + vny * (voffset + vpadding);
                        break;
                }
                break;
        }
    };
    var rotateAlignHorizontalRight = function (align) {
        switch (align) {
            case EShapeTextAlignHorizontal.LEFT:
                return EShapeTextAlignVertical.BOTTOM;
            case EShapeTextAlignHorizontal.CENTER:
                return EShapeTextAlignVertical.MIDDLE;
            case EShapeTextAlignHorizontal.RIGHT:
                return EShapeTextAlignVertical.TOP;
            case EShapeTextAlignHorizontal.OUTSIDE_LEFT:
                return EShapeTextAlignVertical.OUTSIDE_BOTTOM;
            case EShapeTextAlignHorizontal.OUTSIDE_RIGHT:
                return EShapeTextAlignVertical.OUTSIDE_TOP;
        }
    };
    var rotateAlignVerticalRight = function (align) {
        switch (align) {
            case EShapeTextAlignVertical.TOP:
                return EShapeTextAlignHorizontal.LEFT;
            case EShapeTextAlignVertical.MIDDLE:
                return EShapeTextAlignHorizontal.CENTER;
            case EShapeTextAlignVertical.BOTTOM:
                return EShapeTextAlignHorizontal.RIGHT;
            case EShapeTextAlignVertical.OUTSIDE_TOP:
                return EShapeTextAlignHorizontal.OUTSIDE_LEFT;
            case EShapeTextAlignVertical.OUTSIDE_BOTTOM:
                return EShapeTextAlignHorizontal.OUTSIDE_RIGHT;
        }
    };
    var rotateAlignHorizontalLeft = function (align) {
        switch (align) {
            case EShapeTextAlignHorizontal.LEFT:
                return EShapeTextAlignVertical.TOP;
            case EShapeTextAlignHorizontal.CENTER:
                return EShapeTextAlignVertical.MIDDLE;
            case EShapeTextAlignHorizontal.RIGHT:
                return EShapeTextAlignVertical.BOTTOM;
            case EShapeTextAlignHorizontal.OUTSIDE_LEFT:
                return EShapeTextAlignVertical.OUTSIDE_TOP;
            case EShapeTextAlignHorizontal.OUTSIDE_RIGHT:
                return EShapeTextAlignVertical.OUTSIDE_BOTTOM;
        }
    };
    var rotateAlignVerticalLeft = function (align) {
        switch (align) {
            case EShapeTextAlignVertical.TOP:
                return EShapeTextAlignHorizontal.RIGHT;
            case EShapeTextAlignVertical.MIDDLE:
                return EShapeTextAlignHorizontal.CENTER;
            case EShapeTextAlignVertical.BOTTOM:
                return EShapeTextAlignHorizontal.LEFT;
            case EShapeTextAlignVertical.OUTSIDE_TOP:
                return EShapeTextAlignHorizontal.OUTSIDE_RIGHT;
            case EShapeTextAlignVertical.OUTSIDE_BOTTOM:
                return EShapeTextAlignHorizontal.OUTSIDE_LEFT;
        }
    };
    var invertAlignHorizontal = function (align) {
        switch (align) {
            case EShapeTextAlignHorizontal.LEFT:
                return EShapeTextAlignHorizontal.RIGHT;
            case EShapeTextAlignHorizontal.CENTER:
                return EShapeTextAlignHorizontal.CENTER;
            case EShapeTextAlignHorizontal.RIGHT:
                return EShapeTextAlignHorizontal.LEFT;
            case EShapeTextAlignHorizontal.OUTSIDE_LEFT:
                return EShapeTextAlignHorizontal.OUTSIDE_RIGHT;
            case EShapeTextAlignHorizontal.OUTSIDE_RIGHT:
                return EShapeTextAlignHorizontal.OUTSIDE_LEFT;
        }
    };
    var invertAlignVertical = function (align) {
        switch (align) {
            case EShapeTextAlignVertical.TOP:
                return EShapeTextAlignVertical.BOTTOM;
            case EShapeTextAlignVertical.MIDDLE:
                return EShapeTextAlignVertical.MIDDLE;
            case EShapeTextAlignVertical.BOTTOM:
                return EShapeTextAlignVertical.TOP;
            case EShapeTextAlignVertical.OUTSIDE_TOP:
                return EShapeTextAlignVertical.OUTSIDE_BOTTOM;
            case EShapeTextAlignVertical.OUTSIDE_BOTTOM:
                return EShapeTextAlignVertical.OUTSIDE_TOP;
        }
    };
    var buildTextVertex = function (vertices, uvs, voffset, vcount, originX, originY, sizeX, sizeY, textAtlas, textSize, textCharacters, textStyle, textAlignHorizontal, textAlignVertical, textOffsetHorizontal, textOffsetVertical, textSpacingHorizontal, textSpacingVertical, textDirection, textPaddingHorizontal, textPaddingVertical, textClipping, textFitting, textWorld, textureUvs, internalTransform) {
        // Calculate the transformed positions
        //
        //  0               1
        // |---------------|
        // |               |
        // |3              |2
        // |---------------|
        //
        var sx = sizeX * 0.5;
        var sy = sizeY * 0.5;
        var a = internalTransform.a;
        var b = internalTransform.b;
        var c = internalTransform.c;
        var d = internalTransform.d;
        var tx = internalTransform.tx;
        var ty = internalTransform.ty;
        var ltx = originX - sx;
        var lty = originY - sy;
        var rtx = originX + sx;
        var rty = originY - sy;
        var rbx = originX + sx;
        var rby = originY + sy;
        var x0 = a * ltx + c * lty + tx;
        var y0 = b * ltx + d * lty + ty;
        var x1 = a * rtx + c * rty + tx;
        var y1 = b * rtx + d * rty + ty;
        var x2 = a * rbx + c * rby + tx;
        var y2 = b * rbx + d * rby + ty;
        var x3 = x0 + (x2 - x1);
        var y3 = y0 + (y2 - y1);
        // Horizontal normal
        var hl = toLength(x0, y0, x1, y1);
        var hnl = toLength(0, 0, a, b);
        var hnx = 1;
        var hny = 0;
        if (TEXT_FMIN < hnl) {
            var hnli = 1 / hnl;
            hnx = a * hnli;
            hny = b * hnli;
        }
        // Vertical normal
        var vl = toLength(x0, y0, x3, y3);
        var vnl = toLength(0, 0, c, d);
        var vnx = 0;
        var vny = 1;
        if (TEXT_FMIN < hnl) {
            var vnli = 1 / vnl;
            vnx = c * vnli;
            vny = d * vnli;
        }
        var work = TEXT_WORK_POINT;
        switch (textDirection) {
            case EShapeTextDirection.LEFT_TO_RIGHT:
                // DO NOTHING
                break;
            case EShapeTextDirection.TOP_TO_BOTTOM:
                work.set(vnx, vny);
                vnx = -hnx;
                vny = -hny;
                hnx = work.x;
                hny = work.y;
                work.x = vnl;
                vnl = hnl;
                hnl = work.x;
                break;
            case EShapeTextDirection.BOTTOM_TO_TOP:
                work.set(vnx, vny);
                vnx = hnx;
                vny = hny;
                hnx = -work.x;
                hny = -work.y;
                work.x = vnl;
                vnl = hnl;
                hnl = work.x;
                break;
            case EShapeTextDirection.RIGHT_TO_LEFT:
                hnx = -hnx;
                hny = -hny;
                vnx = -vnx;
                vny = -vny;
                break;
        }
        // Calculate the width / height
        var width = 0;
        var height = 0;
        var heightChar = 0;
        var textSizeY = textSize * vnl;
        var lineHeight = Math.max(0, textSize + textSpacingVertical) * vnl;
        var lineWidth = 0;
        var lineCount = 1;
        var textAtlasCharacters = textAtlas.characters;
        var advancePrevious = 0;
        for (var i = 0, imax = textCharacters.length; i < imax; ++i) {
            var character = textCharacters[i];
            if (character !== Character.NEW_LINE) {
                if (0 < advancePrevious) {
                    lineWidth += Math.max(0, advancePrevious + textSpacingHorizontal);
                }
                var data = textAtlasCharacters.get(character);
                if (data) {
                    advancePrevious = data.advance;
                    heightChar = data.height;
                }
                else {
                    advancePrevious = 0;
                }
            }
            else {
                lineWidth += advancePrevious;
                advancePrevious = 0;
                width = Math.max(width, lineWidth);
                lineWidth = 0;
                height += lineHeight;
                lineCount += 1;
            }
        }
        lineWidth += advancePrevious;
        width = Math.max(width, lineWidth);
        height += textSizeY;
        lineWidth = 0;
        if (textFitting && isIn(textAlignHorizontal, textAlignVertical)) {
            var w0 = 0;
            var h0 = 0;
            switch (textDirection) {
                case EShapeTextDirection.LEFT_TO_RIGHT:
                case EShapeTextDirection.RIGHT_TO_LEFT:
                    w0 = Math.max(0, hl - textPaddingHorizontal * 2);
                    h0 = Math.max(0, vl - textPaddingVertical * 2);
                    break;
                case EShapeTextDirection.TOP_TO_BOTTOM:
                case EShapeTextDirection.BOTTOM_TO_TOP:
                    w0 = Math.max(0, vl - textPaddingVertical * 2);
                    h0 = Math.max(0, hl - textPaddingHorizontal * 2);
                    break;
            }
            var w1 = width * hnl * (textSize / textAtlas.font.size);
            var h1 = height;
            var s = Math.min(1, Math.min(w0 / w1, h0 / h1));
            textSize *= s;
            textSizeY *= s;
            lineHeight *= s;
            height *= s;
        }
        var scaleZ = textSize / textAtlas.font.size;
        var scaleX = hnl * scaleZ;
        var scaleY = vnl * scaleZ;
        width *= scaleX;
        heightChar *= scaleY;
        //
        var tx0 = 0;
        var ty0 = 0;
        var lineWidthMaximum = width;
        switch (textDirection) {
            case EShapeTextDirection.LEFT_TO_RIGHT:
                getTextBBox(textAlignHorizontal, textAlignVertical, textOffsetHorizontal, textOffsetVertical, textPaddingHorizontal, textPaddingVertical, width, height, x0, y0, x1, y1, x2, y2, x3, y3, hnx, hny, vnx, vny, work);
                tx0 = work.x;
                ty0 = work.y;
                if (textClipping && isIn(textAlignHorizontal, textAlignVertical)) {
                    lineWidthMaximum = hl - textPaddingHorizontal * 2;
                }
                break;
            case EShapeTextDirection.TOP_TO_BOTTOM:
                getTextBBox(rotateAlignVerticalRight(textAlignVertical), rotateAlignHorizontalRight(textAlignHorizontal), textOffsetVertical, textOffsetHorizontal, textPaddingVertical, textPaddingHorizontal, width, height, x1, y1, x2, y2, x3, y3, x0, y0, hnx, hny, vnx, vny, work);
                tx0 = work.x;
                ty0 = work.y;
                if (textClipping && isIn(textAlignHorizontal, textAlignVertical)) {
                    lineWidthMaximum = vl - textPaddingVertical * 2;
                }
                break;
            case EShapeTextDirection.BOTTOM_TO_TOP:
                getTextBBox(rotateAlignVerticalLeft(textAlignVertical), rotateAlignHorizontalLeft(textAlignHorizontal), textOffsetVertical, textOffsetHorizontal, textPaddingVertical, textPaddingHorizontal, width, height, x3, y3, x0, y0, x1, y1, x2, y2, hnx, hny, vnx, vny, work);
                tx0 = work.x;
                ty0 = work.y;
                if (textClipping && isIn(textAlignHorizontal, textAlignVertical)) {
                    lineWidthMaximum = vl - textPaddingVertical * 2;
                }
                break;
            case EShapeTextDirection.RIGHT_TO_LEFT:
                getTextBBox(invertAlignHorizontal(textAlignHorizontal), invertAlignVertical(textAlignVertical), textOffsetHorizontal, textOffsetVertical, textPaddingHorizontal, textPaddingVertical, width, height, x2, y2, x3, y3, x0, y0, x1, y1, hnx, hny, vnx, vny, work);
                tx0 = work.x;
                ty0 = work.y;
                if (textClipping && isIn(textAlignHorizontal, textAlignVertical)) {
                    lineWidthMaximum = hl - textPaddingHorizontal * 2;
                }
                break;
        }
        //
        if (lineWidthMaximum < width) {
            var dwidth = (width - lineWidthMaximum) * 0.5;
            textWorld[0] = tx0 + hnx * dwidth;
            textWorld[1] = ty0 + hny * dwidth;
            textWorld[2] = hnx;
            textWorld[3] = hny;
            textWorld[4] = vnx;
            textWorld[5] = vny;
            textWorld[6] = lineWidthMaximum;
            textWorld[7] = height;
            textWorld[8] = hnl;
            textWorld[9] = vnl;
        }
        else {
            textWorld[0] = tx0;
            textWorld[1] = ty0;
            textWorld[2] = hnx;
            textWorld[3] = hny;
            textWorld[4] = vnx;
            textWorld[5] = vny;
            textWorld[6] = width;
            textWorld[7] = height;
            textWorld[8] = hnl;
            textWorld[9] = vnl;
        }
        // Texture
        var uvx0 = textureUvs.x0;
        var uvx1 = textureUvs.x1;
        var uvx3 = textureUvs.x3;
        var uvy0 = textureUvs.y0;
        var uvy1 = textureUvs.y1;
        var uvy3 = textureUvs.y3;
        var duvx01 = uvx1 - uvx0;
        var duvy01 = uvy1 - uvy0;
        var duvx03 = uvx3 - uvx0;
        var duvy03 = uvy3 - uvy0;
        // Vertices & UVs
        var lhx = lineHeight * vnx;
        var lhy = lineHeight * vny;
        var snx = scaleX * hnx;
        var sny = scaleX * hny;
        var offsetY = (heightChar - textSizeY) * 0.5;
        var oyx = offsetY * vnx;
        var oyy = offsetY * vny;
        var offsetItalic = textStyle === EShapeTextStyle.NORMAL ? 0 : textSize * 0.25;
        var bx0 = tx0 - oyx + offsetItalic * snx;
        var by0 = ty0 - oyy + offsetItalic * sny;
        var bx3 = tx0 + oyx + textSizeY * vnx;
        var by3 = ty0 + oyy + textSizeY * vny;
        var cx0 = bx0;
        var cy0 = by0;
        var cx3 = bx3;
        var cy3 = by3;
        lineWidth = 0;
        advancePrevious = 0;
        lineCount = 0;
        var iv = voffset * 2;
        for (var i = 0, imax = textCharacters.length; i < imax; i += 1, iv += 8) {
            var character = textCharacters[i];
            if (character !== Character.NEW_LINE) {
                var lineWidthPrevious = lineWidth;
                if (0 < advancePrevious) {
                    lineWidth += Math.max(0, advancePrevious + textSpacingHorizontal);
                }
                var ax = lineWidth * snx;
                var ay = lineWidth * sny;
                cx0 = bx0 + ax;
                cy0 = by0 + ay;
                cx3 = bx3 + ax;
                cy3 = by3 + ay;
                var data = textAtlasCharacters.get(character);
                lineCount += 1;
                if (data) {
                    var advance = data.advance;
                    if (lineWidthMaximum < (lineWidth + advance) * scaleX) {
                        var dots = textAtlasCharacters.get(Character.DOTS);
                        if (dots) {
                            if (1 < lineCount &&
                                lineWidthMaximum < (lineWidth + dots.advance) * scaleX) {
                                lineWidth = lineWidthPrevious;
                                iv -= 8;
                                lineCount -= 1;
                                var bx = lineWidth * snx;
                                var by = lineWidth * sny;
                                cx0 = bx0 + bx;
                                cy0 = by0 + by;
                                cx3 = bx3 + bx;
                                cy3 = by3 + by;
                            }
                            advancePrevious = dots.advance;
                            writeCharacter(vertices, uvs, iv, dots, textAtlas, snx, sny, cx0, cy0, cx3, cy3, duvx01, duvy01, duvx03, duvy03, uvx0, uvy0);
                            for (iv += 8; true; iv += 8) {
                                if (i + 1 < imax && textCharacters[i + 1] !== Character.NEW_LINE) {
                                    writeCharacterEmpty(vertices, uvs, iv, cx0, cy0, cx3, cy3, uvx0, uvy0, uvx3, uvy3);
                                    lineCount += 1;
                                    i += 1;
                                }
                                else {
                                    iv -= 8;
                                    break;
                                }
                            }
                        }
                        else {
                            advancePrevious = advance;
                            writeCharacterEmpty(vertices, uvs, iv, cx0, cy0, cx3, cy3, uvx0, uvy0, uvx3, uvy3);
                        }
                    }
                    else {
                        advancePrevious = advance;
                        writeCharacter(vertices, uvs, iv, data, textAtlas, snx, sny, cx0, cy0, cx3, cy3, duvx01, duvy01, duvx03, duvy03, uvx0, uvy0);
                    }
                }
                else {
                    advancePrevious = 0;
                    writeCharacterEmpty(vertices, uvs, iv, cx0, cy0, cx3, cy3, uvx0, uvy0, uvx3, uvy3);
                }
            }
            else {
                lineWidth += advancePrevious;
                advancePrevious = 0;
                bx0 += lhx;
                by0 += lhy;
                bx3 += lhx;
                by3 += lhy;
                cx0 = bx0;
                cy0 = by0;
                cx3 = bx3;
                cy3 = by3;
                writeCharacterEmpty(vertices, uvs, iv, cx0, cy0, cx3, cy3, uvx0, uvy0, uvx3, uvy3);
                adjustTextAlignment(vertices, hnx, hny, lineCount, iv, width - lineWidth * scaleX, textDirection, textAlignHorizontal, textAlignVertical);
                lineWidth = 0;
                lineCount = 0;
            }
        }
        lineWidth += advancePrevious;
        adjustTextAlignment(vertices, hnx, hny, lineCount, iv, width - lineWidth * scaleX, textDirection, textAlignHorizontal, textAlignVertical);
        for (var ivmax = (voffset + vcount) * 2; iv < ivmax; iv += 2) {
            vertices[iv + 0] = tx0;
            vertices[iv + 1] = ty0;
            uvs[iv + 0] = uvx0;
            uvs[iv + 1] = uvy0;
        }
    };
    var isIn = function (textAlignHorizontal, textAlignVertical) {
        switch (textAlignHorizontal) {
            case EShapeTextAlignHorizontal.LEFT:
            case EShapeTextAlignHorizontal.CENTER:
            case EShapeTextAlignHorizontal.RIGHT:
                switch (textAlignVertical) {
                    case EShapeTextAlignVertical.TOP:
                    case EShapeTextAlignVertical.MIDDLE:
                    case EShapeTextAlignVertical.BOTTOM:
                        return true;
                }
                break;
        }
        return false;
    };
    var writeCharacterEmpty = function (vertices, uvs, iv, cx0, cy0, cx3, cy3, uvx0, uvy0, uvx3, uvy3) {
        vertices[iv + 0] = cx0;
        vertices[iv + 1] = cy0;
        vertices[iv + 2] = cx0;
        vertices[iv + 3] = cy0;
        vertices[iv + 4] = cx3;
        vertices[iv + 5] = cy3;
        vertices[iv + 6] = cx3;
        vertices[iv + 7] = cy3;
        uvs[iv + 0] = uvx0;
        uvs[iv + 1] = uvy0;
        uvs[iv + 2] = uvx0;
        uvs[iv + 3] = uvy0;
        uvs[iv + 4] = uvx3;
        uvs[iv + 5] = uvy3;
        uvs[iv + 6] = uvx3;
        uvs[iv + 7] = uvy3;
    };
    var writeCharacter = function (vertices, uvs, iv, data, atlas, snx, sny, cx0, cy0, cx3, cy3, duvx01, duvy01, duvx03, duvy03, uvx0, uvy0) {
        // Vertices
        var dataOffsetX = data.x - data.origin.x;
        var dataWidth = data.width;
        var dx0 = dataOffsetX * snx;
        var dy0 = dataOffsetX * sny;
        var dx1 = (dataOffsetX + dataWidth) * snx;
        var dy1 = (dataOffsetX + dataWidth) * sny;
        vertices[iv + 0] = cx0 + dx0;
        vertices[iv + 1] = cy0 + dy0;
        vertices[iv + 2] = cx0 + dx1;
        vertices[iv + 3] = cy0 + dy1;
        vertices[iv + 4] = cx3 + dx1;
        vertices[iv + 5] = cy3 + dy1;
        vertices[iv + 6] = cx3 + dx0;
        vertices[iv + 7] = cy3 + dy0;
        // UVs
        var px0 = data.x / atlas.width;
        var py0 = data.y / atlas.height;
        var px1 = (data.x + data.width) / atlas.width;
        var py1 = (data.y + data.height) / atlas.height;
        var dux0 = duvx01 * px0;
        var duy0 = duvy01 * px0;
        var dux1 = duvx01 * px1;
        var duy1 = duvy01 * px1;
        var dvx0 = duvx03 * py0;
        var dvy0 = duvy03 * py0;
        var dvx1 = duvx03 * py1;
        var dvy1 = duvy03 * py1;
        uvs[iv + 0] = uvx0 + dux0 + dvx0;
        uvs[iv + 1] = uvy0 + duy0 + dvy0;
        uvs[iv + 2] = uvx0 + dux1 + dvx0;
        uvs[iv + 3] = uvy0 + duy1 + dvy0;
        uvs[iv + 4] = uvx0 + dux1 + dvx1;
        uvs[iv + 5] = uvy0 + duy1 + dvy1;
        uvs[iv + 6] = uvx0 + dux0 + dvx1;
        uvs[iv + 7] = uvy0 + duy0 + dvy1;
    };
    var moveText = function (vertices, vertexIndex, textCount, dx, dy) {
        var iv = vertexIndex - 8 * textCount - 1;
        for (var i = 0; i < textCount; ++i) {
            vertices[++iv] += dx;
            vertices[++iv] += dy;
            vertices[++iv] += dx;
            vertices[++iv] += dy;
            vertices[++iv] += dx;
            vertices[++iv] += dy;
            vertices[++iv] += dx;
            vertices[++iv] += dy;
        }
    };
    var moveTextHalf = function (vertices, vertexIndex, textCount, offset, nx, ny) {
        offset *= 0.5;
        moveText(vertices, vertexIndex, textCount, offset * nx, offset * ny);
    };
    var moveTextFull = function (vertices, vertexIndex, textCount, offset, nx, ny) {
        moveText(vertices, vertexIndex, textCount, offset * nx, offset * ny);
    };
    var adjustTextAlignment = function (vertices, nx, ny, lineCount, vertexIndex, offset, textDirection, textAlignHorizontal, textAlignVertical) {
        if (TEXT_FMIN < offset) {
            switch (textDirection) {
                case EShapeTextDirection.LEFT_TO_RIGHT:
                    switch (textAlignHorizontal) {
                        case EShapeTextAlignHorizontal.OUTSIDE_RIGHT:
                        case EShapeTextAlignHorizontal.LEFT:
                            // DO NOTHING
                            break;
                        case EShapeTextAlignHorizontal.CENTER:
                            moveTextHalf(vertices, vertexIndex, lineCount, offset, nx, ny);
                            break;
                        case EShapeTextAlignHorizontal.OUTSIDE_LEFT:
                        case EShapeTextAlignHorizontal.RIGHT:
                            moveTextFull(vertices, vertexIndex, lineCount, offset, nx, ny);
                            break;
                    }
                    break;
                case EShapeTextDirection.TOP_TO_BOTTOM:
                    switch (textAlignVertical) {
                        case EShapeTextAlignVertical.OUTSIDE_BOTTOM:
                        case EShapeTextAlignVertical.TOP:
                            // DO NOTHING
                            break;
                        case EShapeTextAlignVertical.MIDDLE:
                            moveTextHalf(vertices, vertexIndex, lineCount, offset, nx, ny);
                            break;
                        case EShapeTextAlignVertical.OUTSIDE_TOP:
                        case EShapeTextAlignVertical.BOTTOM:
                            moveTextFull(vertices, vertexIndex, lineCount, offset, nx, ny);
                            break;
                    }
                    break;
                case EShapeTextDirection.BOTTOM_TO_TOP:
                    switch (textAlignVertical) {
                        case EShapeTextAlignVertical.OUTSIDE_BOTTOM:
                        case EShapeTextAlignVertical.TOP:
                            moveTextFull(vertices, vertexIndex, lineCount, offset, nx, ny);
                            break;
                        case EShapeTextAlignVertical.MIDDLE:
                            moveTextHalf(vertices, vertexIndex, lineCount, offset, nx, ny);
                            break;
                        case EShapeTextAlignVertical.OUTSIDE_TOP:
                        case EShapeTextAlignVertical.BOTTOM:
                            // DO NOTHING
                            break;
                    }
                    break;
                case EShapeTextDirection.RIGHT_TO_LEFT:
                    switch (textAlignHorizontal) {
                        case EShapeTextAlignHorizontal.OUTSIDE_RIGHT:
                        case EShapeTextAlignHorizontal.LEFT:
                            moveTextFull(vertices, vertexIndex, lineCount, offset, nx, ny);
                            break;
                        case EShapeTextAlignHorizontal.CENTER:
                            moveTextHalf(vertices, vertexIndex, lineCount, offset, nx, ny);
                            break;
                        case EShapeTextAlignHorizontal.OUTSIDE_LEFT:
                        case EShapeTextAlignHorizontal.RIGHT:
                            // DO NOTHING
                            break;
                    }
                    break;
            }
        }
    };

    /******************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise, SuppressedError, Symbol */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
        var e = new Error(message);
        return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var CLOSED = 1;
    var NON_EXPANDING_WIDTH = 2;
    var NON_SHRINKING_WIDTH = 4;
    var NON_SCALING_DOT_AND_DASH = 8;
    var DOTTED = 16;
    var DOTTED_DENSELY = 32;
    var DOTTED_LOOSELY = 64;
    var DASHED = 128;
    var DASHED_DENSELY = 256;
    var DASHED_LOOSELY = 512;
    var FORMATTER_SHIFT = 10;
    var FORMATTER_MASK = 0xffc00;
    var FORMATTER_EXTENSION_LOWEST = 512;
    var FORMATTER_EXTENSION_HIGHEST = 1023;
    var FORMATTER_CURVE_SPLINE = 1;
    var FORMATTER_CURVE_BEZIER_QUADRATIC = 2;
    var CURVE_SPLINE = FORMATTER_CURVE_SPLINE << FORMATTER_SHIFT;
    var CURVE_BEZIER_QUADRATIC = FORMATTER_CURVE_BEZIER_QUADRATIC << FORMATTER_SHIFT;
    /**
     * EShape point style.
     *
     * * Bits 0 to 9: Bit field of styles.
     * * Bits 10 to 19: Formatter ID.
     */
    var EShapePointsStyle = {
        NONE: 0,
        CLOSED: CLOSED,
        /** @deprecated in favor of EShapeStrokeStyle. */
        NON_EXPANDING_WIDTH: NON_EXPANDING_WIDTH,
        /** @deprecated in favor of EShapeStrokeStyle. */
        NON_SHRINKING_WIDTH: NON_SHRINKING_WIDTH,
        /** @deprecated in favor of EShapeStrokeStyle. */
        NON_SCALING_DOT_AND_DASH: NON_SCALING_DOT_AND_DASH,
        /** @deprecated in favor of EShapeStrokeStyle. */
        NON_SCALING_MASK: NON_EXPANDING_WIDTH | NON_SHRINKING_WIDTH | NON_SCALING_DOT_AND_DASH,
        /** @deprecated in favor of EShapeStrokeStyle. */
        DOTTED: DOTTED,
        /** @deprecated in favor of EShapeStrokeStyle. */
        DOTTED_DENSELY: DOTTED_DENSELY,
        /** @deprecated in favor of EShapeStrokeStyle. */
        DOTTED_LOOSELY: DOTTED_LOOSELY,
        /** @deprecated in favor of EShapeStrokeStyle. */
        DOTTED_MASK: DOTTED | DOTTED_DENSELY | DOTTED_LOOSELY,
        /** @deprecated in favor of EShapeStrokeStyle. */
        DASHED: DASHED,
        /** @deprecated in favor of EShapeStrokeStyle. */
        DASHED_DENSELY: DASHED_DENSELY,
        /** @deprecated in favor of EShapeStrokeStyle. */
        DASHED_LOOSELY: DASHED_LOOSELY,
        /** @deprecated in favor of EShapeStrokeStyle. */
        DASHED_MASK: DASHED | DASHED_DENSELY | DASHED_LOOSELY,
        /** @deprecated in favor of CURVE_SPLINE. */
        CURVE: CURVE_SPLINE,
        CURVE_SPLINE: CURVE_SPLINE,
        CURVE_BEZIER_QUADRATIC: CURVE_BEZIER_QUADRATIC,
        FORMATTER_SHIFT: FORMATTER_SHIFT,
        FORMATTER_MASK: FORMATTER_MASK,
        FORMATTER_EXTENSION_LOWEST: FORMATTER_EXTENSION_LOWEST,
        FORMATTER_EXTENSION_HIGHEST: FORMATTER_EXTENSION_HIGHEST,
        /** @deprecated in favor of FORMATTER_CURVE_SPLINE. */
        FORMATTER_CURVE: FORMATTER_CURVE_SPLINE,
        FORMATTER_CURVE_SPLINE: FORMATTER_CURVE_SPLINE,
        FORMATTER_CURVE_BEZIER_QUADRATIC: FORMATTER_CURVE_BEZIER_QUADRATIC
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var NONE$1 = 0;
    var VERTEX = 1;
    var STEP = 2;
    var COLOR = 4;
    var UV = 8;
    var INDEX = 16;
    var VERTEX_AND_STEP = VERTEX | STEP;
    var VERTEX_STEP_AND_UV = VERTEX_AND_STEP | UV;
    var ALL$1 = VERTEX | STEP | COLOR | UV | INDEX;
    var BuilderFlag = {
        NONE: NONE$1,
        VERTEX: VERTEX,
        STEP: STEP,
        COLOR: COLOR,
        UV: UV,
        INDEX: INDEX,
        VERTEX_AND_STEP: VERTEX_AND_STEP,
        VERTEX_STEP_AND_UV: VERTEX_STEP_AND_UV,
        ALL: ALL$1
    };

    var buildColor = function (fillColor, fillAlpha, strokeColor, strokeAlpha, voffset, vcount, colors) {
        var alpha = toPackedF2x1024(Math.max(0, Math.min(1, fillAlpha)), Math.max(0, Math.min(1, strokeAlpha)));
        var ic = voffset * 3 - 1;
        var icmax = (voffset + vcount) * 3 - 1;
        for (; ic < icmax;) {
            colors[++ic] = fillColor;
            colors[++ic] = strokeColor;
            colors[++ic] = alpha;
        }
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var TOP$1 = 1;
    var RIGHT$1 = 2;
    var BOTTOM$1 = 4;
    var LEFT$1 = 8;
    var EShapeStrokeSide = {
        NONE: 0,
        TOP: TOP$1,
        RIGHT: RIGHT$1,
        BOTTOM: BOTTOM$1,
        LEFT: LEFT$1,
        TOP_OR_LEFT: TOP$1 | LEFT$1,
        TOP_OR_RIGHT: TOP$1 | RIGHT$1,
        BOTTOM_OR_LEFT: BOTTOM$1 | LEFT$1,
        BOTTOM_OR_RIGHT: BOTTOM$1 | RIGHT$1,
        ALL: TOP$1 | RIGHT$1 | BOTTOM$1 | LEFT$1
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var BuilderBase = /** @class */ (function () {
        function BuilderBase(buffer, vertexOffset, indexOffset, vertexCount, indexCount) {
            this.buffer = buffer;
            this.vertexOffset = vertexOffset;
            this.indexOffset = indexOffset;
            this.vertexCount = vertexCount;
            this.indexCount = indexCount;
            this.inited = BuilderFlag.NONE;
            this.sizeX = 0;
            this.sizeY = 0;
            this.transformLocalId = -1;
            this.strokeAlign = 0;
            this.strokeWidth = 0;
            this.strokeSide = EShapeStrokeSide.NONE;
            this.strokeStyle = EShapeStrokeStyle.NONE;
            this.colorFill = 0;
            this.alphaFill = 0;
            this.colorStroke = 0;
            this.alphaStroke = 0;
            this.texture = null;
            this.textureTransformId = -1;
        }
        BuilderBase.prototype.reinit = function (buffer, shape, vertexOffset, indexOffset) {
            if (this.buffer !== buffer ||
                this.vertexOffset !== vertexOffset ||
                this.indexOffset !== indexOffset) {
                if (buffer.check(vertexOffset, indexOffset, this.vertexCount, this.indexCount)) {
                    this.inited = BuilderFlag.NONE;
                    this.buffer = buffer;
                    this.vertexOffset = vertexOffset;
                    this.indexOffset = indexOffset;
                    this.init();
                    return true;
                }
                else {
                    return false;
                }
            }
            else {
                return true;
            }
        };
        BuilderBase.prototype.isCompatible = function (shape) {
            return true;
        };
        BuilderBase.prototype.updateColor = function (buffer, shape) {
            var fill = shape.fill;
            var colorFill = fill.color;
            var alphaFill = shape.visible && fill.enable ? fill.alpha : 0;
            var stroke = shape.stroke;
            var colorStroke = stroke.color;
            var alphaStroke = shape.visible && stroke.enable && 0 < stroke.width ? stroke.alpha : 0;
            var isNotInited = !(this.inited & BuilderFlag.COLOR);
            if (isNotInited ||
                colorFill !== this.colorFill ||
                alphaFill !== this.alphaFill ||
                colorStroke !== this.colorStroke ||
                alphaStroke !== this.alphaStroke) {
                this.inited |= BuilderFlag.COLOR;
                this.colorFill = colorFill;
                this.alphaFill = alphaFill;
                this.colorStroke = colorStroke;
                this.alphaStroke = alphaStroke;
                buffer.updateColors();
                buildColor(colorFill, alphaFill, colorStroke, alphaStroke, this.vertexOffset, this.vertexCount, buffer.colors);
            }
        };
        BuilderBase.prototype.buildUnit = function (builder) {
            var texture = this.texture || pixi_js.Texture.WHITE;
            var baseTexture = texture.baseTexture;
            if (baseTexture !== builder.baseTexture) {
                builder.baseTexture = baseTexture;
                var indexOffset = this.indexOffset;
                builder.push(texture, indexOffset);
            }
        };
        return BuilderBase;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var toTransformLocalId = function (shape) {
        shape.updateTransform();
        return shape.transform.getLocalId();
    };
    var toTexture = function (shape) {
        return shape.texture || pixi_js.Texture.WHITE;
    };
    var toTextureTransformId = function (texture) {
        var textureAny = texture;
        if (textureAny._uvs == null) {
            texture.updateUvs();
        }
        return textureAny._updateID;
    };
    var toTextureUvs = function (texture) {
        return texture._uvs;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DThemes = /** @class */ (function () {
        function DThemes() {
        }
        DThemes.setDefaultThemeClass = function (theme) {
            this.DEFAULT_THEME_CLASS = theme;
        };
        DThemes.getDefaultThemeClass = function () {
            return this.DEFAULT_THEME_CLASS;
        };
        DThemes.getInstance = function () {
            if (this.INSTANCE == null) {
                var defaultThemeClass = this.getDefaultThemeClass();
                if (defaultThemeClass == null) {
                    throw new Error("No default theme class found");
                }
                this.INSTANCE = new defaultThemeClass();
            }
            return this.INSTANCE;
        };
        DThemes.setInstance = function (instance) {
            var result = this.INSTANCE;
            this.INSTANCE = instance;
            return result;
        };
        DThemes.get = function (type) {
            return this.getInstance().get(type);
        };
        DThemes.set = function (type, instance) {
            this.getInstance().set(type, instance);
        };
        DThemes.getClass = function (type) {
            return this.getInstance().getClass(type);
        };
        DThemes.setClass = function (type, themeClass) {
            this.getInstance().setClass(type, themeClass);
        };
        DThemes.getAtlas = function () {
            return this.getInstance().getAtlas();
        };
        DThemes.DEFAULT_THEME_CLASS = null;
        DThemes.INSTANCE = null;
        return DThemes;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeDefaults = /** @class */ (function () {
        function EShapeDefaults() {
        }
        Object.defineProperty(EShapeDefaults, "THEME", {
            get: function () {
                var theme = this._THEME;
                if (theme != null) {
                    return theme;
                }
                var newTheme = DThemes.getInstance().get("EShape");
                this._THEME = newTheme;
                return newTheme;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeDefaults, "FILL_COLOR", {
            get: function () {
                return this.THEME.getFillColor();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeDefaults, "FILL_ALPHA", {
            get: function () {
                return this.THEME.getFillAlpha();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeDefaults, "STROKE_COLOR", {
            get: function () {
                return this.THEME.getStrokeColor();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeDefaults, "STROKE_ALPHA", {
            get: function () {
                return this.THEME.getStrokeAlpha();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeDefaults, "STROKE_WIDTH", {
            get: function () {
                return this.THEME.getStrokeWidth();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeDefaults, "STROKE_ALIGN", {
            get: function () {
                return this.THEME.getStrokeAlign();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeDefaults, "STROKE_SIDE", {
            get: function () {
                return this.THEME.getStrokeSide();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeDefaults, "STROKE_STYLE", {
            get: function () {
                return this.THEME.getStrokeStyle();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeDefaults, "TEXT_VALUE", {
            get: function () {
                return this.THEME.getTextValue();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeDefaults, "TEXT_COLOR", {
            get: function () {
                return this.THEME.getTextColor();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeDefaults, "TEXT_ALPHA", {
            get: function () {
                return this.THEME.getTextAlpha();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeDefaults, "TEXT_FAMILY", {
            get: function () {
                return this.THEME.getTextFamily();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeDefaults, "TEXT_SIZE", {
            get: function () {
                return this.THEME.getTextSize();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeDefaults, "RADIUS", {
            get: function () {
                return this.THEME.getRadius();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeDefaults, "SIZE_X", {
            get: function () {
                return this.THEME.getSizeX();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeDefaults, "SIZE_Y", {
            get: function () {
                return this.THEME.getSizeY();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeDefaults, "HIGHLIGHT_COLOR", {
            get: function () {
                return this.THEME.getHighlightColor();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeDefaults, "CURVE_SEGMENT_COUNT", {
            get: function () {
                return this.THEME.getCurveSegmentCount();
            },
            enumerable: false,
            configurable: true
        });
        return EShapeDefaults;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapePointsMarkerType = {
        NONE: 0,
        CIRCLE: 1,
        TRIANGLE: 2,
        RECTANGLE: 3
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeFillImpl = /** @class */ (function () {
        function EShapeFillImpl(parent, enable, color, alpha) {
            this._parent = parent;
            this._enable = enable;
            this._color = color;
            this._alpha = alpha;
        }
        Object.defineProperty(EShapeFillImpl.prototype, "enable", {
            get: function () {
                return this._enable;
            },
            set: function (enable) {
                if (this._enable !== enable) {
                    this._enable = enable;
                    this._parent.updateUploaded();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeFillImpl.prototype, "color", {
            get: function () {
                return this._color;
            },
            set: function (color) {
                if (this._color !== color) {
                    this._color = color;
                    this._parent.updateUploaded();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeFillImpl.prototype, "alpha", {
            get: function () {
                return this._alpha;
            },
            set: function (alpha) {
                if (this._alpha !== alpha) {
                    this._alpha = alpha;
                    this._parent.updateUploaded();
                }
            },
            enumerable: false,
            configurable: true
        });
        EShapeFillImpl.prototype.copy = function (target) {
            if (target) {
                this.set(target.enable, target.color, target.alpha);
            }
        };
        EShapeFillImpl.prototype.set = function (enable, color, alpha) {
            var isChanged = false;
            if (enable !== undefined && this._enable !== enable) {
                this._enable = enable;
                isChanged = true;
            }
            if (color !== undefined && this._color !== color) {
                this._color = color;
                isChanged = true;
            }
            if (alpha !== undefined && this._alpha !== alpha) {
                this._alpha = alpha;
                isChanged = true;
            }
            if (isChanged) {
                this._parent.updateUploaded();
            }
        };
        EShapeFillImpl.prototype.clone = function () {
            return new EShapeFillImpl(this._parent, this._enable, this._color, this._alpha);
        };
        EShapeFillImpl.prototype.toObject = function () {
            return {
                enable: this._enable,
                color: this._color,
                alpha: this._alpha
            };
        };
        EShapeFillImpl.prototype.serialize = function (manager) {
            var stringified = "[".concat(this._enable ? 1 : 0, ",").concat(this._color, ",").concat(this._alpha, "]");
            return manager.addResource(stringified);
        };
        EShapeFillImpl.prototype.deserialize = function (target, manager) {
            var resources = manager.resources;
            if (0 <= target && target < resources.length) {
                var parsed = manager.getFill(target);
                if (parsed != null) {
                    this.set(!!parsed[0], parsed[1], parsed[2]);
                }
                else {
                    var deserialized = JSON.parse(resources[target]);
                    manager.setFill(target, deserialized);
                    this.set(!!deserialized[0], deserialized[1], deserialized[2]);
                }
            }
        };
        return EShapeFillImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapePointsMarkerNoop = /** @class */ (function () {
        function EShapePointsMarkerNoop() {
        }
        EShapePointsMarkerNoop.prototype.lock = function () {
            return this;
        };
        EShapePointsMarkerNoop.prototype.unlock = function () {
            return this;
        };
        Object.defineProperty(EShapePointsMarkerNoop.prototype, "type", {
            get: function () {
                return EShapePointsMarkerType.NONE;
            },
            set: function (type) {
                // DO NOTHING
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapePointsMarkerNoop.prototype, "size", {
            get: function () {
                var result = this._size;
                if (result == null) {
                    result = new pixi_js.Point();
                    this._size = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapePointsMarkerNoop.prototype, "transform", {
            get: function () {
                var result = this._transform;
                if (result == null) {
                    result = new pixi_js.Matrix();
                    this._transform = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapePointsMarkerNoop.prototype, "fill", {
            get: function () {
                var result = this._fill;
                if (result == null) {
                    result = new EShapeFillImpl(this, true, EShapeDefaults.FILL_COLOR, 1);
                    this._fill = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        EShapePointsMarkerNoop.prototype.updateUploaded = function () {
            // DO NOTHING
        };
        EShapePointsMarkerNoop.prototype.copy = function (source) {
            return this;
        };
        EShapePointsMarkerNoop.prototype.set = function (type, sizeX, sizeY) {
            return this;
        };
        EShapePointsMarkerNoop.prototype.serialize = function (manager) {
            return -1;
        };
        EShapePointsMarkerNoop.prototype.deserialize = function (resourceId, manager) {
            // DO NOTHING
        };
        return EShapePointsMarkerNoop;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapePointsMarkerContainerImplNoop = /** @class */ (function () {
        function EShapePointsMarkerContainerImplNoop() {
            this._marker = new EShapePointsMarkerNoop();
        }
        EShapePointsMarkerContainerImplNoop.prototype.lock = function () {
            return this;
        };
        EShapePointsMarkerContainerImplNoop.prototype.unlock = function () {
            return this;
        };
        Object.defineProperty(EShapePointsMarkerContainerImplNoop.prototype, "head", {
            get: function () {
                return this._marker;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapePointsMarkerContainerImplNoop.prototype, "tail", {
            get: function () {
                return this._marker;
            },
            enumerable: false,
            configurable: true
        });
        EShapePointsMarkerContainerImplNoop.prototype.copy = function (source) {
            return this;
        };
        EShapePointsMarkerContainerImplNoop.prototype.serialize = function (manager) {
            return -1;
        };
        EShapePointsMarkerContainerImplNoop.prototype.deserialize = function (resourceId, manager) {
            // DO NOTHING
        };
        EShapePointsMarkerContainerImplNoop.getInstance = function () {
            var result = this.INSTANCE;
            if (result == null) {
                result = new EShapePointsMarkerContainerImplNoop();
                this.INSTANCE = result;
            }
            return result;
        };
        return EShapePointsMarkerContainerImplNoop;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeBarPosition = {
        TOP: 0,
        LEFT: 1,
        RIGHT: 2,
        BOTTOM: 3
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeBarPoints = /** @class */ (function () {
        function EShapeBarPoints(parent) {
            this._parent = parent;
            this._id = 0;
            this._values = [0, 0, 0, 0];
            this._segments = [];
            this._style = EShapePointsStyle.NONE;
            this._size = -1;
            this._position = EShapeBarPosition.TOP;
            this._updatedSize = NaN;
            this._updatedParentSizeX = NaN;
            this._updatedParentSizeY = NaN;
            this._updatedPosition = NaN;
        }
        EShapeBarPoints.prototype.getComputedSize = function (size, position, sizeX, sizeY) {
            if (0 <= size) {
                return size;
            }
            else {
                switch (position) {
                    case EShapeBarPosition.TOP:
                    case EShapeBarPosition.BOTTOM:
                        return Math.abs(sizeY);
                    case EShapeBarPosition.RIGHT:
                    case EShapeBarPosition.LEFT:
                        return Math.abs(sizeX);
                }
                return 0;
            }
        };
        EShapeBarPoints.prototype.onSizeChange = function () {
            this.update();
        };
        EShapeBarPoints.prototype.update = function () {
            var parentSize = this._parent.size;
            var parentSizeX = parentSize.x;
            var parentSizeY = parentSize.y;
            var position = this._position;
            var size = this._size;
            if (this._updatedSize !== size ||
                this._updatedParentSizeX !== parentSizeX ||
                this._updatedParentSizeY !== parentSizeY ||
                this._updatedPosition !== position) {
                this._id += 1;
                this._updatedSize = size;
                this._updatedParentSizeX = parentSizeX;
                this._updatedParentSizeY = parentSizeY;
                this._updatedPosition = position;
                var psxh = parentSizeX * 0.5;
                var psyh = parentSizeY * 0.5;
                var computedSize = this.getComputedSize(size, position, parentSizeX, parentSizeY);
                var values = this._values;
                switch (position) {
                    case EShapeBarPosition.TOP:
                        values[0] = 0;
                        values[1] = -psyh;
                        values[2] = 0;
                        values[3] = -psyh + computedSize;
                        break;
                    case EShapeBarPosition.RIGHT:
                        values[0] = psxh;
                        values[1] = 0;
                        values[2] = psxh - computedSize;
                        values[3] = 0;
                        break;
                    case EShapeBarPosition.BOTTOM:
                        values[0] = 0;
                        values[1] = psyh;
                        values[2] = 0;
                        values[3] = psyh - computedSize;
                        break;
                    case EShapeBarPosition.LEFT:
                        values[0] = -psxh;
                        values[1] = 0;
                        values[2] = -psxh + computedSize;
                        values[3] = 0;
                        break;
                }
            }
        };
        Object.defineProperty(EShapeBarPoints.prototype, "length", {
            get: function () {
                return 2;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeBarPoints.prototype, "plength", {
            get: function () {
                return 2;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeBarPoints.prototype, "id", {
            get: function () {
                this.update();
                return this._id;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeBarPoints.prototype, "values", {
            get: function () {
                this.update();
                return this._values;
            },
            set: function (values) {
                // SUPPOSED NOT TO BE CALLED
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeBarPoints.prototype, "segments", {
            get: function () {
                return this._segments;
            },
            set: function (segments) {
                // SUPPOSED NOT TO BE CALLED
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeBarPoints.prototype, "size", {
            get: function () {
                return this._size;
            },
            set: function (size) {
                this.moveTo(undefined, size, undefined);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeBarPoints.prototype, "position", {
            get: function () {
                return this._position;
            },
            set: function (position) {
                this.moveTo(position, undefined, undefined);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeBarPoints.prototype, "style", {
            get: function () {
                return this._style;
            },
            set: function (style) {
                this.moveTo(undefined, undefined, style);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeBarPoints.prototype, "marker", {
            get: function () {
                var result = this._marker;
                if (result == null) {
                    result = EShapePointsMarkerContainerImplNoop.getInstance();
                    this._marker = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        EShapeBarPoints.prototype.getMarker = function () {
            return undefined;
        };
        Object.defineProperty(EShapeBarPoints.prototype, "formatter", {
            get: function () {
                return null;
            },
            set: function (formatter) {
                // DO NOTHING
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeBarPoints.prototype, "formatted", {
            get: function () {
                return this;
            },
            enumerable: false,
            configurable: true
        });
        EShapeBarPoints.prototype.copy = function (source) {
            if (source instanceof EShapeBarPoints) {
                return this.moveTo(source.position, source.size, source.style);
            }
            else {
                return this.moveTo(undefined, undefined, source.style);
            }
        };
        EShapeBarPoints.prototype.set = function (newValues, newSegments, newStyle) {
            var newPosition;
            var newSize;
            if (newValues != null) {
                var x0 = newValues[0];
                if (x0 === 0) {
                    var y0 = newValues[1];
                    newPosition = y0 <= 0 ? EShapeBarPosition.TOP : EShapeBarPosition.BOTTOM;
                    newSize = Math.abs(newValues[3] - y0);
                }
                else {
                    newPosition = x0 <= 0 ? EShapeBarPosition.LEFT : EShapeBarPosition.RIGHT;
                    newSize = Math.abs(newValues[2] - x0);
                }
            }
            return this.moveTo(newPosition, newSize, newStyle);
        };
        EShapeBarPoints.prototype.moveTo = function (position, size, style) {
            var isChanged = false;
            if (style != null && this._style !== style) {
                this._style = style;
                isChanged = true;
            }
            if (position != null && this._position !== position) {
                this._position = position;
                isChanged = true;
            }
            if (size != null && this._size !== size) {
                this._size = size;
                isChanged = true;
            }
            if (isChanged) {
                this._parent.updateUploaded();
            }
            return this;
        };
        EShapeBarPoints.prototype.clone = function (parent) {
            return new EShapeBarPoints(parent).copy(this);
        };
        EShapeBarPoints.prototype.toPoints = function (transform) {
            var result = [];
            var values = this.values;
            for (var i = 0, imax = values.length; i < imax; i += 2) {
                var point = new pixi_js.Point(values[i + 0], values[i + 1]);
                result.push(transform.apply(point, point));
            }
            return result;
        };
        EShapeBarPoints.prototype.serialize = function (manager) {
            return manager.addResource("[".concat(this._position, ",").concat(this._size, ",").concat(this._style, "]"));
        };
        EShapeBarPoints.prototype.deserialize = function (resourceId, manager) {
            if (0 <= resourceId && resourceId < manager.resources.length) {
                var resource = manager.resources[resourceId];
                var parsed = JSON.parse(resource);
                this.moveTo(parsed[0], parsed[1], parsed[2]);
            }
        };
        EShapeBarPoints.prototype.calcHitPointAbs = function (x, y, ax, ay, threshold, toRange, tester, result) {
            var length = this.length;
            if (2 <= length) {
                var values = this._values;
                var v0x = values[0];
                var v0y = values[1];
                var v1x = values[2];
                var v1y = values[3];
                if (tester(x, y, v0x, v0y, v1x, v1y, 0, threshold, result)) {
                    return true;
                }
            }
            return false;
        };
        return EShapeBarPoints;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeLineBaseHitPart = {
        NONE: 0,
        LINE: 1,
        MARKER_TAIL: 2,
        MARKER_HEAD: 3,
        TEXT: 4,
        CHILDREN: 5
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var TOP_LEFT$1 = 1;
    var TOP_RIGHT$1 = 2;
    var BOTTOM_LEFT$1 = 4;
    var BOTTOM_RIGHT$1 = 8;
    var EShapeCorner = {
        NONE: 0,
        TOP_LEFT: TOP_LEFT$1,
        TOP_RIGHT: TOP_RIGHT$1,
        BOTTOM_LEFT: BOTTOM_LEFT$1,
        BOTTOM_RIGHT: BOTTOM_RIGHT$1,
        TOP: TOP_LEFT$1 | TOP_RIGHT$1,
        BOTTOM: BOTTOM_LEFT$1 | BOTTOM_RIGHT$1,
        LEFT: TOP_LEFT$1 | BOTTOM_LEFT$1,
        RIGHT: TOP_RIGHT$1 | BOTTOM_RIGHT$1,
        ALL: TOP_LEFT$1 | TOP_RIGHT$1 | BOTTOM_LEFT$1 | BOTTOM_RIGHT$1
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DApplications = /** @class */ (function () {
        function DApplications() {
        }
        DApplications.add = function (instance) {
            var instances = DApplications.INSTANCES;
            instances.push(instance);
        };
        DApplications.first = function () {
            var instances = DApplications.INSTANCES;
            if (0 < instances.length) {
                return instances[0];
            }
            throw new Error("No application found.");
        };
        DApplications.last = function () {
            var instances = DApplications.INSTANCES;
            if (0 < instances.length) {
                return instances[instances.length - 1];
            }
            throw new Error("No application found.");
        };
        DApplications.get = function (index) {
            var instances = DApplications.INSTANCES;
            if (0 <= index && index < instances.length) {
                return instances[index];
            }
            return null;
        };
        DApplications.indexOf = function (instance) {
            return DApplications.INSTANCES.indexOf(instance);
        };
        DApplications.size = function () {
            return DApplications.INSTANCES.length;
        };
        DApplications.getStage = function (target) {
            var stage = target;
            while (stage.parent) {
                stage = stage.parent;
            }
            if ("application" in stage && "layer" in stage) {
                return stage;
            }
            return null;
        };
        DApplications.find = function (target) {
            var stage = this.getStage(target);
            if (stage) {
                return stage.layer.application;
            }
            return null;
        };
        DApplications.getLayerBase = function (target) {
            var stage = this.getStage(target);
            if (stage) {
                return stage.layer.application.getLayerBase();
            }
            return null;
        };
        DApplications.getLayerOverlay = function (target) {
            var stage = this.getStage(target);
            if (stage) {
                return stage.layer.application.getLayerOverlay();
            }
            return null;
        };
        DApplications.getLayer = function (target) {
            var stage = this.getStage(target);
            if (stage) {
                return stage.layer;
            }
            return null;
        };
        DApplications.getResolution = function (target) {
            var _a;
            var layer = this.getLayer(target);
            if (layer) {
                return layer.renderer.resolution;
            }
            return (_a = window.devicePixelRatio) !== null && _a !== void 0 ? _a : 1;
        };
        DApplications.update = function (target) {
            if (target) {
                var stage = this.getStage(target);
                if (stage) {
                    stage.layer.update();
                }
            }
            else {
                var instances = DApplications.INSTANCES;
                for (var i = 0, imax = instances.length; i < imax; ++i) {
                    instances[i].update();
                }
            }
        };
        DApplications.render = function (target) {
            if (target) {
                var stage = this.getStage(target);
                if (stage) {
                    stage.layer.render();
                }
            }
            else {
                var instances = DApplications.INSTANCES;
                for (var i = 0, imax = instances.length; i < imax; ++i) {
                    instances[i].render();
                }
            }
        };
        DApplications.INSTANCES = [];
        return DApplications;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeAction = /** @class */ (function () {
        function EShapeAction() {
            this.values = [];
        }
        EShapeAction.prototype.add = function (value, index) {
            var values = this.values;
            if (index != null) {
                values.splice(index, 0, value);
            }
            else {
                values.push(value);
            }
            return this;
        };
        EShapeAction.prototype.addAll = function (values) {
            var destination = this.values;
            for (var i = 0, imax = values.length; i < imax; ++i) {
                destination.push(values[i]);
            }
            return this;
        };
        EShapeAction.prototype.clearAndAdd = function (value) {
            this.clear();
            this.add(value);
            return this;
        };
        EShapeAction.prototype.clearAndAddAll = function (values) {
            this.clear();
            this.addAll(values);
            return this;
        };
        EShapeAction.prototype.indexOf = function (target) {
            var values = this.values;
            // Instance-based matching
            for (var i = 0, imax = values.length; i < imax; ++i) {
                var value = values[i];
                if (value === target) {
                    return i;
                }
            }
            // Data-based matching
            for (var i = 0, imax = values.length; i < imax; ++i) {
                var value = values[i];
                if (value.isEquals(target)) {
                    return i;
                }
            }
            return -1;
        };
        EShapeAction.prototype.get = function (index) {
            var values = this.values;
            if (0 <= index || index < values.length) {
                return values[index];
            }
            return null;
        };
        EShapeAction.prototype.set = function (index, value) {
            var values = this.values;
            if (0 <= index || index < values.length) {
                var result = values[index];
                values[index] = value;
                return result;
            }
            return null;
        };
        EShapeAction.prototype.remove = function (index) {
            var values = this.values;
            if (0 <= index || index < values.length) {
                return values.splice(index, 1)[0];
            }
            return null;
        };
        EShapeAction.prototype.clear = function () {
            this.values.length = 0;
            return this;
        };
        EShapeAction.prototype.size = function () {
            return this.values.length;
        };
        EShapeAction.prototype.swap = function (indexA, indexB) {
            var values = this.values;
            var tmp = values[indexB];
            values[indexB] = values[indexA];
            values[indexA] = tmp;
            return this;
        };
        EShapeAction.prototype.serialize = function (manager) {
            var result = [];
            var values = this.values;
            for (var i = 0, imax = values.length; i < imax; ++i) {
                result.push(values[i].serialize(manager));
            }
            return result;
        };
        return EShapeAction;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeConnectorContainerImpl = /** @class */ (function () {
        function EShapeConnectorContainerImpl(parent) {
            this._parent = parent;
            this._edges = new Set();
        }
        EShapeConnectorContainerImpl.prototype.add = function (target) {
            var edges = this._edges;
            if (!edges.has(target)) {
                edges.add(target);
                return true;
            }
            return false;
        };
        EShapeConnectorContainerImpl.prototype.contains = function (target) {
            return this._edges.has(target);
        };
        EShapeConnectorContainerImpl.prototype.size = function () {
            return this._edges.size;
        };
        EShapeConnectorContainerImpl.prototype.remove = function (target) {
            return this._edges.delete(target);
        };
        EShapeConnectorContainerImpl.prototype.clear = function () {
            var edges = this._edges;
            if (0 < edges.size) {
                this._edges.clear();
                return true;
            }
            return false;
        };
        EShapeConnectorContainerImpl.prototype.copy = function (source) {
            var edges = this._edges;
            edges.clear();
            source.each(function (edge) {
                edges.add(edge);
            });
            return this;
        };
        EShapeConnectorContainerImpl.prototype.each = function (iteratee) {
            this._edges.forEach(iteratee);
            return this;
        };
        EShapeConnectorContainerImpl.prototype.fit = function (forcibly) {
            this._edges.forEach(this.toOnFitBound(forcibly));
        };
        EShapeConnectorContainerImpl.prototype.toOnFitBound = function (forcibly) {
            if (forcibly) {
                var result = this._onFitBoundForcibly;
                if (result == null) {
                    result = this.newOnFitBound(true);
                    this._onFitBoundForcibly = result;
                }
                return result;
            }
            else {
                var result = this._onFitBound;
                if (result == null) {
                    result = this.newOnFitBound(false);
                    this._onFitBound = result;
                }
                return result;
            }
        };
        EShapeConnectorContainerImpl.prototype.newOnFitBound = function (forcibly) {
            var _this = this;
            return function (edge) {
                _this.onFit(edge, forcibly);
            };
        };
        EShapeConnectorContainerImpl.prototype.onFit = function (target, forcibly) {
            target.fit(forcibly);
        };
        EShapeConnectorContainerImpl.prototype.attach = function () {
            var parent = this._parent;
            this._edges.forEach(function (edge) {
                edge.set(parent);
            });
            return this;
        };
        EShapeConnectorContainerImpl.prototype.detach = function (exceptions) {
            this._edges.forEach(function (edge) {
                if (exceptions == null || !exceptions.has(edge.parent)) {
                    edge.set(null);
                }
            });
            return this;
        };
        return EShapeConnectorContainerImpl;
    }());

    /*
     * Copyright (C) 2021 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var TRANSFORM = 1;
    var SIZE = 2;
    var STYLE = 4;
    var ACTION$1 = 8;
    var POINTS = 16;
    var STATE = 32;
    var IMAGE = 64;
    var DATA$1 = 128;
    var CONNECTOR$1 = 256;
    var CAPABILITY = 512;
    var EShapeCopyPart = {
        NONE: 0,
        TRANSFORM: TRANSFORM,
        SIZE: SIZE,
        STYLE: STYLE,
        ACTION: ACTION$1,
        POINTS: POINTS,
        STATE: STATE,
        IMAGE: IMAGE,
        DATA: DATA$1,
        /** @deprecated in favor of {@link DATA} */
        TAG: DATA$1,
        CONNECTOR: CONNECTOR$1,
        CAPABILITY: CAPABILITY,
        ALL: TRANSFORM | SIZE | STYLE | ACTION$1 | POINTS | STATE | IMAGE | DATA$1 | CONNECTOR$1 | CAPABILITY
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DBaseState = {
        HOVERED: "HOVERED",
        ACTIVE: "ACTIVE",
        FOCUSED: "FOCUSED",
        UNFOCUSABLE: "UNFOCUSABLE",
        FOCUS_ROOT: "FOCUS_ROOT",
        FOCUS_REVERSE: "FOCUS_REVERSE",
        READ_ONLY: "READ_ONLY",
        DISABLED: "DISABLED",
        GESTURING: "GESTURING",
        PRESSED: "PRESSED",
        INVALID: "INVALID",
        PROCESSING: "PROCESSING",
        SUCCEEDED: "SUCCEEDED",
        FAILED: "FAILED",
        WARNED: "WARNED",
        CHANGED: "CHANGED",
        ALTERNATED: "ALTERNATED",
        NEW_WINDOW: "NEW_WINDOW"
    };

    var DBaseStateSetSubDatumImp = /** @class */ (function () {
        function DBaseStateSetSubDatumImp(interval) {
            var _this = this;
            this._stateToTargets = new Map();
            this._interval = interval;
            this._onTimeBound = function () { return _this.onTime(); };
        }
        Object.defineProperty(DBaseStateSetSubDatumImp.prototype, "interval", {
            get: function () {
                return this._interval;
            },
            enumerable: false,
            configurable: true
        });
        DBaseStateSetSubDatumImp.prototype.add = function (state, target) {
            var stateToTargets = this._stateToTargets;
            var targets = stateToTargets.get(state);
            if (targets == null) {
                targets = new Set();
                targets.add(target);
                stateToTargets.set(state, targets);
                if (stateToTargets.size <= 1) {
                    this.start();
                }
            }
            else {
                targets.add(target);
            }
            return this;
        };
        DBaseStateSetSubDatumImp.prototype.remove = function (state, target) {
            var stateToTargets = this._stateToTargets;
            var targets = stateToTargets.get(state);
            if (targets != null && targets.has(target)) {
                targets.delete(target);
                target.remove(state);
                if (targets.size <= 0) {
                    stateToTargets.delete(state);
                }
                if (stateToTargets.size <= 0) {
                    this.stop();
                }
            }
            return this;
        };
        DBaseStateSetSubDatumImp.prototype.start = function () {
            if (this._timeoutId == null) {
                this.onTime();
            }
            return this;
        };
        DBaseStateSetSubDatumImp.prototype.stop = function () {
            var timeoutId = this._timeoutId;
            if (timeoutId != null) {
                clearTimeout(timeoutId);
                this._timeoutId = undefined;
            }
            return this;
        };
        DBaseStateSetSubDatumImp.prototype.onTime = function () {
            var now = Date.now();
            var interval = this.interval;
            var value = this.newValue(now, interval);
            var on = this.newOn(now, interval);
            this._stateToTargets.forEach(function (targets, state) {
                targets.forEach(function (target) {
                    target.set(state, value, on);
                });
            });
            this._timeoutId = window.setTimeout(this._onTimeBound, Math.max(0, interval - (now % interval)));
        };
        return DBaseStateSetSubDatumImp;
    }());

    var DBaseStateSetBlinkerDatumImpl = /** @class */ (function (_super) {
        __extends(DBaseStateSetBlinkerDatumImpl, _super);
        function DBaseStateSetBlinkerDatumImpl() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DBaseStateSetBlinkerDatumImpl.prototype.newValue = function (now, interval) {
            return null;
        };
        DBaseStateSetBlinkerDatumImpl.prototype.newOn = function (now, interval) {
            return Math.round(now / interval) % 2 === 0;
        };
        return DBaseStateSetBlinkerDatumImpl;
    }(DBaseStateSetSubDatumImp));

    var DBaseStateSetSubImpl = /** @class */ (function () {
        function DBaseStateSetSubImpl(parent, intervalToDatum) {
            this._parent = parent;
            this._stateToInterval = new Map();
            this._intervalToDatum = intervalToDatum;
        }
        DBaseStateSetSubImpl.prototype.add = function (state, interval) {
            // Check if the interval is not same
            var stateToInterval = this._stateToInterval;
            var oldInterval = stateToInterval.get(state);
            if (oldInterval === interval) {
                return this;
            }
            // Remove the existing one
            if (oldInterval != null) {
                stateToInterval.delete(state);
                var datum_1 = this._intervalToDatum.get(oldInterval);
                if (datum_1 != null) {
                    datum_1.remove(state, this._parent);
                }
            }
            // Add a new one
            stateToInterval.set(state, interval);
            var datum = this._intervalToDatum.get(interval);
            if (datum == null) {
                datum = this.newDatum(interval);
                this._intervalToDatum.set(interval, datum);
            }
            datum.add(state, this._parent);
            // Done
            return this;
        };
        DBaseStateSetSubImpl.prototype.remove = function (state) {
            var interval = this._stateToInterval.get(state);
            if (interval == null) {
                return this;
            }
            this._stateToInterval.delete(state);
            var datum = this._intervalToDatum.get(interval);
            if (datum == null) {
                return this;
            }
            datum.remove(state, this._parent);
            return this;
        };
        DBaseStateSetSubImpl.prototype.set = function (state, interval, on) {
            if (on) {
                return this.add(state, interval);
            }
            else {
                return this.remove(state);
            }
        };
        DBaseStateSetSubImpl.prototype.has = function (state) {
            return this._stateToInterval.has(state);
        };
        DBaseStateSetSubImpl.prototype.clear = function () {
            var _this = this;
            var parent = this._parent;
            var stateToInterval = this._stateToInterval;
            stateToInterval.forEach(function (interval, state) {
                var datum = _this._intervalToDatum.get(interval);
                if (datum != null) {
                    datum.remove(state, parent);
                }
            });
            stateToInterval.clear();
            return this;
        };
        return DBaseStateSetSubImpl;
    }());

    var intervalToDatum$1;
    var DBaseStateSetBlinkerImpl = /** @class */ (function (_super) {
        __extends(DBaseStateSetBlinkerImpl, _super);
        function DBaseStateSetBlinkerImpl(parent) {
            return _super.call(this, parent, (intervalToDatum$1 !== null && intervalToDatum$1 !== void 0 ? intervalToDatum$1 : (intervalToDatum$1 = new Map()))) || this;
        }
        DBaseStateSetBlinkerImpl.prototype.newDatum = function (interval) {
            return new DBaseStateSetBlinkerDatumImpl(interval);
        };
        return DBaseStateSetBlinkerImpl;
    }(DBaseStateSetSubImpl));

    var DBaseStateSetTickerDatumImpl = /** @class */ (function (_super) {
        __extends(DBaseStateSetTickerDatumImpl, _super);
        function DBaseStateSetTickerDatumImpl() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DBaseStateSetTickerDatumImpl.prototype.newValue = function (now, interval) {
            return Math.round(now / interval);
        };
        DBaseStateSetTickerDatumImpl.prototype.newOn = function (now, interval) {
            return true;
        };
        return DBaseStateSetTickerDatumImpl;
    }(DBaseStateSetSubDatumImp));

    var intervalToDatum;
    var DBaseStateSetTickerImpl = /** @class */ (function (_super) {
        __extends(DBaseStateSetTickerImpl, _super);
        function DBaseStateSetTickerImpl(parent) {
            return _super.call(this, parent, (intervalToDatum !== null && intervalToDatum !== void 0 ? intervalToDatum : (intervalToDatum = new Map()))) || this;
        }
        DBaseStateSetTickerImpl.prototype.newDatum = function (interval) {
            return new DBaseStateSetTickerDatumImpl(interval);
        };
        return DBaseStateSetTickerImpl;
    }(DBaseStateSetSubImpl));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var isArray = Array.isArray ||
        (function (target) {
            return Object.prototype.toString.call(target) === "[object Array]";
        });

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    // eslint-disable-next-line @typescript-eslint/ban-types
    var isFunction = function (target) {
        return typeof target === "function";
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var isNumber = function (target) {
        return (typeof target === "number" || Object.prototype.toString.call(target) === "[object Number]");
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var isString = function (target) {
        return (typeof target === "string" || Object.prototype.toString.call(target) === "[object String]");
    };

    /*
     * Copyright (C) 2020 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DBaseStateSetImpl = /** @class */ (function () {
        function DBaseStateSetImpl() {
            this._local = new Map();
            this._parent = null;
        }
        Object.defineProperty(DBaseStateSetImpl.prototype, "local", {
            get: function () {
                return this._local;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "parent", {
            get: function () {
                return this._parent;
            },
            set: function (parent) {
                if (this._parent !== parent) {
                    this.begin();
                    this._parent = parent;
                    this.end();
                }
            },
            enumerable: false,
            configurable: true
        });
        DBaseStateSetImpl.prototype.onParentChange = function (newState, oldState) {
            this._parent = oldState;
            this.begin();
            this._parent = newState;
            this.end();
        };
        Object.defineProperty(DBaseStateSetImpl.prototype, "blinker", {
            get: function () {
                var result = this._blinker;
                if (result == null) {
                    result = this.newBlinker();
                    this._blinker = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DBaseStateSetImpl.prototype.newBlinker = function () {
            return new DBaseStateSetBlinkerImpl(this);
        };
        Object.defineProperty(DBaseStateSetImpl.prototype, "ticker", {
            get: function () {
                var result = this._ticker;
                if (result == null) {
                    result = this.newTicker();
                    this._ticker = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DBaseStateSetImpl.prototype.newTicker = function () {
            return new DBaseStateSetTickerImpl(this);
        };
        DBaseStateSetImpl.prototype.is = function (state, value) {
            var v = this._local.get(state);
            return v !== undefined && (value === undefined || value === v);
        };
        DBaseStateSetImpl.prototype.in = function (state, value) {
            return this.is(state, value) || this.under(state, value);
        };
        DBaseStateSetImpl.prototype.on = function (state, value) {
            var parent = this._parent;
            return parent != null && parent.is(state, value);
        };
        DBaseStateSetImpl.prototype.under = function (state, value) {
            var parent = this._parent;
            return parent != null && parent.in(state, value);
        };
        DBaseStateSetImpl.prototype.lock = function (callOnChange) {
            return this;
        };
        DBaseStateSetImpl.prototype.unlock = function () {
            return this;
        };
        DBaseStateSetImpl.prototype.begin = function () {
            return this;
        };
        DBaseStateSetImpl.prototype.end = function () {
            return this;
        };
        DBaseStateSetImpl.prototype.checkAdded = function (added, value) {
            var v = this._local.get(added);
            return v === undefined || v !== value;
        };
        DBaseStateSetImpl.prototype.add = function (state, value) {
            if (value === void 0) { value = null; }
            if (this.checkAdded(state, value)) {
                this.begin();
                this._local.set(state, value);
                this.end();
            }
            return this;
        };
        DBaseStateSetImpl.prototype.checkAddedsString = function (states) {
            var local = this._local;
            for (var i = 0, imax = states.length; i < imax; ++i) {
                var v = local.get(states[i]);
                if (v === undefined || v !== null) {
                    return true;
                }
            }
            return false;
        };
        DBaseStateSetImpl.prototype.checkAddedsObject = function (states) {
            var local = this._local;
            for (var i = 0, imax = states.length; i < imax; ++i) {
                var state = states[i];
                var v = local.get(state.state);
                if (v === undefined || v !== state.value) {
                    return true;
                }
            }
            return false;
        };
        DBaseStateSetImpl.prototype.addAll = function (first) {
            if (isString(first)) {
                return this.addAllString(arguments); // eslint-disable-line prefer-rest-params
            }
            else if (isArray(first)) {
                if (0 < first.length) {
                    var element = first[0];
                    if (isString(element)) {
                        return this.addAllString(first);
                    }
                    else {
                        return this.addAllObject(first);
                    }
                }
                return this;
            }
            else {
                return this.addAllObject(arguments); // eslint-disable-line prefer-rest-params
            }
        };
        DBaseStateSetImpl.prototype.addAllString = function (states) {
            if (this.checkAddedsString(states)) {
                this.begin();
                var local = this._local;
                for (var i = 0, imax = states.length; i < imax; ++i) {
                    local.set(states[i], null);
                }
                this.end();
            }
            return this;
        };
        DBaseStateSetImpl.prototype.addAllObject = function (states) {
            if (this.checkAddedsObject(states)) {
                this.begin();
                var local = this._local;
                for (var i = 0, imax = states.length; i < imax; ++i) {
                    var state = states[i];
                    local.set(state.state, state.value);
                }
                this.end();
            }
            return this;
        };
        DBaseStateSetImpl.prototype.checkRemoved = function (removed) {
            return this._local.has(removed);
        };
        DBaseStateSetImpl.prototype.remove = function (state) {
            if (this.checkRemoved(state)) {
                this.begin();
                this._local.delete(state);
                this.end();
            }
            return this;
        };
        DBaseStateSetImpl.prototype.checkRemovedsString = function (states) {
            var local = this._local;
            for (var i = 0, imax = states.length; i < imax; ++i) {
                if (local.has(states[i])) {
                    return true;
                }
            }
            return false;
        };
        DBaseStateSetImpl.prototype.checkRemovedsObject = function (states) {
            var local = this._local;
            for (var i = 0, imax = states.length; i < imax; ++i) {
                if (local.has(states[i].state)) {
                    return true;
                }
            }
            return false;
        };
        DBaseStateSetImpl.prototype.removeAll = function (first) {
            if (isFunction(first)) {
                return this.removeAllMatcher(first);
            }
            else if (isString(first)) {
                return this.removeAllString(arguments); // eslint-disable-line prefer-rest-params
            }
            else if (isArray(first)) {
                if (0 < first.length) {
                    var element = first[0];
                    if (isString(element)) {
                        return this.removeAllString(first);
                    }
                    else {
                        return this.removeAllObject(first);
                    }
                }
                return this;
            }
            else {
                return this.removeAllObject(arguments); // eslint-disable-line prefer-rest-params
            }
        };
        DBaseStateSetImpl.prototype.removeAllMatcher = function (matcher) {
            var _this = this;
            var isDirty = false;
            var local = this._local;
            local.forEach(function (value, state) {
                if (matcher(state)) {
                    if (!isDirty) {
                        isDirty = true;
                        _this.begin();
                    }
                    local.delete(state);
                }
            });
            if (isDirty) {
                this.end();
            }
            return this;
        };
        DBaseStateSetImpl.prototype.removeAllString = function (states) {
            if (this.checkRemovedsString(states)) {
                this.begin();
                var local = this._local;
                for (var i = 0, imax = states.length; i < imax; ++i) {
                    local.delete(states[i]);
                }
                this.end();
            }
            return this;
        };
        DBaseStateSetImpl.prototype.removeAllObject = function (states) {
            if (this.checkRemovedsObject(states)) {
                this.begin();
                var local = this._local;
                for (var i = 0, imax = states.length; i < imax; ++i) {
                    local.delete(states[i].state);
                }
                this.end();
            }
            return this;
        };
        DBaseStateSetImpl.prototype.set = function (first, second, third) {
            if (second === true) {
                if (first != null) {
                    this.add(first);
                }
            }
            else if (second === false) {
                if (first != null) {
                    this.remove(first);
                }
            }
            else if (second == null || isNumber(second)) {
                if (third === true) {
                    if (first != null) {
                        this.add(first, second);
                    }
                }
                else if (third === false) {
                    if (first != null) {
                        this.remove(first);
                    }
                }
                else {
                    return this.doSet(first, second, third);
                }
            }
            else {
                return this.doSet(first, null, second);
            }
            return this;
        };
        DBaseStateSetImpl.prototype.doSet = function (added, value, removed) {
            if (added != null) {
                if (removed != null) {
                    if (this.checkAdded(added, value) || this.checkRemoved(removed)) {
                        this.begin();
                        this._local.set(added, value).delete(removed);
                        this.end();
                    }
                }
                else {
                    this.add(added, value);
                }
            }
            else if (removed != null) {
                this.remove(removed);
            }
            return this;
        };
        DBaseStateSetImpl.prototype.setAll = function (first, second) {
            if (second === true) {
                if (first != null) {
                    this.addAll(first);
                }
            }
            else if (second === false) {
                if (first != null) {
                    this.removeAll(first);
                }
            }
            else {
                if (first != null && 0 < first.length) {
                    if (second != null && 0 < second.length) {
                        var added = first[0];
                        if (isString(added)) {
                            return this.setAllString(first, second);
                        }
                        else {
                            return this.setAllObject(first, second);
                        }
                    }
                    else {
                        this.addAll(first);
                    }
                }
                else if (second != null) {
                    this.removeAll(second);
                }
            }
            return this;
        };
        DBaseStateSetImpl.prototype.setAllString = function (addeds, removeds) {
            if (this.checkAddedsString(addeds) || this.checkRemovedsString(removeds)) {
                this.begin();
                var local = this._local;
                for (var i = 0, imax = addeds.length; i < imax; ++i) {
                    local.set(addeds[i], null);
                }
                for (var i = 0, imax = removeds.length; i < imax; ++i) {
                    local.delete(removeds[i]);
                }
                this.end();
            }
            return this;
        };
        DBaseStateSetImpl.prototype.setAllObject = function (addeds, removeds) {
            if (this.checkAddedsObject(addeds) || this.checkRemovedsString(removeds)) {
                this.begin();
                var local = this._local;
                for (var i = 0, imax = addeds.length; i < imax; ++i) {
                    var added = addeds[i];
                    local.set(added.state, added.value);
                }
                for (var i = 0, imax = removeds.length; i < imax; ++i) {
                    local.delete(removeds[i]);
                }
                this.end();
            }
            return this;
        };
        DBaseStateSetImpl.prototype.clear = function () {
            var local = this._local;
            if (0 < local.size) {
                this.begin();
                local.clear();
                this.end();
            }
            return this;
        };
        DBaseStateSetImpl.prototype.valueOf = function (state, def) {
            var result = this._local.get(state);
            if (result !== undefined) {
                if (result == null && def !== undefined) {
                    return def;
                }
                return result;
            }
            var parent = this._parent;
            if (parent != null) {
                if (def !== undefined) {
                    return parent.valueOf(state, def);
                }
                else {
                    return parent.valueOf(state);
                }
            }
            return def;
        };
        DBaseStateSetImpl.prototype.each = function (iteratee) {
            this._local.forEach(function (value, state) {
                iteratee(state, value);
            });
            return this;
        };
        DBaseStateSetImpl.prototype.size = function () {
            return this._local.size;
        };
        DBaseStateSetImpl.prototype.copy = function (other) {
            if (other instanceof DBaseStateSetImpl) {
                this.begin();
                var local_1 = this._local;
                local_1.clear();
                other.local.forEach(function (value, state) {
                    local_1.set(state, value);
                });
                this._parent = other.parent;
                this.end();
            }
            return this;
        };
        Object.defineProperty(DBaseStateSetImpl.prototype, "isHovered", {
            get: function () {
                return this.is(DBaseState.HOVERED);
            },
            set: function (isHovered) {
                this.set(DBaseState.HOVERED, isHovered);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "inHovered", {
            get: function () {
                return this.in(DBaseState.HOVERED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "onHovered", {
            get: function () {
                return this.on(DBaseState.HOVERED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "underHovered", {
            get: function () {
                return this.under(DBaseState.HOVERED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "isActive", {
            get: function () {
                return this.is(DBaseState.ACTIVE);
            },
            set: function (isActive) {
                this.set(DBaseState.ACTIVE, isActive);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "inActive", {
            get: function () {
                return this.in(DBaseState.ACTIVE);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "onActive", {
            get: function () {
                return this.on(DBaseState.ACTIVE);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "underActive", {
            get: function () {
                return this.under(DBaseState.ACTIVE);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "isPressed", {
            get: function () {
                return this.is(DBaseState.PRESSED);
            },
            set: function (isPressed) {
                this.set(DBaseState.PRESSED, isPressed);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "inPressed", {
            get: function () {
                return this.in(DBaseState.PRESSED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "onPressed", {
            get: function () {
                return this.on(DBaseState.PRESSED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "underPressed", {
            get: function () {
                return this.under(DBaseState.PRESSED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "isReadOnly", {
            get: function () {
                return this.is(DBaseState.READ_ONLY);
            },
            set: function (isReadOnly) {
                this.set(DBaseState.READ_ONLY, isReadOnly);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "inReadOnly", {
            get: function () {
                return this.in(DBaseState.READ_ONLY);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "onReadOnly", {
            get: function () {
                return this.on(DBaseState.READ_ONLY);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "underReadOnly", {
            get: function () {
                return this.under(DBaseState.READ_ONLY);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "isEnabled", {
            get: function () {
                return !this.is(DBaseState.DISABLED);
            },
            set: function (isEnabled) {
                this.set(DBaseState.DISABLED, !isEnabled);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "inEnabled", {
            get: function () {
                return !this.in(DBaseState.DISABLED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "onEnabled", {
            get: function () {
                return !this.on(DBaseState.DISABLED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "underEnabled", {
            get: function () {
                return !this.under(DBaseState.DISABLED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "isDisabled", {
            get: function () {
                return this.is(DBaseState.DISABLED);
            },
            set: function (isDisabled) {
                this.set(DBaseState.DISABLED, isDisabled);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "inDisabled", {
            get: function () {
                return this.in(DBaseState.DISABLED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "onDisabled", {
            get: function () {
                return this.on(DBaseState.DISABLED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "underDisabled", {
            get: function () {
                return this.under(DBaseState.DISABLED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "isActionable", {
            get: function () {
                return !this.in(DBaseState.DISABLED) && !this.in(DBaseState.READ_ONLY);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "isGesturing", {
            get: function () {
                return this.is(DBaseState.GESTURING);
            },
            set: function (isGesturing) {
                this.set(DBaseState.GESTURING, isGesturing);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "inGesturing", {
            get: function () {
                return this.in(DBaseState.GESTURING);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "onGesturing", {
            get: function () {
                return this.on(DBaseState.GESTURING);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "underGesturing", {
            get: function () {
                return this.under(DBaseState.GESTURING);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "isFocused", {
            get: function () {
                return this.is(DBaseState.FOCUSED);
            },
            set: function (isFocused) {
                this.set(DBaseState.FOCUSED, isFocused);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "inFocused", {
            get: function () {
                return this.in(DBaseState.FOCUSED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "onFocused", {
            get: function () {
                return this.on(DBaseState.FOCUSED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "underFocused", {
            get: function () {
                return this.under(DBaseState.FOCUSED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "isFocusRoot", {
            get: function () {
                return this.is(DBaseState.FOCUS_ROOT);
            },
            set: function (isFocusRoot) {
                this.set(DBaseState.FOCUS_ROOT, isFocusRoot);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "inFocusRoot", {
            get: function () {
                return this.in(DBaseState.FOCUS_ROOT);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "onFocusRoot", {
            get: function () {
                return this.on(DBaseState.FOCUS_ROOT);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "underFocusRoot", {
            get: function () {
                return this.under(DBaseState.FOCUS_ROOT);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "isFocusReverse", {
            get: function () {
                return this.is(DBaseState.FOCUS_REVERSE);
            },
            set: function (isFocusReverse) {
                this.set(DBaseState.FOCUS_REVERSE, isFocusReverse);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "inFocusReverse", {
            get: function () {
                return this.in(DBaseState.FOCUS_REVERSE);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "onFocusReverse", {
            get: function () {
                return this.on(DBaseState.FOCUS_REVERSE);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "underFocusReverse", {
            get: function () {
                return this.under(DBaseState.FOCUS_REVERSE);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "isFocusable", {
            get: function () {
                return !this.is(DBaseState.UNFOCUSABLE);
            },
            set: function (isFocusable) {
                this.set(DBaseState.UNFOCUSABLE, !isFocusable);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "inFocusable", {
            get: function () {
                return !this.in(DBaseState.UNFOCUSABLE);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "onFocusable", {
            get: function () {
                return !this.on(DBaseState.UNFOCUSABLE);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "underFocusable", {
            get: function () {
                return !this.under(DBaseState.UNFOCUSABLE);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "isUnfocusable", {
            get: function () {
                return this.is(DBaseState.UNFOCUSABLE);
            },
            set: function (unfocusable) {
                this.set(DBaseState.UNFOCUSABLE, unfocusable);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "inUnfocusable", {
            get: function () {
                return this.in(DBaseState.UNFOCUSABLE);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "onUnfocusable", {
            get: function () {
                return this.on(DBaseState.UNFOCUSABLE);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "underUnfocusable", {
            get: function () {
                return this.under(DBaseState.UNFOCUSABLE);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "isInvalid", {
            get: function () {
                return this.is(DBaseState.INVALID);
            },
            set: function (invalid) {
                this.set(DBaseState.INVALID, invalid);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "inInvalid", {
            get: function () {
                return this.in(DBaseState.INVALID);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "onInvalid", {
            get: function () {
                return this.on(DBaseState.INVALID);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "underInvalid", {
            get: function () {
                return this.on(DBaseState.INVALID);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "isProcessing", {
            get: function () {
                return this.is(DBaseState.PROCESSING);
            },
            set: function (processing) {
                this.set(DBaseState.PROCESSING, processing);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "inProcessing", {
            get: function () {
                return this.in(DBaseState.PROCESSING);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "onProcessing", {
            get: function () {
                return this.on(DBaseState.PROCESSING);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "underProcessing", {
            get: function () {
                return this.under(DBaseState.PROCESSING);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "isSucceeded", {
            get: function () {
                return this.is(DBaseState.SUCCEEDED);
            },
            set: function (succeeded) {
                this.set(DBaseState.SUCCEEDED, succeeded);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "inSucceeded", {
            get: function () {
                return this.in(DBaseState.SUCCEEDED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "onSucceeded", {
            get: function () {
                return this.on(DBaseState.SUCCEEDED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "underSucceeded", {
            get: function () {
                return this.under(DBaseState.SUCCEEDED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "isFailed", {
            get: function () {
                return this.is(DBaseState.FAILED);
            },
            set: function (failed) {
                this.set(DBaseState.FAILED, failed);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "inFailed", {
            get: function () {
                return this.in(DBaseState.FAILED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "onFailed", {
            get: function () {
                return this.on(DBaseState.FAILED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "underFailed", {
            get: function () {
                return this.under(DBaseState.FAILED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "isWarned", {
            get: function () {
                return this.is(DBaseState.WARNED);
            },
            set: function (isWarned) {
                this.set(DBaseState.WARNED, isWarned);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "inWarned", {
            get: function () {
                return this.in(DBaseState.WARNED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "onWarned", {
            get: function () {
                return this.on(DBaseState.WARNED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "underWarned", {
            get: function () {
                return this.on(DBaseState.WARNED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "isChanged", {
            get: function () {
                return this.is(DBaseState.CHANGED);
            },
            set: function (isChanged) {
                this.set(DBaseState.CHANGED, isChanged);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "inChanged", {
            get: function () {
                return this.in(DBaseState.CHANGED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "onChanged", {
            get: function () {
                return this.on(DBaseState.CHANGED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "underChanged", {
            get: function () {
                return this.on(DBaseState.CHANGED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "isAlternated", {
            get: function () {
                return this.is(DBaseState.ALTERNATED);
            },
            set: function (isAlternated) {
                this.set(DBaseState.ALTERNATED, isAlternated);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "inAlternated", {
            get: function () {
                return this.in(DBaseState.ALTERNATED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "onAlternated", {
            get: function () {
                return this.on(DBaseState.ALTERNATED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "underAlternated", {
            get: function () {
                return this.on(DBaseState.ALTERNATED);
            },
            enumerable: false,
            configurable: true
        });
        DBaseStateSetImpl.prototype.toObject = function () {
            var states = [];
            this._local.forEach(function (value, state) {
                states.push(state);
            });
            return {
                local: states
            };
        };
        DBaseStateSetImpl.prototype.toString = function () {
            return JSON.stringify(this.toObject());
        };
        return DBaseStateSetImpl;
    }());

    /*
     * Copyright (C) 2020 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DBaseStateSetImplObservable = /** @class */ (function (_super) {
        __extends(DBaseStateSetImplObservable, _super);
        function DBaseStateSetImplObservable(onChange) {
            var _this = _super.call(this) || this;
            _this._onChange = onChange;
            _this._isLocked = 0;
            _this._isSaved = false;
            _this._doSave = true;
            return _this;
        }
        DBaseStateSetImplObservable.prototype.lock = function (callOnChange) {
            this._isLocked += 1;
            if (callOnChange === false) {
                this._doSave = false;
            }
            return this;
        };
        DBaseStateSetImplObservable.prototype.unlock = function () {
            this._isLocked -= 1;
            return this.end();
        };
        Object.defineProperty(DBaseStateSetImplObservable.prototype, "saved", {
            get: function () {
                var result = this._saved;
                if (result == null) {
                    result = new DBaseStateSetImpl();
                    this._saved = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DBaseStateSetImplObservable.prototype.begin = function () {
            if (this._doSave && !this._isSaved) {
                this._isSaved = true;
                this.saved.copy(this);
            }
            return this;
        };
        DBaseStateSetImplObservable.prototype.end = function () {
            if (this._isLocked <= 0) {
                this._doSave = true;
                if (this._isSaved) {
                    this._isSaved = false;
                    this.onChange(this, this.saved);
                }
            }
            return this;
        };
        DBaseStateSetImplObservable.prototype.onChange = function (newState, oldState) {
            this._onChange(newState, oldState);
        };
        return DBaseStateSetImplObservable;
    }(DBaseStateSetImpl));

    /*
     * Copyright (C) 2020 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeState = {
        CLICKED: "CLICKED",
        DBL_CLICKED: "DBL_CLICKED",
        DOWN: "DOWN",
        UP: "UP",
        UP_OUTSIDE: "UP_OUTSIDE",
        RIGHT_CLICKED: "RIGHT_CLICKED",
        RIGHT_DOWN: "RIGHT_DOWN",
        RIGHT_UP: "RIGHT_UP",
        RIGHT_UP_OUTSIDE: "RIGHT_UP_OUTSIDE",
        RIGHT_PRESSED: "RIGHT_PRESSED",
        ACTIVATED: "ACTIVATED",
        DEACTIVATED: "DEACTIVATED"
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeStateSetImplObservable = /** @class */ (function (_super) {
        __extends(EShapeStateSetImplObservable, _super);
        function EShapeStateSetImplObservable() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        EShapeStateSetImplObservable.prototype.onChange = function (newState, oldState) {
            if (newState.isActive) {
                if (!oldState.isActive) {
                    this._local.set(EShapeState.ACTIVATED, null).delete(EShapeState.DEACTIVATED);
                }
            }
            else {
                if (oldState.isActive) {
                    this._local.set(EShapeState.DEACTIVATED, null).delete(EShapeState.ACTIVATED);
                }
            }
            _super.prototype.onChange.call(this, newState, oldState);
        };
        Object.defineProperty(EShapeStateSetImplObservable.prototype, "isClicked", {
            get: function () {
                return this.is(EShapeState.CLICKED);
            },
            set: function (isClicked) {
                this.set(EShapeState.CLICKED, isClicked);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStateSetImplObservable.prototype, "inClicked", {
            get: function () {
                return this.in(EShapeState.CLICKED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStateSetImplObservable.prototype, "onClicked", {
            get: function () {
                return this.on(EShapeState.CLICKED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStateSetImplObservable.prototype, "underClicked", {
            get: function () {
                return this.under(EShapeState.CLICKED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStateSetImplObservable.prototype, "isDblClicked", {
            get: function () {
                return this.is(EShapeState.DBL_CLICKED);
            },
            set: function (isDblClicked) {
                this.set(EShapeState.DBL_CLICKED, isDblClicked);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStateSetImplObservable.prototype, "inDblClicked", {
            get: function () {
                return this.in(EShapeState.DBL_CLICKED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStateSetImplObservable.prototype, "onDblClicked", {
            get: function () {
                return this.on(EShapeState.DBL_CLICKED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStateSetImplObservable.prototype, "underDblClicked", {
            get: function () {
                return this.under(EShapeState.DBL_CLICKED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStateSetImplObservable.prototype, "isDown", {
            get: function () {
                return this.is(EShapeState.DOWN);
            },
            set: function (isDown) {
                this.set(EShapeState.DOWN, isDown);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStateSetImplObservable.prototype, "inDown", {
            get: function () {
                return this.in(EShapeState.DOWN);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStateSetImplObservable.prototype, "onDown", {
            get: function () {
                return this.on(EShapeState.DOWN);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStateSetImplObservable.prototype, "underDown", {
            get: function () {
                return this.under(EShapeState.DOWN);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStateSetImplObservable.prototype, "isUp", {
            get: function () {
                return this.is(EShapeState.UP);
            },
            set: function (isUp) {
                this.set(EShapeState.UP, isUp);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStateSetImplObservable.prototype, "inUp", {
            get: function () {
                return this.in(EShapeState.UP);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStateSetImplObservable.prototype, "onUp", {
            get: function () {
                return this.on(EShapeState.UP);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStateSetImplObservable.prototype, "underUp", {
            get: function () {
                return this.under(EShapeState.UP);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStateSetImplObservable.prototype, "isUpOutside", {
            get: function () {
                return this.is(EShapeState.UP_OUTSIDE);
            },
            set: function (isUpOutside) {
                this.set(EShapeState.UP_OUTSIDE, isUpOutside);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStateSetImplObservable.prototype, "inUpOutside", {
            get: function () {
                return this.in(EShapeState.UP_OUTSIDE);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStateSetImplObservable.prototype, "onUpOutside", {
            get: function () {
                return this.on(EShapeState.UP_OUTSIDE);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStateSetImplObservable.prototype, "underUpOutside", {
            get: function () {
                return this.under(EShapeState.UP_OUTSIDE);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStateSetImplObservable.prototype, "isRightClicked", {
            get: function () {
                return this.is(EShapeState.RIGHT_CLICKED);
            },
            set: function (isRightClicked) {
                this.set(EShapeState.RIGHT_CLICKED, isRightClicked);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStateSetImplObservable.prototype, "inRightClicked", {
            get: function () {
                return this.in(EShapeState.RIGHT_CLICKED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStateSetImplObservable.prototype, "onRightClicked", {
            get: function () {
                return this.on(EShapeState.RIGHT_CLICKED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStateSetImplObservable.prototype, "underRightClicked", {
            get: function () {
                return this.under(EShapeState.RIGHT_CLICKED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStateSetImplObservable.prototype, "isRightDown", {
            get: function () {
                return this.is(EShapeState.RIGHT_DOWN);
            },
            set: function (isRightDown) {
                this.set(EShapeState.RIGHT_DOWN, isRightDown);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStateSetImplObservable.prototype, "inRightDown", {
            get: function () {
                return this.in(EShapeState.RIGHT_DOWN);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStateSetImplObservable.prototype, "onRightDown", {
            get: function () {
                return this.on(EShapeState.RIGHT_DOWN);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStateSetImplObservable.prototype, "underRightDown", {
            get: function () {
                return this.under(EShapeState.RIGHT_DOWN);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStateSetImplObservable.prototype, "isRightUp", {
            get: function () {
                return this.is(EShapeState.RIGHT_UP);
            },
            set: function (isRightUp) {
                this.set(EShapeState.RIGHT_UP, isRightUp);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStateSetImplObservable.prototype, "inRightUp", {
            get: function () {
                return this.in(EShapeState.RIGHT_UP);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStateSetImplObservable.prototype, "onRightUp", {
            get: function () {
                return this.on(EShapeState.RIGHT_UP);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStateSetImplObservable.prototype, "underRightUp", {
            get: function () {
                return this.under(EShapeState.RIGHT_UP);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStateSetImplObservable.prototype, "isRightUpOutside", {
            get: function () {
                return this.is(EShapeState.RIGHT_UP_OUTSIDE);
            },
            set: function (isRightUpOutside) {
                this.set(EShapeState.RIGHT_UP_OUTSIDE, isRightUpOutside);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStateSetImplObservable.prototype, "inRightUpOutside", {
            get: function () {
                return this.in(EShapeState.RIGHT_UP_OUTSIDE);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStateSetImplObservable.prototype, "onRightUpOutside", {
            get: function () {
                return this.on(EShapeState.RIGHT_UP_OUTSIDE);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStateSetImplObservable.prototype, "underRightUpOutside", {
            get: function () {
                return this.under(EShapeState.RIGHT_UP_OUTSIDE);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStateSetImplObservable.prototype, "isRightPressed", {
            get: function () {
                return this.is(EShapeState.RIGHT_PRESSED);
            },
            set: function (isRightPressed) {
                this.set(EShapeState.RIGHT_PRESSED, isRightPressed);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStateSetImplObservable.prototype, "inRightPressed", {
            get: function () {
                return this.in(EShapeState.RIGHT_PRESSED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStateSetImplObservable.prototype, "onRightPressed", {
            get: function () {
                return this.on(EShapeState.RIGHT_PRESSED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStateSetImplObservable.prototype, "underRightPressed", {
            get: function () {
                return this.under(EShapeState.RIGHT_PRESSED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStateSetImplObservable.prototype, "isActivated", {
            get: function () {
                return this.is(EShapeState.ACTIVATED);
            },
            set: function (isActivated) {
                this.set(EShapeState.ACTIVATED, isActivated);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStateSetImplObservable.prototype, "inActivated", {
            get: function () {
                return this.in(EShapeState.ACTIVATED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStateSetImplObservable.prototype, "onActivated", {
            get: function () {
                return this.on(EShapeState.ACTIVATED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStateSetImplObservable.prototype, "underActivated", {
            get: function () {
                return this.under(EShapeState.ACTIVATED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStateSetImplObservable.prototype, "isDeactivated", {
            get: function () {
                return this.is(EShapeState.DEACTIVATED);
            },
            set: function (isDeactivated) {
                this.set(EShapeState.DEACTIVATED, isDeactivated);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStateSetImplObservable.prototype, "inDeactivated", {
            get: function () {
                return this.in(EShapeState.DEACTIVATED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStateSetImplObservable.prototype, "onDeactivated", {
            get: function () {
                return this.on(EShapeState.DEACTIVATED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStateSetImplObservable.prototype, "underDeactivated", {
            get: function () {
                return this.under(EShapeState.DEACTIVATED);
            },
            enumerable: false,
            configurable: true
        });
        return EShapeStateSetImplObservable;
    }(DBaseStateSetImplObservable));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeTransformImpl = /** @class */ (function (_super) {
        __extends(EShapeTransformImpl, _super);
        function EShapeTransformImpl(parent) {
            var _this = _super.call(this) || this;
            _this.internalTransform = new pixi_js.Matrix();
            _this._parent = parent;
            return _this;
        }
        EShapeTransformImpl.prototype.onChange = function () {
            _super.prototype.onChange.call(this);
            this._parent.onTransformChange();
        };
        EShapeTransformImpl.prototype.updateSkew = function () {
            _super.prototype.updateSkew.call(this);
            this._parent.onTransformChange();
        };
        EShapeTransformImpl.prototype.getLocalIdCurrent = function () {
            return this._currentLocalID;
        };
        EShapeTransformImpl.prototype.getLocalId = function () {
            return this._localID;
        };
        EShapeTransformImpl.prototype.getParentId = function () {
            return this._parentID;
        };
        EShapeTransformImpl.prototype.getWorldId = function () {
            return this._worldID;
        };
        EShapeTransformImpl.prototype.updateTransform = function (parentTransform) {
            var oldLocalId = this._currentLocalID;
            var oldWorldId = this._worldID;
            _super.prototype.updateTransform.call(this, parentTransform);
            var newLocalId = this._currentLocalID;
            var newWorldId = this._worldID;
            if (oldLocalId !== newLocalId) {
                var localTransform = this.localTransform;
                var internalTransform = this.internalTransform;
                localTransform.copyTo(internalTransform);
                if (parentTransform instanceof EShapeTransformImpl) {
                    internalTransform.prepend(parentTransform.internalTransform);
                }
            }
            else if (oldWorldId !== newWorldId) {
                var localTransform = this.localTransform;
                var internalTransform = this.internalTransform;
                if (parentTransform instanceof EShapeTransformImpl) {
                    localTransform.copyTo(internalTransform).prepend(parentTransform.internalTransform);
                    this._currentLocalID += 1;
                    this._localID = this._currentLocalID;
                }
            }
        };
        return EShapeTransformImpl;
    }(pixi_js.Transform));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeBaseHitTestData = /** @class */ (function () {
        function EShapeBaseHitTestData() {
            this.x = 0;
            this.y = 0;
            this.width = 0;
            this.height = 0;
            this.strokeWidth = 0;
            this.strokeScale = 1;
            this.strokeAlign = 0;
        }
        EShapeBaseHitTestData.prototype.set = function (x, y, width, height, strokeWidth, strokeScale, strokeAlign) {
            this.x = x;
            this.y = y;
            this.width = width;
            this.height = height;
            this.strokeWidth = strokeWidth;
            this.strokeScale = strokeScale;
            this.strokeAlign = strokeAlign;
            return this;
        };
        return EShapeBaseHitTestData;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var hitTestBBox = function (x, y, ax, ay) {
        return -ax <= x && x <= +ax && -ay <= y && y <= +ay;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /* eslint-disable prettier/prettier */
    var NONE = 0x0;
    var ID = 0x1;
    var POSITION = 0x2;
    var WIDTH$1 = 0x4;
    var HEIGHT$1 = 0x8;
    var ROTATION$1 = 0x10;
    var SKEW = 0x20;
    var REPLACING = 0x40;
    var GROUPING = 0x80;
    var UNGROUPING = 0x100;
    var FILL$1 = 0x200;
    var STROKE$1 = 0x400;
    var STROKE_SIDE = 0x800;
    var BORDER_RADIUS = 0x1000;
    var TEXT$2 = 0x2000;
    var TEXTURE = 0x4000;
    var DATA = 0x8000;
    var ACTION = 0x10000;
    var CURSOR$1 = 0x20000;
    var ORDER_IN_LAYER = 0x40000;
    var CHILDREN$1 = 0x80000;
    var DATA_MAPPING = 0x100000;
    var LINE = 0x200000;
    var LINE_TAIL = 0x400000;
    var LINE_HEAD = 0x800000;
    var COORDINATE = POSITION | WIDTH$1 | HEIGHT$1 | ROTATION$1 | SKEW;
    var SHAPE = REPLACING | GROUPING | FILL$1 | STROKE$1 | LINE | LINE_TAIL | LINE_HEAD;
    var LAYER = ORDER_IN_LAYER;
    var PRIMITIVE = ID | COORDINATE | SHAPE | TEXT$2 | TEXTURE | DATA | ACTION | CURSOR$1 | LAYER | CHILDREN$1;
    var GROUP = PRIMITIVE | UNGROUPING;
    var EMBEDDED = ID | COORDINATE | REPLACING | GROUPING | TEXT$2 | DATA | ACTION | LAYER | DATA_MAPPING;
    var EMBEDDED_ACCEPTOR_EDGE = ID | COORDINATE | REPLACING | FILL$1 | STROKE$1 | TEXT$2 | TEXTURE | DATA | ACTION | CURSOR$1 | LAYER;
    var CONNECTOR = ID | SHAPE | TEXT$2 | TEXTURE | DATA | ACTION | CURSOR$1 | LAYER | CHILDREN$1;
    var ALL = PRIMITIVE | STROKE_SIDE | BORDER_RADIUS | DATA_MAPPING | UNGROUPING;
    var EShapeCapability = {
        NONE: NONE,
        /**
         * Allows shape IDs to be modified.
         */
        ID: ID,
        /**
         * Allows shape positions to be modified.
         */
        POSITION: POSITION,
        /**
         * Allows shape widths to be modified.
         */
        WIDTH: WIDTH$1,
        /**
         * Allows shape heights to be modified.
         */
        HEIGHT: HEIGHT$1,
        /**
         * Allows shape rotations to be modified.
         */
        ROTATION: ROTATION$1,
        /**
         * Allows shape skews to be modified.
         */
        SKEW: SKEW,
        /** @deprecated */
        ALIGN: NONE,
        /**
         * Allows shapes to be replaced with other shapes.
         */
        REPLACING: REPLACING,
        /**
         * Allows shapes to be grouped.
         */
        GROUPING: GROUPING,
        /**
         * Allows grouped shapes to be ungrouped.
         */
        UNGROUPING: UNGROUPING,
        /**
         * Allows shape fills to be modified.
         */
        FILL: FILL$1,
        /**
         * Allows shape strokes to be modified.
         */
        STROKE: STROKE$1,
        /**
         * Allows shape stroke sides to be modified.
         */
        STROKE_SIDE: STROKE_SIDE,
        /**
         * Allows shape border radiuses to be modified.
         */
        BORDER_RADIUS: BORDER_RADIUS,
        /**
         * Allows shape texts to be modified.
         */
        TEXT: TEXT$2,
        /**
         * Allows shape textures to be modified.
         */
        TEXTURE: TEXTURE,
        /** @deprecated in favor of {@link DATA} */
        TAG: DATA,
        /**
         * Allows shape data to be modified.
         */
        DATA: DATA,
        /**
         * Allows shape data mapping to be modified.
         */
        DATA_MAPPING: DATA_MAPPING,
        /**
         * Allows shape actions to be modified.
         */
        ACTION: ACTION,
        /**
         * Allows shape cursors to be modified.
         */
        CURSOR: CURSOR$1,
        /**
         * Allows shape orders in layer to be modified.
         */
        ORDER_IN_LAYER: ORDER_IN_LAYER,
        /**
         * Allows shape children to be modified.
         */
        CHILDREN: CHILDREN$1,
        /**
         * Allows shape line to be modified.
         */
        LINE: LINE,
        /**
         * Allows shape line tail to be modified.
         */
        LINE_TAIL: LINE_TAIL,
        /**
         * Allows shape line head to be modified.
         */
        LINE_HEAD: LINE_HEAD,
        COORDINATE: COORDINATE,
        SHAPE: SHAPE,
        LAYER: LAYER,
        PRIMITIVE: PRIMITIVE,
        GROUP: GROUP,
        EMBEDDED: EMBEDDED,
        EMBEDDED_ACCEPTOR_EDGE: EMBEDDED_ACCEPTOR_EDGE,
        CONNECTOR: CONNECTOR,
        ALL: ALL
    };

    var EShapeCapabilityContainerImpl = /** @class */ (function () {
        function EShapeCapabilityContainerImpl() {
            this.added = EShapeCapability.NONE;
            this.removed = EShapeCapability.NONE;
            this.locked = EShapeCapability.NONE;
        }
        EShapeCapabilityContainerImpl.prototype.add = function (target) {
            this.removed &= ~target;
            this.added |= target;
            return this;
        };
        EShapeCapabilityContainerImpl.prototype.remove = function (target) {
            this.added &= ~target;
            this.removed |= target;
            return this;
        };
        EShapeCapabilityContainerImpl.prototype.lock = function (target) {
            this.locked |= target;
            return this;
        };
        EShapeCapabilityContainerImpl.prototype.unlock = function (target) {
            this.locked &= ~target;
            return this;
        };
        EShapeCapabilityContainerImpl.prototype.clear = function () {
            this.added = EShapeCapability.NONE;
            this.removed = EShapeCapability.NONE;
            this.locked = EShapeCapability.NONE;
            return this;
        };
        EShapeCapabilityContainerImpl.prototype.set = function (added, removed, locked) {
            if (added != null) {
                this.added = added;
            }
            if (removed != null) {
                this.removed = removed;
            }
            if (locked != null) {
                this.locked = locked;
            }
            return this;
        };
        EShapeCapabilityContainerImpl.prototype.copy = function (target) {
            this.added = target.added;
            this.removed = target.removed;
            this.locked = target.locked;
            return this;
        };
        return EShapeCapabilityContainerImpl;
    }());

    var EShapeLock = /** @class */ (function () {
        function EShapeLock() {
            this._count = 0;
            this._flag = 0;
        }
        EShapeLock.prototype.lock = function () {
            this._count += 1;
            if (this._count === 1) {
                this._flag = 0;
                return true;
            }
            return false;
        };
        EShapeLock.prototype.unlock = function () {
            this._count -= 1;
            return this._count <= 0 && this._flag !== 0;
        };
        EShapeLock.prototype.isLocked = function (high) {
            if (0 < this._count) {
                this._flag |= high ? 3 : 1;
                return true;
            }
            return false;
        };
        EShapeLock.prototype.isHigh = function () {
            return 1 < this._flag;
        };
        return EShapeLock;
    }());

    var EShapeLockPart = {
        TRANSFORM_CHILD: 1,
        TRANSFORM_THIS: 2,
        TRANSFORM_PARENT: 4,
        TRANSFORM: 7,
        UPLOADED: 8,
        TRANSFORM_AND_UPLOADED: 15,
        CONNECTOR: 16,
        ALL: 31
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeBase = /** @class */ (function (_super) {
        __extends(EShapeBase, _super);
        function EShapeBase(type) {
            var _this = _super.call(this) || this;
            _this.id = "";
            _this.uuid = 0;
            _this.type = type;
            _this.transform = _this.newTransform();
            _this.action = new EShapeAction();
            _this._visible = true;
            _this._lockTransformChild = new EShapeLock();
            _this._lockTransformThis = new EShapeLock();
            _this._lockTransformParent = new EShapeLock();
            _this._lockUploaded = new EShapeLock();
            _this._boundsTransformId = -1;
            _this._boundsInternalTransformId = -1;
            _this._boundsLocalTransformId = -1;
            _this.interactive = false;
            //
            _this.parent = null;
            _this.children = [];
            //
            _this.selected = false;
            _this.index = 0;
            _this.reference = 0;
            return _this;
        }
        EShapeBase.prototype.newTransform = function () {
            return new EShapeTransformImpl(this);
        };
        EShapeBase.prototype.onSizeChange = function () {
            this._boundsTransformId = -1;
            this._boundsInternalTransformId = -1;
            this._boundsLocalTransformId = -1;
            if (!this._lockTransformChild.isLocked()) {
                this.callChildTransformChange();
            }
            var points = this._points;
            if (points != null) {
                points.onSizeChange();
            }
            this.updateUploaded();
            var connector = this._connector;
            if (connector != null) {
                connector.fit(true);
            }
            var runtime = this.runtime;
            if (runtime != null) {
                runtime.onResize(this);
            }
        };
        EShapeBase.prototype.onTransformChange = function () {
            if (!this._lockTransformChild.isLocked()) {
                this.callChildTransformChange();
            }
            if (!this._lockTransformThis.isLocked()) {
                this.onThisTransformChange();
            }
            if (!this._lockTransformParent.isLocked()) {
                this.callParentTransformChange();
            }
        };
        EShapeBase.prototype.callChildTransformChange = function () {
            var parent = this.parent;
            if (parent != null) {
                parent.onChildTransformChange();
            }
        };
        EShapeBase.prototype.onThisTransformChange = function () {
            this.updateUploaded();
            var connector = this._connector;
            if (connector != null) {
                connector.fit(true);
            }
        };
        EShapeBase.prototype.callParentTransformChange = function () {
            var children = this.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                children[i].onParentTransformChange();
            }
        };
        EShapeBase.prototype.onParentTransformChange = function () {
            if (!this._lockTransformThis.isLocked()) {
                this.onThisTransformChange();
            }
            if (!this._lockTransformParent.isLocked()) {
                this.callParentTransformChange();
            }
        };
        EShapeBase.prototype.lock = function (part) {
            if (part & EShapeLockPart.UPLOADED) {
                this._lockUploaded.lock();
            }
            if (part & EShapeLockPart.TRANSFORM_PARENT) {
                this._lockTransformParent.lock();
            }
            if (part & EShapeLockPart.TRANSFORM_THIS) {
                this._lockTransformThis.lock();
            }
            if (part & EShapeLockPart.TRANSFORM_CHILD) {
                this._lockTransformChild.lock();
            }
            return this;
        };
        EShapeBase.prototype.unlock = function (part, invoke) {
            if (part & EShapeLockPart.TRANSFORM_CHILD) {
                if (this._lockTransformChild.unlock() && invoke) {
                    var parent_1 = this.parent;
                    if (parent_1 != null) {
                        parent_1.onChildTransformChange();
                    }
                }
            }
            if (part & EShapeLockPart.TRANSFORM_THIS) {
                if (this._lockTransformThis.unlock() && invoke) {
                    this.onThisTransformChange();
                }
            }
            if (part & EShapeLockPart.TRANSFORM_PARENT) {
                if (this._lockTransformParent.unlock() && invoke) {
                    var children = this.children;
                    for (var i = 0, imax = children.length; i < imax; ++i) {
                        children[i].onParentTransformChange();
                    }
                }
            }
            if (part & EShapeLockPart.UPLOADED) {
                var lockUploaded = this._lockUploaded;
                if (lockUploaded.unlock() && invoke) {
                    this.updateUploaded(lockUploaded.isHigh());
                }
            }
            return this;
        };
        EShapeBase.prototype.onChildTransformChange = function () {
            //
        };
        EShapeBase.prototype.updateUploaded = function (recursively) {
            if (this._lockUploaded.isLocked(recursively)) {
                return;
            }
            var uploaded = this.uploaded;
            if (uploaded != null) {
                uploaded.update(this);
            }
            if (recursively === true) {
                var children = this.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    children[i].updateUploaded(true);
                }
            }
        };
        Object.defineProperty(EShapeBase.prototype, "points", {
            get: function () {
                return this._points;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeBase.prototype, "root", {
            get: function () {
                var root = this;
                while (root.parent instanceof EShapeBase) {
                    root = root.parent;
                }
                return root;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeBase.prototype, "connector", {
            get: function () {
                var result = this._connector;
                if (result == null) {
                    result = new EShapeConnectorContainerImpl(this);
                    this._connector = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeBase.prototype, "visible", {
            get: function () {
                if (this._visible) {
                    var parent_2 = this.parent;
                    if (parent_2 instanceof EShapeBase) {
                        return parent_2.visible;
                    }
                    return true;
                }
                return false;
            },
            set: function (visible) {
                if (this._visible !== visible) {
                    this._visible = visible;
                    this.updateUploaded(true);
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeBase.prototype, "worldVisible", {
            get: function () {
                if (this._visible) {
                    var parent_3 = this.parent;
                    if (parent_3) {
                        return parent_3.worldVisible;
                    }
                    return true;
                }
                return false;
            },
            enumerable: false,
            configurable: true
        });
        //
        EShapeBase.prototype.toDirty = function () {
            var parent = this.parent;
            if (parent != null) {
                parent.toDirty();
            }
        };
        // Hierarchy
        EShapeBase.prototype.attach = function (parent, at) {
            this.detach();
            this.parent = parent;
            var children = parent.children;
            if (at != null && 0 <= at && at < children.length) {
                children.splice(at, 0, this);
            }
            else {
                children.push(this);
            }
            parent.onChildTransformChange();
            parent.toDirty();
            this.onAttach();
            return this;
        };
        EShapeBase.prototype.onAttach = function () {
            this.uploaded = undefined;
            var connector = this._connector;
            if (connector) {
                connector.attach();
                connector.fit(true);
            }
            var children = this.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                children[i].onAttach();
            }
        };
        EShapeBase.prototype.detach = function (exceptions) {
            var parent = this.parent;
            if (parent) {
                this.parent = null;
                var children = parent.children;
                var index = children.indexOf(this);
                if (0 <= index) {
                    children.splice(index, 1);
                    parent.onChildTransformChange();
                    parent.toDirty();
                    this.onDetach(exceptions);
                }
            }
            return this;
        };
        EShapeBase.prototype.onDetach = function (exceptions) {
            this.uploaded = undefined;
            var connector = this._connector;
            if (connector) {
                connector.detach(exceptions);
            }
            var children = this.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                children[i].onDetach(exceptions);
            }
        };
        // Transform
        EShapeBase.prototype.updateTransform = function () {
            var parent = this.parent;
            if (parent) {
                if (parent.parent) {
                    parent.updateTransform();
                }
                this.transform.updateTransform(parent.transform);
            }
            else {
                this.transform.updateTransform(pixi_js.Transform.IDENTITY);
            }
        };
        // Serialization
        EShapeBase.prototype.serializeChildren = function (manager) {
            var children = this.children;
            var childrenSerialized = [];
            for (var i = 0, imax = children.length; i < imax; ++i) {
                var child = children[i];
                childrenSerialized.push(child.serialize(manager));
            }
            return childrenSerialized;
        };
        EShapeBase.prototype.serializeState = function (manager) {
            var state = this.state;
            return (this.interactive ? 1 : 0) | (state.isFocusable ? 0 : 2) | (state.isActive ? 4 : 0);
        };
        EShapeBase.prototype.serialize = function (manager) {
            var transform = this.transform;
            var position = transform.position;
            var pivot = transform.pivot;
            var size = this.size;
            var shortcut = this.shortcut;
            var shortcutId = shortcut != null ? manager.addResource(shortcut) : -1;
            var cursor = this.cursor;
            var cursorId = cursor != null ? manager.addResource(cursor) : -1;
            var title = this.title;
            var titleId = title != null ? manager.addResource(title) : -1;
            var capabilitiesAdded = EShapeCapability.NONE;
            var capabilitiesRemoved = EShapeCapability.NONE;
            var capabilitiesLocked = EShapeCapability.NONE;
            var capability = this._capability;
            if (capability != null) {
                capabilitiesAdded = capability.added;
                capabilitiesRemoved = capability.removed;
                capabilitiesLocked = capability.locked;
            }
            return [
                this.type,
                manager.addResource(this.id),
                position.x,
                position.y,
                size.x,
                size.y,
                transform.rotation,
                transform.skew.x,
                this.fill.serialize(manager),
                this.stroke.serialize(manager),
                cursorId,
                this.text.serialize(manager),
                this.data.serialize(manager),
                this.radius,
                this.corner,
                -1,
                -1,
                this.action.serialize(manager),
                this.serializeImage(manager),
                this.serializeGradient(manager),
                this.serializeChildren(manager),
                pivot.x,
                pivot.y,
                this.serializeState(manager),
                shortcutId,
                titleId,
                this.uuid,
                capabilitiesAdded,
                capabilitiesRemoved,
                capabilitiesLocked
            ];
        };
        EShapeBase.prototype.addUuid = function (manager) {
            this.uuid = manager.addUuid(this.uuid);
            var children = this.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                children[i].addUuid(manager);
            }
        };
        EShapeBase.prototype.updateUuid = function (manager) {
            this.uuid = manager.updateUuid(this.uuid);
            var children = this.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                children[i].updateUuid(manager);
            }
        };
        // Hit test
        EShapeBase.prototype.getShapeScale = function () {
            var container = this.root.parent;
            if (container != null && container.getShapeScale != null) {
                return container.getShapeScale();
            }
            return 1.0;
        };
        EShapeBase.prototype.getStrokeWidthScale = function (style) {
            if (style & EShapeStrokeStyle.NON_EXPANDING_WIDTH) {
                if (style & EShapeStrokeStyle.NON_SHRINKING_WIDTH) {
                    return this.getShapeScale();
                }
                else {
                    return Math.min(1.0, this.getShapeScale());
                }
            }
            else {
                if (style & EShapeStrokeStyle.NON_SHRINKING_WIDTH) {
                    return Math.max(1.0, this.getShapeScale());
                }
                else {
                    return 1.0;
                }
            }
        };
        EShapeBase.prototype.getHitTestSize = function (result) {
            var size = this.size;
            result.width = 0.5 * size.x;
            result.height = 0.5 * size.y;
            return result;
        };
        EShapeBase.prototype.toHitTestData = function (x, y) {
            var _a;
            var result = this.getHitTestSize(((_a = EShapeBase.WORK_HIT_TEST_DATA) !== null && _a !== void 0 ? _a : (EShapeBase.WORK_HIT_TEST_DATA = new EShapeBaseHitTestData())));
            var sx = result.width;
            var sy = result.height;
            var pivot = this.transform.pivot;
            var dx = x - pivot.x;
            var dy = y - pivot.y;
            var stroke = this.stroke;
            var strokeWidth = stroke.enable ? stroke.width : 0;
            var strokeScale = this.getStrokeWidthScale(stroke.style);
            var strokeAlign = stroke.align;
            var s = strokeWidth * strokeScale * strokeAlign;
            return result.set(0 <= sx ? +dx : -dx, 0 <= sy ? +dy : -dy, Math.abs(sx) + s, Math.abs(sy) + s, strokeWidth, strokeScale, strokeAlign);
        };
        EShapeBase.prototype.contains = function (x, y) {
            var data = this.toHitTestData(x, y);
            if (this.containsAbs(data.x, data.y, data.width, data.height, data.strokeWidth, data.strokeScale, data.strokeAlign)) {
                return this;
            }
            return this.containsText(x, y) || this.containsChildren(x, y);
        };
        EShapeBase.prototype.containsText = function (x, y) {
            var text = this.text;
            var textAtlas = text.atlas;
            if (textAtlas != null) {
                var textWorld = text.world;
                if (textWorld != null) {
                    var transform = this.transform.internalTransform;
                    var tx = transform.a * x + transform.c * y + transform.tx - textWorld[0];
                    var ty = transform.b * x + transform.d * y + transform.ty - textWorld[1];
                    var th = textWorld[2] * tx + textWorld[3] * ty;
                    var tv = textWorld[4] * tx + textWorld[5] * ty;
                    var w = textWorld[6];
                    var h = textWorld[7];
                    if (0 <= th && th <= w && 0 <= tv && tv <= h) {
                        return this;
                    }
                }
            }
            return null;
        };
        EShapeBase.prototype.containsChildren = function (x, y) {
            var children = this.children;
            for (var i = children.length - 1; 0 <= i; --i) {
                var child = children[i];
                child.updateTransform();
                var localTransform = child.transform.localTransform;
                var a = localTransform.a;
                var b = localTransform.b;
                var c = localTransform.c;
                var d = localTransform.d;
                var tx = localTransform.tx;
                var ty = localTransform.ty;
                var id = 1 / (a * d - c * b);
                var lx = (d * x - c * y + ty * c - tx * d) * id;
                var ly = (a * y - b * x - ty * a + tx * b) * id;
                var childResult = child.contains(lx, ly);
                if (childResult != null) {
                    return childResult;
                }
            }
            return null;
        };
        EShapeBase.prototype.containsBBox = function (x, y) {
            var data = this.toHitTestData(x, y);
            return this.containsAbsBBox(data.x, data.y, data.width, data.height);
        };
        EShapeBase.prototype.containsAbs = function (x, y, ax, ay, sw, ss, sa) {
            return this.containsAbsBBox(x, y, ax, ay);
        };
        EShapeBase.prototype.containsAbsBBox = function (x, y, ax, ay) {
            return hitTestBBox(x, y, ax, ay);
        };
        EShapeBase.prototype.select = function (point) {
            return false;
        };
        //
        EShapeBase.prototype.toGlobal = function (position, result, skipUpdate) {
            if (skipUpdate !== true) {
                this.updateTransform();
            }
            result.copyFrom(position);
            this.transform.worldTransform.apply(result, result);
            return result;
        };
        EShapeBase.prototype.toLocal = function (position, from, result, skipUpdate) {
            if (skipUpdate !== true) {
                this.updateTransform();
            }
            if (result === undefined) {
                result = new pixi_js.Point();
            }
            result.copyFrom(position);
            this.transform.worldTransform.applyInverse(result, result);
            return result;
        };
        EShapeBase.prototype.getBounds = function (skipUpdate, result) {
            if (skipUpdate !== true) {
                this.updateTransform();
            }
            var bounds = this._bounds || new pixi_js.Rectangle();
            this._bounds = bounds;
            var worldId = this.transform.getWorldId();
            if (worldId !== this._boundsTransformId) {
                this._boundsTransformId = worldId;
                this.getBounds_(this.transform.worldTransform, bounds);
            }
            result !== null && result !== void 0 ? result : (result = new pixi_js.Rectangle());
            result.copyFrom(bounds);
            return result;
        };
        EShapeBase.prototype.getBoundsInternal = function (skipUpdate, result) {
            if (skipUpdate !== true) {
                this.updateTransform();
            }
            var boundsInternal = this._boundsInternal || new pixi_js.Rectangle();
            this._boundsInternal = boundsInternal;
            var currentLocalId = this.transform.getLocalIdCurrent();
            if (currentLocalId !== this._boundsInternalTransformId) {
                this._boundsInternalTransformId = currentLocalId;
                this.getBounds_(this.transform.internalTransform, boundsInternal);
            }
            result !== null && result !== void 0 ? result : (result = new pixi_js.Rectangle());
            result.copyFrom(boundsInternal);
            return result;
        };
        EShapeBase.prototype.getBoundsLocal = function (skipUpdate, result) {
            if (skipUpdate !== true) {
                this.updateTransform();
            }
            var boundsLocal = this._boundsLocal || new pixi_js.Rectangle();
            this._boundsLocal = boundsLocal;
            var currentLocalId = this.transform.getLocalIdCurrent();
            if (currentLocalId !== this._boundsLocalTransformId) {
                this._boundsLocalTransformId = currentLocalId;
                this.getBounds_(this.transform.localTransform, boundsLocal);
            }
            result !== null && result !== void 0 ? result : (result = new pixi_js.Rectangle());
            result.copyFrom(boundsLocal);
            return result;
        };
        EShapeBase.prototype.getBoundsSize = function () {
            return this.size;
        };
        EShapeBase.prototype.getBounds_ = function (transform, result) {
            var pivot = this.transform.pivot;
            var px = pivot.x;
            var py = pivot.y;
            var size = this.getBoundsSize();
            var sx = 0.5 * size.x;
            var sy = 0.5 * size.y;
            var a = transform.a;
            var b = transform.b;
            var c = transform.c;
            var d = transform.d;
            var x = -sx + px;
            var y = -sy + py;
            var x0 = a * x + c * y;
            var y0 = b * x + d * y;
            x = +sx + px;
            y = -sy + py;
            var x1 = a * x + c * y;
            var y1 = b * x + d * y;
            x = -sx + px;
            y = +sy + py;
            var x2 = a * x + c * y;
            var y2 = b * x + d * y;
            x = +sx + px;
            y = +sy + py;
            var x3 = a * x + c * y;
            var y3 = b * x + d * y;
            var xmin = Math.min(x0, x1, x2, x3);
            var ymin = Math.min(y0, y1, y2, y3);
            var xmax = Math.max(x0, x1, x2, x3);
            var ymax = Math.max(y0, y1, y2, y3);
            result.x = xmin + transform.tx;
            result.y = ymin + transform.ty;
            result.width = xmax - xmin;
            result.height = ymax - ymin;
            return result;
        };
        //
        EShapeBase.prototype.destroy = function () {
            var children = this.children;
            for (var i = children.length - 1; 0 <= i; --i) {
                children[i].destroy();
            }
            children.length = 0;
        };
        //
        EShapeBase.prototype.onStateChange = function (newState, oldState) {
            var runtime = this.runtime;
            if (runtime != null) {
                runtime.onStateChange(this, newState, oldState);
            }
            var children = this.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                var child = children[i];
                if (child instanceof EShapeBase) {
                    child.state.onParentChange(newState, oldState);
                }
            }
        };
        Object.defineProperty(EShapeBase.prototype, "state", {
            get: function () {
                var _this = this;
                var result = this._state;
                if (result == null) {
                    result = new EShapeStateSetImplObservable(function (newState, oldState) {
                        _this.onStateChange(newState, oldState);
                    });
                    this._state = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeBase.prototype, "capability", {
            get: function () {
                var result = this._capability;
                if (result == null) {
                    result = new EShapeCapabilityContainerImpl();
                    this._capability = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        EShapeBase.prototype.getCapability = function () {
            return this._capability;
        };
        EShapeBase.prototype.focus = function () {
            this.setFocused(true);
            return this;
        };
        EShapeBase.prototype.blur = function () {
            this.setFocused(false);
            return this;
        };
        EShapeBase.prototype.setFocused = function (isFocused) {
            if (this.state.isFocused !== isFocused) {
                var layer = DApplications.getLayer(this);
                if (layer) {
                    layer.getFocusController().set(this, isFocused);
                }
            }
        };
        EShapeBase.prototype.onKeyDown = function (e) {
            var runtime = this.runtime;
            if (runtime) {
                return runtime.onKeyDown(this, e);
            }
            return false;
        };
        EShapeBase.prototype.onKeyUp = function (e) {
            var runtime = this.runtime;
            if (runtime) {
                return runtime.onKeyUp(this, e);
            }
            return false;
        };
        //
        EShapeBase.prototype.update = function (time) {
            var runtime = this.runtime;
            if (runtime) {
                runtime.update(this, time);
            }
        };
        EShapeBase.prototype.onRender = function (time, renderer) {
            var runtime = this.runtime;
            if (runtime) {
                runtime.onRender(this, time, renderer);
            }
        };
        EShapeBase.prototype.copy = function (source, part) {
            if (part === void 0) { part = EShapeCopyPart.ALL; }
            this.lock(EShapeLockPart.ALL);
            this.id = source.id;
            this.uuid = source.uuid;
            this.visible = source.visible;
            if (part & EShapeCopyPart.TRANSFORM) {
                var transform = this.transform;
                var sourceTransform = source.transform;
                transform.position.copyFrom(sourceTransform.position);
                transform.rotation = sourceTransform.rotation;
                transform.skew.copyFrom(sourceTransform.skew);
                transform.pivot.copyFrom(sourceTransform.pivot);
                transform.scale.copyFrom(sourceTransform.scale);
            }
            if (part & EShapeCopyPart.SIZE) {
                this.size.copyFrom(source.size);
            }
            if (part & EShapeCopyPart.STYLE) {
                this.fill.copy(source.fill);
                this.stroke.copy(source.stroke);
                this.text.copy(source.text);
                this.radius = source.radius;
                this.corner = source.corner;
            }
            if (part & EShapeCopyPart.DATA) {
                this.data.copy(source.data);
            }
            if (part & EShapeCopyPart.IMAGE) {
                this.image = source.image;
            }
            if (part & EShapeCopyPart.ACTION) {
                this.action.clearAndAddAll(source.action.values);
                this.interactive = source.interactive;
                this.title = source.title;
                this.cursor = source.cursor;
                this.shortcut = source.shortcut;
            }
            if (part & EShapeCopyPart.POINTS) {
                var sourcePoints = source.points;
                if (sourcePoints != null) {
                    var points = this.points;
                    if (points != null) {
                        points.copy(sourcePoints);
                    }
                }
            }
            if (part & EShapeCopyPart.STATE) {
                this.state.lock(false).copy(source.state).unlock();
            }
            if (part & EShapeCopyPart.CONNECTOR) {
                if (source instanceof EShapeBase) {
                    var sourceConnector = source._connector;
                    if (sourceConnector) {
                        this.connector.copy(sourceConnector);
                    }
                    else {
                        var connector = this._connector;
                        if (connector) {
                            connector.clear();
                        }
                    }
                }
                else {
                    var connector = this._connector;
                    if (connector) {
                        connector.clear();
                    }
                }
            }
            if (part & EShapeCopyPart.CAPABILITY) {
                var sourceCapability = source.getCapability();
                if (sourceCapability != null) {
                    this.capability.copy(sourceCapability);
                }
                else {
                    var capability = this._capability;
                    if (capability != null) {
                        capability.clear();
                    }
                }
            }
            this.unlock(EShapeLockPart.ALL, true);
            return this;
        };
        return EShapeBase;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeStrokeImpl = /** @class */ (function () {
        function EShapeStrokeImpl(parent, enable, color, alpha, width, align, side, style) {
            this._parent = parent;
            this._enable = enable;
            this._color = color;
            this._alpha = alpha;
            this._width = width;
            this._align = align;
            this._side = side;
            this._style = style;
        }
        Object.defineProperty(EShapeStrokeImpl.prototype, "enable", {
            get: function () {
                return this._enable;
            },
            set: function (enable) {
                if (this._enable !== enable) {
                    this._enable = enable;
                    this._parent.updateUploaded();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStrokeImpl.prototype, "color", {
            get: function () {
                return this._color;
            },
            set: function (color) {
                if (this._color !== color) {
                    this._color = color;
                    this._parent.updateUploaded();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStrokeImpl.prototype, "alpha", {
            get: function () {
                return this._alpha;
            },
            set: function (alpha) {
                if (this._alpha !== alpha) {
                    this._alpha = alpha;
                    this._parent.updateUploaded();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStrokeImpl.prototype, "width", {
            get: function () {
                return this._width;
            },
            set: function (width) {
                if (this._width !== width) {
                    this._width = width;
                    this._parent.updateUploaded();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStrokeImpl.prototype, "align", {
            get: function () {
                return this._align;
            },
            set: function (align) {
                if (this._align !== align) {
                    this._align = align;
                    this._parent.updateUploaded();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStrokeImpl.prototype, "side", {
            get: function () {
                return this._side;
            },
            set: function (side) {
                if (this._side !== side) {
                    this._side = side;
                    this._parent.updateUploaded();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStrokeImpl.prototype, "style", {
            get: function () {
                return this._style;
            },
            set: function (style) {
                if (this._style !== style) {
                    this._style = style;
                    this._parent.updateUploaded();
                }
            },
            enumerable: false,
            configurable: true
        });
        EShapeStrokeImpl.prototype.copy = function (target) {
            if (target) {
                this.set(target.enable, target.color, target.alpha, target.width, target.align, target.side, target.style);
            }
        };
        EShapeStrokeImpl.prototype.set = function (enable, color, alpha, width, align, side, style) {
            var isChanged = false;
            if (enable !== undefined && this._enable !== enable) {
                this._enable = enable;
                isChanged = true;
            }
            if (color !== undefined && this._color !== color) {
                this._color = color;
                isChanged = true;
            }
            if (alpha !== undefined && this._alpha !== alpha) {
                this._alpha = alpha;
                isChanged = true;
            }
            if (width !== undefined && this._width !== width) {
                this._width = width;
                isChanged = true;
            }
            if (align !== undefined && this._align !== align) {
                this._align = align;
                isChanged = true;
            }
            if (side !== undefined && this._side !== side) {
                this._side = side;
                isChanged = true;
            }
            if (style !== undefined && this._style !== style) {
                this._style = style;
                isChanged = true;
            }
            if (isChanged) {
                this._parent.updateUploaded();
            }
        };
        EShapeStrokeImpl.prototype.clone = function () {
            return new EShapeStrokeImpl(this._parent, this._enable, this._color, this._alpha, this._width, this._align, this._side, this._style);
        };
        EShapeStrokeImpl.prototype.toObject = function () {
            return {
                enable: this._enable,
                color: this._color,
                alpha: this._alpha,
                width: this._width,
                align: this._align,
                side: this._side,
                style: this._style
            };
        };
        EShapeStrokeImpl.prototype.serialize = function (manager) {
            var enable = this._enable ? 1 : 0;
            var serialized = "[".concat(enable, ",").concat(this._color, ",").concat(this._alpha, ",").concat(this._width, ",").concat(this._align, ",").concat(this._side, ",").concat(this._style, "]");
            return manager.addResource(serialized);
        };
        EShapeStrokeImpl.prototype.deserialize = function (target, manager) {
            var resources = manager.resources;
            if (0 <= target && target < resources.length) {
                var parsed = manager.getStroke(target);
                if (parsed != null) {
                    this.set(!!parsed[0], parsed[1], parsed[2], parsed[3], parsed[4], parsed[5], parsed[6]);
                }
                else {
                    var deserialized = JSON.parse(resources[target]);
                    manager.setStroke(target, deserialized);
                    this.set(!!deserialized[0], deserialized[1], deserialized[2], deserialized[3], deserialized[4], deserialized[5], deserialized[6]);
                }
            }
        };
        return EShapeStrokeImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FROM = 1;
    var TO = 2;
    var EShapeDataValueRangeType = {
        NONE: 0,
        FROM: FROM,
        TO: TO,
        FROM_TO: FROM | TO
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeDataValueRangeImpl = /** @class */ (function () {
        function EShapeDataValueRangeImpl() {
            this._type = EShapeDataValueRangeType.NONE;
            this._from = 0;
            this._to = 1;
        }
        Object.defineProperty(EShapeDataValueRangeImpl.prototype, "type", {
            get: function () {
                return this._type;
            },
            set: function (type) {
                if (this._type !== type) {
                    this._type = type;
                    var parent_1 = this.parent;
                    if (parent_1 != null) {
                        parent_1.isChanged = true;
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeDataValueRangeImpl.prototype, "from", {
            get: function () {
                return this._from;
            },
            set: function (from) {
                if (this._from !== from) {
                    this._from = from;
                    var parent_2 = this.parent;
                    if (parent_2 != null) {
                        parent_2.isChanged = true;
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeDataValueRangeImpl.prototype, "to", {
            get: function () {
                return this._to;
            },
            set: function (to) {
                if (this._to !== to) {
                    this._to = to;
                    var parent_3 = this.parent;
                    if (parent_3 != null) {
                        parent_3.isChanged = true;
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        EShapeDataValueRangeImpl.prototype.set = function (from, to) {
            var result = false;
            if (from !== undefined && to !== undefined) {
                if (from !== null && to !== null) {
                    var type = this._type | EShapeDataValueRangeType.FROM | EShapeDataValueRangeType.TO;
                    if (this._type !== type || this._from !== from || this._to !== to) {
                        this._type = type;
                        this._from = from;
                        this._to = to;
                        result = true;
                    }
                }
                else if (from !== null) {
                    var type = (this._type | EShapeDataValueRangeType.FROM) & ~EShapeDataValueRangeType.TO;
                    if (this._type !== type || this._from !== from) {
                        this._type = type;
                        this._from = from;
                        result = true;
                    }
                }
                else if (to !== null) {
                    var type = (this._type | EShapeDataValueRangeType.TO) & ~EShapeDataValueRangeType.FROM;
                    if (this._type !== type || this._from !== from) {
                        this._type = type;
                        this._to = to;
                        result = true;
                    }
                }
                else {
                    var type = this._type & ~(EShapeDataValueRangeType.TO | EShapeDataValueRangeType.FROM);
                    if (this._type !== type) {
                        this._type = type;
                        result = true;
                    }
                }
            }
            else if (from !== undefined) {
                if (from !== null) {
                    var type = this._type | EShapeDataValueRangeType.FROM;
                    if (this._type !== type || this._from !== from) {
                        this._type = type;
                        this._from = from;
                        result = true;
                    }
                }
                else {
                    var type = this._type & ~EShapeDataValueRangeType.FROM;
                    if (this._type !== type) {
                        this._type = type;
                        result = true;
                    }
                }
            }
            else if (to !== undefined) {
                if (to !== null) {
                    var type = this._type | EShapeDataValueRangeType.TO;
                    if (this._type !== type || this._to !== to) {
                        this._type = type;
                        this._to = to;
                        result = true;
                    }
                }
                else {
                    var type = this._type & ~EShapeDataValueRangeType.TO;
                    if (this._type !== type) {
                        this._type = type;
                        result = true;
                    }
                }
            }
            if (result) {
                var parent_4 = this.parent;
                if (parent_4 != null) {
                    parent_4.isChanged = true;
                }
            }
            return result;
        };
        EShapeDataValueRangeImpl.prototype.normalize = function (value) {
            var type = this._type;
            var from = this._from;
            var to = this._to;
            switch (type) {
                case EShapeDataValueRangeType.FROM_TO:
                    return (value - from) / (to - from);
                case EShapeDataValueRangeType.FROM:
                    return value - from;
                case EShapeDataValueRangeType.TO:
                    return to - value;
                case EShapeDataValueRangeType.NONE:
                default:
                    return value;
            }
        };
        EShapeDataValueRangeImpl.prototype.isEquals = function (target) {
            return this._type === target.type && this._from === target.from && this._to === target.to;
        };
        EShapeDataValueRangeImpl.prototype.copy = function (target) {
            return this.copy_(target.type, target.from, target.to);
        };
        EShapeDataValueRangeImpl.prototype.copy_ = function (type, from, to) {
            var isChanged = false;
            if (this._type !== type) {
                this._type = type;
                isChanged = true;
            }
            if (this._from !== from) {
                this._from = from;
                isChanged = true;
            }
            if (this._to !== to) {
                this._to = to;
                isChanged = true;
            }
            if (isChanged) {
                var parent_5 = this.parent;
                if (parent_5 != null) {
                    parent_5.isChanged = true;
                }
            }
            return this;
        };
        EShapeDataValueRangeImpl.prototype.toObject = function () {
            return {
                type: this.type,
                from: this.from,
                to: this.to
            };
        };
        EShapeDataValueRangeImpl.prototype.serialize = function (manager) {
            var serialized = "[".concat(this._type, ",").concat(this._from, ",").concat(this._to, "]");
            return manager.addResource(serialized);
        };
        EShapeDataValueRangeImpl.prototype.deserialize = function (target, manager) {
            var resources = manager.resources;
            if (0 <= target && target < resources.length) {
                var parsed = manager.getRange(target);
                if (parsed != null) {
                    this.copy_(parsed[0], parsed[1], parsed[2]);
                }
                else {
                    var deserialized = JSON.parse(resources[target]);
                    manager.setRange(target, deserialized);
                    this.copy_(deserialized[0], deserialized[1], deserialized[2]);
                }
            }
        };
        return EShapeDataValueRangeImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeDataValueOrder = {
        ASCENDING: 0,
        DESCENDING: 1
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeDataValueType = {
        BOOLEAN: 7,
        BOOLEAN_ARRAY: 8,
        NUMBER: 0,
        NUMBER_ARRAY: 1,
        STRING: 2,
        STRING_ARRAY: 3,
        OBJECT: 4,
        OBJECT_ARRAY: 5,
        TICKER: 6,
        EXTENSION: 1000
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeDataValueScope = {
        /**
         * A private data is accessible only from inside the graphic that this data belongs to.
         * The data is not accessible from anywhere outside the graphic.
         */
        PRIVATE: 0,
        /**
         * A public data is accessible from anywhere outside graphics.
         */
        PUBLIC: 1,
        /**
         * A protected data is accessible only from inside graphics.
         * Unlike the private data, the protected data is also accessible from parent graphics
         * containing the graphic that this data belongs to.
         */
        PROTECTED: 2
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeDataValueState = {
        /**
         * The data status is not known.
         * This is the default state.
         */
        UNKNOWN: -1,
        /**
         * The request succeeded.
         */
        FOUND: 0,
        /**
         * The server can not find the requested data.
         */
        NOT_FOUND: 1,
        /**
         * The settings or something provided by clients are considered incorrect.
         */
        BAD_REQUEST: 2,
        /**
         * The server has encountered unknown errors.
         */
        SERVER_ERROR: 3,
        /**
         * The server is not ready to handle the request.
         */
        SERVICE_UNAVAILABLE: 4,
        /**
         * A client is not allowed to access this data.
         */
        FORBIDDEN: 5,
        /**
         * The server can not find the definition of the requested data.
         */
        NOT_DEFINED: 6
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var INDEX_COMPARATOR = function (a, b) {
        return a - b;
    };
    var EShapeDataValueImpl = /** @class */ (function () {
        function EShapeDataValueImpl() {
            this.id = "";
            this.as = "";
            this.type = EShapeDataValueType.NUMBER;
            this.scope = EShapeDataValueScope.PUBLIC;
            this.initial = "";
            this.format = "";
            this.range = new EShapeDataValueRangeImpl();
            this._value = 0;
            this._time = 0;
            this._state = EShapeDataValueState.UNKNOWN;
            this._capacity = 0;
            this._order = EShapeDataValueOrder.ASCENDING;
        }
        Object.defineProperty(EShapeDataValueImpl.prototype, "parent", {
            get: function () {
                return this._parent;
            },
            set: function (parent) {
                if (this._parent !== parent) {
                    this._parent = parent;
                    this.range.parent = parent;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeDataValueImpl.prototype, "value", {
            get: function () {
                return this._value;
            },
            set: function (newValue) {
                var formatter = this.formatter;
                if (formatter != null) {
                    newValue = formatter(newValue);
                }
                var capacity = this._capacity;
                if (capacity <= 0) {
                    if (this._value !== newValue) {
                        this._value = newValue;
                        var parent_1 = this.parent;
                        if (parent_1 != null) {
                            parent_1.isChanged = true;
                        }
                    }
                }
                else {
                    var values = this._values;
                    if (values == null) {
                        values = [];
                        this._values = values;
                    }
                    // Update the value
                    this._value = newValue;
                    // Update the values
                    var order = this._order;
                    if (order === EShapeDataValueOrder.ASCENDING) {
                        values.push(newValue);
                    }
                    else {
                        values.unshift(newValue);
                    }
                    // Remove the unnecessary values
                    var count = values.length - capacity;
                    if (0 < count) {
                        if (order === EShapeDataValueOrder.ASCENDING) {
                            for (var i = 0; i < count; ++i) {
                                values.shift();
                            }
                        }
                        else {
                            values.length = capacity;
                        }
                    }
                    // Tell the parent it's changed
                    var parent_2 = this.parent;
                    if (parent_2 != null) {
                        parent_2.isChanged = true;
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeDataValueImpl.prototype, "nvalue", {
            get: function () {
                return this.range.normalize(this._value);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeDataValueImpl.prototype, "values", {
            get: function () {
                var result = this._values;
                if (result == null) {
                    result = [];
                    this._values = result;
                }
                return result;
            },
            set: function (newValues) {
                var newValuesLength = newValues.length;
                if (0 < newValuesLength) {
                    var capacity = this._capacity;
                    if (capacity <= 0) {
                        var newValue = newValues[newValuesLength - 1];
                        var formatter = this.formatter;
                        if (formatter != null) {
                            newValue = formatter(newValue);
                        }
                        if (this._value !== newValue) {
                            this._value = newValue;
                            var parent_3 = this.parent;
                            if (parent_3 != null) {
                                parent_3.isChanged = true;
                            }
                        }
                    }
                    else {
                        var values = this._values;
                        if (values == null) {
                            values = [];
                            this._values = values;
                        }
                        var order = this._order;
                        var formatter = this.formatter;
                        if (formatter != null) {
                            // Update the value
                            this._value = formatter(newValues[newValuesLength - 1]);
                            // Update the values
                            if (order === EShapeDataValueOrder.ASCENDING) {
                                for (var i = 0; i < newValuesLength; ++i) {
                                    values.push(formatter(newValues[i]));
                                }
                            }
                            else {
                                for (var i = 0; i < newValuesLength; ++i) {
                                    values.unshift(formatter(newValues[i]));
                                }
                            }
                        }
                        else {
                            // Update the value
                            this._value = newValues[newValuesLength - 1];
                            // Update the values
                            if (order === EShapeDataValueOrder.ASCENDING) {
                                for (var i = 0; i < newValuesLength; ++i) {
                                    values.push(newValues[i]);
                                }
                            }
                            else {
                                for (var i = 0; i < newValuesLength; ++i) {
                                    values.unshift(newValues[i]);
                                }
                            }
                        }
                        // Remove the unnecessary values
                        var count = values.length - capacity;
                        if (0 < count) {
                            if (order === EShapeDataValueOrder.ASCENDING) {
                                for (var i = 0; i < count; ++i) {
                                    values.shift();
                                }
                            }
                            else {
                                values.length = capacity;
                            }
                        }
                        // Tell the parent it's changed
                        var parent_4 = this.parent;
                        if (parent_4 != null) {
                            parent_4.isChanged = true;
                        }
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeDataValueImpl.prototype, "time", {
            get: function () {
                return this._time;
            },
            set: function (newTime) {
                var capacity = this._capacity;
                if (capacity <= 0) {
                    if (this._time !== newTime) {
                        this._time = newTime;
                        var parent_5 = this.parent;
                        if (parent_5 != null) {
                            parent_5.isChanged = true;
                        }
                    }
                }
                else {
                    // Update the times
                    var times = this._times;
                    if (times == null) {
                        times = [];
                        this._times = times;
                    }
                    // Update the time
                    this._time = newTime;
                    // Update the times
                    var order = this._order;
                    if (order === EShapeDataValueOrder.ASCENDING) {
                        times.push(newTime);
                    }
                    else {
                        times.unshift(newTime);
                    }
                    // Remove the unnecessary times
                    var count = times.length - capacity;
                    if (0 < count) {
                        if (order === EShapeDataValueOrder.ASCENDING) {
                            for (var i = 0; i < count; ++i) {
                                times.shift();
                            }
                        }
                        else {
                            times.length = capacity;
                        }
                    }
                    // Tell the parent it's changed
                    var parent_6 = this.parent;
                    if (parent_6 != null) {
                        parent_6.isChanged = true;
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeDataValueImpl.prototype, "times", {
            get: function () {
                var result = this._times;
                if (result == null) {
                    result = [];
                    this._times = result;
                }
                return result;
            },
            set: function (newTimes) {
                var newTimesLength = newTimes.length;
                if (0 < newTimesLength) {
                    var capacity = this._capacity;
                    if (capacity <= 0) {
                        var newTime = newTimes[newTimesLength - 1];
                        if (this._time !== newTime) {
                            this._time = newTime;
                            var parent_7 = this.parent;
                            if (parent_7 != null) {
                                parent_7.isChanged = true;
                            }
                        }
                    }
                    else {
                        // Update the times
                        var times = this._times;
                        if (times == null) {
                            times = [];
                            this._times = times;
                        }
                        // Update the value
                        this._time = newTimes[newTimesLength - 1];
                        //
                        var order = this._order;
                        if (order === EShapeDataValueOrder.ASCENDING) {
                            for (var i = 0; i < newTimesLength; ++i) {
                                times.push(newTimes[i]);
                            }
                        }
                        else {
                            for (var i = 0; i < newTimesLength; ++i) {
                                times.unshift(newTimes[i]);
                            }
                        }
                        //
                        var count = times.length - capacity;
                        if (0 < count) {
                            if (order === EShapeDataValueOrder.ASCENDING) {
                                for (var i = 0; i < count; ++i) {
                                    times.shift();
                                }
                            }
                            else {
                                times.length = capacity;
                            }
                        }
                        // Tell the parent it's changed
                        var parent_8 = this.parent;
                        if (parent_8 != null) {
                            parent_8.isChanged = true;
                        }
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeDataValueImpl.prototype, "state", {
            get: function () {
                return this._state;
            },
            set: function (newState) {
                var capacity = this._capacity;
                if (capacity <= 0) {
                    if (this._state !== newState) {
                        this._state = newState;
                        var parent_9 = this.parent;
                        if (parent_9 != null) {
                            parent_9.isChanged = true;
                        }
                    }
                }
                else {
                    // Update the states
                    var states = this._states;
                    if (states == null) {
                        states = [];
                        this._states = states;
                    }
                    // Update the state
                    this._state = newState;
                    // Update the states
                    var order = this._order;
                    if (order === EShapeDataValueOrder.ASCENDING) {
                        states.push(newState);
                    }
                    else {
                        states.unshift(newState);
                    }
                    // Remove the unnecessary states
                    var count = states.length - capacity;
                    if (0 < count) {
                        if (order === EShapeDataValueOrder.ASCENDING) {
                            for (var i = 0; i < count; ++i) {
                                states.shift();
                            }
                        }
                        else {
                            states.length = capacity;
                        }
                    }
                    // Tell the parent it's changed
                    var parent_10 = this.parent;
                    if (parent_10 != null) {
                        parent_10.isChanged = true;
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeDataValueImpl.prototype, "states", {
            get: function () {
                var result = this._states;
                if (result == null) {
                    result = [];
                    this._states = result;
                }
                return result;
            },
            set: function (newStates) {
                var newStatesLength = newStates.length;
                if (0 < newStatesLength) {
                    var capacity = this._capacity;
                    if (capacity <= 0) {
                        var newState = newStates[newStatesLength - 1];
                        if (this._state !== newState) {
                            this._state = newState;
                            var parent_11 = this.parent;
                            if (parent_11 != null) {
                                parent_11.isChanged = true;
                            }
                        }
                    }
                    else {
                        // Update the states
                        var states = this._states;
                        if (states == null) {
                            states = [];
                            this._states = states;
                        }
                        // Update the value
                        this._state = newStates[newStatesLength - 1];
                        //
                        var order = this._order;
                        if (order === EShapeDataValueOrder.ASCENDING) {
                            for (var i = 0; i < newStatesLength; ++i) {
                                states.push(newStates[i]);
                            }
                        }
                        else {
                            for (var i = 0; i < newStatesLength; ++i) {
                                states.unshift(newStates[i]);
                            }
                        }
                        //
                        var count = states.length - capacity;
                        if (0 < count) {
                            if (order === EShapeDataValueOrder.ASCENDING) {
                                for (var i = 0; i < count; ++i) {
                                    states.shift();
                                }
                            }
                            else {
                                states.length = capacity;
                            }
                        }
                        // Tell the parent it's changed
                        var parent_12 = this.parent;
                        if (parent_12 != null) {
                            parent_12.isChanged = true;
                        }
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeDataValueImpl.prototype, "capacity", {
            get: function () {
                return this._capacity;
            },
            set: function (capacity) {
                if (this._capacity < capacity) {
                    this._capacity = capacity;
                }
                else if (capacity < this._capacity) {
                    this._capacity = capacity;
                    var isChanged = false;
                    // Values
                    var order = this._order;
                    var values = this._values;
                    if (values != null) {
                        var count = values.length - capacity;
                        if (0 < count) {
                            if (order === EShapeDataValueOrder.ASCENDING) {
                                for (var i = 0; i < count; ++i) {
                                    values.shift();
                                }
                            }
                            else {
                                values.length = capacity;
                            }
                            isChanged = true;
                        }
                    }
                    // Times
                    var times = this._times;
                    if (times != null) {
                        var count = times.length - capacity;
                        if (0 < count) {
                            if (order === EShapeDataValueOrder.ASCENDING) {
                                for (var i = 0; i < count; ++i) {
                                    times.shift();
                                }
                            }
                            else {
                                times.length = capacity;
                            }
                            isChanged = true;
                        }
                    }
                    // States
                    var states = this._states;
                    if (states != null) {
                        var count = states.length - capacity;
                        if (0 < count) {
                            if (order === EShapeDataValueOrder.ASCENDING) {
                                for (var i = 0; i < count; ++i) {
                                    states.shift();
                                }
                            }
                            else {
                                states.length = capacity;
                            }
                            isChanged = true;
                        }
                    }
                    if (isChanged) {
                        var parent_13 = this.parent;
                        if (parent_13 != null) {
                            parent_13.isChanged = true;
                        }
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeDataValueImpl.prototype, "order", {
            get: function () {
                return this._order;
            },
            set: function (order) {
                this._order = order;
            },
            enumerable: false,
            configurable: true
        });
        EShapeDataValueImpl.prototype.remove = function (index) {
            var isChanged = false;
            // Values
            var values = this._values;
            if (values != null) {
                if (0 <= index && index < values.length) {
                    values.splice(index, 1);
                    isChanged = true;
                }
            }
            // Times
            var times = this._times;
            if (times != null) {
                if (0 <= index && index < times.length) {
                    times.splice(index, 1);
                    isChanged = true;
                }
            }
            // States
            var states = this._states;
            if (states != null) {
                if (0 <= index && index < states.length) {
                    states.splice(index, 1);
                    isChanged = true;
                }
            }
            if (isChanged) {
                var parent_14 = this.parent;
                if (parent_14 != null) {
                    parent_14.isChanged = true;
                }
            }
        };
        EShapeDataValueImpl.prototype.removeAll = function (indices) {
            var isChanged = false;
            var sorted = indices.slice(0).sort(INDEX_COMPARATOR);
            var sortedLength = sorted.length;
            // Values
            var values = this._values;
            if (values != null) {
                for (var i = sortedLength - 1; 0 <= i; --i) {
                    var index = sorted[i];
                    if (0 <= index && index < values.length) {
                        values.splice(index, 1);
                        isChanged = true;
                    }
                }
            }
            // Times
            var times = this._times;
            if (times != null) {
                for (var i = sortedLength - 1; 0 <= i; --i) {
                    var index = sorted[i];
                    if (0 <= index && index < times.length) {
                        times.splice(index, 1);
                        isChanged = true;
                    }
                }
            }
            // States
            var states = this._states;
            if (states != null) {
                for (var i = sortedLength - 1; 0 <= i; --i) {
                    var index = sorted[i];
                    if (0 <= index && index < states.length) {
                        states.splice(index, 1);
                        isChanged = true;
                    }
                }
            }
            if (isChanged) {
                var parent_15 = this.parent;
                if (parent_15 != null) {
                    parent_15.isChanged = true;
                }
            }
        };
        EShapeDataValueImpl.prototype.clear = function () {
            var isChanged = false;
            // Values
            var values = this._values;
            if (values != null) {
                values.length = 0;
                isChanged = true;
            }
            // Times
            var times = this._times;
            if (times != null) {
                times.length = 0;
                isChanged = true;
            }
            // States
            var states = this._states;
            if (states != null) {
                states.length = 0;
                isChanged = true;
            }
            // Change flag
            if (isChanged) {
                var parent_16 = this.parent;
                if (parent_16 != null) {
                    parent_16.isChanged = true;
                }
            }
        };
        EShapeDataValueImpl.prototype.toDirty = function () {
            var parent = this.parent;
            if (parent != null) {
                parent.isChanged = true;
            }
        };
        /**
         * This method does not copy the `#values` and `#times` for the performance.
         *
         * @param target a copy target
         */
        EShapeDataValueImpl.prototype.copy = function (target) {
            this.id = target.id;
            this.as = target.as;
            this.type = target.type;
            this.scope = target.scope;
            this.initial = target.initial;
            this.format = target.format;
            this.formatter = target.formatter;
            this.range.copy(target.range);
            this._value = target.value;
            this._time = target.time;
            this._state = target.state;
            this._capacity = target.capacity;
            return this;
        };
        EShapeDataValueImpl.prototype.isEquals = function (target) {
            return (this.id === target.id &&
                this.as === target.as &&
                this.type === target.type &&
                this.scope === target.scope &&
                this.initial === target.initial &&
                this.formatter === target.formatter &&
                this.range.isEquals(target.range));
        };
        EShapeDataValueImpl.prototype.serialize = function (manager) {
            var id = manager.addData(this.id);
            var as = manager.addResource(this.as);
            var initial = manager.addResource(this.initial);
            var format = manager.addResource(this.format.trim());
            var range = this.range.serialize(manager);
            return manager.addResource("[".concat(id, ",").concat(initial, ",").concat(format, ",").concat(range, ",").concat(this._capacity, ",").concat(this._order, ",").concat(this.type, ",").concat(this.scope, ",").concat(as, "]"));
        };
        EShapeDataValueImpl.prototype.deserialize = function (target, manager) {
            var _a, _b;
            var resources = manager.resources;
            if (0 <= target && target < resources.length) {
                var parsed = manager.getDataValue(target);
                if (parsed == null) {
                    parsed = JSON.parse(resources[target]);
                    manager.setDataValue(target, parsed);
                }
                this.id = manager.data[parsed[0]] || "";
                var as = parsed[8];
                this.as = as != null ? resources[as] || "" : "";
                this.type = (_a = parsed[6]) !== null && _a !== void 0 ? _a : EShapeDataValueType.NUMBER;
                this.scope = (_b = parsed[7]) !== null && _b !== void 0 ? _b : EShapeDataValueScope.PUBLIC;
                this.initial = resources[parsed[1]] || "";
                this.format = resources[parsed[2]] || "";
                this.range.deserialize(parsed[3], manager);
                this._capacity = parsed[4];
                this._order = parsed[5];
            }
            return this;
        };
        return EShapeDataValueImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeDataMappingImpl = /** @class */ (function () {
        function EShapeDataMappingImpl() {
            this.values = [];
        }
        EShapeDataMappingImpl.prototype.add = function (value, index) {
            var values = this.values;
            if (index != null) {
                values.splice(index, 0, value);
            }
            else {
                values.push(value);
            }
            return this;
        };
        EShapeDataMappingImpl.prototype.addAll = function (values) {
            var destination = this.values;
            for (var i = 0, imax = values.length; i < imax; ++i) {
                destination.push(values[i]);
            }
            return this;
        };
        EShapeDataMappingImpl.prototype.clearAndAdd = function (value) {
            this.clear();
            this.add(value);
            return this;
        };
        EShapeDataMappingImpl.prototype.clearAndAddAll = function (values) {
            this.clear();
            this.addAll(values);
            return this;
        };
        EShapeDataMappingImpl.prototype.indexOf = function (target) {
            var values = this.values;
            // Instance-based matching
            for (var i = 0, imax = values.length; i < imax; ++i) {
                var value = values[i];
                if (value === target) {
                    return i;
                }
            }
            // Data-based matching
            for (var i = 0, imax = values.length; i < imax; ++i) {
                var value = values[i];
                if (value[0] === target[0] && value[1] === target[1] && value[2] === target[2]) {
                    return i;
                }
            }
            return -1;
        };
        EShapeDataMappingImpl.prototype.get = function (index) {
            var values = this.values;
            if (0 <= index || index < values.length) {
                return values[index];
            }
            return null;
        };
        EShapeDataMappingImpl.prototype.set = function (index, value) {
            var values = this.values;
            if (0 <= index || index < values.length) {
                var result = values[index];
                values[index] = value;
                return result;
            }
            return null;
        };
        EShapeDataMappingImpl.prototype.remove = function (index) {
            var values = this.values;
            if (0 <= index || index < values.length) {
                return values.splice(index, 1)[0];
            }
            return null;
        };
        EShapeDataMappingImpl.prototype.clear = function () {
            this.values.length = 0;
            return this;
        };
        EShapeDataMappingImpl.prototype.size = function () {
            return this.values.length;
        };
        EShapeDataMappingImpl.prototype.swap = function (indexA, indexB) {
            var values = this.values;
            var tmp = values[indexB];
            values[indexB] = values[indexA];
            values[indexA] = tmp;
            return this;
        };
        EShapeDataMappingImpl.prototype.copy = function (target) {
            this.clearAndAddAll(target.values);
        };
        EShapeDataMappingImpl.prototype.serialize = function (manager) {
            var values = this.values;
            var valuesLength = values.length;
            if (valuesLength <= 0) {
                return -1;
            }
            var result = "[";
            var delimiter = "";
            for (var i = 0, imax = values.length; i < imax; ++i) {
                var value = values[i];
                var s = manager.addResource(value[0]);
                var d = manager.addResource(value[1]);
                var t = manager.addResource(value[2]);
                result += "".concat(delimiter).concat(s, ",").concat(d, ",").concat(t);
                delimiter = ",";
            }
            result += "]";
            return manager.addResource(result);
        };
        EShapeDataMappingImpl.prototype.deserialize = function (target, manager) {
            var values = this.values;
            values.length = 0;
            var resources = manager.resources;
            var resourcesLength = resources.length;
            if (0 <= target && target < resourcesLength) {
                var parsed = manager.getDataMapping(target);
                if (parsed == null) {
                    parsed = JSON.parse(resources[target]);
                    manager.setDataMapping(target, parsed);
                }
                for (var i = 0, imax = parsed.length; i < imax; i += 3) {
                    var is = parsed[i];
                    var id = parsed[i + 1];
                    var it = parsed[i + 2];
                    values.push([
                        0 <= is && is < resourcesLength ? resources[is] : "",
                        0 <= id && id < resourcesLength ? resources[id] : "",
                        0 <= it && it < resourcesLength ? resources[it] : ""
                    ]);
                }
            }
        };
        return EShapeDataMappingImpl;
    }());

    var EShapeDataScopedImpl = /** @class */ (function () {
        function EShapeDataScopedImpl() {
        }
        Object.defineProperty(EShapeDataScopedImpl.prototype, "ids", {
            get: function () {
                var data = this._data;
                if (data == null) {
                    return [];
                }
                var result = [];
                data.forEach(function (value, id) {
                    result.push(id);
                });
                return result;
            },
            enumerable: false,
            configurable: true
        });
        EShapeDataScopedImpl.prototype.add = function (id, value) {
            var _a;
            var data = ((_a = this._data) !== null && _a !== void 0 ? _a : (this._data = new Map()));
            var list = data.get(id);
            if (list == null) {
                data.set(id, [value]);
            }
            else {
                list.push(value);
            }
        };
        EShapeDataScopedImpl.prototype.set = function (id, value, time, state, from, to) {
            var data = this._data;
            if (data == null) {
                return false;
            }
            var datum = data.get(id);
            if (datum == null) {
                return false;
            }
            var size = datum.length;
            if (size <= 0) {
                return false;
            }
            for (var i = 0; i < size; ++i) {
                var datumValue = datum[i];
                var range = datumValue.range;
                // Range
                range.set(from, to);
                // Time
                if (time !== undefined) {
                    datumValue.time = time;
                }
                // State
                if (state !== undefined) {
                    datumValue.state = state;
                }
                // Value
                datumValue.value = value;
            }
            return true;
        };
        EShapeDataScopedImpl.prototype.toDirty = function (id) {
            var data = this._data;
            if (data == null) {
                return false;
            }
            var datum = data.get(id);
            if (datum == null) {
                return false;
            }
            var size = datum.length;
            if (size <= 0) {
                return false;
            }
            for (var i = 0; i < size; ++i) {
                datum[i].toDirty();
            }
            return true;
        };
        EShapeDataScopedImpl.prototype.each = function (iteratee) {
            var data = this._data;
            if (data == null) {
                return null;
            }
            var result = null;
            data.forEach(function (values, id) {
                if (result == null) {
                    if (iteratee(id) === false) {
                        result = id;
                    }
                }
            });
            return result;
        };
        return EShapeDataScopedImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeDataSystemImpl = /** @class */ (function () {
        function EShapeDataSystemImpl() {
            this._data = new Map();
        }
        EShapeDataSystemImpl.prototype.set = function (key, value) {
            this._data.set(key, value);
            return this;
        };
        EShapeDataSystemImpl.prototype.get = function (key) {
            var _a;
            return (_a = this._data.get(key)) !== null && _a !== void 0 ? _a : null;
        };
        EShapeDataSystemImpl.prototype.contains = function (key) {
            return this._data.has(key);
        };
        EShapeDataSystemImpl.prototype.remove = function (key) {
            var data = this._data;
            var result = data.get(key);
            data.delete(key);
            return result !== null && result !== void 0 ? result : null;
        };
        EShapeDataSystemImpl.prototype.clear = function () {
            this._data.clear();
            return this;
        };
        EShapeDataSystemImpl.prototype.size = function () {
            return this._data.size;
        };
        EShapeDataSystemImpl.prototype.each = function (iteratee) {
            var isCanceled = false;
            this._data.forEach(function (value, key) {
                if (!isCanceled) {
                    if (iteratee(value, key) === false) {
                        isCanceled = true;
                    }
                }
            });
            return this;
        };
        EShapeDataSystemImpl.prototype.copy = function (target) {
            var data = this._data;
            data.clear();
            target.each(function (value, key) {
                data.set(key, value);
            });
            return this;
        };
        EShapeDataSystemImpl.prototype.serialize = function (manager) {
            var data = this._data;
            if (data.size <= 0) {
                return -1;
            }
            var result = [];
            data.forEach(function (value, key) {
                var valueId = manager.addResource(value);
                var keyId = manager.addResource(key);
                result.push(keyId, valueId);
            });
            return manager.addResource(JSON.stringify(result));
        };
        EShapeDataSystemImpl.prototype.deserialize = function (target, manager) {
            var data = this._data;
            data.clear();
            var resources = manager.resources;
            var resourcesLength = resources.length;
            if (0 <= target && target < resourcesLength) {
                var parsed = manager.getDataSystem(target);
                if (parsed == null) {
                    parsed = JSON.parse(resources[target]);
                    manager.setDataSystem(target, parsed);
                }
                for (var i = 0, imax = parsed.length; i < imax; i += 2) {
                    var keyId = parsed[i];
                    if (0 <= keyId && keyId < resourcesLength) {
                        var key = resources[keyId];
                        var valueId = parsed[i + 1];
                        if (0 <= valueId && valueId < resourcesLength) {
                            data.set(key, resources[valueId]);
                        }
                    }
                }
            }
        };
        return EShapeDataSystemImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var RANGE_DUMMY;
    var ALIAS_DUMMY;
    var EShapeDataImpl = /** @class */ (function () {
        function EShapeDataImpl() {
            this._values = [];
            this._isChanged = true;
        }
        Object.defineProperty(EShapeDataImpl.prototype, "values", {
            get: function () {
                return this._values;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeDataImpl.prototype, "isChanged", {
            get: function () {
                return this._isChanged;
            },
            set: function (isChanged) {
                this._isChanged = isChanged;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeDataImpl.prototype, "id", {
            get: function () {
                var values = this._values;
                if (0 < values.length) {
                    return values[0].id;
                }
                return "";
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeDataImpl.prototype, "as", {
            get: function () {
                var values = this._values;
                if (0 < values.length) {
                    return values[0].as;
                }
                return "";
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeDataImpl.prototype, "type", {
            get: function () {
                var values = this._values;
                if (0 < values.length) {
                    return values[0].type;
                }
                return EShapeDataValueType.NUMBER;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeDataImpl.prototype, "scope", {
            get: function () {
                var values = this._values;
                if (0 < values.length) {
                    return values[0].scope;
                }
                return EShapeDataValueScope.PRIVATE;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeDataImpl.prototype, "initial", {
            get: function () {
                var values = this._values;
                if (0 < values.length) {
                    return values[0].initial;
                }
                return "";
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeDataImpl.prototype, "format", {
            get: function () {
                var values = this._values;
                if (0 < values.length) {
                    return values[0].format;
                }
                return "";
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeDataImpl.prototype, "range", {
            get: function () {
                var values = this._values;
                if (0 < values.length) {
                    return values[0].range;
                }
                return (RANGE_DUMMY !== null && RANGE_DUMMY !== void 0 ? RANGE_DUMMY : (RANGE_DUMMY = new EShapeDataValueRangeImpl()));
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeDataImpl.prototype, "value", {
            get: function () {
                var values = this._values;
                if (0 < values.length) {
                    return values[0].value;
                }
                return 0;
            },
            set: function (value) {
                var values = this._values;
                if (0 < values.length) {
                    values[0].value = value;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeDataImpl.prototype, "nvalue", {
            get: function () {
                var values = this._values;
                if (0 < values.length) {
                    return values[0].nvalue;
                }
                return 0;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeDataImpl.prototype, "time", {
            get: function () {
                var values = this._values;
                if (0 < values.length) {
                    return values[0].time;
                }
                return 0;
            },
            set: function (time) {
                var values = this._values;
                if (0 < values.length) {
                    values[0].time = time;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeDataImpl.prototype, "state", {
            get: function () {
                var values = this._values;
                if (0 < values.length) {
                    return values[0].state;
                }
                return EShapeDataValueState.UNKNOWN;
            },
            set: function (state) {
                var values = this._values;
                if (0 < values.length) {
                    values[0].state = state;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeDataImpl.prototype, "capacity", {
            get: function () {
                var values = this._values;
                if (0 < values.length) {
                    return values[0].capacity;
                }
                return 0;
            },
            set: function (capacity) {
                var values = this._values;
                if (0 < values.length) {
                    values[0].capacity = capacity;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeDataImpl.prototype, "alias", {
            get: function () {
                var result = this._alias;
                if (result == null) {
                    result = this.newAlias();
                    this._alias = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        EShapeDataImpl.prototype.newAlias = function () {
            var values = this._values;
            var valuesLength = values.length;
            if (0 < valuesLength) {
                var result = {};
                for (var i = 0; i < valuesLength; ++i) {
                    var value = values[i];
                    result[value.as || value.id] = value;
                }
                return result;
            }
            else {
                return (ALIAS_DUMMY !== null && ALIAS_DUMMY !== void 0 ? ALIAS_DUMMY : (ALIAS_DUMMY = {}));
            }
        };
        Object.defineProperty(EShapeDataImpl.prototype, "mapping", {
            get: function () {
                var result = this._mapping;
                if (result == null) {
                    result = this.newMapping();
                    this._mapping = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        EShapeDataImpl.prototype.newMapping = function () {
            return new EShapeDataMappingImpl();
        };
        EShapeDataImpl.prototype.getMapping = function () {
            return this._mapping;
        };
        Object.defineProperty(EShapeDataImpl.prototype, "private", {
            get: function () {
                var result = this._private;
                if (result == null) {
                    result = this.newPrivate();
                    this._private = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        EShapeDataImpl.prototype.newPrivate = function () {
            return new EShapeDataScopedImpl();
        };
        EShapeDataImpl.prototype.getPrivate = function () {
            return this._private;
        };
        Object.defineProperty(EShapeDataImpl.prototype, "system", {
            get: function () {
                var result = this._system;
                if (result == null) {
                    result = this.newSystem();
                    this._system = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        EShapeDataImpl.prototype.newSystem = function () {
            return new EShapeDataSystemImpl();
        };
        EShapeDataImpl.prototype.getSystem = function () {
            return this._system;
        };
        EShapeDataImpl.prototype.add = function (value, index) {
            var values = this._values;
            value.parent = this;
            if (index === undefined) {
                values.push(value);
            }
            else {
                values.splice(index, 0, value);
            }
        };
        EShapeDataImpl.prototype.set = function (index, value) {
            var values = this._values;
            if (0 <= index && index < values.length) {
                var result = values[index];
                value.parent = this;
                values[index] = value;
                result.parent = undefined;
                return result;
            }
            return null;
        };
        EShapeDataImpl.prototype.remove = function (index) {
            var values = this._values;
            if (0 <= index && index < values.length) {
                values.splice(index, 1)[0].parent = undefined;
            }
        };
        EShapeDataImpl.prototype.indexOf = function (target) {
            var values = this._values;
            var valuesLength = values.length;
            // Instance-based matching
            for (var i = 0; i < valuesLength; ++i) {
                if (values[i] === target) {
                    return i;
                }
            }
            // Data-based matching
            for (var i = 0; i < valuesLength; ++i) {
                if (values[i].isEquals(target)) {
                    return i;
                }
            }
            // ID-based matching
            for (var i = 0; i < valuesLength; ++i) {
                if (values[i].id === target.id) {
                    return i;
                }
            }
            return -1;
        };
        EShapeDataImpl.prototype.get = function (index) {
            var values = this._values;
            if (0 <= index && index < values.length) {
                return values[index];
            }
            return null;
        };
        EShapeDataImpl.prototype.size = function () {
            return this._values.length;
        };
        EShapeDataImpl.prototype.swap = function (indexA, indexB) {
            var values = this._values;
            var tmp = values[indexB];
            values[indexB] = values[indexA];
            values[indexA] = tmp;
        };
        EShapeDataImpl.prototype.copy = function (target) {
            var values = this._values;
            values.length = 0;
            for (var i = 0, imax = target.size(); i < imax; ++i) {
                var value = target.get(i);
                if (value != null) {
                    var newValue = new EShapeDataValueImpl().copy(value);
                    newValue.parent = this;
                    values.push(newValue);
                }
            }
            var targetMapping = target.getMapping();
            if (targetMapping) {
                this.mapping.copy(targetMapping);
            }
            var targetSystem = target.getSystem();
            if (targetSystem) {
                this.system.copy(targetSystem);
            }
            return this;
        };
        EShapeDataImpl.prototype.serialize = function (manager) {
            var values = this._values;
            var result = [];
            for (var i = 0, imax = values.length; i < imax; ++i) {
                result.push(values[i].serialize(manager));
            }
            var mapping = this._mapping;
            if (mapping != null) {
                result.push(mapping.serialize(manager));
                var system = this._system;
                if (system != null) {
                    return manager.addResource("[".concat(JSON.stringify(result), ",").concat(system.serialize(manager), "]"));
                }
                else {
                    return manager.addResource("[".concat(JSON.stringify(result), "]"));
                }
            }
            else {
                var system = this._system;
                if (system != null) {
                    result.push(-1);
                    return manager.addResource("[".concat(JSON.stringify(result), ",").concat(system.serialize(manager), "]"));
                }
                else {
                    return manager.addResource(JSON.stringify(result));
                }
            }
        };
        EShapeDataImpl.prototype.deserialize = function (target, manager) {
            var resources = manager.resources;
            if (0 <= target && target < resources.length) {
                var parsed = manager.getData(target);
                if (parsed == null) {
                    parsed = JSON.parse(resources[target]);
                    manager.setData(target, parsed);
                }
                var values = this._values;
                values.length = 0;
                if (this.isMapped(parsed)) {
                    var first = parsed[0];
                    var firstLength = first.length;
                    for (var i = 0, imax = firstLength - 1; i < imax; ++i) {
                        var index = first[i];
                        var value = new EShapeDataValueImpl();
                        value.parent = this;
                        value.deserialize(index, manager);
                        values.push(value);
                    }
                    var mappingId = first[firstLength - 1];
                    if (0 <= mappingId) {
                        this.mapping.deserialize(mappingId, manager);
                    }
                    var systemId = parsed[1];
                    if (systemId != null && 0 <= systemId) {
                        this.system.deserialize(systemId, manager);
                    }
                }
                else {
                    for (var i = 0, imax = parsed.length; i < imax; ++i) {
                        var index = parsed[i];
                        var value = new EShapeDataValueImpl();
                        value.parent = this;
                        value.deserialize(index, manager);
                        values.push(value);
                    }
                }
            }
        };
        EShapeDataImpl.prototype.isMapped = function (target) {
            return 0 < target.length && isArray(target[0]);
        };
        return EShapeDataImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeTextAlignImpl = /** @class */ (function () {
        function EShapeTextAlignImpl(parent, horizontal, vertical) {
            this._parent = parent;
            this._horizontal = horizontal;
            this._vertical = vertical;
        }
        Object.defineProperty(EShapeTextAlignImpl.prototype, "horizontal", {
            get: function () {
                return this._horizontal;
            },
            set: function (horizontal) {
                if (this._horizontal !== horizontal) {
                    this._horizontal = horizontal;
                    this._parent.updateUploaded();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeTextAlignImpl.prototype, "vertical", {
            get: function () {
                return this._vertical;
            },
            set: function (vertical) {
                if (this._vertical !== vertical) {
                    this._vertical = vertical;
                    this._parent.updateUploaded();
                }
            },
            enumerable: false,
            configurable: true
        });
        EShapeTextAlignImpl.prototype.copy = function (target) {
            if (target) {
                this.set(target.horizontal, target.vertical);
            }
        };
        EShapeTextAlignImpl.prototype.set = function (horizontal, vertical) {
            var isChanged = false;
            if (horizontal != null && this._horizontal !== horizontal) {
                this._horizontal = horizontal;
                isChanged = true;
            }
            if (vertical != null && this._vertical !== vertical) {
                this._vertical = vertical;
                isChanged = true;
            }
            if (isChanged) {
                this._parent.updateUploaded();
            }
        };
        EShapeTextAlignImpl.prototype.toObject = function () {
            return {
                horizontal: this._horizontal,
                vertical: this._vertical
            };
        };
        EShapeTextAlignImpl.prototype.serialize = function (manager) {
            return manager.addResource("[".concat(this._horizontal, ",").concat(this._vertical, "]"));
        };
        EShapeTextAlignImpl.prototype.deserialize = function (target, manager) {
            var resources = manager.resources;
            if (0 <= target && target < resources.length) {
                var parsed = manager.getAlign(target);
                if (parsed != null) {
                    this.set(parsed[0], parsed[1]);
                }
                else {
                    var deserialized = JSON.parse(resources[target]);
                    manager.setAlign(target, deserialized);
                    this.set(deserialized[0], deserialized[1]);
                }
            }
        };
        return EShapeTextAlignImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeTextOffsetImpl = /** @class */ (function () {
        function EShapeTextOffsetImpl(parent, horizontal, vertical) {
            this._parent = parent;
            this._horizontal = horizontal;
            this._vertical = vertical;
        }
        Object.defineProperty(EShapeTextOffsetImpl.prototype, "horizontal", {
            get: function () {
                return this._horizontal;
            },
            set: function (horizontal) {
                if (this._horizontal !== horizontal) {
                    this._horizontal = horizontal;
                    this._parent.updateUploaded();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeTextOffsetImpl.prototype, "vertical", {
            get: function () {
                return this._vertical;
            },
            set: function (vertical) {
                if (this._vertical !== vertical) {
                    this._vertical = vertical;
                    this._parent.updateUploaded();
                }
            },
            enumerable: false,
            configurable: true
        });
        EShapeTextOffsetImpl.prototype.copy = function (target) {
            if (target) {
                this.set(target.horizontal, target.vertical);
            }
        };
        EShapeTextOffsetImpl.prototype.set = function (horizontal, vertical) {
            var isChanged = false;
            if (horizontal != null && this._horizontal !== horizontal) {
                this._horizontal = horizontal;
                isChanged = true;
            }
            if (vertical != null && this._vertical !== vertical) {
                this._vertical = vertical;
                isChanged = true;
            }
            if (isChanged) {
                this._parent.updateUploaded();
            }
        };
        EShapeTextOffsetImpl.prototype.toObject = function () {
            return {
                horizontal: this._horizontal,
                vertical: this._vertical
            };
        };
        EShapeTextOffsetImpl.prototype.serialize = function (manager) {
            return manager.addResource("[".concat(this._horizontal, ",").concat(this._vertical, "]"));
        };
        EShapeTextOffsetImpl.prototype.deserialize = function (target, manager) {
            var resources = manager.resources;
            if (0 <= target && target < resources.length) {
                var parsed = manager.getMargin(target);
                if (parsed != null) {
                    this.set(parsed[0], parsed[1]);
                }
                else {
                    var deserialized = JSON.parse(resources[target]);
                    manager.setMargin(target, deserialized);
                    this.set(deserialized[0], deserialized[1]);
                }
            }
        };
        return EShapeTextOffsetImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeTextOutlineImpl = /** @class */ (function () {
        function EShapeTextOutlineImpl(parent, enable, color, alpha, width) {
            this._parent = parent;
            this._enable = enable;
            this._color = color;
            this._alpha = alpha;
            this._width = width;
        }
        Object.defineProperty(EShapeTextOutlineImpl.prototype, "enable", {
            get: function () {
                return this._enable;
            },
            set: function (enable) {
                if (this._enable !== enable) {
                    this._enable = enable;
                    this._parent.updateUploaded();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeTextOutlineImpl.prototype, "color", {
            get: function () {
                return this._color;
            },
            set: function (color) {
                if (this._color !== color) {
                    this._color = color;
                    this._parent.updateUploaded();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeTextOutlineImpl.prototype, "alpha", {
            get: function () {
                return this._alpha;
            },
            set: function (alpha) {
                if (this._alpha !== alpha) {
                    this._alpha = alpha;
                    this._parent.updateUploaded();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeTextOutlineImpl.prototype, "width", {
            get: function () {
                return this._width;
            },
            set: function (width) {
                if (this._width !== width) {
                    this._width = width;
                    this._parent.updateUploaded();
                }
            },
            enumerable: false,
            configurable: true
        });
        EShapeTextOutlineImpl.prototype.copy = function (target) {
            if (target) {
                this.set(target.enable, target.color, target.alpha, target.width);
            }
        };
        EShapeTextOutlineImpl.prototype.set = function (enable, color, alpha, width) {
            var isChanged = false;
            if (enable !== undefined && this._enable !== enable) {
                this._enable = enable;
                isChanged = true;
            }
            if (color !== undefined && this._color !== color) {
                this._color = color;
                isChanged = true;
            }
            if (alpha !== undefined && this._alpha !== alpha) {
                this._alpha = alpha;
                isChanged = true;
            }
            if (width !== undefined && this._width !== width) {
                this._width = width;
                isChanged = true;
            }
            if (isChanged) {
                this._parent.updateUploaded();
            }
        };
        EShapeTextOutlineImpl.prototype.clone = function () {
            return new EShapeTextOutlineImpl(this._parent, this._enable, this._color, this._alpha, this._width);
        };
        EShapeTextOutlineImpl.prototype.toObject = function () {
            return {
                enable: this._enable,
                color: this._color,
                alpha: this._alpha,
                width: this._width
            };
        };
        EShapeTextOutlineImpl.prototype.serialize = function (manager) {
            var serialized = "[".concat(this._enable ? 1 : 0, ",").concat(this._color, ",").concat(this._alpha, ",").concat(this._width, "]");
            return manager.addResource(serialized);
        };
        EShapeTextOutlineImpl.prototype.deserialize = function (target, manager) {
            var resources = manager.resources;
            if (0 <= target && target < resources.length) {
                var parsed = manager.getTextOutline(target);
                if (parsed != null) {
                    this.set(!!parsed[0], parsed[1], parsed[2], parsed[3]);
                }
                else {
                    var deserialized = JSON.parse(resources[target]);
                    manager.setTextOutline(target, deserialized);
                    this.set(!!deserialized[0], deserialized[1], deserialized[2], deserialized[3]);
                }
            }
        };
        return EShapeTextOutlineImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeTextImpl = /** @class */ (function () {
        function EShapeTextImpl(parent, value, color, alpha, family, size) {
            this._parent = parent;
            this._enable = true;
            this._value = value;
            this._plength = this._length = value.length;
            this._color = color;
            this._alpha = alpha;
            this._family = family;
            this._size = size;
            this._weight = EShapeTextWeight.NORMAL;
            this.align = new EShapeTextAlignImpl(parent, EShapeTextAlignHorizontal.CENTER, EShapeTextAlignVertical.MIDDLE);
            this.offset = new EShapeTextOffsetImpl(parent, 0, 0);
            this._style = EShapeTextStyle.NORMAL;
            this.spacing = new EShapeTextOffsetImpl(parent, 0, 0);
            this.outline = new EShapeTextOutlineImpl(parent, false, 0xffffff, 1.0, 0.5);
            this._direction = EShapeTextDirection.LEFT_TO_RIGHT;
            this.padding = new EShapeTextOffsetImpl(parent, 10, 10);
            this._clipping = false;
            this._fitting = false;
            this._characters = [];
            this._nacharacters = [];
            this.updateCharacters(value);
        }
        Object.defineProperty(EShapeTextImpl.prototype, "enable", {
            get: function () {
                return this._enable;
            },
            set: function (enable) {
                if (this._enable !== enable) {
                    this._enable = enable;
                    this._parent.updateUploaded();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeTextImpl.prototype, "value", {
            get: function () {
                return this._value;
            },
            set: function (value) {
                if (this._value !== value) {
                    this._value = value;
                    var length_1 = value.length;
                    this._length = length_1;
                    if (this._plength < length_1) {
                        this._plength = length_1;
                    }
                    this.updateCharacters(value);
                    if (this.isCompatible()) {
                        this._parent.updateUploaded();
                    }
                    else {
                        this.atlas = undefined;
                        this._parent.toDirty();
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeTextImpl.prototype, "characters", {
            get: function () {
                return this._characters;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeTextImpl.prototype, "nacharacters", {
            get: function () {
                return this._nacharacters;
            },
            enumerable: false,
            configurable: true
        });
        EShapeTextImpl.prototype.updateCharacters = function (value) {
            var characters = this._characters;
            var charactersLength = characters.length;
            var icharacters = 0;
            var nacharacters = this._nacharacters;
            var nacharactersLength = nacharacters.length;
            var inacharacters = 0;
            for (var i = 0, imax = value.length; i < imax;) {
                if (value.charCodeAt(i) <= 0xff) {
                    // Add an ASCII character
                    var ac = value.substring(i, i + 1);
                    if (icharacters < charactersLength) {
                        characters[icharacters] = ac;
                    }
                    else {
                        characters.push(ac);
                    }
                    icharacters += 1;
                    i += 1;
                    continue;
                }
                var j = i + 1;
                for (; j < imax; ++j) {
                    var cc = value.charCodeAt(j);
                    if ((0xdc00 <= cc && cc <= 0xdfff) || (0xfe00 <= cc && cc <= 0xfe0f)) {
                        // Low surrogate
                        // Variation selector
                        continue;
                    }
                    break;
                }
                // Add an non-ascii character
                var nac = value.substring(i, j);
                if (icharacters < charactersLength) {
                    characters[icharacters] = nac;
                }
                else {
                    characters.push(nac);
                }
                icharacters += 1;
                if (inacharacters < nacharactersLength) {
                    nacharacters[inacharacters] = nac;
                }
                else {
                    nacharacters.push(nac);
                }
                inacharacters += 1;
                // Go to the next
                i = j;
            }
            if (icharacters < charactersLength) {
                characters.length = icharacters;
            }
            if (inacharacters < nacharactersLength) {
                nacharacters.length = inacharacters;
            }
        };
        EShapeTextImpl.prototype.isCompatible = function () {
            // Compatibility check
            var parent = this._parent;
            var uploaded = parent.uploaded;
            if (uploaded == null || !uploaded.isCompatible(parent)) {
                return false;
            }
            // Character code check
            var atlas = this.atlas;
            if (atlas == null) {
                return false;
            }
            var atlasCharacters = atlas.characters;
            var nacharacters = this._nacharacters;
            for (var i = 0, imax = nacharacters.length; i < imax; ++i) {
                if (!atlasCharacters.has(nacharacters[i])) {
                    return false;
                }
            }
            // Done
            return true;
        };
        Object.defineProperty(EShapeTextImpl.prototype, "length", {
            get: function () {
                return this._length;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeTextImpl.prototype, "plength", {
            get: function () {
                return this._plength;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeTextImpl.prototype, "family", {
            get: function () {
                return this._family;
            },
            set: function (family) {
                if (this._family !== family) {
                    this._family = family;
                    this._parent.toDirty();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeTextImpl.prototype, "color", {
            get: function () {
                return this._color;
            },
            set: function (color) {
                if (this._color !== color) {
                    this._color = color;
                    this._parent.updateUploaded();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeTextImpl.prototype, "alpha", {
            get: function () {
                return this._alpha;
            },
            set: function (alpha) {
                if (this._alpha !== alpha) {
                    this._alpha = alpha;
                    this._parent.updateUploaded();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeTextImpl.prototype, "size", {
            get: function () {
                return this._size;
            },
            set: function (size) {
                if (this._size !== size) {
                    this._size = size;
                    this._parent.updateUploaded();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeTextImpl.prototype, "weight", {
            get: function () {
                return this._weight;
            },
            set: function (weight) {
                if (this._weight !== weight) {
                    this._weight = weight;
                    this._parent.updateUploaded();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeTextImpl.prototype, "style", {
            get: function () {
                return this._style;
            },
            set: function (style) {
                if (this._style !== style) {
                    this._style = style;
                    this._parent.updateUploaded();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeTextImpl.prototype, "direction", {
            get: function () {
                return this._direction;
            },
            set: function (direction) {
                if (this._direction !== direction) {
                    this._direction = direction;
                    this._parent.updateUploaded();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeTextImpl.prototype, "clipping", {
            get: function () {
                return this._clipping;
            },
            set: function (clipping) {
                if (this._clipping !== clipping) {
                    this._clipping = clipping;
                    this._parent.updateUploaded();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeTextImpl.prototype, "fitting", {
            get: function () {
                return this._fitting;
            },
            set: function (fitting) {
                if (this._fitting !== fitting) {
                    this._fitting = fitting;
                    this._parent.updateUploaded();
                }
            },
            enumerable: false,
            configurable: true
        });
        EShapeTextImpl.prototype.copy = function (target) {
            if (target) {
                this.set(target.value, target.color, target.alpha, target.family, target.size, target.weight, target.style, target.direction, target.clipping, target.fitting);
                this.align.copy(target.align);
                this.offset.copy(target.offset);
                this.outline.copy(target.outline);
                this.spacing.copy(target.spacing);
                this.padding.copy(target.padding);
            }
            return this;
        };
        EShapeTextImpl.prototype.set = function (value, color, alpha, family, size, weight, style, direction, clipping, fitting) {
            var isChangedDirty = false;
            var isChangedUploaded = false;
            if (value != null && this._value !== value) {
                this._value = value;
                var length_2 = value.length;
                this._length = length_2;
                if (this._plength < length_2) {
                    this._plength = length_2;
                }
                this.updateCharacters(value);
                if (this.isCompatible()) {
                    isChangedUploaded = true;
                }
                else {
                    this.atlas = undefined;
                    isChangedDirty = true;
                }
            }
            if (color != null && this._color !== color) {
                this._color = color;
                isChangedUploaded = true;
            }
            if (alpha != null && this._alpha !== alpha) {
                this._alpha = alpha;
                isChangedUploaded = true;
            }
            if (family != null && this._family !== family) {
                this._family = family;
                isChangedDirty = true;
            }
            if (size != null && this._size !== size) {
                this._size = size;
                isChangedUploaded = true;
            }
            if (weight != null && this._weight !== weight) {
                this._weight = weight;
                isChangedUploaded = true;
            }
            if (style != null && this._style !== style) {
                this._style = style;
                isChangedUploaded = true;
            }
            if (direction != null && this._direction !== direction) {
                this._direction = direction;
                isChangedUploaded = true;
            }
            if (clipping != null && this._clipping !== clipping) {
                this._clipping = clipping;
                isChangedUploaded = true;
            }
            if (fitting != null && this._fitting !== fitting) {
                this._fitting = fitting;
                isChangedUploaded = true;
            }
            if (isChangedDirty) {
                this._parent.toDirty();
            }
            else if (isChangedUploaded) {
                this._parent.updateUploaded();
            }
            return this;
        };
        EShapeTextImpl.prototype.toObject = function () {
            return {
                value: this._value,
                color: this._color,
                alpha: this._alpha,
                family: this._family,
                size: this._size,
                weight: this._weight,
                align: this.align.toObject(),
                offset: this.offset.toObject(),
                style: this._style,
                outline: this.outline.toObject(),
                direction: this._direction,
                spacing: this.spacing.toObject(),
                padding: this.padding.toObject(),
                clipping: this._clipping,
                fitting: this._fitting
            };
        };
        EShapeTextImpl.prototype.serialize = function (manager) {
            var valueId = manager.addResource(this._value);
            var familyId = manager.addResource(this._family);
            var alignId = this.align.serialize(manager);
            var offsetId = this.offset.serialize(manager);
            var outlineId = this.outline.serialize(manager);
            var spacingId = this.spacing.serialize(manager);
            var paddingId = this.padding.serialize(manager);
            var clipping = this._clipping ? 1 : 0;
            var fitting = this._fitting ? 1 : 0;
            var serialized = "[".concat(valueId, ",").concat(this._color, ",").concat(this._alpha, ",").concat(familyId, ",").concat(this._size, ",") +
                "".concat(this._weight, ",").concat(alignId, ",").concat(offsetId, ",").concat(this._style, ",").concat(outlineId, ",") +
                "".concat(spacingId, ",").concat(this._direction, ",").concat(paddingId, ",").concat(clipping, ",").concat(fitting, "]");
            return manager.addResource(serialized);
        };
        EShapeTextImpl.prototype.deserialize = function (target, manager) {
            var resources = manager.resources;
            if (0 <= target && target < resources.length) {
                var parsed = manager.getText(target);
                if (parsed == null) {
                    parsed = JSON.parse(resources[target]);
                    manager.setText(target, parsed);
                }
                this.set(resources[parsed[0]] || "", parsed[1], parsed[2], resources[parsed[3]] || "auto", parsed[4], parsed[5], parsed[8], parsed[11], !!parsed[13], !!parsed[14]);
                this.align.deserialize(parsed[6], manager);
                this.offset.deserialize(parsed[7], manager);
                this.outline.deserialize(parsed[9], manager);
                this.spacing.deserialize(parsed[10], manager);
                this.padding.deserialize(parsed[12], manager);
            }
        };
        return EShapeTextImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var toGradientSerialized = function (gradient) {
        var points = gradient.points;
        var result = "[".concat(gradient.direction);
        for (var i = 0, imax = points.length, j = 1; i < imax; i += 1, j += 3) {
            var point = points[i];
            result += ",".concat(point.color, ",").concat(point.alpha, ",").concat(point.position);
        }
        result += "]";
        return result;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapePrimitive = /** @class */ (function (_super) {
        __extends(EShapePrimitive, _super);
        function EShapePrimitive(type) {
            var _this = _super.call(this, type) || this;
            _this.size = _this.newSize();
            _this.fill = _this.newFill();
            _this.stroke = _this.newStroke();
            _this._radius = EShapeDefaults.RADIUS;
            _this._corner = EShapeCorner.ALL;
            var data = new EShapeDataImpl();
            _this.data = data;
            _this.tag = data;
            _this.text = _this.newText();
            return _this;
        }
        EShapePrimitive.prototype.newSize = function () {
            var _this = this;
            return new pixi_js.ObservablePoint(function () {
                _this.onSizeChange();
            }, undefined, EShapeDefaults.SIZE_X, EShapeDefaults.SIZE_Y);
        };
        EShapePrimitive.prototype.newFill = function () {
            return new EShapeFillImpl(this, true, EShapeDefaults.FILL_COLOR, EShapeDefaults.FILL_ALPHA);
        };
        EShapePrimitive.prototype.newStroke = function () {
            return new EShapeStrokeImpl(this, true, EShapeDefaults.STROKE_COLOR, EShapeDefaults.STROKE_ALPHA, EShapeDefaults.STROKE_WIDTH, EShapeDefaults.STROKE_ALIGN, EShapeDefaults.STROKE_SIDE, EShapeDefaults.STROKE_STYLE);
        };
        EShapePrimitive.prototype.newText = function () {
            return new EShapeTextImpl(this, EShapeDefaults.TEXT_VALUE, EShapeDefaults.TEXT_COLOR, EShapeDefaults.TEXT_ALPHA, EShapeDefaults.TEXT_FAMILY, EShapeDefaults.TEXT_SIZE);
        };
        Object.defineProperty(EShapePrimitive.prototype, "corner", {
            get: function () {
                return this._corner;
            },
            set: function (corner) {
                if (this._corner !== corner) {
                    this._corner = corner;
                    this.updateUploaded();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapePrimitive.prototype, "radius", {
            get: function () {
                return this._radius;
            },
            set: function (radius) {
                if (this._radius !== radius) {
                    this._radius = radius;
                    this.updateUploaded();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapePrimitive.prototype, "image", {
            get: function () {
                return this._image;
            },
            set: function (image) {
                if (this._image !== image) {
                    if (image != null) {
                        this._image = image;
                    }
                    else {
                        this._image = undefined;
                    }
                    var parent_1 = this.parent;
                    if (parent_1 != null) {
                        parent_1.toDirty();
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        EShapePrimitive.prototype.serializeImage = function (manager) {
            var image = this._image;
            return image != null ? manager.addResource(image.url) : -1;
        };
        EShapePrimitive.prototype.serializeGradient = function (manager) {
            var gradient = this.gradient;
            if (gradient != null) {
                if (gradient.serialized == null) {
                    gradient.serialized = toGradientSerialized(gradient);
                }
                return manager.addResource(gradient.serialized);
            }
            return -1;
        };
        return EShapePrimitive;
    }(EShapeBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var hitTestCircle = function (shape, x, y, ax, ay, sw, ss) {
        var fill = shape.fill;
        if (fill.enable) {
            var x2 = x * x;
            var y2 = y * y;
            var ax2 = ax * ax;
            var ay2 = ay * ay;
            if (x2 * ay2 + y2 * ax2 <= ax2 * ay2) {
                return true;
            }
        }
        else {
            if (0 < sw) {
                var s = sw * ss;
                var x2 = x * x;
                var y2 = y * y;
                var wx = Math.max(0.0, ax - s);
                var wy = Math.max(0.0, ay - s);
                var wx2 = wx * wx;
                var wy2 = wy * wy;
                if (wx2 * wy2 <= x2 * wy2 + y2 * wx2) {
                    var ax2 = ax * ax;
                    var ay2 = ay * ay;
                    if (x2 * ay2 + y2 * ax2 <= ax2 * ay2) {
                        return true;
                    }
                }
            }
        }
        return false;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var hitTestRectangle = function (shape, x, y, ax, ay, sw, ss) {
        if (hitTestBBox(x, y, ax, ay)) {
            var fill = shape.fill;
            if (fill.enable) {
                return true;
            }
            else {
                var strokeSide = shape.stroke.side;
                if (0 < sw && strokeSide !== EShapeStrokeSide.NONE) {
                    var s = sw * ss;
                    var wx = Math.max(0.0, ax - s);
                    var wy = Math.max(0.0, ay - s);
                    if (!hitTestBBox(x, y, wx, wy)) {
                        if (strokeSide === EShapeStrokeSide.ALL) {
                            return true;
                        }
                        else {
                            if (x <= -wx) {
                                if (y <= -wy) {
                                    return !!(strokeSide & EShapeStrokeSide.TOP_OR_LEFT);
                                }
                                else if (+wy <= y) {
                                    return !!(strokeSide & EShapeStrokeSide.BOTTOM_OR_LEFT);
                                }
                                else {
                                    return !!(strokeSide & EShapeStrokeSide.LEFT);
                                }
                            }
                            else if (+wx <= x) {
                                if (y <= -wy) {
                                    return !!(strokeSide & EShapeStrokeSide.TOP_OR_RIGHT);
                                }
                                else if (+wy <= y) {
                                    return !!(strokeSide & EShapeStrokeSide.BOTTOM_OR_RIGHT);
                                }
                                else {
                                    return !!(strokeSide & EShapeStrokeSide.RIGHT);
                                }
                            }
                            else {
                                if (y <= -wy) {
                                    return !!(strokeSide & EShapeStrokeSide.TOP);
                                }
                                else if (+wy <= y) {
                                    return !!(strokeSide & EShapeStrokeSide.BOTTOM);
                                }
                                else {
                                    return false;
                                }
                            }
                        }
                    }
                }
            }
        }
        return false;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var hitTestTriangleFilled = function (x, y, a, ay1, ay2) {
        // a = 2 * ay / ax
        // y = + a * x + ay1
        // y = - a * x + ay1
        // y = ay2;
        return +a * x + ay1 - y <= 0 && -a * x + ay1 - y <= 0 && y <= ay2;
    };
    var hitTestTriangle = function (shape, x, y, ax, ay, sw, ss) {
        var a = (2 * ay) / ax;
        var fill = shape.fill;
        if (fill.enable) {
            if (hitTestTriangleFilled(x, y, a, -ay, +ay)) {
                return true;
            }
        }
        else {
            if (0 < sw) {
                var s = sw * ss;
                if (hitTestTriangleFilled(x, y, a, -ay, +ay)) {
                    var az = Math.sqrt(ax * ax + 4 * ay * ay);
                    var aw = (2 * ax * ay) / (ax + az);
                    var cy = ay - aw;
                    var ay1 = cy + ((-ay - cy) * Math.max(0.0, aw - s)) / aw;
                    var ay2 = ay - s;
                    if (!hitTestTriangleFilled(x, y, a, ay1, ay2)) {
                        return true;
                    }
                }
            }
        }
        return false;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var toThresholdDefault = function (size, scale, offset) {
        return 0.5 * (offset + size * scale);
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeLineBase = /** @class */ (function (_super) {
        __extends(EShapeLineBase, _super);
        function EShapeLineBase() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        EShapeLineBase.prototype.getHitTestSize = function (result) {
            var formatted = this._points.formatted;
            if ("boundary" in formatted) {
                var boundary = formatted.boundary;
                result.width = Math.max(Math.abs(boundary[0]), Math.abs(boundary[2]));
                result.height = Math.max(Math.abs(boundary[1]), Math.abs(boundary[3]));
            }
            else {
                _super.prototype.getHitTestSize.call(this, result);
            }
            return result;
        };
        EShapeLineBase.prototype.toMarkerSize = function (points) {
            var result = 0;
            var marker = points.getMarker();
            if (marker) {
                var head = marker.head;
                if (head.type !== EShapePointsMarkerType.NONE) {
                    var size = head.size;
                    result = Math.max(result, Math.max(Math.abs(size.x), Math.abs(size.y)) * 2);
                }
                var tail = marker.tail;
                if (tail.type !== EShapePointsMarkerType.NONE) {
                    var size = tail.size;
                    result = Math.max(result, Math.max(Math.abs(size.x), Math.abs(size.y)) * 2);
                }
            }
            return result;
        };
        EShapeLineBase.prototype.containsAbsMarker = function (marker, x, y, sw, ss, sa) {
            var type = marker.type;
            if (type !== EShapePointsMarkerType.NONE) {
                var transform = marker.transform;
                var a = transform.a;
                var b = transform.b;
                var c = transform.c;
                var d = transform.d;
                var tx = transform.tx;
                var ty = transform.ty;
                var id = 1 / (a * d - c * b);
                var lx = (d * x - c * y + ty * c - tx * d) * id;
                var ly = (a * y - b * x - ty * a + tx * b) * id;
                var size = marker.size;
                var sx = 0.5 * size.x;
                var sy = 0.5 * size.y;
                if (sx < 0) {
                    sx = -sx;
                    x = -x;
                }
                if (sy < 0) {
                    sy = -sy;
                    y = -y;
                }
                var s = sw * ss * sa;
                sx += s;
                sy += s;
                switch (type) {
                    case EShapePointsMarkerType.CIRCLE:
                        return hitTestCircle(this, lx, ly, sx, sy, sw, ss);
                    case EShapePointsMarkerType.TRIANGLE:
                        return hitTestTriangle(this, lx, ly, sx, sy, sw, ss);
                    case EShapePointsMarkerType.RECTANGLE:
                        return hitTestRectangle(this, lx, ly, sx, sy, sw, ss);
                }
            }
            return false;
        };
        EShapeLineBase.prototype.containsAbs = function (x, y, ax, ay, sw, ss, sa) {
            var points = this._points;
            var threshold = toThresholdDefault(sw, ss, 0);
            var margin = threshold + this.toMarkerSize(points);
            if (this.containsAbsBBox(x, y, ax + margin, ay + margin)) {
                var marker = points.getMarker();
                if (marker) {
                    if (this.containsAbsMarker(marker.head, x, y, sw, ss, sa)) {
                        return true;
                    }
                    if (this.containsAbsMarker(marker.tail, x, y, sw, ss, sa)) {
                        return true;
                    }
                }
                var tester = this.calcHitPointAbsHitTester;
                return points.calcHitPointAbs(x, y, ax, ay, threshold, null, tester, null);
            }
            return false;
        };
        EShapeLineBase.prototype.calcHitPart = function (x, y) {
            var data = this.toHitTestData(x, y);
            var sw = data.strokeWidth;
            var ss = data.strokeScale;
            var threshold = toThresholdDefault(sw, ss, 0);
            var points = this._points;
            var margin = threshold + this.toMarkerSize(points);
            var dx = data.x;
            var dy = data.y;
            var ax = data.width;
            var ay = data.height;
            if (this.containsAbsBBox(dx, dy, ax + margin, ay + margin)) {
                var marker = points.getMarker();
                if (marker) {
                    var sa = data.strokeAlign;
                    if (this.containsAbsMarker(marker.head, dx, dy, sw, ss, sa)) {
                        return EShapeLineBaseHitPart.MARKER_HEAD;
                    }
                    if (this.containsAbsMarker(marker.tail, dx, dy, sw, ss, sa)) {
                        return EShapeLineBaseHitPart.MARKER_TAIL;
                    }
                }
                var tester = this.calcHitPointAbsHitTester;
                if (points.calcHitPointAbs(dx, dy, ax, ay, threshold, null, tester, null)) {
                    return EShapeLineBaseHitPart.LINE;
                }
            }
            if (this.containsText(x, y)) {
                return EShapeLineBaseHitPart.TEXT;
            }
            if (this.containsChildren(x, y)) {
                return EShapeLineBaseHitPart.CHILDREN;
            }
            return EShapeLineBaseHitPart.NONE;
        };
        EShapeLineBase.prototype.calcHitPoint = function (x, y, toThreshold, toRange, tester, result) {
            var points = this._points;
            var data = this.toHitTestData(x, y);
            var threshold = (toThreshold || toThresholdDefault)(data.strokeWidth, data.strokeScale, 0);
            if (this.containsAbsBBox(data.x, data.y, data.width + threshold, data.height + threshold)) {
                return points.calcHitPointAbs(data.x, data.y, data.width, data.height, threshold, toRange, tester, result);
            }
            return false;
        };
        EShapeLineBase.prototype.calcHitPointAbsHitTester = function (x, y, p0x, p0y, p1x, p1y, index, threshold, result) {
            // (x, y) = p0 + (p1 - p0) * t where 0 <= t <= 1
            // d0 := p1 - p0
            // d1 := v - p0
            // (p0.x + d0.x * t - x)^2 + (p0.y + d0.y * t - y)^2
            // (d0.x t - d1.x)^2 + (d0.y t - d1.y)^2
            // (d0.x^2 + d0.y^2) t^2 - 2 (d0.x * d1.x + d0.y * d1.y) t + (d1.x^2 + d1.y^2)
            // a := dot( d0, d0 )
            // b := dot( d0, d1 )
            // c := dot( d1, d1 )
            // a t^2 - 2 b t + c = a (t - b / a)^2 + c - b * b / a
            // t0 = b / a  min = c - b * b / a
            var d0x = p1x - p0x;
            var d0y = p1y - p0y;
            var d1x = x - p0x;
            var d1y = y - p0y;
            var a = d0x * d0x + d0y * d0y;
            var b = d0x * d1x + d0y * d1y;
            var c = d1x * d1x + d1y * d1y;
            if (0.0001 < a) {
                var t = Math.max(0, Math.min(1, b / a));
                var d = a * t * t - 2 * b * t + c;
                if (d < threshold * threshold) {
                    return true;
                }
            }
            return false;
        };
        return EShapeLineBase;
    }(EShapePrimitive));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeBar = /** @class */ (function (_super) {
        __extends(EShapeBar, _super);
        function EShapeBar(type) {
            if (type === void 0) { type = EShapeType.BAR; }
            var _this = _super.call(this, type) || this;
            _this._points = new EShapeBarPoints(_this);
            return _this;
        }
        Object.defineProperty(EShapeBar.prototype, "points", {
            get: function () {
                return this._points;
            },
            enumerable: false,
            configurable: true
        });
        EShapeBar.prototype.clone = function () {
            return new EShapeBar(this.type).copy(this);
        };
        EShapeBar.prototype.containsAbsBBox = function (x, y, ax, ay) {
            var size = Math.max(0, this._points.size);
            return _super.prototype.containsAbsBBox.call(this, x, y, ax + size, ay + size);
        };
        EShapeBar.prototype.serialize = function (manager) {
            var result = _super.prototype.serialize.call(this, manager);
            result[15] = this._points.serialize(manager);
            return result;
        };
        return EShapeBar;
    }(EShapeLineBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var BuilderBar = /** @class */ (function (_super) {
        __extends(BuilderBar, _super);
        function BuilderBar(buffer, vertexOffset, indexOffset) {
            var _this = _super.call(this, buffer, vertexOffset, indexOffset, BAR_VERTEX_COUNT, BAR_INDEX_COUNT) || this;
            _this.pointsId = -1;
            _this.pointsStyle = EShapePointsStyle.NONE;
            return _this;
        }
        BuilderBar.prototype.init = function () {
            var voffset = this.vertexOffset;
            var ioffset = this.indexOffset;
            var buffer = this.buffer;
            buffer.updateIndices();
            buildBarIndex(buffer.indices, voffset, ioffset);
            this.inited |= BuilderFlag.INDEX;
        };
        BuilderBar.prototype.update = function (shape) {
            var buffer = this.buffer;
            this.updateVertexStep(buffer, shape);
            this.updateColor(buffer, shape);
            this.updateUv(buffer, shape);
        };
        BuilderBar.prototype.updateVertexStep = function (buffer, shape) {
            if (shape instanceof EShapeBar) {
                var size = shape.size;
                var sizeX = size.x;
                var sizeY = size.y;
                var isSizeChanged = sizeX !== this.sizeX || sizeY !== this.sizeY;
                var stroke = shape.stroke;
                var strokeWidth = stroke.enable ? stroke.width : 0;
                var strokeStyle = stroke.style;
                var isStrokeWidthChanged = strokeWidth !== this.strokeWidth || strokeStyle !== this.strokeStyle;
                var transformLocalId = toTransformLocalId(shape);
                var isTransformChanged = this.transformLocalId !== transformLocalId;
                var points = shape.points;
                var pointsId = points.id;
                var isPointsIdChanged = pointsId !== this.pointsId;
                var pointsStyle = points.style;
                var isPointsStyleChanged = pointsStyle !== this.pointsStyle;
                var isNotInited = !(this.inited & BuilderFlag.VERTEX_AND_STEP);
                if (isNotInited ||
                    isSizeChanged ||
                    isTransformChanged ||
                    isStrokeWidthChanged ||
                    isPointsIdChanged ||
                    isPointsStyleChanged) {
                    this.inited |= BuilderFlag.VERTEX_AND_STEP;
                    this.sizeX = sizeX;
                    this.sizeY = sizeY;
                    this.strokeWidth = strokeWidth;
                    this.strokeStyle = strokeStyle;
                    this.transformLocalId = transformLocalId;
                    this.pointsId = pointsId;
                    this.pointsStyle = pointsStyle;
                    if (isPointsIdChanged) {
                        // Invalidate the UV buffer
                        this.inited &= ~BuilderFlag.UV;
                    }
                    buffer.updateVertices();
                    buffer.updateSteps();
                    buildBarVertexStep(buffer.vertices, buffer.steps, this.vertexOffset, points.values, points.size, strokeWidth, strokeStyle, shape.transform.internalTransform);
                }
            }
        };
        BuilderBar.prototype.updateUv = function (buffer, shape) {
            var texture = toTexture(shape);
            var textureTransformId = toTextureTransformId(texture);
            var isNotInited = !(this.inited & BuilderFlag.UV);
            if (isNotInited ||
                texture !== this.texture ||
                textureTransformId !== this.textureTransformId) {
                this.inited |= BuilderFlag.UV;
                this.texture = texture;
                this.textureTransformId = textureTransformId;
                buffer.updateUvs();
                buildBarUv(buffer.uvs, this.vertexOffset, toTextureUvs(texture));
            }
        };
        return BuilderBar;
    }(BuilderBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var BuilderText = /** @class */ (function () {
        function BuilderText(buffer, vertexOffset, indexOffset, vertexCount, indexCount) {
            this.buffer = buffer;
            this.vertexOffset = vertexOffset;
            this.indexOffset = indexOffset;
            this.vertexCount = vertexCount;
            this.indexCount = indexCount;
            this.inited = BuilderFlag.NONE;
            this.sizeX = 0;
            this.sizeY = 0;
            this.transformLocalId = 0;
            this.scaleX = 1;
            this.scaleY = 1;
            this.size = 0;
            this.family = "auto";
            this.value = "";
            this.texture = null;
            this.textureTransformId = 0;
            this.color = 0;
            this.alpha = 0;
            this.weight = 0;
            this.style = 0;
            this.alignHorizontal = 0;
            this.alignVertical = 0;
            this.offsetHorizontal = 0;
            this.offsetVertical = 0;
            this.outlineWidth = 0;
            this.outlineColor = 0;
            this.outlineAlpha = 0;
            this.spacingHorizontal = 0;
            this.spacingVertical = 0;
            this.direction = 0;
            this.paddingHorizontal = 0;
            this.paddingVertical = 0;
            this.clipping = false;
            this.fitting = false;
        }
        BuilderText.prototype.init = function () {
            var vcount = this.vertexCount;
            if (0 < vcount) {
                // Indices
                var buffer = this.buffer;
                var voffset = this.vertexOffset;
                buffer.updateIndices();
                buildTextIndex(buffer.indices, voffset, this.indexOffset, this.indexCount);
            }
            this.inited |= BuilderFlag.INDEX;
            return this;
        };
        BuilderText.prototype.reinit = function (buffer, shape, vertexOffset, indexOffset) {
            var tcount = toTextBufferCount(shape);
            var vertexCount = tcount << TEXT_VERTEX_COUNT_SHIFT;
            var indexCount = tcount << TEXT_INDEX_COUNT_SHIFT;
            if (this.buffer !== buffer ||
                this.vertexOffset !== vertexOffset ||
                this.indexOffset !== indexOffset ||
                this.vertexCount !== vertexCount ||
                this.indexCount !== indexCount) {
                if (buffer.check(vertexOffset, indexOffset, vertexCount, indexCount)) {
                    this.inited = BuilderFlag.NONE;
                    this.buffer = buffer;
                    this.vertexOffset = vertexOffset;
                    this.indexOffset = indexOffset;
                    this.vertexCount = vertexCount;
                    this.indexCount = indexCount;
                    this.init();
                    return true;
                }
                else {
                    return false;
                }
            }
            else {
                return true;
            }
        };
        BuilderText.prototype.isCompatible = function (shape) {
            return toTextBufferCount(shape) << TEXT_VERTEX_COUNT_SHIFT === this.vertexCount;
        };
        BuilderText.prototype.update = function (shape) {
            var vcount = this.vertexCount;
            if (0 < vcount) {
                var textAtlas = shape.text.atlas;
                if (textAtlas != null) {
                    var buffer = this.buffer;
                    this.updateVertex(buffer, shape, textAtlas);
                    this.updateColor(buffer, shape);
                    this.updateStep(buffer, shape);
                }
            }
            return this;
        };
        BuilderText.prototype.updateVertex = function (buffer, shape, textAtlas) {
            var size = shape.size;
            var sizeX = size.x;
            var sizeY = size.y;
            var isSizeChanged = sizeX !== this.sizeX || sizeY !== this.sizeY;
            var transformLocalId = toTransformLocalId(shape);
            var isTransformChanged = this.transformLocalId !== transformLocalId;
            var text = shape.text;
            var textSize = text.size;
            var textFamily = text.family;
            var textValue = text.value;
            var textStyle = text.style;
            var textAlignHorizontal = text.align.horizontal;
            var textAlignVertical = text.align.vertical;
            var textOffsetHorizontal = text.offset.horizontal;
            var textOffsetVertical = text.offset.vertical;
            var textSpacingHorizontal = text.spacing.horizontal;
            var textSpacingVertical = text.spacing.vertical;
            var textDirection = text.direction;
            var textPaddingHorizontal = text.padding.horizontal;
            var textPaddingVertical = text.padding.vertical;
            var textClipping = text.clipping;
            var textFitting = text.fitting;
            var textTexture = text.texture || pixi_js.Texture.WHITE;
            var textTextureTransformId = toTextureTransformId(textTexture);
            var isCharChanged = textValue !== this.value || textFamily !== this.family;
            var isCharSizeChanged = textSize !== this.size;
            var isCharStyleChanged = textStyle !== this.style;
            var isCharAlignChanged = textAlignHorizontal !== this.alignHorizontal ||
                textAlignVertical !== this.alignVertical;
            var isCharOffsetChanged = textOffsetHorizontal !== this.offsetHorizontal ||
                textOffsetVertical !== this.offsetVertical;
            var isCharSpacingChanged = textSpacingHorizontal !== this.spacingHorizontal ||
                textSpacingVertical !== this.spacingVertical ||
                textPaddingHorizontal !== this.paddingHorizontal ||
                textPaddingVertical !== this.paddingVertical;
            var isCharDirectionChanged = textDirection !== this.direction;
            var isClippingChanged = this.clipping !== textClipping;
            var isFittingChanged = this.fitting !== textFitting;
            var isTextureChanged = textTexture !== this.texture || textTextureTransformId !== this.textureTransformId;
            var isNotInited = !(this.inited & BuilderFlag.VERTEX);
            if (isNotInited ||
                isSizeChanged ||
                isTransformChanged ||
                isCharChanged ||
                isCharSizeChanged ||
                isCharStyleChanged ||
                isCharAlignChanged ||
                isCharOffsetChanged ||
                isCharSpacingChanged ||
                isCharDirectionChanged ||
                isClippingChanged ||
                isFittingChanged ||
                isTextureChanged) {
                this.inited |= BuilderFlag.VERTEX;
                this.size = textSize;
                this.family = textFamily;
                this.value = textValue;
                this.style = textStyle;
                this.alignHorizontal = textAlignHorizontal;
                this.alignVertical = textAlignVertical;
                this.offsetHorizontal = textOffsetHorizontal;
                this.offsetVertical = textOffsetVertical;
                this.spacingHorizontal = textSpacingHorizontal;
                this.spacingVertical = textSpacingVertical;
                this.direction = textDirection;
                this.paddingHorizontal = textPaddingHorizontal;
                this.paddingVertical = textPaddingVertical;
                this.clipping = textClipping;
                this.fitting = textFitting;
                this.texture = textTexture;
                this.textureTransformId = textTextureTransformId;
                if (isCharSizeChanged || isFittingChanged || (textFitting && isSizeChanged)) {
                    // Invalidate the step buffer.
                    this.inited &= ~BuilderFlag.STEP;
                }
                // Vertices & UVs
                buffer.updateVertices();
                buffer.updateUvs();
                var shapeSize = shape.size;
                var textWorld = text.world;
                if (textWorld == null) {
                    textWorld = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0];
                    text.world = textWorld;
                }
                buildTextVertex(buffer.vertices, buffer.uvs, this.vertexOffset, this.vertexCount, 0, 0, shapeSize.x, shapeSize.y, textAtlas, textSize, text.characters, textStyle, textAlignHorizontal, textAlignVertical, textOffsetHorizontal, textOffsetVertical, textSpacingHorizontal, textSpacingVertical, textDirection, textPaddingHorizontal, textPaddingVertical, textClipping, textFitting, textWorld, toTextureUvs(textTexture), shape.transform.internalTransform);
            }
        };
        BuilderText.prototype.updateColor = function (buffer, shape) {
            var text = shape.text;
            var color = text.color;
            var alpha = shape.visible && text.enable ? text.alpha : 0;
            var outline = text.outline;
            var outlineColor = outline.color;
            var outlineAlpha = shape.visible && text.enable ? outline.alpha : 0;
            var isNotInited = !(this.inited & BuilderFlag.COLOR);
            if (isNotInited ||
                color !== this.color ||
                alpha !== this.alpha ||
                color !== this.outlineColor ||
                alpha !== this.outlineAlpha) {
                this.inited |= BuilderFlag.COLOR;
                this.color = color;
                this.alpha = alpha;
                this.outlineColor = outlineColor;
                this.outlineAlpha = outlineAlpha;
                buffer.updateColors();
                buildColor(color, alpha, outlineColor, outlineAlpha, this.vertexOffset, this.vertexCount, buffer.colors);
            }
        };
        BuilderText.prototype.updateStep = function (buffer, shape) {
            var text = shape.text;
            var textOutline = text.outline;
            var textOutlineWidth = textOutline.enable ? textOutline.width : 0;
            var isOutlineWidthChanged = textOutlineWidth !== this.outlineWidth;
            var textWeight = text.weight;
            var isWeightChanged = textWeight !== this.weight;
            var scaleX = 1;
            var scaleY = 1;
            var textWorld = text.world;
            if (textWorld != null) {
                scaleX = textWorld[8];
                scaleY = textWorld[9];
            }
            var isScaleChanged = TEXT_FMIN < Math.abs(this.scaleX - scaleX) ||
                TEXT_FMIN < Math.abs(this.scaleY - scaleY);
            var isNotInited = !(this.inited & BuilderFlag.STEP);
            if (isNotInited || isWeightChanged || isOutlineWidthChanged || isScaleChanged) {
                this.inited |= BuilderFlag.STEP;
                this.weight = textWeight;
                this.outlineWidth = textOutlineWidth;
                this.scaleX = scaleX;
                this.scaleY = scaleY;
                buffer.updateSteps();
                buildTextStep(buffer.steps, this.vertexOffset, this.vertexCount, text.atlas, text.size, textOutlineWidth, textWeight, this.scaleX, this.scaleY);
            }
        };
        BuilderText.prototype.buildUnit = function (builder) {
            if (0 < this.vertexCount) {
                var textTexture = this.texture || pixi_js.Texture.WHITE;
                var textBaseTexture = textTexture.baseTexture;
                if (textBaseTexture !== builder.baseTexture) {
                    builder.baseTexture = textBaseTexture;
                    builder.push(textTexture, this.indexOffset);
                }
            }
        };
        return BuilderText;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var createBarUploaded = function (buffer, shape, voffset, ioffset, antialiasWeight) {
        var tcount = toTextBufferCount(shape);
        var tvcount = tcount << TEXT_VERTEX_COUNT_SHIFT;
        var ticount = tcount << TEXT_INDEX_COUNT_SHIFT;
        var vcount = BAR_VERTEX_COUNT + tvcount;
        var icount = BAR_INDEX_COUNT + ticount;
        if (buffer.check(voffset, ioffset, vcount, icount)) {
            return new EShapeUploadedImpl(buffer, voffset, ioffset, vcount, icount, [
                new BuilderBar(buffer, voffset, ioffset),
                new BuilderText(buffer, voffset + BAR_VERTEX_COUNT, ioffset + BAR_INDEX_COUNT, tvcount, ticount)
            ]).init(shape);
        }
        return null;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var toPadded = function (str, length, c) {
        var strLength = str.length;
        if (length < strLength) {
            return str;
        }
        var padding = "";
        for (var i = 0, imax = length - strLength; i < imax; ++i) {
            padding += c;
        }
        return padding + str;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var UtilRgb = /** @class */ (function () {
        function UtilRgb() {
        }
        UtilRgb.toCode = function (color) {
            return toPadded(color.toString(16).toUpperCase(), 6, "0");
        };
        UtilRgb.fromCode = function (code) {
            var trimmed = code.trim().toLowerCase();
            if (trimmed.length === 6) {
                var color = Number("0x".concat(trimmed));
                if (color === color) {
                    return color;
                }
            }
            return null;
        };
        UtilRgb.fromRgb = function (r, g, b) {
            return ((r * 0xff) << 16) | ((g * 0xff) << 8) | ((b * 0xff) | 0);
        };
        UtilRgb.blend = function (colorA, colorB, t) {
            var ar = (colorA >> 16) & 0xff;
            var ag = (colorA >> 8) & 0xff;
            var ab = (colorA | 0) & 0xff;
            var br = (colorB >> 16) & 0xff;
            var bg = (colorB >> 8) & 0xff;
            var bb = (colorB | 0) & 0xff;
            var w1 = Math.max(0, Math.min(1, t));
            var w0 = 1 - w1;
            var cr = Math.max(0, Math.min(0xff, ar * w0 + br * w1));
            var cg = Math.max(0, Math.min(0xff, ag * w0 + bg * w1));
            var cb = Math.max(0, Math.min(0xff, ab * w0 + bb * w1));
            return (cr << 16) | (cg << 8) | (cb | 0);
        };
        UtilRgb.brighten = function (color, amount) {
            if (0 <= amount) {
                return this.blend(color, 0xffffff, amount);
            }
            else {
                return this.blend(color, 0x000000, -amount);
            }
        };
        UtilRgb.darken = function (color, amount) {
            if (0 <= amount) {
                return this.blend(color, 0x000000, amount);
            }
            else {
                return this.blend(color, 0xffffff, -amount);
            }
        };
        /**
         * Convertes the given color to a grayscale color.
         *
         * @param color a color to be converted
         * @returns a grayscale color
         * @see https://en.wikipedia.org/wiki/Grayscale
         */
        UtilRgb.toGrayscale = function (color) {
            var l = this.toLuma(color);
            return (l << 16) | (l << 8) | l;
        };
        /**
         * Convertes the given color to a luma in the range [0, 255].
         *
         * @param color a color to be converted
         * @returns a luma in the range [0, 255]
         * @see https://en.wikipedia.org/wiki/Grayscale
         */
        UtilRgb.toLuma = function (color) {
            var r = (color >> 16) & 0xff;
            var g = (color >> 8) & 0xff;
            var b = (color | 0) & 0xff;
            return (0.2126 * r + 0.7152 * g + 0.0722 * b) & 0xff;
        };
        return UtilRgb;
    }());

    var POSITION_X = 1;
    var POSITION_Y = 2;
    var ROTATION = 4;
    var COLOR_FILL = 8;
    var COLOR_STROKE = 16;
    var COLOR_TEXT = 32;
    var COLOR_TEXT_OUTLINE = 64;
    var VISIBILITY = 128;
    var HEIGHT = 256;
    var WIDTH = 512;
    var TEXT$1 = 1024;
    var CURSOR = 2048;
    var EShapeRuntimeReset = {
        NONE: 0,
        POSITION_X: POSITION_X,
        POSITION_Y: POSITION_Y,
        POSITION: POSITION_X | POSITION_Y,
        ROTATION: ROTATION,
        COLOR_FILL: COLOR_FILL,
        COLOR_STROKE: COLOR_STROKE,
        COLOR_FILL_AND_STROKE: COLOR_FILL | COLOR_STROKE,
        COLOR_TEXT: COLOR_TEXT,
        COLOR_TEXT_OUTLINE: COLOR_TEXT_OUTLINE,
        COLOR: COLOR_FILL | COLOR_STROKE | COLOR_TEXT | COLOR_TEXT_OUTLINE,
        VISIBILITY: VISIBILITY,
        HEIGHT: HEIGHT,
        WIDTH: WIDTH,
        SIZE: HEIGHT | WIDTH,
        TEXT: TEXT$1,
        CURSOR: CURSOR
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionBases = /** @class */ (function () {
        function EShapeActionBases() {
        }
        EShapeActionBases.toBaseFill = function (shape, runtime) {
            return (runtime.written & EShapeRuntimeReset.COLOR_FILL ? shape : runtime).fill;
        };
        EShapeActionBases.toBaseStroke = function (shape, runtime) {
            return (runtime.written & EShapeRuntimeReset.COLOR_STROKE ? shape : runtime).stroke;
        };
        EShapeActionBases.toBaseText = function (shape, runtime) {
            return (runtime.written & EShapeRuntimeReset.COLOR_TEXT ? shape : runtime).text;
        };
        EShapeActionBases.toBaseTextOutline = function (shape, runtime) {
            return (runtime.written & EShapeRuntimeReset.COLOR_TEXT_OUTLINE ? shape : runtime).text
                .outline;
        };
        return EShapeActionBases;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionEnvironment = {
        isInitializing: false
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * {@link EShape} action expression utility class.
     */
    var EShapeActionExpressions = /** @class */ (function () {
        function EShapeActionExpressions() {
        }
        EShapeActionExpressions.from = function (expression, caster, def, defLiteral, nullable, parameter) {
            if (expression.trim().length <= 0) {
                return def;
            }
            try {
                /* eslint-disable prettier/prettier */
                var body = "" +
                    "try {" +
                    "with (shape) {" +
                    "with (state) {" +
                    "with (data.alias) {" +
                    "with (environment) {" +
                    (nullable ?
                        ("var result = (".concat(expression, ");") +
                            "return (result != null ? ".concat(caster, "(result) : null);")) :
                        "return ".concat(caster, "(").concat(expression, ");")) +
                    "}" +
                    "}" +
                    "}" +
                    "}" +
                    "} catch (e) {" +
                    "return ".concat(defLiteral, ";") +
                    "}";
                /* eslint-enable prettier/prettier */
                if (parameter == null) {
                    return Function("shape", "time", "environment", body);
                }
                else {
                    return Function("shape", "time", "environment", parameter, body);
                }
            }
            catch (e) {
                return def;
            }
        };
        EShapeActionExpressions.ofNumberOrNull = function (expression) {
            return this.from(expression, "Number", this.NULL, "null", true);
        };
        EShapeActionExpressions.ofStringOrNull = function (expression) {
            return this.from(expression, "String", this.NULL, "null", true);
        };
        EShapeActionExpressions.ofUnknown = function (expression) {
            return this.from(expression, "", this.NULL, "null", false);
        };
        EShapeActionExpressions.ofNumber = function (expression) {
            return this.from(expression, "Number", this.ZERO, "0", false);
        };
        EShapeActionExpressions.ofNumberOrOne = function (expression) {
            return this.from(expression, "Number", this.ONE, "1", false);
        };
        EShapeActionExpressions.ofNumberOrOneHundred = function (expression) {
            return this.from(expression, "Number", this.ONE_HUNDRED, "100", false);
        };
        EShapeActionExpressions.ofString = function (expression) {
            return this.from(expression, "String", this.EMPTY, '""', false);
        };
        EShapeActionExpressions.ofBoolean = function (expression) {
            return this.from(expression, "Boolean", this.TRUE, "true", false);
        };
        EShapeActionExpressions.ofBooleanOrTrue = function (expression) {
            return this.from(expression, "Boolean", this.TRUE, "true", false);
        };
        EShapeActionExpressions.ofBooleanOrFalse = function (expression) {
            return this.from(expression, "Boolean", this.FALSE, "false", false);
        };
        EShapeActionExpressions.ofElementOrNull = function (expression) {
            return this.from(expression, "", undefined, "null", false, "container");
        };
        EShapeActionExpressions.NULL = function () { return null; };
        EShapeActionExpressions.ZERO = function () { return 0; };
        EShapeActionExpressions.ONE = function () { return 1; };
        EShapeActionExpressions.ONE_HUNDRED = function () { return 100; };
        EShapeActionExpressions.EMPTY = function () { return ""; };
        EShapeActionExpressions.TRUE = function () { return true; };
        EShapeActionExpressions.FALSE = function () { return false; };
        return EShapeActionExpressions;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A base class of action runtimes.
     */
    var EShapeActionRuntimeBase = /** @class */ (function () {
        function EShapeActionRuntimeBase(reset) {
            this.reset = reset || EShapeRuntimeReset.NONE;
        }
        EShapeActionRuntimeBase.prototype.initialize = function (shape, runtime) {
            // DO NOTHING
        };
        EShapeActionRuntimeBase.prototype.execute = function (shape, runtime, time) {
            // DO NOTHING
        };
        EShapeActionRuntimeBase.prototype.onResize = function (shape, runtime) {
            // DO NOTHING
        };
        EShapeActionRuntimeBase.prototype.onFocus = function (shape, runtime) {
            // DO NOTHING
        };
        EShapeActionRuntimeBase.prototype.onBlur = function (shape, runtime) {
            // DO NOTHING
        };
        EShapeActionRuntimeBase.prototype.onClick = function (shape, runtime, e) {
            // DO NOTHING
        };
        EShapeActionRuntimeBase.prototype.onDblClick = function (shape, runtime, e, manager) {
            // DO NOTHING
        };
        EShapeActionRuntimeBase.prototype.onDowning = function (shape, runtime, e) {
            // DO NOTHING
        };
        EShapeActionRuntimeBase.prototype.onDown = function (shape, runtime, e) {
            // DO NOTHING
        };
        EShapeActionRuntimeBase.prototype.onMove = function (shape, runtime, e) {
            // DO NOTHING
        };
        EShapeActionRuntimeBase.prototype.onOver = function (shape, runtime, e) {
            // DO NOTHING
        };
        EShapeActionRuntimeBase.prototype.onOut = function (shape, runtime, e) {
            // DO NOTHING
        };
        EShapeActionRuntimeBase.prototype.onUp = function (shape, runtime, e) {
            // DO NOTHING
        };
        EShapeActionRuntimeBase.prototype.onUpOutside = function (shape, runtime, e) {
            // DO NOTHING
        };
        EShapeActionRuntimeBase.prototype.onPressed = function (shape, runtime, e) {
            // DO NOTHING
        };
        EShapeActionRuntimeBase.prototype.onUnpressed = function (shape, runtime, e) {
            // DO NOTHING
        };
        EShapeActionRuntimeBase.prototype.onKeyDown = function (shape, runtime, e) {
            // DO NOTHING
        };
        EShapeActionRuntimeBase.prototype.onKeyUp = function (shape, runtime, e) {
            // DO NOTHING
        };
        EShapeActionRuntimeBase.prototype.onRightClick = function (shape, runtime, e) {
            // DO NOTHING
        };
        EShapeActionRuntimeBase.prototype.onRightDowning = function (shape, runtime, e) {
            // DO NOTHING
        };
        EShapeActionRuntimeBase.prototype.onRightDown = function (shape, runtime, e) {
            // DO NOTHING
        };
        EShapeActionRuntimeBase.prototype.onRightUp = function (shape, runtime, e) {
            // DO NOTHING
        };
        EShapeActionRuntimeBase.prototype.onRightUpOutside = function (shape, runtime, e) {
            // DO NOTHING
        };
        EShapeActionRuntimeBase.prototype.onRightPressed = function (shape, runtime, e) {
            // DO NOTHING
        };
        EShapeActionRuntimeBase.prototype.onRightUnpressed = function (shape, runtime, e) {
            // DO NOTHING
        };
        EShapeActionRuntimeBase.prototype.onRender = function (shape, runtime, time, renderer) {
            // DO NOTHING
        };
        return EShapeActionRuntimeBase;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeConditional = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeConditional, _super);
        function EShapeActionRuntimeConditional(value, reset) {
            var _this = _super.call(this, reset) || this;
            _this.condition = EShapeActionExpressions.ofBoolean(value.condition);
            return _this;
        }
        return EShapeActionRuntimeConditional;
    }(EShapeActionRuntimeBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeBlink = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeBlink, _super);
        function EShapeActionRuntimeBlink(value, reset) {
            var _this = _super.call(this, value, reset) || this;
            _this.interval = value.interval;
            return _this;
        }
        EShapeActionRuntimeBlink.prototype.execute = function (shape, runtime, time) {
            if (this.condition(shape, time, EShapeActionEnvironment)) {
                var interval = this.interval;
                var dinterval = interval << 1;
                var elapsed = time % dinterval;
                if (elapsed < interval) {
                    this.toOff(shape, runtime);
                    runtime.effect = time + (interval - elapsed);
                }
                else {
                    this.toOn(shape, runtime);
                    runtime.effect = time + (dinterval - elapsed);
                }
            }
        };
        EShapeActionRuntimeBlink.prototype.toOn = function (shape, runtime) {
            //
        };
        EShapeActionRuntimeBlink.prototype.toOff = function (shape, runtime) {
            //
        };
        return EShapeActionRuntimeBlink;
    }(EShapeActionRuntimeConditional));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeBlinkBrighten = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeBlinkBrighten, _super);
        function EShapeActionRuntimeBlinkBrighten(value) {
            return _super.call(this, value, EShapeRuntimeReset.COLOR) || this;
        }
        EShapeActionRuntimeBlinkBrighten.prototype.toOn = function (shape, runtime) {
            var fill = EShapeActionBases.toBaseFill(shape, runtime);
            shape.fill.set(undefined, UtilRgb.brighten(fill.color, 0.5), fill.alpha);
            var stroke = EShapeActionBases.toBaseStroke(shape, runtime);
            shape.stroke.set(undefined, UtilRgb.brighten(stroke.color, 0.5), stroke.alpha);
            var text = EShapeActionBases.toBaseText(shape, runtime);
            shape.text.set(undefined, UtilRgb.brighten(text.color, 0.5), text.alpha);
            var outline = EShapeActionBases.toBaseTextOutline(shape, runtime);
            shape.text.outline.set(undefined, UtilRgb.brighten(outline.color, 0.5), outline.alpha);
            runtime.written |= this.reset;
        };
        return EShapeActionRuntimeBlinkBrighten;
    }(EShapeActionRuntimeBlink));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeBlinkColorFill = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeBlinkColorFill, _super);
        function EShapeActionRuntimeBlinkColorFill(value) {
            var _this = _super.call(this, value, EShapeRuntimeReset.COLOR_FILL) || this;
            _this.color = value.color;
            _this.alpha = value.alpha;
            return _this;
        }
        EShapeActionRuntimeBlinkColorFill.prototype.toOn = function (shape, runtime) {
            shape.fill.set(undefined, this.color, this.alpha);
            runtime.written |= this.reset;
        };
        return EShapeActionRuntimeBlinkColorFill;
    }(EShapeActionRuntimeBlink));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeBlinkColorStroke = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeBlinkColorStroke, _super);
        function EShapeActionRuntimeBlinkColorStroke(value) {
            var _this = _super.call(this, value, EShapeRuntimeReset.COLOR_STROKE) || this;
            _this.color = value.color;
            _this.alpha = value.alpha;
            return _this;
        }
        EShapeActionRuntimeBlinkColorStroke.prototype.toOn = function (shape, runtime) {
            shape.stroke.set(undefined, this.color, this.alpha);
            runtime.written |= this.reset;
        };
        return EShapeActionRuntimeBlinkColorStroke;
    }(EShapeActionRuntimeBlink));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeBlinkDarken = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeBlinkDarken, _super);
        function EShapeActionRuntimeBlinkDarken(value) {
            return _super.call(this, value, EShapeRuntimeReset.COLOR) || this;
        }
        EShapeActionRuntimeBlinkDarken.prototype.toOn = function (shape, runtime) {
            var fill = EShapeActionBases.toBaseFill(shape, runtime);
            shape.fill.set(undefined, UtilRgb.darken(fill.color, 0.5), fill.alpha);
            var stroke = EShapeActionBases.toBaseStroke(shape, runtime);
            shape.stroke.set(undefined, UtilRgb.darken(stroke.color, 0.5), stroke.alpha);
            var text = EShapeActionBases.toBaseText(shape, runtime);
            shape.text.set(undefined, UtilRgb.darken(text.color, 0.5), text.alpha);
            var outline = EShapeActionBases.toBaseTextOutline(shape, runtime);
            shape.text.outline.set(undefined, UtilRgb.darken(outline.color, 0.5), outline.alpha);
            runtime.written |= this.reset;
        };
        return EShapeActionRuntimeBlinkDarken;
    }(EShapeActionRuntimeBlink));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeBlinkOpacity = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeBlinkOpacity, _super);
        function EShapeActionRuntimeBlinkOpacity(value) {
            return _super.call(this, value, EShapeRuntimeReset.COLOR_FILL_AND_STROKE) || this;
        }
        EShapeActionRuntimeBlinkOpacity.prototype.toOn = function (shape, runtime) {
            var fill = EShapeActionBases.toBaseFill(shape, runtime);
            shape.fill.set(undefined, fill.color, fill.alpha * 0.5);
            var stroke = EShapeActionBases.toBaseStroke(shape, runtime);
            shape.stroke.set(undefined, stroke.color, stroke.alpha * 0.5);
            runtime.written |= this.reset;
        };
        return EShapeActionRuntimeBlinkOpacity;
    }(EShapeActionRuntimeBlink));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeBlinkVisibility = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeBlinkVisibility, _super);
        function EShapeActionRuntimeBlinkVisibility(value) {
            return _super.call(this, value, EShapeRuntimeReset.VISIBILITY) || this;
        }
        EShapeActionRuntimeBlinkVisibility.prototype.toOn = function (shape, runtime) {
            shape.visible = true;
            runtime.written |= this.reset;
        };
        EShapeActionRuntimeBlinkVisibility.prototype.toOff = function (shape, runtime) {
            shape.visible = false;
            runtime.written |= this.reset;
        };
        return EShapeActionRuntimeBlinkVisibility;
    }(EShapeActionRuntimeBlink));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueBlinkType = {
        VISIBILITY: 0,
        BRIGHTEN: 1,
        DARKEN: 2,
        OPACITY: 3,
        COLOR_FILL: 4,
        COLOR_STROKE: 5
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueBase = /** @class */ (function () {
        function EShapeActionValueBase(type, condition) {
            this.type = type;
            this.condition = condition;
        }
        EShapeActionValueBase.prototype.isEquals = function (value) {
            return this.type === value.type && this.condition === value.condition;
        };
        EShapeActionValueBase.prototype.toLabel = function () {
            return this.getTheme().toLabel(this);
        };
        EShapeActionValueBase.prototype.getTheme = function () {
            var _a;
            return ((_a = EShapeActionValueBase.THEME) !== null && _a !== void 0 ? _a : (EShapeActionValueBase.THEME = DThemes.getInstance().get("EShapeActionValue")));
        };
        return EShapeActionValueBase;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueSubtyped = /** @class */ (function (_super) {
        __extends(EShapeActionValueSubtyped, _super);
        function EShapeActionValueSubtyped(type, condition, subtype) {
            var _this = _super.call(this, type, condition) || this;
            _this.subtype = subtype;
            return _this;
        }
        EShapeActionValueSubtyped.prototype.isEquals = function (value) {
            return (_super.prototype.isEquals.call(this, value) &&
                value instanceof EShapeActionValueSubtyped &&
                this.subtype === value.subtype);
        };
        return EShapeActionValueSubtyped;
    }(EShapeActionValueBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueType = {
        SHOW_HIDE: 0,
        BLINK: 1,
        TRANSFORM: 2,
        OPEN: 3,
        /** @deprecated in favor of {@link EShapeActionValueMiscType}'s MISC */
        EMIT_EVENT: 4,
        /** @deprecated in favor of {@link EShapeActionValueType}'s CHANGE_COLOR */
        CHANGE_COLOR_LEGACY: 5,
        CHANGE_TEXT: 6,
        CHANGE_CURSOR: 7,
        MISC: 8,
        CHANGE_COLOR: 9,
        GESTURE: 10,
        EXTENSION: 1000
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValues = /** @class */ (function () {
        function EShapeActionValues() {
        }
        EShapeActionValues.toResource = function (index, parsed, resources) {
            if (0 <= index && index < parsed.length) {
                var id = parsed[index];
                if (isNumber(id) && 0 <= id && id < resources.length) {
                    return resources[id];
                }
            }
            return "";
        };
        return EShapeActionValues;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueBlink = /** @class */ (function (_super) {
        __extends(EShapeActionValueBlink, _super);
        function EShapeActionValueBlink(subtype, condition, interval, color, alpha) {
            var _this = _super.call(this, EShapeActionValueType.BLINK, condition, subtype) || this;
            _this.interval = interval;
            _this.color = color;
            _this.alpha = alpha;
            return _this;
        }
        EShapeActionValueBlink.prototype.isEquals = function (value) {
            return (_super.prototype.isEquals.call(this, value) &&
                value instanceof EShapeActionValueBlink &&
                this.interval === value.interval &&
                this.color === value.color &&
                this.alpha === value.alpha);
        };
        EShapeActionValueBlink.prototype.toRuntime = function () {
            switch (this.subtype) {
                case EShapeActionValueBlinkType.BRIGHTEN:
                    return new EShapeActionRuntimeBlinkBrighten(this);
                case EShapeActionValueBlinkType.COLOR_FILL:
                    return new EShapeActionRuntimeBlinkColorFill(this);
                case EShapeActionValueBlinkType.COLOR_STROKE:
                    return new EShapeActionRuntimeBlinkColorStroke(this);
                case EShapeActionValueBlinkType.DARKEN:
                    return new EShapeActionRuntimeBlinkDarken(this);
                case EShapeActionValueBlinkType.OPACITY:
                    return new EShapeActionRuntimeBlinkOpacity(this);
                case EShapeActionValueBlinkType.VISIBILITY:
                    return new EShapeActionRuntimeBlinkVisibility(this);
            }
        };
        EShapeActionValueBlink.prototype.serialize = function (manager) {
            var conditionId = manager.addResource(this.condition);
            return manager.addResource("[".concat(this.type, ",").concat(conditionId, ",").concat(this.subtype, ",").concat(this.interval, ",").concat(this.color, ",").concat(this.alpha, "]"));
        };
        EShapeActionValueBlink.deserialize = function (serialized, manager) {
            var condition = EShapeActionValues.toResource(1, serialized, manager.resources);
            return new EShapeActionValueBlink(serialized[2], condition, serialized[3], serialized[4], serialized[5]);
        };
        return EShapeActionValueBlink;
    }(EShapeActionValueSubtyped));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var UtilAlpha = /** @class */ (function () {
        function UtilAlpha() {
        }
        UtilAlpha.blend = function (alphaA, alphaB, t) {
            var w = Math.max(0, Math.min(1, t));
            return Math.max(0, Math.min(1, alphaA * (1 - w) + alphaB * w));
        };
        return UtilAlpha;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var toReset = function (type) {
        return type << 3;
    };
    var EShapeActionRuntimeChangeColorBase = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeChangeColorBase, _super);
        function EShapeActionRuntimeChangeColorBase(value) {
            return _super.call(this, value, toReset(value.subtype)) || this;
        }
        EShapeActionRuntimeChangeColorBase.prototype.set = function (shape, runtime, time, color, alpha, blend) {
            var reset = this.reset;
            if (color != null) {
                if (alpha != null) {
                    if (blend != null) {
                        if (reset & EShapeRuntimeReset.COLOR_FILL) {
                            var base = EShapeActionBases.toBaseFill(shape, runtime);
                            shape.fill.set(undefined, UtilRgb.blend(base.color, color, blend), UtilAlpha.blend(base.alpha, alpha, blend));
                        }
                        if (reset & EShapeRuntimeReset.COLOR_STROKE) {
                            var base = EShapeActionBases.toBaseStroke(shape, runtime);
                            shape.stroke.set(undefined, UtilRgb.blend(base.color, color, blend), UtilAlpha.blend(base.alpha, alpha, blend));
                        }
                        if (reset & EShapeRuntimeReset.COLOR_TEXT) {
                            var base = EShapeActionBases.toBaseText(shape, runtime);
                            shape.text.set(undefined, UtilRgb.blend(base.color, color, blend), UtilAlpha.blend(base.alpha, alpha, blend));
                        }
                        if (reset & EShapeRuntimeReset.COLOR_TEXT_OUTLINE) {
                            var base = EShapeActionBases.toBaseTextOutline(shape, runtime);
                            shape.text.outline.set(undefined, UtilRgb.blend(base.color, color, blend), UtilAlpha.blend(base.alpha, alpha, blend));
                        }
                    }
                    else {
                        if (reset & EShapeRuntimeReset.COLOR_FILL) {
                            shape.fill.set(undefined, color, alpha);
                        }
                        if (reset & EShapeRuntimeReset.COLOR_STROKE) {
                            shape.stroke.set(undefined, color, alpha);
                        }
                        if (reset & EShapeRuntimeReset.COLOR_TEXT) {
                            shape.text.set(undefined, color, alpha);
                        }
                        if (reset & EShapeRuntimeReset.COLOR_TEXT_OUTLINE) {
                            shape.text.outline.set(undefined, color, alpha);
                        }
                    }
                }
                else {
                    if (blend != null) {
                        if (reset & EShapeRuntimeReset.COLOR_FILL) {
                            var base = EShapeActionBases.toBaseFill(shape, runtime);
                            shape.fill.set(undefined, UtilRgb.blend(base.color, color, blend), base.alpha);
                        }
                        if (reset & EShapeRuntimeReset.COLOR_STROKE) {
                            var base = EShapeActionBases.toBaseStroke(shape, runtime);
                            shape.stroke.set(undefined, UtilRgb.blend(base.color, color, blend), base.alpha);
                        }
                        if (reset & EShapeRuntimeReset.COLOR_TEXT) {
                            var base = EShapeActionBases.toBaseText(shape, runtime);
                            shape.text.set(undefined, UtilRgb.blend(base.color, color, blend), base.alpha);
                        }
                        if (reset & EShapeRuntimeReset.COLOR_TEXT_OUTLINE) {
                            var base = EShapeActionBases.toBaseTextOutline(shape, runtime);
                            shape.text.outline.set(undefined, UtilRgb.blend(base.color, color, blend), base.alpha);
                        }
                    }
                    else {
                        if (reset & EShapeRuntimeReset.COLOR_FILL) {
                            var base = EShapeActionBases.toBaseFill(shape, runtime);
                            shape.fill.set(undefined, color, base.alpha);
                        }
                        if (reset & EShapeRuntimeReset.COLOR_STROKE) {
                            var base = EShapeActionBases.toBaseStroke(shape, runtime);
                            shape.stroke.set(undefined, color, base.alpha);
                        }
                        if (reset & EShapeRuntimeReset.COLOR_TEXT) {
                            var base = EShapeActionBases.toBaseText(shape, runtime);
                            shape.text.set(undefined, color, base.alpha);
                        }
                        if (reset & EShapeRuntimeReset.COLOR_TEXT_OUTLINE) {
                            var base = EShapeActionBases.toBaseTextOutline(shape, runtime);
                            shape.text.outline.set(undefined, color, base.alpha);
                        }
                    }
                }
                runtime.written |= reset;
            }
            else if (alpha != null) {
                if (blend != null) {
                    if (reset & EShapeRuntimeReset.COLOR_FILL) {
                        var base = EShapeActionBases.toBaseFill(shape, runtime);
                        shape.fill.set(undefined, base.color, UtilAlpha.blend(base.alpha, alpha, blend));
                    }
                    if (reset & EShapeRuntimeReset.COLOR_STROKE) {
                        var base = EShapeActionBases.toBaseStroke(shape, runtime);
                        shape.stroke.set(undefined, base.color, UtilAlpha.blend(base.alpha, alpha, blend));
                    }
                    if (reset & EShapeRuntimeReset.COLOR_TEXT) {
                        var base = EShapeActionBases.toBaseText(shape, runtime);
                        shape.text.set(undefined, base.color, UtilAlpha.blend(base.alpha, alpha, blend));
                    }
                    if (reset & EShapeRuntimeReset.COLOR_TEXT_OUTLINE) {
                        var base = EShapeActionBases.toBaseTextOutline(shape, runtime);
                        shape.text.outline.set(undefined, base.color, UtilAlpha.blend(base.alpha, alpha, blend));
                    }
                }
                else {
                    if (reset & EShapeRuntimeReset.COLOR_FILL) {
                        var base = EShapeActionBases.toBaseFill(shape, runtime);
                        shape.fill.set(undefined, base.color, alpha);
                    }
                    if (reset & EShapeRuntimeReset.COLOR_STROKE) {
                        var base = EShapeActionBases.toBaseStroke(shape, runtime);
                        shape.stroke.set(undefined, base.color, alpha);
                    }
                    if (reset & EShapeRuntimeReset.COLOR_TEXT) {
                        var base = EShapeActionBases.toBaseText(shape, runtime);
                        shape.text.set(undefined, base.color, alpha);
                    }
                    if (reset & EShapeRuntimeReset.COLOR_TEXT_OUTLINE) {
                        var base = EShapeActionBases.toBaseTextOutline(shape, runtime);
                        shape.text.outline.set(undefined, base.color, alpha);
                    }
                }
                runtime.written |= reset;
            }
        };
        return EShapeActionRuntimeChangeColorBase;
    }(EShapeActionRuntimeConditional));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueChangeColorTarget = {
        COLOR_AND_ALPHA: 0,
        COLOR: 1,
        ALPHA: 2,
        CODE: 3,
        BRIGHTNESS: 4
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeChangeColor = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeChangeColor, _super);
        function EShapeActionRuntimeChangeColor(value) {
            var _this = _super.call(this, value) || this;
            switch (value.target) {
                case EShapeActionValueChangeColorTarget.COLOR:
                    _this.color = value.color;
                    _this.alpha = null;
                    break;
                case EShapeActionValueChangeColorTarget.ALPHA:
                    _this.color = null;
                    _this.alpha = value.alpha;
                    break;
                default:
                    _this.color = value.color;
                    _this.alpha = value.alpha;
                    break;
            }
            _this.blend = EShapeActionExpressions.ofNumberOrNull(value.blend);
            return _this;
        }
        EShapeActionRuntimeChangeColor.prototype.execute = function (shape, runtime, time) {
            if (this.condition(shape, time, EShapeActionEnvironment)) {
                var color = this.color;
                var alpha = this.alpha;
                var blend = this.blend(shape, time, EShapeActionEnvironment);
                this.set(shape, runtime, time, color, alpha, blend);
            }
        };
        return EShapeActionRuntimeChangeColor;
    }(EShapeActionRuntimeChangeColorBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FILL = 1;
    var STROKE = 2;
    var TEXT = 4;
    var TEXT_OUTLINE = 8;
    var EShapeActionValueChangeColorType = {
        NONE: 0,
        FILL: FILL,
        STROKE: STROKE,
        TEXT: TEXT,
        TEXT_OUTLINE: TEXT_OUTLINE,
        FILL_AND_STROKE: FILL | STROKE,
        ALL: FILL | STROKE | TEXT | TEXT_OUTLINE
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueChangeColorTypeLegacy = {
        FILL: 0,
        STROKE: 1,
        FILL_AND_STROKE: 2,
        TEXT: 3,
        TEXT_OUTLINE: 4,
        ALL: 5
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueChangeColorTypes = /** @class */ (function () {
        function EShapeActionValueChangeColorTypes() {
        }
        EShapeActionValueChangeColorTypes.from = function (serialized) {
            if (serialized[0] === EShapeActionValueType.CHANGE_COLOR) {
                return serialized[2];
            }
            switch (serialized[2]) {
                case EShapeActionValueChangeColorTypeLegacy.FILL:
                    return EShapeActionValueChangeColorType.FILL;
                case EShapeActionValueChangeColorTypeLegacy.STROKE:
                    return EShapeActionValueChangeColorType.STROKE;
                case EShapeActionValueChangeColorTypeLegacy.FILL_AND_STROKE:
                    return EShapeActionValueChangeColorType.FILL_AND_STROKE;
                case EShapeActionValueChangeColorTypeLegacy.TEXT:
                    return EShapeActionValueChangeColorType.TEXT;
                case EShapeActionValueChangeColorTypeLegacy.TEXT_OUTLINE:
                    return EShapeActionValueChangeColorType.TEXT_OUTLINE;
                case EShapeActionValueChangeColorTypeLegacy.ALL:
                    return EShapeActionValueChangeColorType.ALL;
            }
        };
        EShapeActionValueChangeColorTypes.unpack = function (type) {
            var result = [];
            if (type & EShapeActionValueChangeColorType.FILL) {
                result.push(EShapeActionValueChangeColorType.FILL);
            }
            if (type & EShapeActionValueChangeColorType.STROKE) {
                result.push(EShapeActionValueChangeColorType.STROKE);
            }
            if (type & EShapeActionValueChangeColorType.TEXT) {
                result.push(EShapeActionValueChangeColorType.TEXT);
            }
            if (type & EShapeActionValueChangeColorType.TEXT_OUTLINE) {
                result.push(EShapeActionValueChangeColorType.TEXT_OUTLINE);
            }
            return result;
        };
        EShapeActionValueChangeColorTypes.pack = function (types) {
            var result = EShapeActionValueChangeColorType.NONE;
            for (var i = 0, imax = types.length; i < imax; ++i) {
                result |= types[i];
            }
            return result;
        };
        return EShapeActionValueChangeColorTypes;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueChangeColor = /** @class */ (function (_super) {
        __extends(EShapeActionValueChangeColor, _super);
        function EShapeActionValueChangeColor(subtype, condition, target, color, alpha, blend) {
            var _this = _super.call(this, EShapeActionValueType.CHANGE_COLOR, condition, subtype) || this;
            _this.target = target;
            _this.color = color;
            _this.alpha = alpha;
            _this.blend = blend;
            return _this;
        }
        EShapeActionValueChangeColor.prototype.isEquals = function (value) {
            return (_super.prototype.isEquals.call(this, value) &&
                value instanceof EShapeActionValueChangeColor &&
                this.target === value.target &&
                this.color === value.color &&
                this.alpha === value.alpha &&
                this.blend === value.blend);
        };
        EShapeActionValueChangeColor.prototype.toRuntime = function () {
            return new EShapeActionRuntimeChangeColor(this);
        };
        EShapeActionValueChangeColor.prototype.serialize = function (manager) {
            var conditionId = manager.addResource(this.condition);
            var blendId = manager.addResource(this.blend);
            return manager.addResource("[".concat(this.type, ",").concat(conditionId, ",").concat(this.subtype, ",").concat(this.target, ",").concat(this.color, ",").concat(this.alpha, ",").concat(blendId, "]"));
        };
        EShapeActionValueChangeColor.deserialize = function (serialized, manager) {
            var subtype = EShapeActionValueChangeColorTypes.from(serialized);
            var condition = EShapeActionValues.toResource(1, serialized, manager.resources);
            var blend = EShapeActionValues.toResource(6, serialized, manager.resources);
            return new EShapeActionValueChangeColor(subtype, condition, serialized[3], serialized[4], serialized[5], blend);
        };
        return EShapeActionValueChangeColor;
    }(EShapeActionValueSubtyped));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeChangeColorBrightness = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeChangeColorBrightness, _super);
        function EShapeActionRuntimeChangeColorBrightness(value) {
            var _this = _super.call(this, value) || this;
            _this.brightness = EShapeActionExpressions.ofNumberOrNull(value.brightness);
            return _this;
        }
        EShapeActionRuntimeChangeColorBrightness.prototype.execute = function (shape, runtime, time) {
            if (this.condition(shape, time, EShapeActionEnvironment)) {
                var brightness = this.brightness(shape, time, EShapeActionEnvironment);
                this.set(shape, runtime, time, brightness);
            }
        };
        EShapeActionRuntimeChangeColorBrightness.prototype.set = function (shape, runtime, time, brightness) {
            var reset = this.reset;
            if (brightness != null) {
                var toAdjusted = this.toAdjusted;
                if (reset & EShapeRuntimeReset.COLOR_FILL) {
                    var base = EShapeActionBases.toBaseFill(shape, runtime);
                    shape.fill.set(undefined, toAdjusted(base.color, brightness), base.alpha);
                }
                if (reset & EShapeRuntimeReset.COLOR_STROKE) {
                    var base = EShapeActionBases.toBaseStroke(shape, runtime);
                    shape.stroke.set(undefined, toAdjusted(base.color, brightness), base.alpha);
                }
                if (reset & EShapeRuntimeReset.COLOR_TEXT) {
                    var base = EShapeActionBases.toBaseText(shape, runtime);
                    shape.text.set(undefined, toAdjusted(base.color, brightness), base.alpha);
                }
                if (reset & EShapeRuntimeReset.COLOR_TEXT_OUTLINE) {
                    var base = EShapeActionBases.toBaseTextOutline(shape, runtime);
                    shape.text.outline.set(undefined, toAdjusted(base.color, brightness), base.alpha);
                }
                runtime.written |= reset;
            }
        };
        EShapeActionRuntimeChangeColorBrightness.prototype.toAdjusted = function (color, brightness) {
            if (0 <= brightness) {
                return UtilRgb.brighten(color, +brightness);
            }
            else {
                return UtilRgb.darken(color, -brightness);
            }
        };
        return EShapeActionRuntimeChangeColorBrightness;
    }(EShapeActionRuntimeChangeColorBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueChangeColorBrightness = /** @class */ (function (_super) {
        __extends(EShapeActionValueChangeColorBrightness, _super);
        function EShapeActionValueChangeColorBrightness(subtype, condition, brightness) {
            var _this = _super.call(this, EShapeActionValueType.CHANGE_COLOR, condition, subtype) || this;
            _this.brightness = brightness;
            return _this;
        }
        EShapeActionValueChangeColorBrightness.prototype.isEquals = function (value) {
            return (_super.prototype.isEquals.call(this, value) &&
                value instanceof EShapeActionValueChangeColorBrightness &&
                this.brightness === value.brightness);
        };
        EShapeActionValueChangeColorBrightness.prototype.toRuntime = function () {
            return new EShapeActionRuntimeChangeColorBrightness(this);
        };
        EShapeActionValueChangeColorBrightness.prototype.serialize = function (manager) {
            var conditionId = manager.addResource(this.condition);
            var target = EShapeActionValueChangeColorTarget.BRIGHTNESS;
            var brightnessId = manager.addResource(this.brightness);
            return manager.addResource("[".concat(this.type, ",").concat(conditionId, ",").concat(this.subtype, ",").concat(target, ",").concat(brightnessId, "]"));
        };
        EShapeActionValueChangeColorBrightness.deserialize = function (serialized, manager) {
            var subtype = EShapeActionValueChangeColorTypes.from(serialized);
            var condition = EShapeActionValues.toResource(1, serialized, manager.resources);
            var brightness = EShapeActionValues.toResource(4, serialized, manager.resources);
            return new EShapeActionValueChangeColorBrightness(subtype, condition, brightness);
        };
        return EShapeActionValueChangeColorBrightness;
    }(EShapeActionValueSubtyped));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeChangeColorCode = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeChangeColorCode, _super);
        function EShapeActionRuntimeChangeColorCode(value) {
            var _this = _super.call(this, value) || this;
            _this.color = EShapeActionExpressions.ofNumberOrNull(value.color);
            _this.alpha = EShapeActionExpressions.ofNumberOrNull(value.alpha);
            _this.blend = EShapeActionExpressions.ofNumberOrNull(value.blend);
            return _this;
        }
        EShapeActionRuntimeChangeColorCode.prototype.execute = function (shape, runtime, time) {
            if (this.condition(shape, time, EShapeActionEnvironment)) {
                var color = this.color(shape, time, EShapeActionEnvironment);
                var alpha = this.alpha(shape, time, EShapeActionEnvironment);
                var blend = this.blend(shape, time, EShapeActionEnvironment);
                this.set(shape, runtime, time, color, alpha, blend);
            }
        };
        return EShapeActionRuntimeChangeColorCode;
    }(EShapeActionRuntimeChangeColorBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueChangeColorCode = /** @class */ (function (_super) {
        __extends(EShapeActionValueChangeColorCode, _super);
        function EShapeActionValueChangeColorCode(subtype, condition, color, alpha, blend) {
            var _this = _super.call(this, EShapeActionValueType.CHANGE_COLOR, condition, subtype) || this;
            _this.color = color;
            _this.alpha = alpha;
            _this.blend = blend;
            return _this;
        }
        EShapeActionValueChangeColorCode.prototype.isEquals = function (value) {
            return (_super.prototype.isEquals.call(this, value) &&
                value instanceof EShapeActionValueChangeColorCode &&
                this.color === value.color &&
                this.alpha === value.alpha &&
                this.blend === value.blend);
        };
        EShapeActionValueChangeColorCode.prototype.toRuntime = function () {
            return new EShapeActionRuntimeChangeColorCode(this);
        };
        EShapeActionValueChangeColorCode.prototype.serialize = function (manager) {
            var conditionId = manager.addResource(this.condition);
            var target = EShapeActionValueChangeColorTarget.CODE;
            var colorId = manager.addResource(this.color);
            var alphaId = manager.addResource(this.alpha);
            var blendId = manager.addResource(this.blend);
            return manager.addResource("[".concat(this.type, ",").concat(conditionId, ",").concat(this.subtype, ",").concat(target, ",").concat(colorId, ",").concat(alphaId, ",").concat(blendId, "]"));
        };
        EShapeActionValueChangeColorCode.deserialize = function (serialized, manager) {
            var subtype = EShapeActionValueChangeColorTypes.from(serialized);
            var condition = EShapeActionValues.toResource(1, serialized, manager.resources);
            var color = EShapeActionValues.toResource(4, serialized, manager.resources);
            var alpha = EShapeActionValues.toResource(5, serialized, manager.resources);
            var blend = EShapeActionValues.toResource(6, serialized, manager.resources);
            return new EShapeActionValueChangeColorCode(subtype, condition, color, alpha, blend);
        };
        return EShapeActionValueChangeColorCode;
    }(EShapeActionValueSubtyped));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeChangeCursor = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeChangeCursor, _super);
        function EShapeActionRuntimeChangeCursor(value) {
            var _this = _super.call(this, value, EShapeRuntimeReset.CURSOR) || this;
            _this.name = EShapeActionExpressions.ofStringOrNull(value.name);
            return _this;
        }
        EShapeActionRuntimeChangeCursor.prototype.execute = function (shape, runtime, time) {
            if (this.condition(shape, time, EShapeActionEnvironment)) {
                var name_1 = this.name(shape, time, EShapeActionEnvironment);
                if (name_1 != null) {
                    shape.cursor = name_1;
                    runtime.written |= this.reset;
                }
            }
        };
        return EShapeActionRuntimeChangeCursor;
    }(EShapeActionRuntimeConditional));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueChangeCursor = /** @class */ (function (_super) {
        __extends(EShapeActionValueChangeCursor, _super);
        function EShapeActionValueChangeCursor(condition, name) {
            var _this = _super.call(this, EShapeActionValueType.CHANGE_CURSOR, condition) || this;
            _this.name = name;
            return _this;
        }
        EShapeActionValueChangeCursor.prototype.isEquals = function (value) {
            return (_super.prototype.isEquals.call(this, value) &&
                value instanceof EShapeActionValueChangeCursor &&
                this.name === value.name);
        };
        EShapeActionValueChangeCursor.prototype.toRuntime = function () {
            return new EShapeActionRuntimeChangeCursor(this);
        };
        EShapeActionValueChangeCursor.prototype.serialize = function (manager) {
            var conditionId = manager.addResource(this.condition);
            var nameId = manager.addResource(this.name);
            return manager.addResource("[".concat(this.type, ",").concat(conditionId, ",").concat(nameId, "]"));
        };
        EShapeActionValueChangeCursor.deserialize = function (serialized, manager) {
            var condition = EShapeActionValues.toResource(1, serialized, manager.resources);
            var name = EShapeActionValues.toResource(2, serialized, manager.resources);
            return new EShapeActionValueChangeCursor(condition, name);
        };
        return EShapeActionValueChangeCursor;
    }(EShapeActionValueBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNodeA = /** @class */ (function () {
        function FormatNodeA() {
        }
        FormatNodeA.prototype.format = function (target, step, date) {
            return date.getHours() < 12 ? "AM" : "PM";
        };
        return FormatNodeA;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNodea = /** @class */ (function () {
        function FormatNodea() {
        }
        FormatNodea.prototype.format = function (target, step, date) {
            return date.getHours() < 12 ? "am" : "pm";
        };
        return FormatNodea;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNodeD = /** @class */ (function () {
        function FormatNodeD() {
        }
        FormatNodeD.prototype.format = function (target, step, date) {
            return String(date.getDate());
        };
        return FormatNodeD;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNoded = /** @class */ (function () {
        function FormatNoded() {
        }
        FormatNoded.prototype.format = function (target, step, date) {
            return "".concat(target | 0);
        };
        return FormatNoded;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNodePrecision = /** @class */ (function () {
        function FormatNodePrecision(precision) {
            if (precision != null) {
                this.precision = +precision.substring(1, precision.length);
            }
            else {
                this.precision = undefined;
            }
        }
        return FormatNodePrecision;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNodee = /** @class */ (function (_super) {
        __extends(FormatNodee, _super);
        function FormatNodee() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        FormatNodee.prototype.format = function (target, step, date) {
            return target.toExponential(this.precision);
        };
        return FormatNodee;
    }(FormatNodePrecision));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNodef = /** @class */ (function (_super) {
        __extends(FormatNodef, _super);
        function FormatNodef() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        FormatNodef.prototype.format = function (target, step, date) {
            return target.toFixed(this.precision);
        };
        return FormatNodef;
    }(FormatNodePrecision));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNodefsi = /** @class */ (function (_super) {
        __extends(FormatNodefsi, _super);
        function FormatNodefsi() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        FormatNodefsi.prototype.format = function (target, step, date) {
            var abs = this.toAbs(target, step, date);
            if (abs < 1e-24) {
                return this.format_(target, 1, "");
            }
            else if (abs < 1e-21) {
                return this.format_(target, 1e24, "y");
            }
            else if (abs < 1e-18) {
                return this.format_(target, 1e21, "z");
            }
            else if (abs < 1e-15) {
                return this.format_(target, 1e18, "a");
            }
            else if (abs < 1e-12) {
                return this.format_(target, 1e15, "f");
            }
            else if (abs < 1e-9) {
                return this.format_(target, 1e12, "p");
            }
            else if (abs < 1e-6) {
                return this.format_(target, 1e9, "n");
            }
            else if (abs < 1e-3) {
                return this.format_(target, 1e6, "μ");
            }
            else if (abs < 1) {
                return this.format_(target, 1e3, "m");
            }
            else if (abs < 1e3) {
                return this.format_(target, 1, "");
            }
            else if (abs < 1e6) {
                return this.format_(target, 1e-3, "k");
            }
            else if (abs < 1e9) {
                return this.format_(target, 1e-6, "M");
            }
            else if (abs < 1e12) {
                return this.format_(target, 1e-9, "G");
            }
            else if (abs < 1e15) {
                return this.format_(target, 1e-12, "T");
            }
            else if (abs < 1e18) {
                return this.format_(target, 1e-15, "P");
            }
            else if (abs < 1e21) {
                return this.format_(target, 1e-18, "E");
            }
            else if (abs < 1e24) {
                return this.format_(target, 1e-21, "Z");
            }
            else {
                return this.format_(target, 1e-24, "Y");
            }
        };
        FormatNodefsi.prototype.toAbs = function (target, step, date) {
            return Math.abs(target);
        };
        FormatNodefsi.prototype.format_ = function (target, unitInverse, postfix) {
            var value = target * unitInverse;
            return "".concat(value.toFixed(this.precision)).concat(postfix);
        };
        return FormatNodefsi;
    }(FormatNodePrecision));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNodeg = /** @class */ (function (_super) {
        __extends(FormatNodeg, _super);
        function FormatNodeg() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        FormatNodeg.prototype.format = function (target, step, date) {
            return target.toPrecision(this.precision);
        };
        return FormatNodeg;
    }(FormatNodePrecision));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNodeH = /** @class */ (function () {
        function FormatNodeH() {
        }
        FormatNodeH.prototype.format = function (target, step, date) {
            return String(date.getHours());
        };
        return FormatNodeH;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNodeh = /** @class */ (function () {
        function FormatNodeh() {
        }
        FormatNodeh.prototype.format = function (target, step, date) {
            return String(date.getHours() % 12);
        };
        return FormatNodeh;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNodeM = /** @class */ (function () {
        function FormatNodeM() {
        }
        FormatNodeM.prototype.format = function (target, step, date) {
            return String(date.getMonth() + 1);
        };
        return FormatNodeM;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNodem = /** @class */ (function () {
        function FormatNodem() {
        }
        FormatNodem.prototype.format = function (target, step, date) {
            return String(date.getMinutes());
        };
        return FormatNodem;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNodemi = /** @class */ (function () {
        function FormatNodemi() {
        }
        FormatNodemi.prototype.format = function (target, step, date) {
            return String(date.getMilliseconds());
        };
        return FormatNodemi;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNodeP = /** @class */ (function () {
        function FormatNodeP() {
        }
        FormatNodeP.prototype.format = function (target, step, date) {
            return "".concat((target * 100) | 0, "%");
        };
        return FormatNodeP;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNodep = /** @class */ (function () {
        function FormatNodep() {
        }
        FormatNodep.prototype.format = function (target, step, date) {
            return "".concat(target | 0, "%");
        };
        return FormatNodep;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNodePadding = /** @class */ (function () {
        function FormatNodePadding(length, character, node) {
            this.length = length;
            this.character = character;
            this.node = node;
        }
        FormatNodePadding.prototype.format = function (target, step, date) {
            return toPadded(this.node.format(target, step, date), this.length, this.character);
        };
        return FormatNodePadding;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNodeParenthesis = /** @class */ (function () {
        function FormatNodeParenthesis(node) {
            this.node = node;
        }
        FormatNodeParenthesis.prototype.format = function (target, step, date) {
            var result = this.node.format(target, step, date);
            if (0 < result.length && result[0] === "-") {
                return "(".concat(result.substring(1, result.length), ")");
            }
            return result;
        };
        return FormatNodeParenthesis;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNodePlus = /** @class */ (function () {
        function FormatNodePlus(node) {
            this.node = node;
        }
        FormatNodePlus.prototype.format = function (target, step, date) {
            var result = this.node.format(target, step, date);
            if (0 < result.length && result[0] !== "-") {
                return "+".concat(result);
            }
            return result;
        };
        return FormatNodePlus;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNodeRP = /** @class */ (function () {
        function FormatNodeRP() {
        }
        FormatNodeRP.prototype.format = function (target, step, date) {
            return "".concat(Math.round(target * 100), "%");
        };
        return FormatNodeRP;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNoderp = /** @class */ (function () {
        function FormatNoderp() {
        }
        FormatNoderp.prototype.format = function (target, step, date) {
            return "".concat(Math.round(target), "%");
        };
        return FormatNoderp;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNodesdt = /** @class */ (function () {
        function FormatNodesdt(Y, M, D, H, m, s, mi) {
            this.Y = Y;
            this.M = M;
            this.D = D;
            this.H = H;
            this.m = m;
            this.s = s;
            this.mi = mi;
        }
        FormatNodesdt.prototype.format = function (target, step, date) {
            if (step < 1000) {
                return "".concat(this.s.format(target, step, date), ".").concat(this.mi.format(target, step, date));
            }
            else if (step < 60000) {
                return "".concat(this.m.format(target, step, date), ":").concat(this.s.format(target, step, date));
            }
            else if (step < 3600000) {
                return "".concat(this.H.format(target, step, date), ":").concat(this.m.format(target, step, date));
            }
            else if (step < 86400000) {
                var M = this.M.format(target, step, date);
                var D = this.D.format(target, step, date);
                return "".concat(M, "/").concat(D, " ").concat(this.H.format(target, step, date));
            }
            else if (step < 2592000000) {
                return "".concat(this.M.format(target, step, date), "/").concat(this.D.format(target, step, date));
            }
            else {
                return "".concat(this.Y.format(target, step, date), "/").concat(this.M.format(target, step, date));
            }
        };
        return FormatNodesdt;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNodeSpace = /** @class */ (function () {
        function FormatNodeSpace(node) {
            this.node = node;
        }
        FormatNodeSpace.prototype.format = function (target, step, date) {
            var result = this.node.format(target, step, date);
            if (0 < result.length && result[0] !== "-") {
                return " ".concat(result);
            }
            return result;
        };
        return FormatNodeSpace;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNodessi = /** @class */ (function (_super) {
        __extends(FormatNodessi, _super);
        function FormatNodessi() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        FormatNodessi.prototype.toAbs = function (target, step, date) {
            return Math.abs(step);
        };
        return FormatNodessi;
    }(FormatNodefsi));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNodeString = /** @class */ (function () {
        function FormatNodeString(str) {
            this.str = str;
        }
        FormatNodeString.prototype.format = function (target, step, date) {
            return this.str;
        };
        return FormatNodeString;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNodeY = /** @class */ (function () {
        function FormatNodeY() {
        }
        FormatNodeY.prototype.format = function (target, step, date) {
            return String(date.getFullYear());
        };
        return FormatNodeY;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNodey = /** @class */ (function () {
        function FormatNodey() {
        }
        FormatNodey.prototype.format = function (target, step, date) {
            return String(date.getFullYear() % 100);
        };
        return FormatNodey;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNodez = /** @class */ (function () {
        function FormatNodez() {
        }
        FormatNodez.prototype.format = function (target, step, date) {
            var z = date.getTimezoneOffset();
            var tzs = z <= 0 ? "+" : "-";
            var tzh = toPadded(String(Math.floor(Math.abs(z) / 60)), 2, "0");
            var tzm = toPadded(String(Math.floor(Math.abs(z) % 60)), 2, "0");
            return "".concat(tzs).concat(tzh, ":").concat(tzm);
        };
        return FormatNodez;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNoderd = /** @class */ (function () {
        function FormatNoderd() {
        }
        FormatNoderd.prototype.format = function (target, step, date) {
            return "".concat(Math.round(target));
        };
        return FormatNoderd;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNodes = /** @class */ (function () {
        function FormatNodes() {
        }
        FormatNodes.prototype.format = function (target, step, date) {
            return String(date.getSeconds());
        };
        return FormatNodes;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var REGEXP = undefined;
    var getRegExp = function () {
        var result = REGEXP;
        if (result) {
            result.lastIndex = 0;
        }
        else {
            result =
                /%(0|_|-|\+|\()?(\.\d+)?(Y(?:MD?)?|y(?:MD?)?|MD?|D|H(?:ms?)?|h(?:ms?)?|m(?:i|s)?|a|A|s(?:s?i|dt)?|z|%|f(?:si)?|e|g|d|r(?:d|p)|p|P|RP)/g;
            REGEXP = result;
        }
        return result;
    };
    var toModifiedDatetime = function (modifier, length, node) {
        switch (modifier) {
            case "_":
                return new FormatNodePadding(length, " ", node);
            case "-":
                return node;
            default:
                return new FormatNodePadding(length, "0", node);
        }
    };
    var toModifiedNumber = function (modifier, node) {
        switch (modifier) {
            case "_": // space for non-negative numbers
                return new FormatNodeSpace(node);
            case "+": // plus sign for non-negative numbers
                return new FormatNodePlus(node);
            case "(": // parenthesis for the negative numbers
                return new FormatNodeParenthesis(node);
            default:
                return node;
        }
    };
    var toParsed = function (format) {
        var previousIndex = 0;
        var isDateRequired = false;
        var result = [];
        var regExp = getRegExp();
        while (true) {
            var matched = regExp.exec(format);
            if (matched != null) {
                var index = matched.index;
                if (previousIndex < index) {
                    result.push(new FormatNodeString(format.substring(previousIndex, index)));
                }
                previousIndex = index + matched[0].length;
                var all = matched[0];
                var modifier = matched[1];
                var precision = matched[2];
                var specifier = matched[3];
                switch (specifier) {
                    case "Y": // full year
                        isDateRequired = true;
                        result.push(new FormatNodeY());
                        break;
                    case "YM":
                        isDateRequired = true;
                        result.push(new FormatNodeY(), new FormatNodeString("/"), toModifiedDatetime(modifier, 2, new FormatNodeM()));
                        break;
                    case "YMD":
                        isDateRequired = true;
                        result.push(new FormatNodeY(), new FormatNodeString("/"), toModifiedDatetime(modifier, 2, new FormatNodeM()), new FormatNodeString("/"), toModifiedDatetime(modifier, 2, new FormatNodeD()));
                        break;
                    case "y": // short year: [0, 99]
                        isDateRequired = true;
                        result.push(toModifiedDatetime(modifier, 2, new FormatNodey()));
                        break;
                    case "yM":
                        isDateRequired = true;
                        result.push(toModifiedDatetime(modifier, 2, new FormatNodey()), new FormatNodeString("/"), toModifiedDatetime(modifier, 2, new FormatNodeM()));
                        break;
                    case "yMD":
                        result.push(toModifiedDatetime(modifier, 2, new FormatNodey()), new FormatNodeString("/"), toModifiedDatetime(modifier, 2, new FormatNodeM()), new FormatNodeString("/"), toModifiedDatetime(modifier, 2, new FormatNodeD()));
                        break;
                    case "M": // month: [1, 12]
                        isDateRequired = true;
                        result.push(toModifiedDatetime(modifier, 2, new FormatNodeM()));
                        break;
                    case "MD":
                        isDateRequired = true;
                        result.push(toModifiedDatetime(modifier, 2, new FormatNodeM()), new FormatNodeString("/"), toModifiedDatetime(modifier, 2, new FormatNodeD()));
                        break;
                    case "D": // day of the month: [1, 31]
                        isDateRequired = true;
                        result.push(toModifiedDatetime(modifier, 2, new FormatNodeD()));
                        break;
                    case "H": // 24-hour clock: [0, 23]
                        isDateRequired = true;
                        result.push(toModifiedDatetime(modifier, 2, new FormatNodeH()));
                        break;
                    case "Hm":
                        isDateRequired = true;
                        result.push(toModifiedDatetime(modifier, 2, new FormatNodeH()), new FormatNodeString(":"), toModifiedDatetime(modifier, 2, new FormatNodem()));
                        break;
                    case "Hms":
                        isDateRequired = true;
                        result.push(toModifiedDatetime(modifier, 2, new FormatNodeH()), new FormatNodeString(":"), toModifiedDatetime(modifier, 2, new FormatNodem()), new FormatNodeString(":"), toModifiedDatetime(modifier, 2, new FormatNodes()));
                        break;
                    case "h": // 12-hour clock: [1, 12]
                        isDateRequired = true;
                        result.push(toModifiedDatetime(modifier, 2, new FormatNodeh()));
                        break;
                    case "hm":
                        isDateRequired = true;
                        result.push(toModifiedDatetime(modifier, 2, new FormatNodeh()), new FormatNodeString(":"), toModifiedDatetime(modifier, 2, new FormatNodem()));
                        break;
                    case "hms":
                        isDateRequired = true;
                        result.push(toModifiedDatetime(modifier, 2, new FormatNodeh()), new FormatNodeString(":"), toModifiedDatetime(modifier, 2, new FormatNodem()), new FormatNodeString(":"), toModifiedDatetime(modifier, 2, new FormatNodes()));
                        break;
                    case "m": // minute [0, 59]
                        isDateRequired = true;
                        result.push(toModifiedDatetime(modifier, 2, new FormatNodem()));
                        break;
                    case "ms":
                        isDateRequired = true;
                        result.push(toModifiedDatetime(modifier, 2, new FormatNodem()), new FormatNodeString(":"), toModifiedDatetime(modifier, 2, new FormatNodes()));
                        break;
                    case "mi": // milliseconds [0, 999]
                        isDateRequired = true;
                        result.push(toModifiedDatetime(modifier, 3, new FormatNodemi()));
                        break;
                    case "a": // am or pm
                        isDateRequired = true;
                        result.push(new FormatNodea());
                        break;
                    case "A": // AM or PM
                        isDateRequired = true;
                        result.push(new FormatNodeA());
                        break;
                    case "s": // seconds: [0, 61]
                        isDateRequired = true;
                        result.push(toModifiedDatetime(modifier, 2, new FormatNodes()));
                        break;
                    case "sdt":
                        isDateRequired = true;
                        result.push(new FormatNodesdt(new FormatNodeY(), toModifiedDatetime(modifier, 2, new FormatNodeM()), toModifiedDatetime(modifier, 2, new FormatNodeD()), toModifiedDatetime(modifier, 2, new FormatNodeH()), toModifiedDatetime(modifier, 2, new FormatNodem()), toModifiedDatetime(modifier, 2, new FormatNodes()), toModifiedDatetime(modifier, 3, new FormatNodemi())));
                        break;
                    case "z": // time zone
                        isDateRequired = true;
                        result.push(new FormatNodez());
                        break;
                    case "%": // a % literal
                        result.push(new FormatNodeString("%"));
                        break;
                    case "f": // fixed point notation
                        result.push(toModifiedNumber(modifier, new FormatNodef(precision)));
                        break;
                    case "e": // exponent notation
                        result.push(toModifiedNumber(modifier, new FormatNodee(precision)));
                        break;
                    case "g": // %f or %e
                        result.push(toModifiedNumber(modifier, new FormatNodeg(precision)));
                        break;
                    case "rd": // rounded decimal notation
                        result.push(toModifiedNumber(modifier, new FormatNoderd()));
                        break;
                    case "d": // decimal notation
                        result.push(toModifiedNumber(modifier, new FormatNoded()));
                        break;
                    case "P": // percent notation (Multiplied by 100)
                        result.push(toModifiedNumber(modifier, new FormatNodeP()));
                        break;
                    case "p": // percent notation (Not multiplied by 100)
                        result.push(toModifiedNumber(modifier, new FormatNodep()));
                        break;
                    case "RP": // percent notation (Multiplied by 100)
                        result.push(toModifiedNumber(modifier, new FormatNodeRP()));
                        break;
                    case "rp": // percent notation (Not multiplied by 100)
                        result.push(toModifiedNumber(modifier, new FormatNoderp()));
                        break;
                    case "fsi": // fixed point notation with a SI prefix
                        result.push(toModifiedNumber(modifier, new FormatNodefsi(precision)));
                        break;
                    case "ssi": // Step-based fixed point notation with a SI prefix
                        result.push(toModifiedNumber(modifier, new FormatNodessi(precision)));
                        break;
                    default:
                        result.push(new FormatNodeString(all));
                        break;
                }
            }
            else {
                if (previousIndex < format.length) {
                    result.push(new FormatNodeString(format.substring(previousIndex, format.length)));
                }
                break;
            }
        }
        return {
            nodes: result,
            date: isDateRequired
        };
    };
    /**
     * A NumberFormatter implementation class.
     */
    var NumberFormatterImpl = /** @class */ (function () {
        function NumberFormatterImpl(format) {
            var parsed = toParsed(format);
            this.date = parsed.date;
            this.nodes = parsed.nodes;
        }
        NumberFormatterImpl.prototype.format = function (target, step) {
            var nodes = this.nodes;
            var date = NumberFormatterImpl.DATE;
            if (date == null) {
                date = new Date();
                NumberFormatterImpl.DATE = date;
            }
            if (this.date) {
                date.setTime(target);
            }
            var result = "";
            for (var i = 0, imax = nodes.length; i < imax; ++i) {
                result += nodes[i].format(target, step, date);
            }
            return result;
        };
        return NumberFormatterImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * An number formatter utility class.
     */
    var NumberFormatters = /** @class */ (function () {
        function NumberFormatters() {
        }
        /**
         * Creates a number formatter of the given format.
         * Please refer to {@link NumberFormatter} for format details.
         *
         * @return A created number formatter
         */
        NumberFormatters.create = function (format) {
            return new NumberFormatterImpl(format);
        };
        return NumberFormatters;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeChangeTextNumber = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeChangeTextNumber, _super);
        function EShapeActionRuntimeChangeTextNumber(value) {
            var _this = _super.call(this, value, EShapeRuntimeReset.TEXT) || this;
            _this.number = EShapeActionExpressions.ofNumber(value.value);
            _this.formatters = new Map();
            return _this;
        }
        EShapeActionRuntimeChangeTextNumber.prototype.getFormatter = function (shape, runtime) {
            var formatters = this.formatters;
            var text = runtime.text.value;
            var result = formatters.get(text);
            if (result === undefined) {
                result = this.newFormatter(text);
                formatters.set(text, result);
            }
            return result;
        };
        EShapeActionRuntimeChangeTextNumber.prototype.newFormatter = function (format) {
            format = format.trim();
            if (0 < format.length) {
                return NumberFormatters.create(format);
            }
            return null;
        };
        EShapeActionRuntimeChangeTextNumber.prototype.execute = function (shape, runtime, time) {
            if (this.condition(shape, time, EShapeActionEnvironment)) {
                var value = this.number(shape, time, EShapeActionEnvironment);
                var formatter = this.getFormatter(shape, runtime);
                shape.text.value = formatter != null ? formatter.format(value, 0) : String(value);
                runtime.written |= this.reset;
            }
        };
        return EShapeActionRuntimeChangeTextNumber;
    }(EShapeActionRuntimeConditional));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeChangeTextText = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeChangeTextText, _super);
        function EShapeActionRuntimeChangeTextText(value) {
            var _this = _super.call(this, value, EShapeRuntimeReset.TEXT) || this;
            _this.text = EShapeActionExpressions.ofString(value.value);
            return _this;
        }
        EShapeActionRuntimeChangeTextText.prototype.execute = function (shape, runtime, time) {
            if (this.condition(shape, time, EShapeActionEnvironment)) {
                shape.text.value = this.text(shape, time, EShapeActionEnvironment);
                runtime.written |= this.reset;
            }
        };
        return EShapeActionRuntimeChangeTextText;
    }(EShapeActionRuntimeConditional));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueChangeTextType = {
        TEXT: 0,
        NUMBER: 1
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueChangeText = /** @class */ (function (_super) {
        __extends(EShapeActionValueChangeText, _super);
        function EShapeActionValueChangeText(subtype, condition, value) {
            var _this = _super.call(this, EShapeActionValueType.CHANGE_TEXT, condition, subtype) || this;
            _this.value = value;
            return _this;
        }
        EShapeActionValueChangeText.prototype.isEquals = function (value) {
            return (_super.prototype.isEquals.call(this, value) &&
                value instanceof EShapeActionValueChangeText &&
                this.value === value.value);
        };
        EShapeActionValueChangeText.prototype.toRuntime = function () {
            switch (this.subtype) {
                case EShapeActionValueChangeTextType.TEXT:
                    return new EShapeActionRuntimeChangeTextText(this);
                case EShapeActionValueChangeTextType.NUMBER:
                    return new EShapeActionRuntimeChangeTextNumber(this);
            }
        };
        EShapeActionValueChangeText.prototype.serialize = function (manager) {
            var conditionId = manager.addResource(this.condition);
            var valueId = manager.addResource(this.value);
            return manager.addResource("[".concat(this.type, ",").concat(conditionId, ",").concat(this.subtype, ",").concat(valueId, "]"));
        };
        EShapeActionValueChangeText.deserialize = function (serialized, manager) {
            var condition = EShapeActionValues.toResource(1, serialized, manager.resources);
            var value = EShapeActionValues.toResource(3, serialized, manager.resources);
            return new EShapeActionValueChangeText(serialized[2], condition, value);
        };
        return EShapeActionValueChangeText;
    }(EShapeActionValueSubtyped));

    /**
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * {@link DDiagram} controller open type.
     */
    var DDiagramBaseControllerOpenType = {
        DIAGRAM: 0,
        PAGE: 1,
        EXTENSION: 1000
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeDataMapperImpl = /** @class */ (function () {
        function EShapeDataMapperImpl(source) {
            this._sources = this.newSources(source);
        }
        EShapeDataMapperImpl.prototype.map = function (value, destinations, initial) {
            var sources = this._sources;
            if (sources == null) {
                return false;
            }
            var valueId = value.id;
            var target = valueId.toLowerCase();
            var targetLength = target.length;
            if (targetLength !== valueId.length) {
                return false;
            }
            var first = sources[0];
            var firstLength = first.length;
            if (firstLength !== 0 && target.indexOf(first) !== 0) {
                return false;
            }
            var spans = EShapeDataMapperImpl.SPANS;
            spans[0] = 0;
            spans[1] = firstLength;
            var sourcesLength = sources.length;
            for (var i = 1; i < sourcesLength; ++i) {
                var ispan = i << 1;
                var source = sources[i];
                var sourceLength = source.length;
                if (sourceLength === 0) {
                    spans[ispan] = targetLength;
                    spans[ispan + 1] = targetLength;
                }
                else {
                    var index = target.indexOf(source, spans[ispan - 1]);
                    if (index < 0) {
                        return false;
                    }
                    spans[ispan] = index;
                    spans[ispan + 1] = index + sourceLength;
                }
            }
            // Update the ID
            if (destinations != null) {
                var destinationsLength = destinations.length;
                var id = "";
                for (var i = 0, imax = sourcesLength; i < imax; ++i) {
                    var id0 = i < destinationsLength ? destinations[i] : sources[i];
                    var ispan = i << 1;
                    var s0 = spans[ispan + 1];
                    var s1 = spans[ispan + 2];
                    var id1 = valueId.substring(s0, i + 1 < imax ? s1 : targetLength);
                    id += id0 + id1;
                }
                value.id = id;
            }
            // Update the initial value
            if (0 < initial.length) {
                value.initial = initial;
            }
            return true;
        };
        EShapeDataMapperImpl.prototype.newSources = function (source) {
            if (source == null) {
                return null;
            }
            var trimmed = source.trim();
            if (trimmed.length <= 0) {
                return null;
            }
            return trimmed.toLowerCase().split(EShapeDataMapperImpl.WILDCARD);
        };
        EShapeDataMapperImpl.split = function (target) {
            if (target == null) {
                return null;
            }
            var trimmed = target.trim();
            if (trimmed.length <= 0) {
                return null;
            }
            return trimmed.split(this.WILDCARD);
        };
        EShapeDataMapperImpl.WILDCARD = "*";
        EShapeDataMapperImpl.SPANS = [];
        return EShapeDataMapperImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeResourceManagerDeserialization = /** @class */ (function () {
        function EShapeResourceManagerDeserialization(serialized, pieces, pieceData, mode, depth) {
            this.resources = serialized.resources;
            this.data = serialized.data || serialized.tags || serialized.resources;
            this.pieces = pieces;
            this.pieceData = pieceData;
            this.mode = mode;
            this.depth = depth;
            this._actions = new Map();
            this._fills = new Map();
            this._strokes = new Map();
            this._data = new Map();
            this._dataValues = new Map();
            this._dataMapping = new Map();
            this._dataMappers = new Map();
            this._dataDestinations = new Map();
            this._dataSystem = new Map();
            this._ranges = new Map();
            this._aligns = new Map();
            this._margins = new Map();
            this._texts = new Map();
            this._textOutlines = new Map();
            this._capabilities = new Map();
            this._extensions = new Map();
        }
        EShapeResourceManagerDeserialization.prototype.getAction = function (id) {
            return this._actions.get(id);
        };
        EShapeResourceManagerDeserialization.prototype.setAction = function (id, action) {
            this._actions.set(id, action);
        };
        EShapeResourceManagerDeserialization.prototype.getFill = function (id) {
            return this._fills.get(id);
        };
        EShapeResourceManagerDeserialization.prototype.setFill = function (id, fill) {
            this._fills.set(id, fill);
        };
        EShapeResourceManagerDeserialization.prototype.getStroke = function (id) {
            return this._strokes.get(id);
        };
        EShapeResourceManagerDeserialization.prototype.setStroke = function (id, stroke) {
            this._strokes.set(id, stroke);
        };
        EShapeResourceManagerDeserialization.prototype.getData = function (id) {
            return this._data.get(id);
        };
        EShapeResourceManagerDeserialization.prototype.setData = function (id, data) {
            this._data.set(id, data);
        };
        EShapeResourceManagerDeserialization.prototype.getDataValue = function (id) {
            return this._dataValues.get(id);
        };
        EShapeResourceManagerDeserialization.prototype.setDataValue = function (id, dataValue) {
            this._dataValues.set(id, dataValue);
        };
        EShapeResourceManagerDeserialization.prototype.getDataMapping = function (id) {
            return this._dataMapping.get(id);
        };
        EShapeResourceManagerDeserialization.prototype.setDataMapping = function (id, dataMapping) {
            this._dataMapping.set(id, dataMapping);
        };
        EShapeResourceManagerDeserialization.prototype.getDataMapper = function (source) {
            var dataMappers = this._dataMappers;
            var result = dataMappers.get(source);
            if (result === undefined) {
                result = new EShapeDataMapperImpl(source);
                dataMappers.set(source, result);
            }
            return result;
        };
        EShapeResourceManagerDeserialization.prototype.getDataDestination = function (destination) {
            var dataDestinations = this._dataDestinations;
            var result = dataDestinations.get(destination);
            if (result === undefined) {
                result = EShapeDataMapperImpl.split(destination);
                dataDestinations.set(destination, result);
            }
            return result;
        };
        EShapeResourceManagerDeserialization.prototype.getDataSystem = function (id) {
            return this._dataSystem.get(id);
        };
        EShapeResourceManagerDeserialization.prototype.setDataSystem = function (id, dataSystem) {
            this._dataSystem.set(id, dataSystem);
        };
        EShapeResourceManagerDeserialization.prototype.getRange = function (id) {
            return this._ranges.get(id);
        };
        EShapeResourceManagerDeserialization.prototype.setRange = function (id, range) {
            this._ranges.set(id, range);
        };
        EShapeResourceManagerDeserialization.prototype.getAlign = function (id) {
            return this._aligns.get(id);
        };
        EShapeResourceManagerDeserialization.prototype.setAlign = function (id, align) {
            this._aligns.set(id, align);
        };
        EShapeResourceManagerDeserialization.prototype.getMargin = function (id) {
            return this._margins.get(id);
        };
        EShapeResourceManagerDeserialization.prototype.setMargin = function (id, margin) {
            this._margins.set(id, margin);
        };
        EShapeResourceManagerDeserialization.prototype.getText = function (id) {
            return this._texts.get(id);
        };
        EShapeResourceManagerDeserialization.prototype.setText = function (id, text) {
            this._texts.set(id, text);
        };
        EShapeResourceManagerDeserialization.prototype.getTextOutline = function (id) {
            return this._textOutlines.get(id);
        };
        EShapeResourceManagerDeserialization.prototype.setTextOutline = function (id, textOutline) {
            this._textOutlines.set(id, textOutline);
        };
        EShapeResourceManagerDeserialization.prototype.getCapability = function (id) {
            return this._capabilities.get(id);
        };
        EShapeResourceManagerDeserialization.prototype.setCapability = function (id, capability) {
            this._capabilities.set(id, capability);
        };
        EShapeResourceManagerDeserialization.prototype.getExtension = function (id) {
            return this._extensions.get(id);
        };
        EShapeResourceManagerDeserialization.prototype.setExtension = function (id, extension) {
            this._extensions.set(id, extension);
        };
        return EShapeResourceManagerDeserialization;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeResourceManagerDeserializationMode = {
        VIEWER: 0,
        EDITOR_DATA_MAPPED: 1,
        EDITOR: 2
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeAcceptorEdgeSide = {
        NONE: 0,
        TOP: 1,
        RIGHT: 2,
        BOTTOM: 4,
        LEFT: 8,
        ALL: 15
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeAcceptorEdgeType = {
        TAIL: 1,
        HEAD: 2,
        ALL: 3
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeCircle = /** @class */ (function (_super) {
        __extends(EShapeCircle, _super);
        function EShapeCircle(type) {
            if (type === void 0) { type = EShapeType.CIRCLE; }
            return _super.call(this, type) || this;
        }
        EShapeCircle.prototype.clone = function () {
            return new EShapeCircle(this.type).copy(this);
        };
        EShapeCircle.prototype.containsAbs = function (x, y, ax, ay, sw, ss, sa) {
            if (_super.prototype.containsAbsBBox.call(this, x, y, ax, ay)) {
                return hitTestCircle(this, x, y, ax, ay, sw, ss);
            }
            return false;
        };
        return EShapeCircle;
    }(EShapePrimitive));

    var EShapeEmbeddedAcceptorEdge = /** @class */ (function (_super) {
        __extends(EShapeEmbeddedAcceptorEdge, _super);
        function EShapeEmbeddedAcceptorEdge(type) {
            if (type === void 0) { type = EShapeType.EMBEDDED_ACCEPTOR_EDGE; }
            var _this = _super.call(this, type) || this;
            _this._subtype = EShapeAcceptorEdgeType.HEAD;
            _this._side = EShapeAcceptorEdgeSide.ALL;
            _this._vvisible = true;
            return _this;
        }
        Object.defineProperty(EShapeEmbeddedAcceptorEdge.prototype, "subtype", {
            get: function () {
                return this._subtype;
            },
            set: function (subtype) {
                this._subtype = subtype;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeEmbeddedAcceptorEdge.prototype, "side", {
            get: function () {
                return this._side;
            },
            set: function (side) {
                this._side = side;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeEmbeddedAcceptorEdge.prototype, "vvisible", {
            /**
             * True if visible in the viewer mode.
             */
            get: function () {
                return this._vvisible;
            },
            set: function (vvisible) {
                this._vvisible = vvisible;
            },
            enumerable: false,
            configurable: true
        });
        EShapeEmbeddedAcceptorEdge.prototype.clone = function () {
            return new EShapeEmbeddedAcceptorEdge(this.type).copy(this);
        };
        EShapeEmbeddedAcceptorEdge.prototype.copy = function (source, part) {
            if (part === void 0) { part = EShapeCopyPart.ALL; }
            _super.prototype.copy.call(this, source, part);
            if (source instanceof EShapeEmbeddedAcceptorEdge) {
                this._subtype = source.subtype;
                this._side = source.side;
                this._vvisible = source.vvisible;
            }
            return this;
        };
        EShapeEmbeddedAcceptorEdge.prototype.serialize = function (manager) {
            var result = _super.prototype.serialize.call(this, manager);
            result[15] = this._subtype | (this._side << 2) | (this._vvisible ? 1 << 6 : 0);
            return result;
        };
        return EShapeEmbeddedAcceptorEdge;
    }(EShapeCircle));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeCapabilities = /** @class */ (function () {
        function EShapeCapabilities() {
        }
        EShapeCapabilities.get = function (type) {
            var capability = this.mappings[type];
            if (capability != null) {
                return capability;
            }
            return EShapeCapability.PRIMITIVE;
        };
        EShapeCapabilities.contains = function (shape, target) {
            if (shape != null) {
                var capability = this.get(shape.type);
                var shapeCapability = shape.getCapability();
                if (shapeCapability != null) {
                    capability &= ~shapeCapability.removed;
                    capability |= shapeCapability.added;
                    capability &= ~shapeCapability.locked;
                }
                return (capability & target) === target;
            }
            return false;
        };
        EShapeCapabilities.set = function (type, capability) {
            this.mappings[type] = capability;
        };
        EShapeCapabilities.mappings = {};
        return EShapeCapabilities;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var toSizeNormalized = function (size) {
        var THRESHOLD = 0.001;
        if (Math.abs(size) < THRESHOLD) {
            return size < 0 ? -THRESHOLD : +THRESHOLD;
        }
        return size;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeGroupSizeLayout = /** @class */ (function () {
        function EShapeGroupSizeLayout(shape, bx, by) {
            this.shape = shape;
            // Base group size
            this.base = new pixi_js.Point(bx, by);
            // Base shape size
            var size = shape.size;
            this.shapeBase = new pixi_js.Point(size.x, size.y);
            // Transform
            this.transform = new pixi_js.Matrix();
            shape.updateTransform();
            shape.transform.localTransform.copyTo(this.transform);
            this.capable =
                EShapeCapabilities.contains(shape, EShapeCapability.POSITION) &&
                    EShapeCapabilities.contains(shape, EShapeCapability.WIDTH) &&
                    EShapeCapabilities.contains(shape, EShapeCapability.HEIGHT) &&
                    EShapeCapabilities.contains(shape, EShapeCapability.ROTATION) &&
                    EShapeCapabilities.contains(shape, EShapeCapability.SKEW);
        }
        EShapeGroupSizeLayout.prototype.isCompatible = function (shape) {
            return this.shape === shape;
        };
        EShapeGroupSizeLayout.prototype.reset = function (shape, baseX, baseY) {
            this.base.set(baseX, baseY);
            // Base shape size
            var size = shape.size;
            this.shapeBase.copyFrom(size);
            // Transform
            shape.updateTransform();
            shape.transform.localTransform.copyTo(this.transform);
        };
        EShapeGroupSizeLayout.prototype.update = function (shape, baseX, baseY, pivotX, pivotY) {
            if (!this.capable) {
                return;
            }
            var sx = baseX / this.base.x;
            var sy = baseY / this.base.y;
            var childBase = this.shapeBase;
            var transform = EShapeGroupSizeLayout.WORK_TRANSFORM;
            transform
                .identity()
                .append(this.transform)
                .translate(-pivotX, -pivotY)
                .scale(sx, sy)
                .translate(+pivotX, +pivotY);
            shape.lock(EShapeLockPart.TRANSFORM_AND_UPLOADED);
            this.apply(shape, transform, EShapeCapability.ALL, childBase);
            shape.unlock(EShapeLockPart.TRANSFORM_CHILD, false);
            shape.unlock(EShapeLockPart.TRANSFORM_THIS |
                EShapeLockPart.TRANSFORM_PARENT |
                EShapeLockPart.UPLOADED, true);
        };
        EShapeGroupSizeLayout.prototype.apply = function (shape, localTransform, capability, size) {
            // Reconstruct the position, the rotation and the size
            var a = localTransform.a;
            var b = localTransform.b;
            var c = localTransform.c;
            var d = localTransform.d;
            var tx = localTransform.tx;
            var ty = localTransform.ty;
            // Transform
            var transform = shape.transform;
            // Capability
            var cposition = !!(capability & EShapeCapability.POSITION);
            var crotation = !!(capability & EShapeCapability.ROTATION);
            var cskew = !!(capability & EShapeCapability.SKEW);
            var cwidth = !!(capability & EShapeCapability.WIDTH);
            var cheight = !!(capability & EShapeCapability.HEIGHT);
            // Rotation and skew
            if (crotation || cskew) {
                // Rotation
                var rx = Math.atan2(-c, d); // rotation - skewX
                var ry = Math.atan2(+b, a); // rotation + skewY
                if (crotation) {
                    transform.rotation = (rx + ry) * 0.5; // Here, assumes `skewX` === `skewY`
                }
                // Skew
                if (cskew) {
                    var skew = (ry - rx) * 0.5;
                    transform.skew.set(skew, skew);
                }
            }
            // Position
            if (cposition) {
                // Assumes the pivot is invariant.
                // tx = position.x - (a * px + c * py)
                // ty = position.y - (b * px + d * py)
                //
                // Thus,
                // position.x = tx + (a * px + c * py)
                // position.y = ty + (b * px + d * py)
                var pivot = transform.pivot;
                var px = pivot.x;
                var py = pivot.y;
                transform.position.set(tx + (a * px + c * py), ty + (b * px + d * py));
            }
            // Scale
            if (size != null && (cwidth || cheight)) {
                var w = toSizeNormalized(size.x * Math.sqrt(a * a + b * b));
                var h = toSizeNormalized(size.y * Math.sqrt(c * c + d * d));
                var s = shape.size;
                if (cwidth && cheight) {
                    s.set(w, h);
                }
                else if (cwidth) {
                    s.x = w;
                }
                else {
                    s.y = h;
                }
            }
        };
        EShapeGroupSizeLayout.WORK_TRANSFORM = new pixi_js.Matrix();
        return EShapeGroupSizeLayout;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeGroupSizeEditor = /** @class */ (function () {
        function EShapeGroupSizeEditor(parent, x, y, isFittable) {
            this._workRectForCalcRect = new pixi_js.Rectangle();
            this._workRectForFit = new pixi_js.Rectangle();
            this._parent = parent;
            this._layouts = [];
            this._size = new pixi_js.Point(x, y);
            this._isFittable = isFittable;
        }
        EShapeGroupSizeEditor.prototype.init = function () {
            return this;
        };
        Object.defineProperty(EShapeGroupSizeEditor.prototype, "x", {
            get: function () {
                return this._size.x;
            },
            set: function (x) {
                var size = this._size;
                if (size.x !== x) {
                    var ox = size.x;
                    size.x = x;
                    this.onChange(ox, size.y);
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupSizeEditor.prototype, "y", {
            get: function () {
                return this._size.y;
            },
            set: function (y) {
                var size = this._size;
                if (size.y !== y) {
                    var oy = size.y;
                    size.y = y;
                    this.onChange(size.x, oy);
                }
            },
            enumerable: false,
            configurable: true
        });
        EShapeGroupSizeEditor.prototype.set = function (x, y) {
            var isChanged = false;
            var size = this._size;
            var ox = size.x;
            var oy = size.y;
            if (x != null && ox !== x) {
                isChanged = true;
                size.x = x;
            }
            if (y != null && oy !== y) {
                isChanged = true;
                size.y = y;
            }
            if (isChanged) {
                this.onChange(ox, oy);
            }
            return this;
        };
        EShapeGroupSizeEditor.prototype.clone = function () {
            var size = this._size;
            return new EShapeGroupSizeEditor(this._parent, size.x, size.y, this._isFittable);
        };
        EShapeGroupSizeEditor.prototype.copy = function () {
            // DO NOTHING
        };
        EShapeGroupSizeEditor.prototype.copyFrom = function (point) {
            var x = point.x;
            var y = point.y;
            var size = this._size;
            var ox = size.x;
            var oy = size.y;
            if (ox !== x || oy !== y) {
                size.x = x;
                size.y = y;
                this.onChange(ox, oy);
            }
            return this;
        };
        EShapeGroupSizeEditor.prototype.copyTo = function (point) {
            return this._size.copyTo(point);
        };
        EShapeGroupSizeEditor.prototype.equals = function (point) {
            return this._size.equals(point);
        };
        EShapeGroupSizeEditor.prototype.fit = function () {
            if (this._isFittable) {
                this.doFit();
            }
            return this;
        };
        EShapeGroupSizeEditor.prototype.doFit = function () {
            var parent = this._parent;
            parent.lock(EShapeLockPart.TRANSFORM);
            // Calculate the rect
            var rect = this.calcRect(this._workRectForFit);
            // Set size
            var size = this._size;
            size.set(rect.width, rect.height);
            // Calculating new position & pivot
            //
            // cx := rect.x + rect.width * 0.5
            // cy := rect.y + rect.height * 0.5
            //
            // Since the local transform need to be unchanged:
            //
            // | a c tx |   | a c px' - (a * pvx' + c * pvy') |
            // | b d ty | = | b d py' - (b * pvx' + d * pvy') |
            // | 0 0 1  |   | 0 0 1                           |
            //
            // Here, (px', py') and (pvx', pvy') are the new position
            // and the new pivot, respectively.
            //
            // Setting the new pivot (pvx', pvy') to (cx, cy) leads to
            //
            // | a c tx |   | a c px' - (a * cx + c * cy) |
            // | b d ty | = | b d py' - (b * cx + d * cy) |
            // | 0 0 1  |   | 0 0 1                       |
            //
            // tx = px - (a * pvx + c * pvy) = px' - (a * cx + c * cy)
            // ty = py - (b * pvx + d * pvy) = py' - (b * cx + d * cy)
            //
            // Thus, the new position (px', py') is
            //
            // px' = px + (a * (cx - pvx) + c * (cy - pvy))
            // py' = py + (b * (cy - pvx) + d * (cy - pvy))
            parent.updateTransform();
            var transform = parent.transform;
            var cx = rect.x + rect.width * 0.5;
            var cy = rect.y + rect.height * 0.5;
            var position = transform.position;
            var localTransform = transform.localTransform;
            var a = localTransform.a;
            var b = localTransform.b;
            var c = localTransform.c;
            var d = localTransform.d;
            var pivot = transform.pivot;
            var pvx = pivot.x;
            var pvy = pivot.y;
            var dpvx = cx - pvx;
            var dpvy = cy - pvy;
            position.set(position.x + (a * dpvx + c * dpvy), position.y + (b * dpvx + d * dpvy));
            pivot.set(cx, cy);
            // Reset the data
            this.reset(parent.children, this._layouts, size);
            //
            parent.unlock(EShapeLockPart.TRANSFORM_CHILD | EShapeLockPart.TRANSFORM_THIS, true);
            parent.unlock(EShapeLockPart.TRANSFORM_PARENT, false);
        };
        EShapeGroupSizeEditor.prototype.reset = function (children, layouts, size) {
            for (var i = 0, imax = Math.min(layouts.length, children.length); i < imax; ++i) {
                var child = children[i];
                var layout = layouts[i];
                if (layout.isCompatible(child)) {
                    layout.reset(child, size.x, size.y);
                }
                else {
                    layouts.length = i;
                    break;
                }
            }
            if (children.length < layouts.length) {
                layouts.length = children.length;
            }
        };
        EShapeGroupSizeEditor.prototype.calcRect = function (result) {
            var parent = this._parent;
            var children = parent.children;
            if (children.length <= 0) {
                result.x = 0;
                result.y = 0;
                result.width = 0;
                result.height = 0;
            }
            else {
                var workRect = this._workRectForCalcRect;
                children[0].getBoundsLocal(false, result);
                for (var i = 1, imax = children.length; i < imax; ++i) {
                    var child = children[i];
                    child.getBoundsLocal(false, workRect);
                    result.enlarge(workRect);
                }
            }
            return result;
        };
        EShapeGroupSizeEditor.prototype.onChange = function (ox, oy) {
            var parent = this._parent;
            var size = this._size;
            var pivot = parent.transform.pivot;
            this.onChange_(parent.children, this._layouts, size.x, size.y, pivot.x, pivot.y, ox, oy);
            parent.onSizeChange();
        };
        EShapeGroupSizeEditor.prototype.onChange_ = function (children, layouts, sx, sy, px, py, ox, oy) {
            for (var i = 0, imax = Math.min(layouts.length, children.length); i < imax; ++i) {
                var child = children[i];
                var layout = layouts[i];
                if (layout.isCompatible(child)) {
                    layout.update(child, sx, sy, px, py);
                }
                else {
                    layouts.length = i;
                    break;
                }
            }
            for (var i = layouts.length, imax = children.length; i < imax; ++i) {
                var child = children[i];
                var layout = this.newLayout(child, ox, oy);
                layout.update(child, sx, sy, px, py);
                layouts.push(layout);
            }
            if (layouts.length !== children.length) {
                layouts.length = children.length;
            }
        };
        EShapeGroupSizeEditor.prototype.newLayout = function (shape, ox, oy) {
            return shape.layout || new EShapeGroupSizeLayout(shape, ox, oy);
        };
        return EShapeGroupSizeEditor;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeGroupSizeViewer = /** @class */ (function () {
        function EShapeGroupSizeViewer(parent, x, y, bx, by) {
            this._parent = parent;
            this._x = x;
            this._y = y;
            this._base = new pixi_js.Point(bx, by);
        }
        Object.defineProperty(EShapeGroupSizeViewer.prototype, "x", {
            get: function () {
                return this._x;
            },
            set: function (x) {
                if (this._x !== x) {
                    this._x = x;
                    this.onChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupSizeViewer.prototype, "y", {
            get: function () {
                return this._y;
            },
            set: function (y) {
                if (this._y !== y) {
                    this._y = y;
                    this.onChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupSizeViewer.prototype, "base", {
            get: function () {
                return this._base;
            },
            enumerable: false,
            configurable: true
        });
        EShapeGroupSizeViewer.prototype.init = function () {
            this._base.copyFrom(this);
            this.onChange();
            return this;
        };
        EShapeGroupSizeViewer.prototype.clone = function () {
            var base = this._base;
            return new EShapeGroupSizeViewer(this._parent, this._x, this._y, base.x, base.y);
        };
        EShapeGroupSizeViewer.prototype.set = function (x, y) {
            var isChanged = false;
            if (x != null && this._x !== x) {
                this._x = x;
                isChanged = true;
            }
            if (y != null && this._y !== y) {
                this._y = y;
                isChanged = true;
            }
            if (isChanged) {
                this.onChange();
            }
            return this;
        };
        EShapeGroupSizeViewer.prototype.copyFrom = function (p) {
            if (p instanceof EShapeGroupSizeViewer) {
                this._base.copyFrom(p.base);
            }
            if (this._x !== p.x || this._y !== p.y) {
                this._x = p.x;
                this._y = p.y;
                this.onChange();
            }
            return this;
        };
        EShapeGroupSizeViewer.prototype.copyTo = function (p) {
            if (p instanceof EShapeGroupSizeViewer) {
                this._base.copyTo(p.base);
            }
            p.set(this._x, this._y);
            return p;
        };
        EShapeGroupSizeViewer.prototype.equals = function (p) {
            return p.x === this._x && p.y === this._y;
        };
        EShapeGroupSizeViewer.prototype.fit = function () {
            return this;
        };
        EShapeGroupSizeViewer.prototype.onChange = function () {
            var base = this._base;
            this._parent.transform.scale.set(this._x / base.x, this._y / base.y);
        };
        return EShapeGroupSizeViewer;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeGroupFillViewer = /** @class */ (function () {
        function EShapeGroupFillViewer() {
            // DO NOTHING
        }
        Object.defineProperty(EShapeGroupFillViewer.prototype, "enable", {
            get: function () {
                return true;
            },
            set: function (enable) {
                // DO NOTHING
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupFillViewer.prototype, "color", {
            get: function () {
                return 0xffffff;
            },
            set: function (color) {
                // DO NOTHING
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupFillViewer.prototype, "alpha", {
            get: function () {
                return 1.0;
            },
            set: function (alpha) {
                // DO NOTHING
            },
            enumerable: false,
            configurable: true
        });
        EShapeGroupFillViewer.prototype.copy = function (target) {
            // DO NOTHING
        };
        EShapeGroupFillViewer.prototype.set = function (enable, color, alpha) {
            // DO NOTHING
        };
        EShapeGroupFillViewer.prototype.clone = function () {
            return new EShapeGroupFillViewer();
        };
        EShapeGroupFillViewer.prototype.toObject = function () {
            return {
                enable: true,
                color: 0xffffff,
                alpha: 1.0
            };
        };
        EShapeGroupFillViewer.prototype.serialize = function (manager) {
            return -1;
        };
        EShapeGroupFillViewer.prototype.deserialize = function (target, manager) {
            // DO NOTHING
        };
        return EShapeGroupFillViewer;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeGroupStrokeViewer = /** @class */ (function () {
        function EShapeGroupStrokeViewer() {
            // DO NOTHING
        }
        Object.defineProperty(EShapeGroupStrokeViewer.prototype, "enable", {
            get: function () {
                return false;
            },
            set: function (enable) {
                // DO NOTHING
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupStrokeViewer.prototype, "color", {
            get: function () {
                return 0xffffff;
            },
            set: function (color) {
                // DO NOTHING
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupStrokeViewer.prototype, "alpha", {
            get: function () {
                return 1.0;
            },
            set: function (alpha) {
                // DO NOTHING
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupStrokeViewer.prototype, "width", {
            get: function () {
                return 1.0;
            },
            set: function (width) {
                // DO NOTHING
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupStrokeViewer.prototype, "align", {
            get: function () {
                return 0.0;
            },
            set: function (width) {
                // DO NOTHING
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupStrokeViewer.prototype, "side", {
            get: function () {
                return EShapeStrokeSide.NONE;
            },
            set: function (side) {
                // DO NOTHING
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupStrokeViewer.prototype, "style", {
            get: function () {
                return EShapeStrokeStyle.NONE;
            },
            set: function (style) {
                // DO NOTHING
            },
            enumerable: false,
            configurable: true
        });
        EShapeGroupStrokeViewer.prototype.copy = function (target) {
            // DO NOTHING
        };
        EShapeGroupStrokeViewer.prototype.set = function (enable, color, alpha, width, align, side, style) {
            // DO NOTHING
        };
        EShapeGroupStrokeViewer.prototype.clone = function () {
            return new EShapeGroupStrokeViewer();
        };
        EShapeGroupStrokeViewer.prototype.toObject = function () {
            return {
                enable: false,
                color: 0xffffff,
                alpha: 1.0,
                width: 1.0,
                align: 0.0,
                side: EShapeStrokeSide.NONE,
                style: EShapeStrokeStyle.NONE
            };
        };
        EShapeGroupStrokeViewer.prototype.serialize = function (manager) {
            return -1;
        };
        EShapeGroupStrokeViewer.prototype.deserialize = function (target, manager) {
            //
        };
        return EShapeGroupStrokeViewer;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeGroupViewer = /** @class */ (function (_super) {
        __extends(EShapeGroupViewer, _super);
        function EShapeGroupViewer(mode, depth, type) {
            var _this = _super.call(this, type) || this;
            _this._mode = mode;
            _this._depth = depth;
            var data = _this.newData();
            _this.data = data;
            _this.tag = data;
            _this.size = _this.newGroupSize(mode, depth);
            _this.fill = _this.newGroupFill();
            _this.stroke = _this.newGroupStroke();
            _this.text = _this.newGroupText();
            return _this;
        }
        Object.defineProperty(EShapeGroupViewer.prototype, "mode", {
            get: function () {
                return this._mode;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupViewer.prototype, "depth", {
            get: function () {
                return this._depth;
            },
            enumerable: false,
            configurable: true
        });
        EShapeGroupViewer.prototype.newGroupSize = function (mode, depth) {
            var sizeX = EShapeDefaults.SIZE_X;
            var sizeY = EShapeDefaults.SIZE_Y;
            if (mode !== EShapeResourceManagerDeserializationMode.VIEWER) {
                return new EShapeGroupSizeEditor(this, sizeX, sizeY, this.isGroupSizeFittable());
            }
            else {
                return new EShapeGroupSizeViewer(this, sizeX, sizeY, sizeX, sizeY);
            }
        };
        EShapeGroupViewer.prototype.isGroupSizeFittable = function () {
            return true;
        };
        EShapeGroupViewer.prototype.newData = function () {
            return new EShapeDataImpl();
        };
        EShapeGroupViewer.prototype.newGroupFill = function () {
            return new EShapeGroupFillViewer();
        };
        EShapeGroupViewer.prototype.newGroupStroke = function () {
            return new EShapeGroupStrokeViewer();
        };
        EShapeGroupViewer.prototype.newGroupText = function () {
            return new EShapeTextImpl(this, EShapeDefaults.TEXT_VALUE, EShapeDefaults.TEXT_COLOR, EShapeDefaults.TEXT_ALPHA, EShapeDefaults.TEXT_FAMILY, EShapeDefaults.TEXT_SIZE);
        };
        EShapeGroupViewer.prototype.getBoundsSize = function () {
            var size = this.size;
            if (size instanceof EShapeGroupSizeViewer) {
                return size.base;
            }
            else {
                return size;
            }
        };
        EShapeGroupViewer.prototype.onChildTransformChange = function () {
            _super.prototype.onChildTransformChange.call(this);
            this.size.fit();
        };
        Object.defineProperty(EShapeGroupViewer.prototype, "corner", {
            get: function () {
                return EShapeCorner.NONE;
            },
            set: function (corner) {
                // DO NOTHING
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupViewer.prototype, "gradient", {
            get: function () {
                return undefined;
            },
            set: function (gradient) {
                // DO NOTHING
            },
            enumerable: false,
            configurable: true
        });
        EShapeGroupViewer.prototype.serializeGradient = function (manager) {
            return -1;
        };
        Object.defineProperty(EShapeGroupViewer.prototype, "radius", {
            get: function () {
                return 0;
            },
            set: function (radius) {
                // DO NOTHING
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupViewer.prototype, "image", {
            get: function () {
                return undefined;
            },
            set: function (image) {
                // DO NOTHING
            },
            enumerable: false,
            configurable: true
        });
        EShapeGroupViewer.prototype.serializeImage = function (manager) {
            return -1;
        };
        Object.defineProperty(EShapeGroupViewer.prototype, "points", {
            get: function () {
                return undefined;
            },
            set: function (points) {
                // DO NOTHING
            },
            enumerable: false,
            configurable: true
        });
        EShapeGroupViewer.prototype.containsAbs = function (x, y, ax, ay, sw, ss, sa) {
            return false;
        };
        return EShapeGroupViewer;
    }(EShapeBase));

    var EShapeEmbedded = /** @class */ (function (_super) {
        __extends(EShapeEmbedded, _super);
        function EShapeEmbedded(name, mode, depth, type) {
            if (type === void 0) { type = EShapeType.EMBEDDED; }
            var _this = _super.call(this, mode, depth, type) || this;
            _this._name = name;
            _this._depth = depth;
            return _this;
        }
        Object.defineProperty(EShapeEmbedded.prototype, "name", {
            get: function () {
                return this._name;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeEmbedded.prototype, "edges", {
            get: function () {
                var _a;
                return ((_a = this._edges) !== null && _a !== void 0 ? _a : (this._edges = this.newEdges()));
            },
            enumerable: false,
            configurable: true
        });
        EShapeEmbedded.prototype.newEdges = function () {
            var result = new Map();
            var layers = this.children;
            if (layers != null) {
                var s = this.size;
                var sx = s.x;
                var sy = s.y;
                var sxh = sx * 0.5;
                var syh = sy * 0.5;
                for (var i = 0, imax = layers.length; i < imax; ++i) {
                    var layer = layers[i];
                    var lp = layer.transform.position;
                    var lpx = lp.x + sxh;
                    var lpy = lp.y + syh;
                    var children = layer.children;
                    for (var j = 0, jmax = children.length; j < jmax; ++j) {
                        var child = children[j];
                        if (child instanceof EShapeEmbeddedAcceptorEdge) {
                            child.transform.updateLocalTransform();
                            var clt = child.transform.localTransform;
                            result.set(child.id, {
                                type: child.subtype,
                                x: this.toEdgePosition(lpx, clt.tx, sxh, sx),
                                y: this.toEdgePosition(lpy, clt.ty, syh, sy),
                                normal: this.toEdgeNormal(-clt.c, -clt.d),
                                size: {
                                    x: 0,
                                    y: 0
                                },
                                side: child.side
                            });
                        }
                    }
                }
            }
            return result;
        };
        EShapeEmbedded.prototype.toEdgePosition = function (lp, cp, sh, s) {
            if (0.00001 < Math.abs(s)) {
                return (lp + cp - sh) / s;
            }
            return 0;
        };
        EShapeEmbedded.prototype.toEdgeNormal = function (x, y) {
            var d = x * x + y * y;
            if (0.00001 < d) {
                var f = 1 / d;
                return {
                    x: x * f,
                    y: y * f
                };
            }
            return {
                x: 0,
                y: -1
            };
        };
        EShapeEmbedded.prototype.isGroupSizeFittable = function () {
            return false;
        };
        EShapeEmbedded.prototype.newGroupSize = function (mode, depth) {
            var sizeX = EShapeDefaults.SIZE_X;
            var sizeY = EShapeDefaults.SIZE_Y;
            if (mode !== EShapeResourceManagerDeserializationMode.VIEWER && depth <= 0) {
                return new EShapeGroupSizeEditor(this, sizeX, sizeY, this.isGroupSizeFittable());
            }
            else {
                return new EShapeGroupSizeViewer(this, sizeX, sizeY, sizeX, sizeY);
            }
        };
        EShapeEmbedded.prototype.clone = function () {
            var result = this.newClone().copy(this);
            var children = this.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                var clone = children[i].clone();
                clone.parent = result;
                result.children.push(clone);
            }
            result.onChildTransformChange();
            result.toDirty();
            return result;
        };
        EShapeEmbedded.prototype.newClone = function () {
            var constructor = this.constructor;
            return new constructor(this._name, this._mode, this._depth, this.type);
        };
        EShapeEmbedded.prototype.serializeChildren = function (manager) {
            return [];
        };
        EShapeEmbedded.prototype.serializeImage = function (manager) {
            return -1;
        };
        EShapeEmbedded.prototype.serializeGradient = function (manager) {
            return -1;
        };
        EShapeEmbedded.prototype.serialize = function (manager) {
            var result = _super.prototype.serialize.call(this, manager);
            result[15] = manager.addPiece(this._name);
            return result;
        };
        EShapeEmbedded.prototype.addUuid = function (manager) {
            this.uuid = manager.addUuid(this.uuid);
        };
        EShapeEmbedded.prototype.updateUuid = function (manager) {
            this.uuid = manager.updateUuid(this.uuid);
        };
        return EShapeEmbedded;
    }(EShapeGroupViewer));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeUuidMappingImpl = /** @class */ (function () {
        function EShapeUuidMappingImpl(shapes) {
            this._shapes = shapes;
        }
        EShapeUuidMappingImpl.prototype.find = function (uuid) {
            return this.getUuidToShape().get(uuid);
        };
        EShapeUuidMappingImpl.prototype.getUuidToShape = function () {
            var result = this._uuidToShape;
            if (result == null) {
                result = this.newUuidToShape();
                this._uuidToShape = result;
            }
            return result;
        };
        EShapeUuidMappingImpl.prototype.newUuidToShape = function () {
            var result = new Map();
            this.fillUuidToShape(this._shapes, result);
            return result;
        };
        EShapeUuidMappingImpl.prototype.fillUuidToShape = function (shapes, result) {
            for (var i = 0, imax = shapes.length; i < imax; ++i) {
                var shape = shapes[i];
                result.set(shape.uuid, shape);
                if (!(shape instanceof EShapeEmbedded)) {
                    var children = shape.children;
                    if (0 < children.length) {
                        this.fillUuidToShape(children, result);
                    }
                }
            }
        };
        return EShapeUuidMappingImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var deserialize = function (item, manager) {
        var deserializer = EShapeDeserializers[item[0]] || EShapeDeserializers[EShapeType.NULL];
        if (deserializer != null) {
            var result = deserializer(item, manager);
            if (result != null) {
                return result;
            }
        }
        throw new Error("Missing shape deserializers");
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var deserializeAll = function (serializeds, manager) {
        var shapes = [];
        for (var i = 0, imax = serializeds.length; i < imax; ++i) {
            shapes.push(deserialize(serializeds[i], manager));
        }
        if (0 < shapes.length) {
            return Promise.all(shapes).then(function (resolved) {
                callOnDeserialized(serializeds, resolved, new EShapeUuidMappingImpl(resolved), manager);
                return resolved;
            });
        }
        return null;
    };
    var callOnDeserialized = function (serializeds, shapes, mapping, manager) {
        for (var i = 0, imax = serializeds.length; i < imax; ++i) {
            var serialized = serializeds[i];
            var shape = shapes[i];
            var onDeserialized = EShapeOnDeserializeds[serialized[0]];
            if (onDeserialized) {
                onDeserialized(serialized, shape, mapping, manager);
            }
            callOnDeserialized(serialized[20], shape.children, mapping, manager);
        }
    };

    var EShapeEmbeddedDatum = /** @class */ (function () {
        function EShapeEmbeddedDatum(name, width, height, layer) {
            this.name = name;
            this.width = width;
            this.height = height;
            this.layer = layer;
        }
        return EShapeEmbeddedDatum;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var toEnum = function (target, te) {
        return isString(target) ? te[target] : target;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeAcceptorImpl = /** @class */ (function () {
        function EShapeAcceptorImpl() {
            this._edges = new Map();
        }
        EShapeAcceptorImpl.prototype.add = function (id, type, x, y, nx, ny, sx, sy, side) {
            this._edges.set(id, {
                type: toEnum(type, EShapeAcceptorEdgeType),
                x: x,
                y: y,
                normal: this.toNormal(x, y, nx, ny),
                size: {
                    x: sx !== null && sx !== void 0 ? sx : 0,
                    y: sy !== null && sy !== void 0 ? sy : 0
                },
                side: this.toSide(side)
            });
            return true;
        };
        EShapeAcceptorImpl.prototype.toNormal = function (x, y, nx, ny) {
            if (nx != null && ny != null) {
                return {
                    x: nx,
                    y: ny
                };
            }
            else {
                var d = x * x + y * y;
                if (0.00001 < d) {
                    var m = 1 / Math.sqrt(d);
                    return {
                        x: x * m,
                        y: y * m
                    };
                }
                else {
                    return {
                        x: 0,
                        y: 0
                    };
                }
            }
        };
        EShapeAcceptorImpl.prototype.toSide = function (side) {
            if (side == null) {
                return EShapeAcceptorEdgeSide.TOP;
            }
            else if (isNumber(side)) {
                return side;
            }
            else if (isString(side)) {
                return toEnum(side, EShapeAcceptorEdgeSide);
            }
            else {
                var result = EShapeAcceptorEdgeSide.NONE;
                for (var i = 0, imax = side.length; i < imax; ++i) {
                    result |= toEnum(side[i], EShapeAcceptorEdgeSide);
                }
                return result;
            }
        };
        EShapeAcceptorImpl.prototype.remove = function (id) {
            var edges = this._edges;
            var result = edges.get(id);
            if (result != null) {
                edges.delete(id);
                return result;
            }
            return null;
        };
        EShapeAcceptorImpl.prototype.size = function () {
            return this._edges.size;
        };
        EShapeAcceptorImpl.prototype.get = function (shape, id) {
            return this._edges.get(id) || null;
        };
        EShapeAcceptorImpl.prototype.each = function (shape, iteratee) {
            this._edges.forEach(iteratee);
            return this;
        };
        EShapeAcceptorImpl.prototype.contains = function (id) {
            return this._edges.has(id);
        };
        EShapeAcceptorImpl.prototype.clear = function () {
            var edges = this._edges;
            if (0 < edges.size) {
                edges.clear();
                return true;
            }
            return false;
        };
        return EShapeAcceptorImpl;
    }());

    var EShapeEmbeddedAcceptor = /** @class */ (function (_super) {
        __extends(EShapeEmbeddedAcceptor, _super);
        function EShapeEmbeddedAcceptor() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        EShapeEmbeddedAcceptor.prototype.get = function (shape, id) {
            var edges = this.getEdges(shape);
            if (edges != null) {
                var edge = edges.get(id);
                if (edge != null) {
                    return edge;
                }
            }
            return _super.prototype.get.call(this, shape, id);
        };
        EShapeEmbeddedAcceptor.prototype.each = function (shape, iteratee) {
            var edges = this.getEdges(shape);
            if (edges != null) {
                edges.forEach(function (edge, id) {
                    iteratee(edge, id);
                });
            }
            return _super.prototype.each.call(this, shape, iteratee);
        };
        EShapeEmbeddedAcceptor.prototype.getEdges = function (shape) {
            if (shape instanceof EShapeEmbedded) {
                return shape.edges;
            }
            return null;
        };
        return EShapeEmbeddedAcceptor;
    }(EShapeAcceptorImpl));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeAcceptors = /** @class */ (function () {
        function EShapeAcceptors() {
        }
        EShapeAcceptors.set = function (type, acceptor) {
            var acceptors = this._acceptors;
            if (acceptors == null) {
                acceptors = new Map();
                this._acceptors = acceptors;
            }
            acceptors.set(type, acceptor);
        };
        EShapeAcceptors.get = function (type) {
            var _a;
            var acceptors = this._acceptors;
            if (acceptors != null) {
                var acceptor = acceptors.get(type);
                if (acceptor != null) {
                    return acceptor;
                }
            }
            var defaults = ((_a = this._defaults) !== null && _a !== void 0 ? _a : (this._defaults = new Map()));
            switch (type) {
                case EShapeType.EMBEDDED:
                    var embedded = defaults.get(type);
                    if (embedded == null) {
                        embedded = this.newDefaultEmbedded();
                        defaults.set(type, embedded);
                    }
                    return embedded;
                case EShapeType.EMBEDDED_ACCEPTOR_EDGE:
                    var edge = defaults.get(type);
                    if (edge == null) {
                        edge = this.newDefaultEmbeddedAcceptorEdge();
                        defaults.set(type, edge);
                    }
                    return edge;
                default:
                    var other = defaults.get(null);
                    if (other == null) {
                        other = this.newDefaultOther();
                        defaults.set(null, other);
                    }
                    return other;
            }
        };
        EShapeAcceptors.newDefaultEmbedded = function () {
            return this.initDefault(new EShapeEmbeddedAcceptor());
        };
        EShapeAcceptors.newDefaultEmbeddedAcceptorEdge = function () {
            var result = new EShapeAcceptorImpl();
            result.add("CENTER", EShapeAcceptorEdgeType.ALL, 0, 0, 0, 0);
            return result;
        };
        EShapeAcceptors.newDefaultOther = function () {
            return this.initDefault(new EShapeAcceptorImpl());
        };
        EShapeAcceptors.initDefault = function (result) {
            var s = 1 / Math.sqrt(2);
            result.add("TOP", EShapeAcceptorEdgeType.ALL, 0, -0.5, 0, -1);
            result.add("LEFT", EShapeAcceptorEdgeType.ALL, -0.5, 0, -1, 0);
            result.add("RIGHT", EShapeAcceptorEdgeType.ALL, 0.5, 0, 1, 0);
            result.add("BOTTOM", EShapeAcceptorEdgeType.ALL, 0, 0.5, 0, 1);
            result.add("CENTER", EShapeAcceptorEdgeType.ALL, 0, 0, 0, 0);
            result.add("TOP_LEFT", EShapeAcceptorEdgeType.ALL, -0.5, -0.5, -s, -s);
            result.add("TOP_RIGHT", EShapeAcceptorEdgeType.ALL, 0.5, -0.5, s, -s);
            result.add("BOTTOM_LEFT", EShapeAcceptorEdgeType.ALL, -0.5, 0.5, -s, s);
            result.add("BOTTOM_RIGHT", EShapeAcceptorEdgeType.ALL, 0.5, 0.5, s, s);
            return result;
        };
        return EShapeAcceptors;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeConnectorEdgeAcceptorImpl = /** @class */ (function () {
        function EShapeConnectorEdgeAcceptorImpl(parent) {
            this._parent = parent;
            this._shape = null;
            this._edge = null;
            this._x = null;
            this._y = null;
        }
        Object.defineProperty(EShapeConnectorEdgeAcceptorImpl.prototype, "shape", {
            get: function () {
                return this._shape;
            },
            set: function (shape) {
                this.set(shape);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeConnectorEdgeAcceptorImpl.prototype, "edge", {
            get: function () {
                return this._edge;
            },
            set: function (edge) {
                this.set(undefined, edge);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeConnectorEdgeAcceptorImpl.prototype, "x", {
            get: function () {
                return this._x;
            },
            set: function (x) {
                this.set(undefined, undefined, x);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeConnectorEdgeAcceptorImpl.prototype, "y", {
            get: function () {
                return this._y;
            },
            set: function (y) {
                this.set(undefined, undefined, undefined, y);
            },
            enumerable: false,
            configurable: true
        });
        EShapeConnectorEdgeAcceptorImpl.prototype.copy = function (source) {
            return this.set(source.shape, source.edge, source.x, source.y);
        };
        EShapeConnectorEdgeAcceptorImpl.prototype.set = function (shape, edge, x, y) {
            var isChanged = false;
            if (shape !== undefined && this._shape !== shape) {
                this._shape = shape;
                isChanged = true;
            }
            if (edge !== undefined && this._edge !== edge) {
                this._edge = edge;
                isChanged = true;
            }
            if (x !== undefined && this._x !== x) {
                this._x = x;
                isChanged = true;
            }
            if (y !== undefined && this._y !== y) {
                this._y = y;
                isChanged = true;
            }
            if (isChanged) {
                this._parent.onAcceptorChange();
            }
            return this;
        };
        return EShapeConnectorEdgeAcceptorImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeConnectorEdgeImpl = /** @class */ (function () {
        function EShapeConnectorEdgeImpl(parent, onChange) {
            var _this = this;
            this._parent = parent;
            this._onChange = onChange;
            this._acceptor = new EShapeConnectorEdgeAcceptorImpl(this);
            this._acceptorTransformNew = new pixi_js.Matrix();
            this._acceptorTransformOld = new pixi_js.Matrix();
            this._hasAcceptorTransformOld = false;
            this._local = new pixi_js.ObservablePoint(function () {
                _this.onLocalChange();
            }, undefined);
            this._localIdRequired = 0;
            this._localId = 0;
            this._normal = new pixi_js.ObservablePoint(function () {
                _this.onNormalChange();
            }, undefined);
            this._normalIdRequired = 0;
            this._normalId = 0;
            this._side = EShapeAcceptorEdgeSide.TOP;
            this._margin = 0;
            this._other = null;
            this._lockCount = 0;
            this._isAcceptorChanged = false;
            this._isLocalChanged = false;
            this._isNormalChanged = false;
            this._isOtherChanged = false;
        }
        EShapeConnectorEdgeImpl.prototype.lock = function () {
            this._lockCount += 1;
            if (this._lockCount === 1) {
                this._isAcceptorChanged = false;
                this._isLocalChanged = false;
                this._isNormalChanged = false;
                this._isOtherChanged = false;
            }
        };
        EShapeConnectorEdgeImpl.prototype.unlock = function () {
            this._lockCount -= 1;
            if (this._lockCount === 0) {
                var isChanged = false;
                if (this._isLocalChanged) {
                    this._localIdRequired += 1;
                    this._localId = this._localIdRequired;
                    isChanged = true;
                }
                if (this._isNormalChanged) {
                    this._normalIdRequired += 1;
                    this._normalId = this._normalIdRequired;
                    isChanged = true;
                }
                if (this._isOtherChanged) {
                    isChanged = true;
                }
                if (this._isAcceptorChanged) {
                    this._hasAcceptorTransformOld = false;
                    if (!this._isLocalChanged) {
                        this._localIdRequired += 1;
                    }
                    if (!this._isNormalChanged) {
                        this._normalIdRequired += 1;
                    }
                    if (this.doFit()) {
                        isChanged = false;
                    }
                }
                if (isChanged) {
                    this._onChange();
                }
            }
        };
        Object.defineProperty(EShapeConnectorEdgeImpl.prototype, "parent", {
            get: function () {
                return this._parent;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeConnectorEdgeImpl.prototype, "acceptor", {
            get: function () {
                return this._acceptor;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeConnectorEdgeImpl.prototype, "local", {
            get: function () {
                return this._local;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeConnectorEdgeImpl.prototype, "localId", {
            get: function () {
                return this._localId;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeConnectorEdgeImpl.prototype, "normal", {
            get: function () {
                return this._normal;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeConnectorEdgeImpl.prototype, "normalId", {
            get: function () {
                return this._normalId;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeConnectorEdgeImpl.prototype, "side", {
            get: function () {
                return this._side;
            },
            set: function (side) {
                if (this._side !== side) {
                    this._side = side;
                    this.onOtherChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeConnectorEdgeImpl.prototype, "margin", {
            get: function () {
                return this._margin;
            },
            set: function (margin) {
                if (this._margin !== margin) {
                    this._margin = margin;
                    this.onOtherChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeConnectorEdgeImpl.prototype, "other", {
            get: function () {
                return this._other;
            },
            set: function (other) {
                this._other = other;
            },
            enumerable: false,
            configurable: true
        });
        EShapeConnectorEdgeImpl.prototype.set = function (acceptorShape, acceptorEdge, acceptorX, acceptorY, margin, x, y, nx, ny, side) {
            this.lock();
            this._acceptor.set(acceptorShape, acceptorEdge, acceptorX, acceptorY);
            var local = this._local;
            if (x != null && y != null) {
                local.set(x, y);
            }
            else if (x != null) {
                local.x = x;
            }
            else if (y != null) {
                local.y = y;
            }
            var normal = this._normal;
            if (nx != null && ny != null) {
                normal.set(nx, ny);
            }
            else if (nx != null) {
                normal.x = nx;
            }
            else if (ny != null) {
                normal.y = ny;
            }
            if (side != null) {
                this.side = side;
            }
            if (margin != null) {
                this.margin = margin;
            }
            this.unlock();
            return this;
        };
        EShapeConnectorEdgeImpl.prototype.copy = function (source) {
            this.lock();
            this._acceptor.copy(source.acceptor);
            this._local.copyFrom(source.local);
            this._normal.copyFrom(source.normal);
            this.side = source.side;
            this.margin = source.margin;
            this.unlock();
            return this;
        };
        EShapeConnectorEdgeImpl.prototype.serialize = function (manager) {
            var acceptor = this._acceptor;
            var shape = acceptor.shape;
            var shapeUuid = shape ? shape.uuid : null;
            var edge = acceptor.edge;
            var edgeId = edge != null ? manager.addResource(edge) : -1;
            var local = this._local;
            var normal = this._normal;
            var side = this._side;
            return manager.addResource("[".concat(shapeUuid, ",").concat(edgeId, ",").concat(local.x, ",").concat(local.y, ",").concat(this._margin, ",").concat(normal.x, ",").concat(normal.y, ",").concat(acceptor.x, ",").concat(acceptor.y, ",").concat(side, "]"));
        };
        EShapeConnectorEdgeImpl.prototype.deserialize = function (resourceId, mapping, manager) {
            var _a, _b, _c;
            var resources = manager.resources;
            if (0 <= resourceId && resourceId < resources.length) {
                var parsed = manager.getExtension(resourceId);
                if (parsed == null) {
                    parsed = JSON.parse(resources[resourceId]);
                    manager.setExtension(resourceId, parsed);
                }
                var shape = null;
                var shapeUuid = parsed[0];
                if (shapeUuid != null) {
                    shape = mapping.find(shapeUuid) || null;
                }
                this.lock();
                var acceptor = this._acceptor;
                acceptor.shape = shape;
                var edgeId = parsed[1];
                acceptor.edge = 0 <= edgeId && edgeId < resources.length ? resources[edgeId] : null;
                acceptor.x = (_a = parsed[7]) !== null && _a !== void 0 ? _a : null;
                acceptor.y = (_b = parsed[8]) !== null && _b !== void 0 ? _b : null;
                this._local.set(parsed[2], parsed[3]);
                var normalX = parsed[5];
                var normalY = parsed[6];
                var normal = this._normal;
                if (normalX != null && normalY != null) {
                    normal.set(normalX, normalY);
                }
                else {
                    normal.set(1, 0);
                }
                this.side = (_c = parsed[9]) !== null && _c !== void 0 ? _c : EShapeAcceptorEdgeSide.TOP;
                this.margin = parsed[4] || 0;
                this.unlock();
                if (shape) {
                    shape.connector.add(this);
                }
            }
        };
        EShapeConnectorEdgeImpl.prototype.fit = function (forcibly) {
            if (forcibly) {
                this._localIdRequired += 1;
                this._normalIdRequired += 1;
            }
            this.doFit();
            return this;
        };
        EShapeConnectorEdgeImpl.prototype.doFit = function () {
            var _a, _b, _c;
            var localIdRequired = this._localIdRequired;
            var isLocalDirty = this._localId !== localIdRequired;
            var normalIdRequired = this._normalIdRequired;
            var isNormalDirty = this._normalId !== normalIdRequired;
            if (isLocalDirty || isNormalDirty) {
                this._localId = localIdRequired;
                this._normalId = normalIdRequired;
                var acceptor = this._acceptor;
                var acceptorShape = acceptor.shape;
                var acceptorEdge = acceptor.edge;
                if (acceptorShape != null && acceptorEdge != null) {
                    var edge = EShapeAcceptors.get(acceptorShape.type).get(acceptorShape, acceptorEdge);
                    if (edge) {
                        var oat = this._acceptorTransformOld;
                        var nat = this._acceptorTransformNew;
                        this.toAcceptorTransform(acceptorShape, nat);
                        var other = this._other;
                        var isOtherDangling = this._hasAcceptorTransformOld &&
                            other != null &&
                            other.acceptor.shape == null;
                        var work = ((_a = EShapeConnectorEdgeImpl.WORK_MATRIX) !== null && _a !== void 0 ? _a : (EShapeConnectorEdgeImpl.WORK_MATRIX = new pixi_js.Matrix()));
                        if (isOtherDangling) {
                            oat.copyTo(work).invert().prepend(nat);
                        }
                        this._acceptorTransformNew = oat;
                        this._acceptorTransformOld = nat;
                        this._hasAcceptorTransformOld = true;
                        this.lock();
                        if (isLocalDirty) {
                            var l = this._local;
                            var olx = l.x;
                            var oly = l.y;
                            var size = acceptorShape.size;
                            var pivot = acceptorShape.transform.pivot;
                            var x = pivot.x + size.x * ((_b = acceptor.x) !== null && _b !== void 0 ? _b : edge.x);
                            var y = pivot.y + size.y * ((_c = acceptor.y) !== null && _c !== void 0 ? _c : edge.y);
                            var nlx = nat.a * x + nat.c * y + nat.tx;
                            var nly = nat.b * x + nat.d * y + nat.ty;
                            l.set(nlx, nly);
                            if (isOtherDangling) {
                                var ol = other.local;
                                var oolx = ol.x;
                                var ooly = ol.y;
                                var nolx = work.a * oolx + work.c * ooly + work.tx;
                                var noly = work.b * oolx + work.d * ooly + work.ty;
                                var odx = oolx - olx;
                                var ody = ooly - oly;
                                var ndx = nolx - nlx;
                                var ndy = noly - nly;
                                var od = odx * odx + ody * ody;
                                var nd = ndx * ndx + ndy * ndy;
                                if (0.000001 < nd) {
                                    var f = Math.sqrt(od / nd);
                                    ol.set(nlx + ndx * f, nly + ndy * f);
                                }
                                else {
                                    ol.set(nolx, noly);
                                }
                            }
                        }
                        if (isNormalDirty) {
                            var en = edge.normal;
                            var enx = en.x;
                            var eny = en.y;
                            var nx = nat.a * enx + nat.c * eny;
                            var ny = nat.b * enx + nat.d * eny;
                            var sd = nx * nx + ny * ny;
                            var n = this._normal;
                            if (0.000001 < sd) {
                                var f = 1 / Math.sqrt(sd);
                                n.set(nx * f, ny * f);
                            }
                            else {
                                n.set(enx, eny);
                            }
                            if (isOtherDangling) {
                                var on = other.normal;
                                var oonx = on.x;
                                var oony = on.y;
                                var nonx = work.a * oonx + work.c * oony;
                                var nony = work.b * oonx + work.d * oony;
                                var osd = nonx * nonx + nony * nony;
                                if (0.000001 < osd) {
                                    var f = 1 / Math.sqrt(osd);
                                    on.set(nonx * f, nony * f);
                                }
                                else {
                                    on.set(oonx, oony);
                                }
                            }
                        }
                        var result = this._isLocalChanged || this._isNormalChanged;
                        this.unlock();
                        return result;
                    }
                }
            }
            return false;
        };
        EShapeConnectorEdgeImpl.prototype.toAcceptorTransform = function (shape, result) {
            shape.updateTransform();
            var parent = this._parent;
            var parentParent = parent.parent;
            if (parentParent instanceof EShapeBase) {
                parent.updateTransform();
                return result
                    .copyFrom(parentParent.transform.internalTransform)
                    .invert()
                    .append(shape.transform.internalTransform);
            }
            else {
                return result.copyFrom(shape.transform.internalTransform);
            }
        };
        EShapeConnectorEdgeImpl.prototype.onAcceptorChange = function () {
            if (0 < this._lockCount) {
                this._isLocalChanged = false;
                this._isNormalChanged = false;
                this._isAcceptorChanged = true;
                return;
            }
            this._hasAcceptorTransformOld = false;
            this.fit(true);
        };
        EShapeConnectorEdgeImpl.prototype.onLocalChange = function () {
            if (0 < this._lockCount) {
                this._isLocalChanged = true;
                return;
            }
            this._localIdRequired += 1;
            this._localId = this._localIdRequired;
            this._onChange();
        };
        EShapeConnectorEdgeImpl.prototype.onNormalChange = function () {
            if (0 < this._lockCount) {
                this._isNormalChanged = true;
                return;
            }
            this._normalIdRequired += 1;
            this._normalId = this._normalIdRequired;
            this._onChange();
        };
        EShapeConnectorEdgeImpl.prototype.onOtherChange = function () {
            if (0 < this._lockCount) {
                this._isOtherChanged = true;
                return;
            }
            this._onChange();
        };
        EShapeConnectorEdgeImpl.prototype.attach = function () {
            var shape = this._acceptor.shape;
            if (shape) {
                if (shape.connector.add(this)) {
                    this.onAcceptorChange();
                }
            }
            return this;
        };
        EShapeConnectorEdgeImpl.prototype.detach = function (exceptions) {
            var shape = this._acceptor.shape;
            if (shape != null && (exceptions == null || !exceptions.has(shape))) {
                if (shape.connector.remove(this)) {
                    this.onAcceptorChange();
                }
            }
            return this;
        };
        return EShapeConnectorEdgeImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeConnectorEdgeContainerImpl = /** @class */ (function () {
        function EShapeConnectorEdgeContainerImpl(parent, onChange) {
            var _this = this;
            this._parent = parent;
            this._lockCount = 0;
            this._isChanged = false;
            this._onChange = onChange;
            var onChangeBound = function () {
                _this.onChange();
            };
            var tail = new EShapeConnectorEdgeImpl(parent, onChangeBound);
            var head = new EShapeConnectorEdgeImpl(parent, onChangeBound);
            tail.other = head;
            head.other = tail;
            this._tail = tail;
            this._head = head;
        }
        EShapeConnectorEdgeContainerImpl.prototype.lock = function () {
            this._lockCount += 1;
            if (this._lockCount === 1) {
                this._isChanged = false;
            }
            return this;
        };
        EShapeConnectorEdgeContainerImpl.prototype.unlock = function () {
            this._lockCount -= 1;
            if (this._lockCount === 0) {
                if (this._isChanged) {
                    this._onChange();
                }
            }
            return this;
        };
        EShapeConnectorEdgeContainerImpl.prototype.onChange = function () {
            if (0 < this._lockCount) {
                this._isChanged = true;
                return;
            }
            this._onChange();
        };
        Object.defineProperty(EShapeConnectorEdgeContainerImpl.prototype, "tail", {
            get: function () {
                return this._tail;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeConnectorEdgeContainerImpl.prototype, "head", {
            get: function () {
                return this._head;
            },
            enumerable: false,
            configurable: true
        });
        EShapeConnectorEdgeContainerImpl.prototype.copy = function (source) {
            this.lock();
            this._tail.copy(source.tail);
            this._head.copy(source.head);
            this.unlock();
            return this;
        };
        EShapeConnectorEdgeContainerImpl.prototype.fit = function (forcibly) {
            this.lock();
            this._tail.fit(forcibly);
            this._head.fit(forcibly);
            this.unlock();
            return this;
        };
        EShapeConnectorEdgeContainerImpl.prototype.serialize = function (manager) {
            var tailId = this._tail.serialize(manager);
            var headId = this._head.serialize(manager);
            return manager.addResource("[".concat(tailId, ",").concat(headId, "]"));
        };
        EShapeConnectorEdgeContainerImpl.prototype.deserialize = function (resourceId, mapping, manager) {
            var resources = manager.resources;
            if (0 <= resourceId && resourceId < resources.length) {
                var parsed = manager.getExtension(resourceId);
                if (parsed == null) {
                    parsed = JSON.parse(resources[resourceId]);
                    manager.setExtension(resourceId, parsed);
                }
                this.lock();
                this._tail.deserialize(parsed[0], mapping, manager);
                this._head.deserialize(parsed[1], mapping, manager);
                this.unlock();
            }
        };
        EShapeConnectorEdgeContainerImpl.prototype.attach = function () {
            this.lock();
            var tail = this._tail;
            var head = this._head;
            tail.attach();
            head.attach();
            tail.fit(true);
            head.fit(true);
            this.unlock();
            return this;
        };
        EShapeConnectorEdgeContainerImpl.prototype.detach = function (exceptions) {
            this.lock();
            this._tail.detach(exceptions);
            this._head.detach(exceptions);
            this.unlock();
            return this;
        };
        return EShapeConnectorEdgeContainerImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var toIndexOf = function (array, value) {
        var i0 = 0;
        var i1 = array.length - 1;
        while (i0 <= i1) {
            var i2 = i0 + ((i1 - i0) >> 1);
            var v2 = array[i2];
            if (value < v2) {
                i1 = i2 - 1;
            }
            else if (v2 < value) {
                i0 = i2 + 1;
            }
            else {
                return i2;
            }
        }
        return -1;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var toPointsBoundary = function (values, result) {
        var valuesLength = values.length;
        if (2 <= valuesLength) {
            var xmin = values[0];
            var ymin = values[1];
            var xmax = xmin;
            var ymax = ymin;
            for (var i = 2, imax = values.length; i < imax; i += 2) {
                var x = values[i];
                var y = values[i + 1];
                xmin = Math.min(xmin, x);
                ymin = Math.min(ymin, y);
                xmax = Math.max(xmax, x);
                ymax = Math.max(ymax, y);
            }
            result[0] = xmin;
            result[1] = ymin;
            result[2] = xmax;
            result[3] = ymax;
        }
        else {
            result[0] = 0;
            result[1] = 0;
            result[2] = 0;
            result[3] = 0;
        }
        return result;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapePointsMarkerBase = /** @class */ (function () {
        function EShapePointsMarkerBase(parent) {
            var _this = this;
            this._parent = parent;
            this._lockCount = 0;
            this._isTypeChanged = false;
            this._isSizeChanged = false;
            this._isFillChanged = false;
            this._type = EShapePointsMarkerType.NONE;
            this._size = new pixi_js.ObservablePoint(function () {
                _this.onSizeChange();
            }, undefined, EShapeDefaults.SIZE_X * 0.15, EShapeDefaults.SIZE_Y * 0.15);
            this._fill = this.newFill();
            this._transformId = 0;
        }
        EShapePointsMarkerBase.prototype.newFill = function () {
            return new EShapeFillImpl(this, true, EShapeDefaults.FILL_COLOR, 1);
        };
        EShapePointsMarkerBase.prototype.lock = function () {
            this._lockCount += 1;
            if (this._lockCount === 1) {
                this._isTypeChanged = false;
                this._isSizeChanged = false;
                this._isFillChanged = false;
            }
            return this;
        };
        EShapePointsMarkerBase.prototype.unlock = function () {
            this._lockCount -= 1;
            if (this._lockCount === 0) {
                if (this._isTypeChanged) {
                    this.onTypeChange();
                }
                else if (this._isSizeChanged) {
                    this.onSizeChange();
                }
                else if (this._isFillChanged) {
                    this.onFillChange();
                }
                this._isTypeChanged = false;
                this._isSizeChanged = false;
                this._isFillChanged = false;
            }
            return this;
        };
        Object.defineProperty(EShapePointsMarkerBase.prototype, "type", {
            get: function () {
                return this._type;
            },
            set: function (type) {
                if (this._type !== type) {
                    this._type = type;
                    this.onTypeChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        EShapePointsMarkerBase.prototype.onTypeChange = function () {
            if (0 < this._lockCount) {
                this._isTypeChanged = true;
                return;
            }
            this._parent.onTypeChange();
        };
        Object.defineProperty(EShapePointsMarkerBase.prototype, "size", {
            get: function () {
                return this._size;
            },
            enumerable: false,
            configurable: true
        });
        EShapePointsMarkerBase.prototype.onSizeChange = function () {
            if (0 < this._lockCount) {
                this._isSizeChanged = true;
                return;
            }
            this._parent.onSizeChange();
        };
        Object.defineProperty(EShapePointsMarkerBase.prototype, "transform", {
            get: function () {
                return this.updateTransform();
            },
            enumerable: false,
            configurable: true
        });
        EShapePointsMarkerBase.prototype.updateTransform = function () {
            var result = this._transform;
            if (result == null) {
                result = new pixi_js.Matrix();
                this._transform = result;
            }
            var parentParent = this._parent.parent;
            var id = parentParent.id;
            if (this._transformId !== id) {
                this._transformId = id;
                var formatted = parentParent.formatted;
                if (2 <= formatted.length) {
                    this.toTransform(formatted.values, result);
                }
                else {
                    result.identity();
                }
            }
            return result;
        };
        EShapePointsMarkerBase.prototype.toTransformMatrix = function (x0, y0, x1, y1, result) {
            var dx = x0 - x1;
            var dy = y0 - y1;
            var n = dx * dx + dy * dy;
            if (0.00001 < n) {
                var f = 1 / Math.sqrt(n);
                var nx = dx * f;
                var ny = dy * f;
                result.set(ny, -nx, -nx, -ny, x0, y0);
            }
            else {
                result.set(1, 0, 0, 1, x0, y0);
            }
            return result;
        };
        Object.defineProperty(EShapePointsMarkerBase.prototype, "fill", {
            get: function () {
                return this._fill;
            },
            enumerable: false,
            configurable: true
        });
        EShapePointsMarkerBase.prototype.onFillChange = function () {
            if (0 < this._lockCount) {
                this._isFillChanged = true;
                return;
            }
            this._parent.onFillChange();
        };
        EShapePointsMarkerBase.prototype.updateUploaded = function () {
            this.onFillChange();
        };
        EShapePointsMarkerBase.prototype.copy = function (source) {
            var size = source.size;
            this.set(source.type, size.x, size.y);
            return this;
        };
        EShapePointsMarkerBase.prototype.set = function (type, sizeX, sizeY) {
            this.lock();
            if (type != null) {
                this.type = type;
            }
            this.size.set(sizeX, sizeY);
            this.unlock();
            return this;
        };
        EShapePointsMarkerBase.prototype.serialize = function (manager) {
            var size = this._size;
            var fillId = this._fill.serialize(manager);
            return manager.addResource("[".concat(this._type, ",").concat(size.x, ",").concat(size.y, ",").concat(fillId, "]"));
        };
        EShapePointsMarkerBase.prototype.deserialize = function (resourceId, manager) {
            var resources = manager.resources;
            if (0 <= resourceId && resourceId < resources.length) {
                var parsed = manager.getExtension(resourceId);
                if (parsed == null) {
                    parsed = JSON.parse(resources[resourceId]);
                    manager.setExtension(resourceId, parsed);
                }
                this.lock();
                this.type = parsed[0];
                this._size.set(parsed[1], parsed[2]);
                this._fill.deserialize(parsed[3], manager);
                this.unlock();
            }
        };
        return EShapePointsMarkerBase;
    }());

    var EShapePointsMarkerHead = /** @class */ (function (_super) {
        __extends(EShapePointsMarkerHead, _super);
        function EShapePointsMarkerHead() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        EShapePointsMarkerHead.prototype.toTransform = function (values, result) {
            var valuesLength = values.length;
            if (4 <= valuesLength) {
                return this.toTransformMatrix(values[valuesLength - 2], values[valuesLength - 1], values[valuesLength - 4], values[valuesLength - 3], result);
            }
            else {
                result.identity();
            }
            return result;
        };
        return EShapePointsMarkerHead;
    }(EShapePointsMarkerBase));

    var EShapePointsMarkerTail = /** @class */ (function (_super) {
        __extends(EShapePointsMarkerTail, _super);
        function EShapePointsMarkerTail() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        EShapePointsMarkerTail.prototype.toTransform = function (values, result) {
            var valuesLength = values.length;
            if (4 <= valuesLength) {
                return this.toTransformMatrix(values[0], values[1], values[2], values[3], result);
            }
            else {
                result.identity();
            }
            return result;
        };
        return EShapePointsMarkerTail;
    }(EShapePointsMarkerBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapePointsMarkerContainerImpl = /** @class */ (function () {
        function EShapePointsMarkerContainerImpl(parent) {
            this._parent = parent;
            this._lockCount = 0;
            this._isTypeChanged = false;
            this._isSizeChanged = false;
            this._isFillChanged = false;
            this._head = new EShapePointsMarkerHead(this);
            this._tail = new EShapePointsMarkerTail(this);
        }
        EShapePointsMarkerContainerImpl.prototype.lock = function () {
            this._lockCount += 1;
            if (this._lockCount === 1) {
                this._isTypeChanged = false;
                this._isSizeChanged = false;
                this._isFillChanged = false;
            }
            return this;
        };
        EShapePointsMarkerContainerImpl.prototype.unlock = function () {
            this._lockCount -= 1;
            if (this._lockCount === 0) {
                if (this._isTypeChanged) {
                    this.onTypeChange();
                }
                else if (this._isSizeChanged) {
                    this.onSizeChange();
                }
                else if (this._isFillChanged) {
                    this.onFillChange();
                }
                this._isTypeChanged = false;
                this._isSizeChanged = false;
                this._isFillChanged = false;
            }
            return this;
        };
        Object.defineProperty(EShapePointsMarkerContainerImpl.prototype, "parent", {
            get: function () {
                return this._parent;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapePointsMarkerContainerImpl.prototype, "head", {
            get: function () {
                return this._head;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapePointsMarkerContainerImpl.prototype, "tail", {
            get: function () {
                return this._tail;
            },
            enumerable: false,
            configurable: true
        });
        EShapePointsMarkerContainerImpl.prototype.onTypeChange = function () {
            if (0 < this._lockCount) {
                this._isTypeChanged = true;
                return;
            }
            this._parent.onMarkerTypeChange();
        };
        EShapePointsMarkerContainerImpl.prototype.onSizeChange = function () {
            if (0 < this._lockCount) {
                this._isSizeChanged = true;
                return;
            }
            this._parent.onMarkerSizeChange();
        };
        EShapePointsMarkerContainerImpl.prototype.onFillChange = function () {
            if (0 < this._lockCount) {
                this._isFillChanged = true;
                return;
            }
            this._parent.onMarkerFillChange();
        };
        EShapePointsMarkerContainerImpl.prototype.copy = function (source) {
            this.lock();
            this._head.copy(source.head);
            this._tail.copy(source.tail);
            this.unlock();
            return this;
        };
        EShapePointsMarkerContainerImpl.prototype.serialize = function (manager) {
            var headId = this._head.serialize(manager);
            var tailId = this._tail.serialize(manager);
            return manager.addResource("[".concat(headId, ",").concat(tailId, "]"));
        };
        EShapePointsMarkerContainerImpl.prototype.deserialize = function (resourceId, manager) {
            var resources = manager.resources;
            if (0 <= resourceId && resourceId < resources.length) {
                var parsed = manager.getExtension(resourceId);
                if (parsed == null) {
                    parsed = JSON.parse(resources[resourceId]);
                    manager.setExtension(resourceId, parsed);
                }
                this.lock();
                this._head.deserialize(parsed[0], manager);
                this._tail.deserialize(parsed[1], manager);
                this.unlock();
            }
        };
        return EShapePointsMarkerContainerImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var PID = Math.PI * 2;
    var PIH = Math.PI * 0.5;
    var vdot = function (x0, y0, x1, y1) {
        return x0 * x1 + y0 * y1;
    };
    var vlen = function (x0, y0) {
        return Math.sqrt(vdot(x0, y0, x0, y0));
    };
    var vcross = function (x0, y0, x1, y1) {
        return x0 * y1 - y0 * x1;
    };
    var pnew = function () {
        return {
            center: [0, 0],
            axis1: [0, 0],
            axis2: [0, 0],
            angle: [0, 0, 0]
        };
    };
    var pset = function (cx, cy, a1x, a1y, a2x, a2y, angle1, angle2, angle3, result) {
        var c = result.center;
        c[0] = cx;
        c[1] = cy;
        var a1 = result.axis1;
        a1[0] = a1x;
        a1[1] = a1y;
        var a2 = result.axis2;
        a2[0] = a2x;
        a2[1] = a2y;
        var a = result.angle;
        a[0] = angle1;
        a[1] = angle2;
        a[2] = angle3;
        return result;
    };
    var pcopy = function (source, result) {
        var c = source.center;
        var a1 = source.axis1;
        var a2 = source.axis2;
        var a = source.angle;
        return pset(c[0], c[1], a1[0], a1[1], a2[0], a2[1], a[0], a[1], a[2], result);
    };
    var acopy$1 = function (source, result) {
        var sourceLength = source.length;
        for (var i = 0; i < sourceLength; ++i) {
            result[i] = source[i];
        }
        if (result.length !== sourceLength) {
            result.length = sourceLength;
        }
        return result;
    };
    /**
     * An utility class for spline curves based on the work of Cem Yuksel.
     * Pleaase refer to the paper `A class of C2 interpolating splines`.
     * http://www.cemyuksel.com/research/interpolating_splines/
     */
    var UtilCurve = /** @class */ (function () {
        function UtilCurve() {
        }
        UtilCurve.set = function (center1, angle10, angle11, axis11, axis12, center2, angle20, angle21, axis21, axis22, nsegment, isAdaptive, isEdge, result, resultIndex) {
            var a = Math.max(Math.abs(angle10 - angle11), Math.abs(angle20 - angle21));
            var n = isAdaptive ? Math.max(1, Math.round(nsegment * (a / PIH))) : nsegment;
            var imax = isEdge ? n + 1 : n;
            for (var i = 0; i < imax; ++i) {
                var t = i / n;
                var w0 = 1 - t;
                var w1 = t;
                var t1 = w0 * angle10 + w1 * angle11;
                var c1 = Math.cos(t1);
                var s1 = Math.sin(t1);
                var x1 = center1[0] + c1 * axis11[0] + s1 * axis12[0];
                var y1 = center1[1] + c1 * axis11[1] + s1 * axis12[1];
                var t2 = w0 * angle20 + w1 * angle21;
                var c2 = Math.cos(t2);
                var s2 = Math.sin(t2);
                var x2 = center2[0] + c2 * axis21[0] + s2 * axis22[0];
                var y2 = center2[1] + c2 * axis21[1] + s2 * axis22[1];
                var t3 = PIH * t;
                var c3 = Math.cos(t3);
                var s3 = Math.sin(t3);
                var cc3 = c3 * c3;
                var ss3 = s3 * s3;
                var x3 = cc3 * x1 + ss3 * x2;
                var y3 = cc3 * y1 + ss3 * y2;
                result[++resultIndex] = x3;
                result[++resultIndex] = y3;
            }
            return resultIndex;
        };
        /**
         * Calculate an interpolated points of the given control points.
         *
         * @param length A number of control points.
         * @param values An array of control points.
         * @param toParameter An interpolation method.
         * @param isClosed True if the line is closed.
         * @param nsegment The number of segments per 90 degree if isAdaptive is true.
         * If isAdaptive is false, the number of segments is fixed to the given number
         * regardless of arc angles.
         * @param isAdaptive True to adjust the number of segments adaptively.
         * @returns An interpolated points of the given control points.
         */
        UtilCurve.interpolate = function (length, values, segments, toParameter, isClosed, nsegment, isAdaptive, result) {
            var rvalues = result.values;
            var rsegments = result.segments;
            if (length <= 2) {
                acopy$1(values, rvalues);
                acopy$1(segments, rsegments);
                return result;
            }
            var c0 = this.WORK_P0 || pnew();
            var c1 = this.WORK_P1 || pnew();
            var c2 = this.WORK_P2 || pnew();
            this.WORK_P0 = c0;
            this.WORK_P1 = c1;
            this.WORK_P2 = c2;
            var rvaluesCount = -1;
            var rsegmentCount = -1;
            if (isClosed) {
                toParameter(0, length, values, c0);
                pcopy(c0, c1);
                for (var i = 1; i < length; ++i) {
                    toParameter(i, length, values, c2);
                    if (0 <= toIndexOf(segments, i)) {
                        var index = (i - 1) << 1;
                        rvalues[++rvaluesCount] = values[index + 0];
                        rvalues[++rvaluesCount] = values[index + 1];
                        rsegments[++rsegmentCount] = (rvaluesCount + 1) >> 1;
                    }
                    else {
                        rvaluesCount = this.set(c1.center, c1.angle[1], c1.angle[2], c1.axis1, c1.axis2, c2.center, c2.angle[0], c2.angle[1], c2.axis1, c2.axis2, nsegment, isAdaptive, false, rvalues, rvaluesCount);
                    }
                    var c3 = c1;
                    c1 = c2;
                    c2 = c3;
                }
                if (0 <= toIndexOf(segments, 0)) {
                    var index = (length - 1) << 1;
                    rvalues[++rvaluesCount] = values[index + 0];
                    rvalues[++rvaluesCount] = values[index + 1];
                    rsegments.unshift(0);
                    rsegmentCount += 1;
                }
                else {
                    rvaluesCount = this.set(c1.center, c1.angle[1], c1.angle[2], c1.axis1, c1.axis2, c0.center, c0.angle[0], c0.angle[1], c0.axis1, c0.axis2, nsegment, isAdaptive, false, rvalues, rvaluesCount);
                }
            }
            else {
                toParameter(1, length, values, c0);
                if (0 <= toIndexOf(segments, 1)) {
                    rvalues[++rvaluesCount] = values[0];
                    rvalues[++rvaluesCount] = values[1];
                    rsegments[++rsegmentCount] = 1;
                }
                else {
                    rvaluesCount = this.set(c0.center, c0.angle[0], c0.angle[1], c0.axis1, c0.axis2, c0.center, c0.angle[0], c0.angle[1], c0.axis1, c0.axis2, nsegment, isAdaptive, false, rvalues, rvaluesCount);
                }
                pcopy(c0, c1);
                for (var i = 2, imax = length - 1; i < imax; ++i) {
                    toParameter(i, length, values, c2);
                    if (0 <= toIndexOf(segments, i)) {
                        var index = (i - 1) << 1;
                        rvalues[++rvaluesCount] = values[index + 0];
                        rvalues[++rvaluesCount] = values[index + 1];
                        rsegments[++rsegmentCount] = (rvaluesCount + 1) >> 1;
                    }
                    else {
                        rvaluesCount = this.set(c1.center, c1.angle[1], c1.angle[2], c1.axis1, c1.axis2, c2.center, c2.angle[0], c2.angle[1], c2.axis1, c2.axis2, nsegment, isAdaptive, false, rvalues, rvaluesCount);
                    }
                    var c3 = c1;
                    c1 = c2;
                    c2 = c3;
                }
                if (0 <= toIndexOf(segments, length - 1)) {
                    var index = (length - 2) << 1;
                    rvalues[++rvaluesCount] = values[index + 0];
                    rvalues[++rvaluesCount] = values[index + 1];
                    rsegments[++rsegmentCount] = (rvaluesCount + 1) >> 1;
                }
                else {
                    rvaluesCount = this.set(c1.center, c1.angle[1], c1.angle[2], c1.axis1, c1.axis2, c1.center, c1.angle[1], c1.angle[2], c1.axis1, c1.axis2, nsegment, isAdaptive, true, rvalues, rvaluesCount);
                }
            }
            rvaluesCount += 1;
            if (rvalues.length !== rvaluesCount) {
                rvalues.length = rvaluesCount;
            }
            rsegmentCount += 1;
            if (rsegments.length !== rsegmentCount) {
                rsegments.length = rsegmentCount;
            }
            return result;
        };
        UtilCurve.toCircle = function (index, length, values, result) {
            var index0 = 0 < index ? index - 1 : length - 1;
            var index1 = index;
            var index2 = index < length - 1 ? index + 1 : 0;
            var i0 = index0 << 1;
            var i1 = index1 << 1;
            var i2 = index2 << 1;
            var x0 = values[i0 + 0];
            var y0 = values[i0 + 1];
            var x1 = values[i1 + 0];
            var y1 = values[i1 + 1];
            var x2 = values[i2 + 0];
            var y2 = values[i2 + 1];
            var d01x = x1 - x0;
            var d01y = y1 - y0;
            var d12x = x2 - x1;
            var d12y = y2 - y1;
            var m1x = x0 + d01x * 0.5;
            var m1y = y0 + d01y * 0.5;
            var m2x = x1 + d12x * 0.5;
            var m2y = y1 + d12y * 0.5;
            var n1x = -d01y;
            var n1y = +d01x;
            var n2x = -d12y;
            var n2y = +d12x;
            var det = vcross(n1x, n1y, n2x, n2y);
            var threshold = 0.001;
            if (Math.abs(det) < threshold) {
                if (0 <= vdot(d01x, d01y, d12x, d12y) || length <= 2) {
                    var a = 0.01;
                    var s_1 = Math.sin(a);
                    var l1 = vlen(d01x, d01y);
                    var l2 = vlen(d12x, d12y);
                    return pset(x1, y1, 0, 0, d12x / s_1, d12y / s_1, (-a * l1) / l2, 0, a, result);
                }
                else {
                    det = threshold;
                }
            }
            var s = (n2y * (m2x - m1x) + n2x * (m1y - m2y)) / det;
            var cx = m1x + s * n1x;
            var cy = m1y + s * n1y;
            var a1x = x1 - cx;
            var a1y = y1 - cy;
            var a2x = -a1y;
            var a2y = +a1x;
            var dc2x = x2 - cx;
            var dc2y = y2 - cy;
            var a2 = Math.atan2(vdot(a2x, a2y, dc2x, dc2y), vdot(a1x, a1y, dc2x, dc2y));
            var dc0x = x0 - cx;
            var dc0y = y0 - cy;
            var a1 = Math.atan2(vdot(a2x, a2y, dc0x, dc0y), vdot(a1x, a1y, dc0x, dc0y));
            if (0 < a1 * a2) {
                if (Math.abs(a1) < Math.abs(a2)) {
                    if (0 < a2) {
                        a2 -= PID;
                    }
                    else {
                        a2 += PID;
                    }
                }
                if (Math.abs(a2) < Math.abs(a1)) {
                    if (0 < a1) {
                        a1 -= PID;
                    }
                    else {
                        a1 += PID;
                    }
                }
            }
            return pset(cx, cy, a1x, a1y, a2x, a2y, a1, 0, a2, result);
        };
        UtilCurve.toEllipse = function (index, length, values, result) {
            var index0 = 0 < index ? index - 1 : length - 1;
            var index1 = index;
            var index2 = index < length - 1 ? index + 1 : 0;
            var i0 = index0 << 1;
            var i1 = index1 << 1;
            var i2 = index2 << 1;
            var x0 = values[i0 + 0];
            var y0 = values[i0 + 1];
            var x1 = values[i1 + 0];
            var y1 = values[i1 + 1];
            var x2 = values[i2 + 0];
            var y2 = values[i2 + 1];
            var d10x = x0 - x1;
            var d10y = y0 - y1;
            var d12x = x2 - x1;
            var d12y = y2 - y1;
            if (length <= 2) {
                var a_1 = 0.01;
                var s = Math.sin(a_1);
                return pset(x1, y1, 0, 0, d12x / s, d12y / s, -a_1, 0, a_1, result);
            }
            var l0 = vlen(d10x, d10y);
            var l2 = vlen(d12x, d12y);
            var cos = vdot(d10x, d10y, d12x, d12y) / (l0 * l2);
            var amax = Math.acos(cos);
            var acurrent = amax * 0.5;
            var adelta = amax * 0.25;
            var a = 0;
            var b = 0;
            var c = 0;
            var d = 0;
            var lmax = Math.max(l0, l2);
            var lmin = Math.min(l0, l2);
            for (var i = 0; i < 16; ++i) {
                var a0 = acurrent * 0.5;
                var a1 = amax - a0;
                a = lmax * Math.sin(a0);
                b = lmax * Math.cos(a0);
                c = lmin * Math.sin(a1);
                d = lmin * Math.cos(a1);
                var v = (1 - d / b) * (1 - d / b) + (c * c) / (a * a);
                if (1 < v) {
                    acurrent += adelta;
                }
                else {
                    acurrent -= adelta;
                }
                adelta *= 0.5;
            }
            var beta = Math.asin(Math.min(c / a, 1));
            if (l0 < l2) {
                var e3x = d12x / l2;
                var e3y = d12y / l2;
                var n3x = void 0, n3y = void 0;
                if (0 < vcross(d10x, d10y, d12x, d12y)) {
                    n3x = +e3y;
                    n3y = -e3x;
                }
                else {
                    n3x = -e3y;
                    n3y = +e3x;
                }
                var we = -(b * b) / l2;
                var wn = -(b * a) / l2;
                var a1x = we * e3x + wn * n3x;
                var a1y = we * e3y + wn * n3y;
                var cx = x1 - a1x;
                var cy = y1 - a1y;
                var a2x = x2 - cx;
                var a2y = y2 - cy;
                return pset(cx, cy, a1x, a1y, a2x, a2y, -beta, 0, PIH, result);
            }
            else {
                var e0x = d10x / l0;
                var e0y = d10y / l0;
                var n3x = void 0, n3y = void 0;
                if (vcross(d10x, d10y, d12x, d12y) < 0) {
                    n3x = +e0y;
                    n3y = -e0x;
                }
                else {
                    n3x = -e0y;
                    n3y = +e0x;
                }
                var we = -(b * b) / l0;
                var wn = -(b * a) / l0;
                var a1x = we * e0x + wn * n3x;
                var a1y = we * e0y + wn * n3y;
                var cx = x1 - a1x;
                var cy = y1 - a1y;
                var a2x = x0 - cx;
                var a2y = y0 - cy;
                return pset(cx, cy, a1x, a1y, -a2x, -a2y, -PIH, 0, beta, result);
            }
        };
        UtilCurve.toHybrid = function (index, length, values, result) {
            var circle = UtilCurve.toCircle(index, length, values, result);
            var a0 = circle.angle[0];
            var a2 = circle.angle[2];
            var amin = Math.min(a0, a2);
            var amax = Math.max(a0, a2);
            if (amin < -PIH || PIH < amax) {
                return UtilCurve.toEllipse(index, length, values, result);
            }
            return circle;
        };
        return UtilCurve;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var eShapePointsFormatterCurve = function (length, values, segments, style, result) {
        UtilCurve.interpolate(length, values, segments, UtilCurve.toHybrid, !!(style & EShapePointsStyle.CLOSED), EShapeDefaults.CURVE_SEGMENT_COUNT, true, result);
        result.length = result.values.length >> 1;
        result.style = style;
        return result;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var acopy = function (source, result) {
        var sourceLength = source.length;
        for (var i = 0; i < sourceLength; ++i) {
            result[i] = source[i];
        }
        if (result.length !== sourceLength) {
            result.length = sourceLength;
        }
        return result;
    };
    var amix = function (x0, y0, x1, y1, t, result) {
        var u = 1 - t;
        result[0] = x0 * u + x1 * t;
        result[1] = y0 * u + y1 * t;
        return result;
    };
    var interpolate2 = function (x0, y0, x1, y1, x2, y2, is0, is1, nsegment, rvalues, rvaluesCount) {
        var v3 = [0, 0];
        var v4 = [0, 0];
        var v5 = [0, 0];
        for (var is = is0; is < is1; ++is) {
            var t = is / nsegment;
            amix(x0, y0, x1, y1, t, v3);
            amix(x1, y1, x2, y2, t, v4);
            amix(v3[0], v3[1], v4[0], v4[1], t, v5);
            rvalues[++rvaluesCount] = v5[0];
            rvalues[++rvaluesCount] = v5[1];
        }
        return rvaluesCount;
    };
    var interpolate1 = function (length, values, segments, isClosed, nsegment, result) {
        var rvalues = result.values;
        var rsegments = result.segments;
        if (length <= 2) {
            acopy(values, rvalues);
            acopy(segments, rsegments);
            return result;
        }
        var rvaluesCount = -1;
        var rsegmentsCount = -1;
        var ism = nsegment >> 1;
        if (isClosed) {
            var i = 0;
            for (; i + 2 < length; i += 2) {
                var j = i << 1;
                var s0 = 0 <= toIndexOf(segments, i + 1);
                var s1 = 0 <= toIndexOf(segments, i + 2);
                if (s0 && s1) {
                    rvalues[++rvaluesCount] = values[j + 0];
                    rvalues[++rvaluesCount] = values[j + 1];
                    rsegments[++rsegmentsCount] = (rvaluesCount >> 1) + 1;
                }
                else if (s0) {
                    rvalues[++rvaluesCount] = values[j + 0];
                    rvalues[++rvaluesCount] = values[j + 1];
                    rsegments[++rsegmentsCount] = (rvaluesCount >> 1) + 1;
                    rvaluesCount = interpolate2(values[j + 0], values[j + 1], values[j + 2], values[j + 3], values[j + 4], values[j + 5], ism, nsegment, nsegment, rvalues, rvaluesCount);
                }
                else if (s1) {
                    rvaluesCount = interpolate2(values[j + 0], values[j + 1], values[j + 2], values[j + 3], values[j + 4], values[j + 5], 0, ism, nsegment, rvalues, rvaluesCount);
                    rsegments[++rsegmentsCount] = (rvaluesCount >> 1) + 1;
                }
                else {
                    rvaluesCount = interpolate2(values[j + 0], values[j + 1], values[j + 2], values[j + 3], values[j + 4], values[j + 5], 0, nsegment, nsegment, rvalues, rvaluesCount);
                }
            }
            if (i + 1 < length) {
                var j = i << 1;
                var s0 = 0 <= toIndexOf(segments, i + 1);
                var s1 = 0 <= toIndexOf(segments, 0);
                if (s0 && s1) {
                    rvalues[++rvaluesCount] = values[0];
                    rvalues[++rvaluesCount] = values[1];
                    rsegments.unshift(0);
                    rsegmentsCount += 1;
                }
                else if (s0) {
                    rvalues[++rvaluesCount] = values[j + 0];
                    rvalues[++rvaluesCount] = values[j + 1];
                    rsegments[++rsegmentsCount] = (rvaluesCount >> 1) + 1;
                    rvaluesCount = interpolate2(values[j + 0], values[j + 1], values[j + 2], values[j + 3], values[0], values[1], ism, nsegment, nsegment, rvalues, rvaluesCount);
                }
                else if (s1) {
                    rvaluesCount = interpolate2(values[j + 0], values[j + 1], values[j + 2], values[j + 3], values[0], values[1], 0, ism, nsegment, rvalues, rvaluesCount);
                    rsegments[++rsegmentsCount] = (rvaluesCount >> 1) + 1;
                }
                else {
                    rvaluesCount = interpolate2(values[j + 0], values[j + 1], values[j + 2], values[j + 3], values[0], values[1], 0, nsegment, nsegment, rvalues, rvaluesCount);
                }
            }
            else if (i < length) {
                var j = i << 1;
                rvalues[++rvaluesCount] = values[j + 0];
                rvalues[++rvaluesCount] = values[j + 1];
                if (0 <= toIndexOf(segments, 0)) {
                    rsegments.unshift(0);
                    rsegmentsCount += 1;
                }
            }
        }
        else {
            var i = 0;
            for (; i + 2 < length; i += 2) {
                var j = i << 1;
                var s0 = 0 <= toIndexOf(segments, i + 1);
                var s1 = 0 <= toIndexOf(segments, i + 2);
                if (s0 && s1) {
                    rvalues[++rvaluesCount] = values[j + 0];
                    rvalues[++rvaluesCount] = values[j + 1];
                    rsegments[++rsegmentsCount] = (rvaluesCount >> 1) + 1;
                }
                else if (s0) {
                    rvalues[++rvaluesCount] = values[j + 0];
                    rvalues[++rvaluesCount] = values[j + 1];
                    rsegments[++rsegmentsCount] = (rvaluesCount >> 1) + 1;
                    rvaluesCount = interpolate2(values[j + 0], values[j + 1], values[j + 2], values[j + 3], values[j + 4], values[j + 5], ism, nsegment, nsegment, rvalues, rvaluesCount);
                }
                else if (s1) {
                    rvaluesCount = interpolate2(values[j + 0], values[j + 1], values[j + 2], values[j + 3], values[j + 4], values[j + 5], 0, ism, nsegment, rvalues, rvaluesCount);
                    rsegments[++rsegmentsCount] = (rvaluesCount >> 1) + 1;
                }
                else {
                    rvaluesCount = interpolate2(values[j + 0], values[j + 1], values[j + 2], values[j + 3], values[j + 4], values[j + 5], 0, nsegment, nsegment, rvalues, rvaluesCount);
                }
            }
            for (; i + 1 < length; ++i) {
                var j = i << 1;
                rvalues[++rvaluesCount] = values[j + 0];
                rvalues[++rvaluesCount] = values[j + 1];
                rvalues[++rvaluesCount] = values[j + 2];
                rvalues[++rvaluesCount] = values[j + 3];
                if (0 <= toIndexOf(segments, i + 1)) {
                    rsegments[++rsegmentsCount] = (rvaluesCount >> 1) + 1;
                }
            }
            for (; i < length; ++i) {
                var j = i << 1;
                rvalues[++rvaluesCount] = values[j + 0];
                rvalues[++rvaluesCount] = values[j + 1];
            }
        }
        rvaluesCount += 1;
        if (rvalues.length !== rvaluesCount) {
            rvalues.length = rvaluesCount;
        }
        rsegmentsCount += 1;
        if (rsegments.length !== rsegmentsCount) {
            rsegments.length = rsegmentsCount;
        }
        return result;
    };
    var eShapePointsFormatterCurveBezierQuadratic = function (length, values, segments, style, result) {
        interpolate1(length, values, segments, !!(style & EShapePointsStyle.CLOSED), EShapeDefaults.CURVE_SEGMENT_COUNT, result);
        result.length = result.values.length >> 1;
        result.style = style;
        return result;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapePointsFormatters = /** @class */ (function () {
        function EShapePointsFormatters() {
        }
        EShapePointsFormatters.set = function (id, datum) {
            if (this.data == null) {
                this.data = this.newData();
            }
            this.data.set(id, datum);
        };
        EShapePointsFormatters.get = function (index) {
            if (this.data == null) {
                this.data = this.newData();
            }
            return this.data.get(index);
        };
        EShapePointsFormatters.each = function (iteratee) {
            if (this.data == null) {
                this.data = this.newData();
            }
            this.data.forEach(function (datum, id) {
                iteratee(id, datum);
            });
        };
        EShapePointsFormatters.find = function (style) {
            return this.get((style & EShapePointsStyle.FORMATTER_MASK) >> EShapePointsStyle.FORMATTER_SHIFT);
        };
        EShapePointsFormatters.newData = function () {
            var result = new Map();
            var theme = DThemes.get("EShapePointsFormatter");
            result.set(EShapePointsStyle.FORMATTER_CURVE_SPLINE, {
                label: theme.getCurveSplineLabel(),
                formatter: eShapePointsFormatterCurve
            });
            result.set(EShapePointsStyle.FORMATTER_CURVE_BEZIER_QUADRATIC, {
                label: theme.getCurveBezierQuadraticLabel(),
                formatter: eShapePointsFormatterCurveBezierQuadratic
            });
            return result;
        };
        return EShapePointsFormatters;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeLinePoints = /** @class */ (function () {
        function EShapeLinePoints(parent) {
            this._parent = parent;
            this._valuesBaseLength = 0;
            this._values = [];
            this._segments = [];
            this._length = 0;
            this._plength = 0;
            var parentSize = parent.size;
            var parentSizeX = parentSize.x;
            var parentSizeY = parentSize.y;
            this._parentSizeBase = new pixi_js.Point(parentSizeX, parentSizeY);
            this._parentSizeFitted = new pixi_js.Point(parentSizeX, parentSizeY);
            this._id = 0;
            this._style = EShapePointsStyle.NONE;
            this._formattedId = -1;
        }
        Object.defineProperty(EShapeLinePoints.prototype, "length", {
            get: function () {
                return this._length;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeLinePoints.prototype, "plength", {
            get: function () {
                return this._plength;
            },
            enumerable: false,
            configurable: true
        });
        EShapeLinePoints.prototype.toFitted = function (x, y) {
            this._valuesBase = undefined;
            this._parentSizeFitted.set(x, y);
            this._parentSizeBase.set(x, y);
        };
        EShapeLinePoints.prototype.onSizeChange = function () {
            this.fit();
        };
        EShapeLinePoints.prototype.fit = function () {
            var parent = this._parent;
            var psizef = this._parentSizeFitted;
            var psize = parent.size;
            var psizeX = psize.x;
            var psizeY = psize.y;
            var threshold = 0.00001;
            if (Math.abs(psizeX - psizef.x) <= threshold && Math.abs(psizeY - psizef.y) <= threshold) {
                return;
            }
            psizef.set(psizeX, psizeY);
            var psizeBase = this._parentSizeBase;
            var isValidX = threshold < Math.abs(psizeBase.x);
            var isValidY = threshold < Math.abs(psizeBase.y);
            if (!isValidX && !isValidY) {
                return;
            }
            var scaleX = isValidX ? psizeX / psizeBase.x : 1;
            var scaleY = isValidY ? psizeY / psizeBase.y : 1;
            // Values
            var values = this._values;
            var valuesBase = this._valuesBase;
            if (valuesBase == null) {
                valuesBase = [];
                this._valuesBase = valuesBase;
                for (var i = 0, imax = values.length; i < imax; i += 2) {
                    var x = values[i];
                    var y = values[i + 1];
                    values[i] = x * scaleX;
                    values[i + 1] = y * scaleY;
                    valuesBase.push(x, y);
                }
            }
            else {
                for (var i = 0, imax = values.length; i < imax; i += 2) {
                    values[i] = valuesBase[i] * scaleX;
                    values[i + 1] = valuesBase[i + 1] * scaleY;
                }
            }
            // Invalidate
            this._id += 1;
            if (this._formatter || this._style & EShapePointsStyle.FORMATTER_MASK) {
                var uploaded = parent.uploaded;
                if (uploaded && !uploaded.isCompatible(parent)) {
                    parent.toDirty();
                }
            }
        };
        Object.defineProperty(EShapeLinePoints.prototype, "id", {
            get: function () {
                this.fit();
                return this._id;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeLinePoints.prototype, "values", {
            get: function () {
                this.fit();
                return this._values;
            },
            set: function (values) {
                this.set(values, undefined, undefined);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeLinePoints.prototype, "segments", {
            get: function () {
                return this._segments;
            },
            /**
             * Must be sorted in ascending order.
             */
            set: function (segments) {
                this.set(undefined, segments, undefined);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeLinePoints.prototype, "style", {
            get: function () {
                return this._style;
            },
            set: function (style) {
                this.set(undefined, undefined, style);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeLinePoints.prototype, "marker", {
            get: function () {
                var result = this._marker;
                if (result == null) {
                    result = this.newMarker();
                    this._marker = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        EShapeLinePoints.prototype.getMarker = function () {
            return this._marker;
        };
        EShapeLinePoints.prototype.newMarker = function () {
            return new EShapePointsMarkerContainerImpl(this);
        };
        EShapeLinePoints.prototype.onMarkerTypeChange = function () {
            var parent = this._parent;
            parent.uploaded = undefined;
            parent.toDirty();
        };
        EShapeLinePoints.prototype.onMarkerSizeChange = function () {
            this._parent.updateUploaded();
        };
        EShapeLinePoints.prototype.onMarkerFillChange = function () {
            this._parent.updateUploaded();
        };
        Object.defineProperty(EShapeLinePoints.prototype, "formatter", {
            get: function () {
                return this._formatter || null;
            },
            set: function (formatter) {
                if (this._formatter !== formatter) {
                    this._formattedId = -1;
                    this._formatter = formatter;
                    this.toDirty(true);
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeLinePoints.prototype, "formatted", {
            get: function () {
                var _a, _b;
                this.fit();
                var id = this._id;
                var result = this._formatted;
                if (this._formattedId !== id) {
                    this._formattedId = id;
                    var style = this._style;
                    var formatter = (_a = this._formatter) !== null && _a !== void 0 ? _a : (_b = EShapePointsFormatters.find(style)) === null || _b === void 0 ? void 0 : _b.formatter;
                    if (formatter != null) {
                        if (result == null) {
                            result = {
                                length: 0,
                                plength: 0,
                                values: [],
                                segments: [],
                                boundary: [0, 0, 0, 0],
                                style: EShapePointsStyle.NONE
                            };
                        }
                        var values = this._values;
                        var segments = this._segments;
                        var length_1 = values.length >> 1;
                        formatter(length_1, values, segments, style, result);
                        if (result.plength < result.length) {
                            result.plength = result.length;
                        }
                        toPointsBoundary(result.values, result.boundary);
                    }
                    else {
                        result = undefined;
                    }
                    this._formatted = result;
                }
                return result || this;
            },
            enumerable: false,
            configurable: true
        });
        EShapeLinePoints.prototype.toScaled = function (values, valuesBase, boundary, boundaryBase) {
            var size = this._parentSizeFitted;
            var sizeBase = this._parentSizeBase;
            var threshold = 0.00001;
            var hasSizeBaseX = threshold < Math.abs(sizeBase.x);
            var hasSizeBaseY = threshold < Math.abs(sizeBase.y);
            if (hasSizeBaseX || hasSizeBaseY) {
                var scaleX = hasSizeBaseX ? size.x / sizeBase.x : 1;
                var scaleY = hasSizeBaseY ? size.y / sizeBase.y : 1;
                for (var i = 0, imax = valuesBase.length; i < imax; i += 2) {
                    values[i] = valuesBase[i] * scaleX;
                    values[i + 1] = valuesBase[i + 1] * scaleY;
                }
                for (var i = 0, imax = boundaryBase.length; i < imax; i += 2) {
                    boundary[i] = boundaryBase[i] * scaleX;
                    boundary[i + 1] = boundaryBase[i + 1] * scaleY;
                }
            }
        };
        EShapeLinePoints.prototype.copy = function (source) {
            this.set(source.values, source.segments, source.style);
            var marker = source.getMarker();
            if (marker) {
                this.marker.copy(marker);
            }
            return this;
        };
        EShapeLinePoints.prototype.set = function (newValues, newSegments, newStyle) {
            var isDirty = false;
            var isUpdated = false;
            // Formatter
            var style = this._style;
            var styleFormatter = style & EShapePointsStyle.FORMATTER_MASK;
            var formatter = this._formatter;
            // Values
            if (newValues != null) {
                var values = this._values;
                var valuesBaseLength = this._valuesBaseLength;
                var newValuesLength = newValues.length;
                var iupdate = Math.min(newValuesLength, valuesBaseLength);
                var parentSize = this._parent.size;
                this.toFitted(parentSize.x, parentSize.y);
                if (values !== newValues) {
                    for (var i = 0; i < iupdate; ++i) {
                        values[i] = newValues[i];
                    }
                    for (var i = iupdate; i < newValuesLength; ++i) {
                        values.push(newValues[i]);
                    }
                    if (valuesBaseLength !== newValuesLength) {
                        values.length = newValuesLength;
                        this._valuesBaseLength = newValuesLength;
                        isDirty = true;
                    }
                    else {
                        if (formatter != null || styleFormatter) {
                            isDirty = true;
                        }
                        else {
                            isUpdated = true;
                        }
                    }
                }
                else {
                    if (valuesBaseLength !== newValuesLength) {
                        this._valuesBaseLength = newValuesLength;
                        isDirty = true;
                    }
                    else {
                        if (formatter != null || styleFormatter) {
                            isDirty = true;
                        }
                        else {
                            isUpdated = true;
                        }
                    }
                }
                var newLength = newValuesLength >> 1;
                this._length = newLength;
                if (this._plength < newLength) {
                    this._plength = newLength;
                }
            }
            // Segments
            if (newSegments != null) {
                var segments = this._segments;
                if (segments !== newSegments) {
                    var newSegmentsLength = newSegments.length;
                    var iupdate = Math.min(segments.length, newSegmentsLength);
                    for (var i = 0; i < iupdate; ++i) {
                        segments[i] = newSegments[i];
                    }
                    for (var i = iupdate; i < newSegmentsLength; ++i) {
                        segments.push(newSegments[i]);
                    }
                    if (segments.length !== newSegmentsLength) {
                        segments.length = newSegmentsLength;
                    }
                }
                if (formatter != null || styleFormatter) {
                    isDirty = true;
                }
                else {
                    isUpdated = true;
                }
            }
            // Style
            if (newStyle != null) {
                if (style !== newStyle) {
                    var newStyleFormatter = newStyle & EShapePointsStyle.FORMATTER_MASK;
                    if (styleFormatter !== newStyleFormatter) {
                        isDirty = true;
                    }
                    else {
                        if (formatter != null || styleFormatter) {
                            var styleClosed = style & EShapePointsStyle.CLOSED;
                            var newStyleClosed = newStyle & EShapePointsStyle.CLOSED;
                            if (styleClosed !== newStyleClosed) {
                                isDirty = true;
                            }
                            else {
                                isUpdated = true;
                            }
                        }
                        else {
                            isUpdated = true;
                        }
                    }
                    this._style = newStyle;
                }
            }
            //
            if (isUpdated || isDirty) {
                this.toDirty(isDirty);
            }
            return this;
        };
        EShapeLinePoints.prototype.toDirty = function (revalidate) {
            if (revalidate) {
                this._id += 1;
                var parent_1 = this._parent;
                var uploaded = parent_1.uploaded;
                if (uploaded) {
                    if (uploaded.isCompatible(parent_1)) {
                        parent_1.updateUploaded();
                    }
                    else {
                        parent_1.toDirty();
                    }
                }
                else {
                    parent_1.updateUploaded();
                }
            }
            else {
                this._id += 1;
                this._parent.updateUploaded();
            }
        };
        EShapeLinePoints.prototype.clone = function (parent) {
            return new EShapeLinePoints(parent).copy(this);
        };
        EShapeLinePoints.prototype.toPoints = function (transform) {
            var result = [];
            var values = this.values;
            for (var i = 0, imax = values.length; i < imax; i += 2) {
                var point = new pixi_js.Point(values[i + 0], values[i + 1]);
                result.push(transform.apply(point, point));
            }
            return result;
        };
        EShapeLinePoints.prototype.serialize = function (manager) {
            var values = JSON.stringify(this._values);
            var segments = JSON.stringify(this._segments);
            var style = this._style;
            var markerId = -1;
            var marker = this._marker;
            if (marker) {
                markerId = marker.serialize(manager);
            }
            return manager.addResource("[".concat(values, ",").concat(segments, ",").concat(style, ",").concat(markerId, "]"));
        };
        EShapeLinePoints.prototype.deserialize = function (resourceId, manager) {
            var resources = manager.resources;
            if (0 <= resourceId && resourceId < resources.length) {
                var parsed = manager.getExtension(resourceId);
                if (parsed == null) {
                    parsed = JSON.parse(resources[resourceId]);
                    manager.setExtension(resourceId, parsed);
                }
                this.set(parsed[0], parsed[1], parsed[2]);
                var markerId = parsed[3];
                if (markerId != null && 0 <= markerId) {
                    this.marker.deserialize(markerId, manager);
                }
            }
        };
        EShapeLinePoints.prototype.calcHitPointAbs = function (x, y, ax, ay, threshold, toRange, tester, result) {
            var formatted = this.formatted;
            var length = formatted.length;
            if (2 <= length) {
                var values = formatted.values;
                var segments = formatted.segments;
                var style = formatted.style;
                var istart = 0;
                var iend = length;
                if (toRange) {
                    var work = EShapeLinePoints.WORK_RANGE;
                    toRange(x, y, threshold, values, work);
                    istart = work[0];
                    iend = work[1];
                }
                for (var i = istart, imax = Math.min(iend, length - 1); i < imax; ++i) {
                    if (toIndexOf(segments, i + 1) < 0) {
                        var iv = i << 1;
                        var p0x = values[iv + 0];
                        var p0y = values[iv + 1];
                        var p1x = values[iv + 2];
                        var p1y = values[iv + 3];
                        if (tester(x, y, p0x, p0y, p1x, p1y, i, threshold, result)) {
                            return true;
                        }
                    }
                }
                if (2 < length && length <= iend && style & EShapePointsStyle.CLOSED) {
                    if (toIndexOf(segments, 0) < 0) {
                        var i = length - 1;
                        var iv = i << 1;
                        var p0x = values[iv + 0];
                        var p0y = values[iv + 1];
                        var p1x = values[0];
                        var p1y = values[1];
                        if (tester(x, y, p0x, p0y, p1x, p1y, i, threshold, result)) {
                            return true;
                        }
                    }
                }
            }
            return false;
        };
        EShapeLinePoints.WORK_RANGE = [0, 0];
        return EShapeLinePoints;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeConnectorBodyImpl = /** @class */ (function () {
        function EShapeConnectorBodyImpl(parent, onChange) {
            this._parent = parent;
            this._id = 0;
            this._values = [];
            this._lockCount = 0;
            this._isChanged = false;
            this._onChange = onChange;
        }
        EShapeConnectorBodyImpl.prototype.lock = function () {
            this._lockCount += 1;
            if (this._lockCount === 1) {
                this._isChanged = false;
            }
        };
        EShapeConnectorBodyImpl.prototype.unlock = function () {
            this._lockCount -= 1;
            if (this._lockCount === 0) {
                if (this._isChanged) {
                    this.onChange();
                }
                this._isChanged = false;
            }
        };
        Object.defineProperty(EShapeConnectorBodyImpl.prototype, "id", {
            get: function () {
                return this._id;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeConnectorBodyImpl.prototype, "values", {
            get: function () {
                return this._values;
            },
            set: function (newValues) {
                this.set(newValues);
            },
            enumerable: false,
            configurable: true
        });
        EShapeConnectorBodyImpl.prototype.set = function (newValues) {
            if (newValues != null) {
                this._id += 1;
                if (this._values !== newValues) {
                    var length_1 = newValues.length;
                    var values = this._values;
                    for (var i = 0; i < length_1; ++i) {
                        values[i] = newValues[i];
                    }
                    values.length = length_1;
                }
                this.onChange();
            }
            return this;
        };
        EShapeConnectorBodyImpl.prototype.copy = function (source) {
            return this.set(source.values);
        };
        EShapeConnectorBodyImpl.prototype.serialize = function (manager) {
            return manager.addResource(JSON.stringify(this._values));
        };
        EShapeConnectorBodyImpl.prototype.deserialize = function (resourceId, mapping, manager) {
            var resources = manager.resources;
            if (0 <= resourceId && resourceId < resources.length) {
                var parsed = manager.getExtension(resourceId);
                if (parsed == null) {
                    parsed = JSON.parse(resources[resourceId]);
                    manager.setExtension(resourceId, parsed);
                }
                this.set(parsed);
            }
        };
        EShapeConnectorBodyImpl.prototype.onChange = function () {
            if (0 < this._lockCount) {
                this._isChanged = true;
                return;
            }
            this._onChange();
        };
        return EShapeConnectorBodyImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeConnectorLine = /** @class */ (function (_super) {
        __extends(EShapeConnectorLine, _super);
        function EShapeConnectorLine(type) {
            if (type === void 0) { type = EShapeType.CONNECTOR_LINE; }
            var _this = _super.call(this, type) || this;
            _this._tailLocalId = 0;
            _this._tailNormalId = 0;
            _this._tailMargin = 0;
            _this._headLocalId = 0;
            _this._headNormalId = 0;
            _this._headMargin = 0;
            _this._bodyId = 0;
            _this._lockConnector = new EShapeLock();
            var sx = EShapeDefaults.SIZE_X;
            var sy = EShapeDefaults.SIZE_Y;
            var hx = sx * 0.5;
            var hy = sy * 0.5;
            _this._points = new EShapeLinePoints(_this).set([-hx, -hy, +hx, +hy]);
            var onChangeBound = function () {
                _this.onChange();
            };
            _this._edge = new EShapeConnectorEdgeContainerImpl(_this, onChangeBound);
            _this._body = new EShapeConnectorBodyImpl(_this, onChangeBound);
            return _this;
        }
        EShapeConnectorLine.prototype.lock = function (part) {
            if (part & EShapeLockPart.CONNECTOR) {
                this._lockConnector.lock();
            }
            _super.prototype.lock.call(this, part);
            return this;
        };
        EShapeConnectorLine.prototype.unlock = function (part, invoke) {
            _super.prototype.unlock.call(this, part, invoke);
            if (part & EShapeLockPart.CONNECTOR) {
                if (this._lockConnector.unlock() && invoke) {
                    this.onChange();
                }
            }
            return this;
        };
        Object.defineProperty(EShapeConnectorLine.prototype, "points", {
            get: function () {
                return this._points;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeConnectorLine.prototype, "edge", {
            get: function () {
                return this._edge;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeConnectorLine.prototype, "body", {
            get: function () {
                return this._body;
            },
            enumerable: false,
            configurable: true
        });
        EShapeConnectorLine.prototype.onAttach = function () {
            _super.prototype.onAttach.call(this);
            this._edge.attach();
        };
        EShapeConnectorLine.prototype.onDetach = function (exceptions) {
            this._edge.detach(exceptions);
            _super.prototype.onDetach.call(this, exceptions);
        };
        EShapeConnectorLine.prototype.onChange = function () {
            var _a;
            if (this._lockConnector.isLocked()) {
                return;
            }
            var edge = this._edge;
            var tail = edge.tail;
            var tailLocalId = tail.localId;
            var tailNormalId = tail.normalId;
            var tailMargin = tail.margin;
            var head = edge.head;
            var headLocalId = head.localId;
            var headNormalId = head.normalId;
            var headMargin = head.margin;
            var body = this._body;
            var bodyId = body.id;
            if (this._tailLocalId !== tailLocalId ||
                this._tailNormalId !== tailNormalId ||
                this._tailMargin !== tailMargin ||
                this._headLocalId !== headLocalId ||
                this._headNormalId !== headNormalId ||
                this._headMargin !== headMargin ||
                this._bodyId !== bodyId) {
                this._tailLocalId = tailLocalId;
                this._tailNormalId = tailNormalId;
                this._tailMargin = tailMargin;
                this._headLocalId = headLocalId;
                this._headNormalId = headNormalId;
                this._headMargin = headMargin;
                this._bodyId !== bodyId;
                var transform = this.transform;
                var transformPosition = transform.position;
                var px = transformPosition.x;
                var py = transformPosition.y;
                var points = this._points;
                var values = points.values;
                // Fill points
                this.fillPoints(tail, tailMargin, head, headMargin, body, px, py, values);
                // Center & size
                var boundary = ((_a = EShapeConnectorLine.WORK_BOUNDARY) !== null && _a !== void 0 ? _a : (EShapeConnectorLine.WORK_BOUNDARY = [0, 0, 0, 0]));
                toPointsBoundary(values, boundary);
                var cx = (boundary[2] + boundary[0]) * 0.5;
                var cy = (boundary[3] + boundary[1]) * 0.5;
                var sx = boundary[2] - boundary[0];
                var sy = boundary[3] - boundary[1];
                // Adjust values
                for (var i = 0, imax = values.length; i < imax; i += 2) {
                    values[i + 0] -= cx;
                    values[i + 1] -= cy;
                }
                this.lock(EShapeLockPart.TRANSFORM_AND_UPLOADED);
                transformPosition.set(px + cx, py + cy);
                transform.scale.set(1, 1);
                transform.rotation = 0;
                transform.skew.set(0, 0);
                points.toFitted(sx, sy);
                this.size.set(sx, sy);
                points.set(values);
                this.unlock(EShapeLockPart.TRANSFORM_AND_UPLOADED, true);
            }
        };
        EShapeConnectorLine.prototype.fillPoints = function (tail, tailMargin, head, headMargin, body, px, py, values) {
            // Tail
            var threshold = 0.000001;
            var tailLocal = tail.local;
            var tailLocalX = tailLocal.x;
            var tailLocalY = tailLocal.y;
            var x0 = tailLocalX - px;
            var y0 = tailLocalY - py;
            // Head
            var headLocal = head.local;
            var headLocalX = headLocal.x;
            var headLocalY = headLocal.y;
            var x1 = headLocalX - px;
            var y1 = headLocalY - py;
            // Body
            var bodyValues = body.values;
            var bodyValuesLength = bodyValues.length;
            // Tail points
            values[0] = x0;
            values[1] = y0;
            // Body points
            if (0 < bodyValuesLength) {
                var cx = (x1 + x0) * 0.5;
                var cy = (y1 + y0) * 0.5;
                var dx = x1 - x0;
                var dy = y1 - y0;
                var a = Math.atan2(dy, dx);
                var c = Math.cos(a);
                var s = Math.sin(a);
                var l = Math.sqrt(dx * dx + dy * dy);
                for (var i = 0; i < bodyValuesLength; i += 2) {
                    var x = bodyValues[i + 0];
                    var y = bodyValues[i + 1];
                    values[i + 2] = cx + (c * x - s * y) * l;
                    values[i + 3] = cy + (c * y + s * x) * l;
                }
            }
            // Head points
            values[2 + bodyValuesLength] = x1;
            values[3 + bodyValuesLength] = y1;
            // Tail margin
            if (tailMargin !== 0) {
                var dx = values[2] - x0;
                var dy = values[3] - y0;
                var d = dx * dx + dy * dy;
                if (threshold < d) {
                    var f = tailMargin / Math.sqrt(dx * dx + dy * dy);
                    values[0] = x0 + dx * f;
                    values[1] = y0 + dy * f;
                }
            }
            // Head margin
            if (headMargin !== 0) {
                var dx = values[0 + bodyValuesLength] - x1;
                var dy = values[1 + bodyValuesLength] - y1;
                var d = dx * dx + dy * dy;
                if (threshold < d) {
                    var f = headMargin / Math.sqrt(dx * dx + dy * dy);
                    values[2 + bodyValuesLength] = x1 + dx * f;
                    values[3 + bodyValuesLength] = y1 + dy * f;
                }
            }
            // Remove the rest
            values.length = bodyValuesLength + 4;
        };
        EShapeConnectorLine.prototype.copy = function (source, part) {
            if (part === void 0) { part = EShapeCopyPart.ALL; }
            this.lock(EShapeLockPart.ALL);
            _super.prototype.copy.call(this, source, part);
            if (source instanceof EShapeConnectorLine) {
                this._edge.copy(source.edge);
                this._body.copy(source.body);
            }
            this.unlock(EShapeLockPart.ALL, true);
            return this;
        };
        EShapeConnectorLine.prototype.clone = function () {
            var constructor = this.constructor;
            return new constructor(this.type).copy(this);
        };
        EShapeConnectorLine.prototype.serialize = function (manager) {
            var result = _super.prototype.serialize.call(this, manager);
            var edgeId = this._edge.serialize(manager);
            var bodyId = this._body.serialize(manager);
            var pointsId = this._points.serialize(manager);
            result[15] = manager.addResource("[".concat(edgeId, ",").concat(pointsId, ",").concat(bodyId, "]"));
            return result;
        };
        return EShapeConnectorLine;
    }(EShapeLineBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeConnectors = /** @class */ (function () {
        function EShapeConnectors() {
        }
        EShapeConnectors.isConnector = function (target) {
            return target instanceof EShapeConnectorLine;
        };
        EShapeConnectors.newMapping = function (sources, destinations, result) {
            var _a;
            if (result == null) {
                result = (_a = EShapeConnectors._MAPPING) !== null && _a !== void 0 ? _a : (EShapeConnectors._MAPPING = new Map());
                result.clear();
            }
            for (var i = 0, imax = sources.length; i < imax; ++i) {
                var fromChild = sources[i];
                var toChild = destinations[i];
                result.set(fromChild, toChild);
                this.newMapping(fromChild.children, toChild.children, result);
            }
            return result;
        };
        EShapeConnectors.moveAll = function (rootSources, rootDestinations, sources, destinations, mapping) {
            for (var i = 0, imax = sources.length; i < imax; ++i) {
                var source = sources[i];
                var destination = destinations[i];
                if (this.isConnector(source)) {
                    if (this.isConnector(destination)) {
                        var sourceEdge = source.edge;
                        var destEdge = destination.edge;
                        var sourceHead = sourceEdge.head;
                        var sourceHeadShape = sourceHead.acceptor.shape;
                        if (sourceHeadShape) {
                            if (mapping == null) {
                                mapping = this.newMapping(rootSources, rootDestinations);
                            }
                            var destHeadShape = mapping.get(sourceHeadShape);
                            if (destHeadShape) {
                                var destHead = destEdge.head;
                                destHead.detach();
                                destHead.set(destHeadShape);
                                destHead.attach();
                                destHeadShape.connector.remove(sourceHead);
                            }
                        }
                        var sourceTail = sourceEdge.tail;
                        var sourceTailShape = sourceTail.acceptor.shape;
                        if (sourceTailShape) {
                            if (mapping == null) {
                                mapping = this.newMapping(rootSources, rootDestinations);
                            }
                            var destTailShape = mapping.get(sourceTailShape);
                            if (destTailShape) {
                                var destTail = destEdge.tail;
                                destTail.detach();
                                destTail.set(destTailShape);
                                destTail.attach();
                                destTailShape.connector.remove(sourceTail);
                            }
                        }
                    }
                }
                mapping = this.moveAll(rootSources, rootDestinations, source.children, destination.children, mapping);
            }
            return mapping;
        };
        EShapeConnectors.move = function (from, to) {
            var fromChildren = from.children;
            var toChildren = to.children;
            this.moveAll(fromChildren, toChildren, fromChildren, toChildren);
        };
        return EShapeConnectors;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DynamicAtlasItem = /** @class */ (function () {
        function DynamicAtlasItem(id, width, height, strokeWidth, baseTexture) {
            this.id = id;
            this.ref = 0;
            var resolution = baseTexture.resolution;
            this.frame = new pixi_js.Rectangle(0, 0, width * resolution, height * resolution);
            this.texture = new pixi_js.Texture(baseTexture, new pixi_js.Rectangle(0, 0, 1, 1));
            this.width = width;
            this.height = height;
            this.strokeWidth = strokeWidth;
        }
        DynamicAtlasItem.prototype.applyFrame = function () {
            var resolutionInverse = 1 / this.texture.baseTexture.resolution;
            this.texture.frame.x = this.frame.x * resolutionInverse;
            this.texture.frame.y = this.frame.y * resolutionInverse;
            this.texture.frame.width = this.width;
            this.texture.frame.height = this.height;
            this.texture.updateUvs();
            this.texture.emit("update", this);
        };
        DynamicAtlasItem.prototype.destroy = function () {
            this.texture.destroy();
        };
        return DynamicAtlasItem;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DynamicAtlasItemEmpty = /** @class */ (function (_super) {
        __extends(DynamicAtlasItemEmpty, _super);
        function DynamicAtlasItemEmpty() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DynamicAtlasItemEmpty.prototype.render = function (context) {
            // DO NOTHING
        };
        return DynamicAtlasItemEmpty;
    }(DynamicAtlasItem));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DynamicAtlasItemWhite = /** @class */ (function (_super) {
        __extends(DynamicAtlasItemWhite, _super);
        function DynamicAtlasItemWhite() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DynamicAtlasItemWhite.prototype.render = function (context) {
            var frame = this.frame;
            context.save();
            context.fillStyle = "#ffffff";
            context.fillRect(frame.x - 1, frame.y - 1, frame.width + 2, frame.height + 2);
            context.restore();
        };
        return DynamicAtlasItemWhite;
    }(DynamicAtlasItem));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var MAXIMUM_TEXTURE_SIZE = 4096;
    var DynamicAtlas = /** @class */ (function () {
        function DynamicAtlas(resolution) {
            var canvas = (this._canvas = document.createElement("canvas"));
            canvas.width = canvas.height = 256;
            var baseTexture = pixi_js.BaseTexture.from(canvas, {
                mipmap: pixi_js.MIPMAP_MODES.OFF,
                resolution: resolution
            });
            this._baseTexture = baseTexture;
            this._idToDatum = {};
            this._sortedData = [];
            this._predefined = {
                empty: new DynamicAtlasItemEmpty("empty", 10, 10, 0, baseTexture),
                white: new DynamicAtlasItemWhite("white", 10, 10, 0, baseTexture)
            };
            this._isDirty = true;
        }
        DynamicAtlas.prototype.updateFrames = function (width, data) {
            var padding = 4;
            var x = padding;
            var y = padding;
            var maxRowHeight = 0;
            for (var i = 0, imax = data.length; i < imax; ++i) {
                var datum = data[i];
                if (width < x + datum.frame.width + padding) {
                    x = padding;
                    y += maxRowHeight + padding;
                    maxRowHeight = 0;
                }
                datum.frame.x = x | 0;
                datum.frame.y = y | 0;
                x += datum.frame.width + padding;
                maxRowHeight = Math.max(maxRowHeight, datum.frame.height);
            }
            var minHeight = y + maxRowHeight + padding;
            var result = 256;
            while (result < minHeight) {
                result <<= 1;
            }
            return Math.min(MAXIMUM_TEXTURE_SIZE, result);
        };
        DynamicAtlas.prototype.renderFrames = function (width, height, data) {
            var canvas = this._canvas;
            canvas.width = width;
            canvas.height = height;
            var context = canvas.getContext("2d");
            if (context != null) {
                for (var i = 0, imax = data.length; i < imax; ++i) {
                    var datum = data[i];
                    datum.render(context);
                }
            }
        };
        DynamicAtlas.prototype.applyFrames = function (data) {
            for (var i = 0, imax = data.length; i < imax; ++i) {
                var datum = data[i];
                datum.applyFrame();
            }
        };
        DynamicAtlas.prototype.calcCanvasWidth = function (data) {
            var result = 512;
            for (var i = data.length - 1; 0 <= i; --i) {
                var datum = data[i];
                var size = Math.max(datum.frame.width, datum.frame.height);
                while (result < size) {
                    result <<= 1;
                }
            }
            return Math.min(MAXIMUM_TEXTURE_SIZE, result << 1);
        };
        DynamicAtlas.prototype.cleanup = function (data) {
            data.sort(DynamicAtlas.ITEM_COMPARATOR);
            for (var i = data.length - 1; 0 <= i; --i) {
                var datum = data[i];
                if (0 < datum.ref) {
                    data.length = i + 1;
                    return;
                }
            }
            data.length = 0;
        };
        DynamicAtlas.prototype.begin = function () {
            var data = this._sortedData;
            for (var i = 0, imax = data.length; i < imax; ++i) {
                var datum = data[i];
                datum.ref = 0;
            }
            this._isDirty = false;
        };
        DynamicAtlas.prototype.end = function () {
            var idToDatum = this._idToDatum;
            var data = this._sortedData;
            for (var i = 0, imax = data.length; i < imax; ++i) {
                var datum = data[i];
                if (datum.ref <= 0) {
                    if (!(datum.id in this._predefined)) {
                        datum.destroy();
                    }
                    delete idToDatum[datum.id];
                    this._isDirty = true;
                }
            }
        };
        DynamicAtlas.prototype.repack = function (forcibly) {
            if (forcibly === true || this._isDirty) {
                this._isDirty = false;
                var data = this._sortedData;
                this.cleanup(data);
                var canvasWidth = this.calcCanvasWidth(data);
                var canvasHeight = this.updateFrames(canvasWidth, data);
                this.renderFrames(canvasWidth, canvasHeight, data);
                this._baseTexture.setRealSize(canvasWidth, canvasHeight);
                this.applyFrames(data);
            }
        };
        DynamicAtlas.prototype.get = function (id) {
            var idToDatum = this._idToDatum;
            var datum = idToDatum[id];
            if (datum != null) {
                datum.ref += 1;
                return datum;
            }
            else {
                var predefined = this._predefined[id];
                if (predefined != null) {
                    this.set(id, predefined);
                    return predefined;
                }
            }
            return null;
        };
        DynamicAtlas.prototype.contains = function (id) {
            return id in this._idToDatum;
        };
        DynamicAtlas.prototype.set = function (id, item) {
            var result = this._idToDatum[id];
            item.ref += 1;
            this._idToDatum[id] = item;
            this._sortedData.push(item);
            this._isDirty = true;
            return result;
        };
        DynamicAtlas.prototype.toDirty = function () {
            this._isDirty = true;
        };
        DynamicAtlas.prototype.getDefaultTexture = function () {
            return this.get("white").texture;
        };
        DynamicAtlas.prototype.getBaseTexture = function () {
            return this._baseTexture;
        };
        DynamicAtlas.prototype.release = function (id) {
            var idToDatum = this._idToDatum;
            var datum = idToDatum[id];
            if (datum != null) {
                datum.ref -= 1;
                if (datum.ref <= 0) {
                    if (!(datum.id in this._predefined)) {
                        datum.destroy();
                    }
                    delete idToDatum[id];
                    this._isDirty = true;
                }
            }
        };
        DynamicAtlas.prototype.destroy = function () {
            var baseTexture = this._baseTexture;
            if (baseTexture != null) {
                baseTexture.destroy();
            }
        };
        DynamicAtlas.ITEM_COMPARATOR = function (a, b) {
            if (a.ref <= 0) {
                if (b.ref <= 0) {
                    return 0;
                }
                else {
                    return +1;
                }
            }
            else {
                if (b.ref <= 0) {
                    return -1;
                }
            }
            if (a.frame.height < b.frame.height) {
                return -1;
            }
            else if (b.frame.height < a.frame.height) {
                return +1;
            }
            else {
                return a.frame.width - b.frame.width;
            }
        };
        return DynamicAtlas;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DynamicAtlasItemFontAtlas = /** @class */ (function (_super) {
        __extends(DynamicAtlasItemFontAtlas, _super);
        function DynamicAtlasItemFontAtlas(atlas, baseTexture) {
            var _this = _super.call(this, atlas.id, atlas.width / baseTexture.resolution, atlas.height / baseTexture.resolution, 0, baseTexture) || this;
            _this.canvas = atlas.canvas;
            return _this;
        }
        DynamicAtlasItemFontAtlas.prototype.render = function (context) {
            var canvas = this.canvas;
            if (canvas != null) {
                var frame = this.frame;
                context.drawImage(canvas, frame.x, frame.y, frame.width, frame.height);
            }
        };
        return DynamicAtlasItemFontAtlas;
    }(DynamicAtlasItem));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DynamicFontAtlasCharacterOrigin = /** @class */ (function () {
        function DynamicFontAtlasCharacterOrigin(x, y) {
            this.x = x;
            this.y = y;
        }
        return DynamicFontAtlasCharacterOrigin;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DynamicFontAtlasCharacter = /** @class */ (function () {
        function DynamicFontAtlasCharacter(type, character, x, y, width, height, advance) {
            this.ref = 1;
            this.life = DynamicFontAtlasCharacter.LIFE;
            this.character = character;
            this.x = x;
            this.y = y;
            this.width = width;
            this.height = height;
            this.advance = advance;
            this.origin = new DynamicFontAtlasCharacterOrigin(0, 0);
            this.type = type;
        }
        DynamicFontAtlasCharacter.LIFE = 10;
        return DynamicFontAtlasCharacter;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var RESERVED = 1;
    var NON_BREAKING = 2;
    var SPACE = 4;
    var SPACE_R = SPACE | RESERVED;
    var SPACE_NB = SPACE | NON_BREAKING;
    var SPACE_RNB = SPACE | RESERVED | NON_BREAKING;
    var LETTER = 8;
    var LETTER_R = LETTER | RESERVED;
    var LETTER_NB = LETTER | NON_BREAKING;
    var LETTER_RNB = LETTER | RESERVED | NON_BREAKING;
    var DynamicFontAtlasCharacterType = {
        RESERVED: RESERVED,
        NON_BREAKING: NON_BREAKING,
        SPACE: SPACE,
        SPACE_R: SPACE_R,
        SPACE_NB: SPACE_NB,
        SPACE_RNB: SPACE_RNB,
        LETTER: LETTER,
        LETTER_R: LETTER_R,
        LETTER_NB: LETTER_NB,
        LETTER_RNB: LETTER_RNB
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DynamicSDFFontAtlasFont = /** @class */ (function () {
        function DynamicSDFFontAtlasFont(fontFamily) {
            this.id = DynamicSDFFontAtlasFont.toFontFamily(fontFamily);
            this.size = 32;
            this.italic = false;
            this.measured = false;
            this.ascent = 0;
            this.descent = 0;
        }
        DynamicSDFFontAtlasFont.toFontFamily = function (fontFamily) {
            return fontFamily === "auto" ? DynamicSDFFontAtlasFont.getAutoFontFamily() : fontFamily;
        };
        DynamicSDFFontAtlasFont.getAutoFontFamily = function () {
            if (DynamicSDFFontAtlasFont.FONT_FAMILY_AUTO == null) {
                DynamicSDFFontAtlasFont.FONT_FAMILY_AUTO = DThemes.getInstance()
                    .get("DBase")
                    .getFontFamilly();
            }
            return DynamicSDFFontAtlasFont.FONT_FAMILY_AUTO;
        };
        DynamicSDFFontAtlasFont.FONT_FAMILY_AUTO = null;
        return DynamicSDFFontAtlasFont;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var VERTEX_SHADER$2 = "\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nvarying mediump vec2 vTextureCoord;\nvoid main(void) {\n\tgl_Position = vec4(aVertexPosition, 0.0, 1.0);\n\tvTextureCoord = aTextureCoord;\n}\n";
    var FRAGMENT_SHADER$2 = "\nprecision mediump float;\n\nvarying mediump vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform vec2 uSize;\n\nfloat norm(vec2 v) {\n\treturn dot(v, v);\n}\n\nfloat norm(vec2 p, vec2 dp) {\n\tvec2 xy = p + dp;\n\tvec2 uvi = vec2(1.0) / uSize;\n\tvec2 uv = xy * uvi;\n\tvec4 t0 = vec4(texture2D(uSampler, uv).a);\n\tvec4 t1 = vec4(\n\t\ttexture2D(uSampler, uv + vec2(-uvi.x, 0.0   )).a,\n\t\ttexture2D(uSampler, uv + vec2(0.0   , -uvi.y)).a,\n\t\ttexture2D(uSampler, uv + vec2(+uvi.x, 0.0   )).a,\n\t\ttexture2D(uSampler, uv + vec2(0.0   , +uvi.y)).a\n\t);\n\tvec4 t2 = vec4(0.5);\n\tvec4 t3 = min(t1,t0);\n\tvec4 t4 = max(t1,t0);\n\n\tvec4 w0 = (t2 - t0) / (t1 - t0);\n\tvec4 s0 = vec4(\n\t\tt3.x < 0.5 && 0.5 <= t4.x,\n\t\tt3.y < 0.5 && 0.5 <= t4.y,\n\t\tt3.z < 0.5 && 0.5 <= t4.z,\n\t\tt3.w < 0.5 && 0.5 <= t4.w\n\t);\n\tvec4 l0 = vec4(\n\t\tnorm(dp + vec2(-w0.x, 0.0  )),\n\t\tnorm(dp + vec2(0.0  , -w0.y)),\n\t\tnorm(dp + vec2(+w0.z, 0.0  )),\n\t\tnorm(dp + vec2(0.0  , +w0.w))\n\t);\n\tvec4 c0 = vec4(100.0);\n\tvec4 r0 = mix(c0, l0, s0);\n\n\tvec4 w1 = w0 * vec4(0.5);\n\tvec4 s1 = vec4(\n\t\t0.5 < s0.x && 0.5 < s0.y,\n\t\t0.5 < s0.y && 0.5 < s0.z,\n\t\t0.5 < s0.z && 0.5 < s0.w,\n\t\t0.5 < s0.w && 0.5 < s0.x\n\t);\n\tvec4 l1 = vec4(\n\t\tnorm(dp + vec2(-w1.x, -w1.y)),\n\t\tnorm(dp + vec2(+w1.z, -w1.y)),\n\t\tnorm(dp + vec2(+w1.z, +w1.w)),\n\t\tnorm(dp + vec2(-w1.x, +w1.w))\n\t);\n\tvec4 r1 = mix(c0, l1, s1);\n\tvec4 r2 = min(r0, r1);\n\tvec2 r3 = min(r2.xy, r2.zw);\n\treturn min(r3.x, r3.y);\n}\n\nfloat normY(vec2 p, float dx) {\n\tfloat result = 100.0;\n\tfor (float dy=-6.0; dy < 6.5; dy += 1.0) {\n\t\tresult = min(result, norm(p, vec2(dx, dy)));\n\t}\n\treturn result;\n}\n\nfloat normX(vec2 p) {\n\tfloat result = 100.0;\n\tfor (float dx=-6.0; dx < 6.5; dx += 1.0) {\n\t\tresult = min(result, normY(p, dx));\n\t}\n\treturn result;\n}\n\nvoid main(void) {\n\tfloat t = texture2D(uSampler, vTextureCoord).a;\n\tfloat d = min( 6.0, sqrt(normX( vTextureCoord * uSize )) ) / 12.0;\n\td = clamp( mix( 0.5 - d, 0.5 + d, step( 0.5, t ) ), 0.0, 1.0 ) * 255.0;\n\tfloat r = floor(d);\n\td = (d - r) * 255.0;\n\tfloat g = floor(d);\n\tgl_FragColor = vec4(r * 0.00392156862745098, g * 0.00392156862745098, d - g, 1.0);\n}\n";
    var DynamicSDFFontGenerator = /** @class */ (function () {
        function DynamicSDFFontGenerator() {
            var _this = this;
            this._gl = null;
            this._texture = null;
            this._shaderProgram = null;
            this._vertexPositionAttribute = 0;
            this._textureCoordAttribute = 1;
            this._samplerUniform = null;
            this._sizeUniform = null;
            this._vb = null;
            this._uvb = null;
            var canvas = (this._canvas = document.createElement("canvas"));
            canvas.width = 64;
            canvas.height = 64;
            this._onLostBound = function (e) {
                e.preventDefault();
            };
            this._onRestoreBound = function () {
                _this.restore();
            };
            this._onUnloadBound = function () {
                _this.destroy();
            };
            canvas.addEventListener("webglcontextlost", this._onLostBound, false);
            canvas.addEventListener("webglcontextrestored", this._onRestoreBound, false);
            window.addEventListener("unload", this._onUnloadBound, false);
        }
        DynamicSDFFontGenerator.prototype.init = function () {
            var canvas = this._canvas;
            if (canvas != null && (this._gl == null || this._gl.isContextLost())) {
                var config = {
                    alpha: true,
                    antialias: false,
                    depth: false,
                    stencil: false,
                    premultipliedAlpha: false
                };
                var gl = canvas.getContext("webgl", config) ||
                    canvas.getContext("experimental-webgl", config);
                this._gl = gl;
                if (gl != null) {
                    gl.clearColor(1.0, 1.0, 1.0, 0.0);
                    this.makeVertexBuffer();
                    this.makeUvBuffer();
                    this.makeShaders();
                    this._texture = null;
                }
            }
            return this;
        };
        DynamicSDFFontGenerator.prototype.restore = function () {
            this.init();
        };
        DynamicSDFFontGenerator.prototype.getCanvas = function () {
            return this._canvas;
        };
        DynamicSDFFontGenerator.prototype.getShader = function (gl, code, type) {
            var shader = type
                ? gl.createShader(gl.FRAGMENT_SHADER)
                : gl.createShader(gl.VERTEX_SHADER);
            if (shader != null) {
                gl.shaderSource(shader, code);
                gl.compileShader(shader);
                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    console &&
                        console.error("Failed to compile the shader: ".concat(gl.getShaderInfoLog(shader)));
                    return null;
                }
            }
            return shader;
        };
        DynamicSDFFontGenerator.prototype.makeShaders = function () {
            var gl = this._gl;
            if (gl != null && gl.isContextLost() !== true) {
                var vertexShader = this.getShader(gl, VERTEX_SHADER$2, false);
                if (vertexShader != null) {
                    var fragmentShader = this.getShader(gl, FRAGMENT_SHADER$2, true);
                    if (fragmentShader != null) {
                        var shaderProgram = (this._shaderProgram = gl.createProgram());
                        if (shaderProgram != null) {
                            gl.attachShader(shaderProgram, vertexShader);
                            gl.attachShader(shaderProgram, fragmentShader);
                            gl.bindAttribLocation(shaderProgram, 0, "aVertexPosition");
                            gl.bindAttribLocation(shaderProgram, 1, "aTextureCoord");
                            gl.linkProgram(shaderProgram);
                            if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
                                console &&
                                    console.error("Failed to link the program: ".concat(gl.getError()));
                                gl.deleteShader(vertexShader);
                                gl.deleteShader(fragmentShader);
                                return null;
                            }
                            else {
                                gl.deleteShader(vertexShader);
                                gl.deleteShader(fragmentShader);
                                gl.useProgram(shaderProgram);
                                this._samplerUniform = gl.getUniformLocation(shaderProgram, "uSampler");
                                this._sizeUniform = gl.getUniformLocation(shaderProgram, "uSize");
                                gl.useProgram(null);
                                return shaderProgram;
                            }
                        }
                        else {
                            gl.deleteShader(vertexShader);
                            gl.deleteShader(fragmentShader);
                        }
                    }
                    else {
                        gl.deleteShader(vertexShader);
                    }
                }
            }
            return null;
        };
        DynamicSDFFontGenerator.prototype.destroyShaders = function () {
            var gl = this._gl;
            if (gl != null && gl.isContextLost() !== true) {
                var shaderProgram = this._shaderProgram;
                if (shaderProgram != null) {
                    this._shaderProgram = null;
                    gl.useProgram(null);
                    gl.deleteProgram(shaderProgram);
                }
            }
        };
        DynamicSDFFontGenerator.prototype.updateTexture = function (width, height, source) {
            var gl = this._gl;
            var canvas = this._canvas;
            if (gl != null && gl.isContextLost() !== true && canvas != null) {
                if (canvas.width !== width || canvas.height !== height) {
                    canvas.width = width;
                    canvas.height = height;
                    gl.viewport(0, 0, width, height);
                }
                var texture = this._texture;
                if (texture == null) {
                    texture = this._texture = gl.createTexture();
                    gl.bindTexture(gl.TEXTURE_2D, texture);
                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, source);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                    gl.bindTexture(gl.TEXTURE_2D, null);
                }
                else {
                    gl.bindTexture(gl.TEXTURE_2D, texture);
                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, source);
                    gl.bindTexture(gl.TEXTURE_2D, null);
                }
                return texture;
            }
            return null;
        };
        DynamicSDFFontGenerator.prototype.destroyTexture = function () {
            var gl = this._gl;
            var texture = this._texture;
            if (gl != null && gl.isContextLost() !== true && texture != null) {
                this._texture = null;
                gl.bindTexture(gl.TEXTURE_2D, null);
                gl.deleteTexture(texture);
            }
        };
        DynamicSDFFontGenerator.prototype.makeVertexBuffer = function () {
            var gl = this._gl;
            if (gl != null && gl.isContextLost() !== true) {
                var vb = (this._vb = gl.createBuffer());
                gl.bindBuffer(gl.ARRAY_BUFFER, vb);
                var vertices = [-1.0, +1.0, +1.0, +1.0, -1.0, -1.0, +1.0, -1.0];
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
                return vb;
            }
            return null;
        };
        DynamicSDFFontGenerator.prototype.destroyVertexBuffer = function () {
            var gl = this._gl;
            var vb = this._vb;
            if (gl != null && gl.isContextLost() !== true && vb != null) {
                this._vb = null;
                gl.bindBuffer(gl.ARRAY_BUFFER, null);
                gl.deleteBuffer(vb);
            }
        };
        DynamicSDFFontGenerator.prototype.makeUvBuffer = function () {
            var gl = this._gl;
            if (gl != null && gl.isContextLost() !== true) {
                var uvb = (this._uvb = gl.createBuffer());
                gl.bindBuffer(gl.ARRAY_BUFFER, uvb);
                var uvs = [0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0, 1.0];
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(uvs), gl.STATIC_DRAW);
                return uvb;
            }
            return null;
        };
        DynamicSDFFontGenerator.prototype.destroyUvBuffer = function () {
            var gl = this._gl;
            var uvb = this._uvb;
            if (gl != null && gl.isContextLost() !== true && uvb != null) {
                this._uvb = null;
                gl.bindBuffer(gl.ARRAY_BUFFER, null);
                gl.deleteBuffer(uvb);
            }
        };
        DynamicSDFFontGenerator.prototype.render = function () {
            var gl = this._gl;
            var canvas = this._canvas;
            var shaderProgram = this._shaderProgram;
            var vb = this._vb;
            var uvb = this._uvb;
            var texture = this._texture;
            if (gl != null &&
                gl.isContextLost() !== true &&
                canvas != null &&
                shaderProgram != null &&
                vb != null &&
                uvb != null &&
                texture != null) {
                gl.clear(gl.COLOR_BUFFER_BIT);
                gl.useProgram(shaderProgram);
                gl.bindBuffer(gl.ARRAY_BUFFER, vb);
                var vertexPositionAttribute = this._vertexPositionAttribute;
                gl.enableVertexAttribArray(vertexPositionAttribute);
                gl.vertexAttribPointer(vertexPositionAttribute, 2, gl.FLOAT, false, 0, 0);
                gl.bindBuffer(gl.ARRAY_BUFFER, uvb);
                var textureCoordAttribute = this._textureCoordAttribute;
                gl.enableVertexAttribArray(textureCoordAttribute);
                gl.vertexAttribPointer(textureCoordAttribute, 2, gl.FLOAT, false, 0, 0);
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, texture);
                gl.uniform1i(this._samplerUniform, 0);
                gl.uniform2f(this._sizeUniform, canvas.width, canvas.height);
                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
                gl.bindTexture(gl.TEXTURE_2D, null);
                gl.bindBuffer(gl.ARRAY_BUFFER, null);
                gl.useProgram(null);
            }
        };
        DynamicSDFFontGenerator.prototype.read = function (copyCanvas) {
            var gl = this._gl;
            var canvas = this._canvas;
            if (gl != null && gl.isContextLost() !== true && canvas != null) {
                var width = canvas.width;
                var height = canvas.height;
                copyCanvas.width = width;
                copyCanvas.height = height;
                var copyContext = copyCanvas.getContext("2d");
                if (copyContext != null) {
                    copyContext.drawImage(canvas, 0, 0);
                }
            }
        };
        DynamicSDFFontGenerator.prototype.destroy = function () {
            this.destroyVertexBuffer();
            this.destroyUvBuffer();
            this.destroyShaders();
            var canvas = this._canvas;
            if (canvas != null) {
                this._canvas = null;
                canvas.removeEventListener("webglcontextlost", this._onLostBound, false);
                canvas.removeEventListener("webglcontextrestored", this._onRestoreBound, false);
                window.removeEventListener("unload", this._onUnloadBound, false);
            }
            var gl = this._gl;
            if (gl != null) {
                this._gl = null;
                var WebGLLoseContext = gl.getExtension("WEBGL_lose_context");
                if (WebGLLoseContext != null) {
                    WebGLLoseContext.loseContext();
                }
            }
        };
        DynamicSDFFontGenerator.getInstance = function () {
            if (DynamicSDFFontGenerator._INSTANCE == null) {
                DynamicSDFFontGenerator._INSTANCE = new DynamicSDFFontGenerator();
            }
            return DynamicSDFFontGenerator._INSTANCE;
        };
        DynamicSDFFontGenerator._INSTANCE = null;
        return DynamicSDFFontGenerator;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var UtilFont = /** @class */ (function () {
        function UtilFont() {
        }
        UtilFont.measure = function (context, font) {
            if (!font.measured) {
                if ("fontBoundingBoxAscent" in window.TextMetrics.prototype) {
                    var metrics = context.measureText(pixi_js.TextMetrics.METRICS_STRING);
                    font.ascent = metrics.fontBoundingBoxAscent;
                    font.descent = metrics.fontBoundingBoxDescent;
                }
                else {
                    var measured = pixi_js.TextMetrics.measureFont(font.id);
                    font.ascent = measured.ascent;
                    font.descent = measured.descent;
                }
                font.measured = true;
            }
        };
        UtilFont.toSize = function (font) {
            this.setup(font);
            return parseFloat(window.getComputedStyle(this._span).fontSize);
        };
        UtilFont.setup = function (font) {
            var span = this._span;
            if (span == null) {
                span = document.createElement("span");
                span.innerText = "|ÉqÅ";
                span.style.border = "none";
                span.style.margin = "0px";
                this._span = span;
            }
            var block = this._block;
            if (block == null) {
                block = document.createElement("div");
                block.style.display = "inline-block";
                block.style.width = "0px";
                block.style.height = "0px";
                block.style.border = "none";
                block.style.margin = "0px";
                block.style.verticalAlign = "baseline";
                this._block = block;
            }
            var div = this._div;
            if (div == null) {
                div = document.createElement("div");
                div.style.position = "absolute";
                div.style.padding = "0px";
                div.style.margin = "0px";
                div.style.visibility = "hidden";
                div.appendChild(span);
                div.appendChild(block);
                document.body.appendChild(div);
                this._div = div;
            }
            span.style.font = font;
        };
        return UtilFont;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DynamicSDFFontAtlas = /** @class */ (function () {
        function DynamicSDFFontAtlas(fontFamily) {
            this._id = "font-atlas:".concat(fontFamily);
            this._generator = DynamicSDFFontGenerator.getInstance().init();
            this._canvas = document.createElement("canvas");
            this._font = new DynamicSDFFontAtlasFont(fontFamily);
            this._width = 1;
            this._height = 1;
            var characters = new Map();
            characters.set(Character.SPACE, this.newChar(Character.SPACE, DynamicFontAtlasCharacterType.SPACE_R));
            characters.set(Character.TAB, this.newChar(Character.SOFT_TAB, DynamicFontAtlasCharacterType.SPACE_R));
            characters.set(Character.DOTS, this.newChar(Character.DOTS, DynamicFontAtlasCharacterType.LETTER_RNB));
            for (var i = 0, imax = Character.ASCII.length; i < imax; ++i) {
                var ac = Character.ASCII[i];
                characters.set(ac, this.newChar(ac, DynamicFontAtlasCharacterType.LETTER_RNB));
            }
            this._characters = characters;
            this._isDirty = true;
            this._isTouched = false;
            this._life = DynamicFontAtlasCharacter.LIFE;
        }
        Object.defineProperty(DynamicSDFFontAtlas.prototype, "id", {
            get: function () {
                return this._id;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DynamicSDFFontAtlas.prototype, "font", {
            get: function () {
                return this._font;
            },
            set: function (font) {
                this._font.id = font.id;
                this._font.size = font.size;
                this._font.italic = font.italic;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DynamicSDFFontAtlas.prototype, "width", {
            get: function () {
                return this._width;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DynamicSDFFontAtlas.prototype, "height", {
            get: function () {
                return this._height;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DynamicSDFFontAtlas.prototype, "canvas", {
            get: function () {
                return this._canvas;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DynamicSDFFontAtlas.prototype, "generator", {
            get: function () {
                return this._generator;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DynamicSDFFontAtlas.prototype, "characters", {
            get: function () {
                return this._characters;
            },
            enumerable: false,
            configurable: true
        });
        DynamicSDFFontAtlas.prototype.begin = function () {
            this._isTouched = false;
            this._characters.forEach(function (character) {
                if (!(character.type & DynamicFontAtlasCharacterType.RESERVED)) {
                    character.ref = 0;
                }
            });
        };
        DynamicSDFFontAtlas.prototype.end = function () {
            var _this = this;
            var characters = this._characters;
            if (this._isTouched) {
                this._life = DynamicFontAtlasCharacter.LIFE;
                characters.forEach(function (character, id) {
                    if (character.ref <= 0 &&
                        !(character.type & DynamicFontAtlasCharacterType.RESERVED)) {
                        character.life -= 1;
                        if (character.life <= 0) {
                            characters.delete(id);
                            _this._isDirty = true;
                        }
                    }
                });
            }
            else {
                this._life -= 1;
                if (this._life <= 0 && 0 < characters.size) {
                    characters.clear();
                    this._isDirty = true;
                }
            }
        };
        DynamicSDFFontAtlas.prototype.newChar = function (character, type) {
            return new DynamicFontAtlasCharacter(type, character, 0, 0, 1, 1, 0);
        };
        DynamicSDFFontAtlas.prototype.add = function (characters, nacharacters) {
            var cs = this._characters;
            for (var i = 0, imax = nacharacters.length; i < imax; ++i) {
                var nac = nacharacters[i];
                var data = cs.get(nac);
                if (data != null) {
                    data.ref += 1;
                    data.life = DynamicFontAtlasCharacter.LIFE;
                }
                else {
                    cs.set(nac, this.newChar(nac, DynamicFontAtlasCharacterType.LETTER));
                    this._isDirty = true;
                }
            }
            if (0 < characters.length) {
                this._isTouched = true;
            }
        };
        DynamicSDFFontAtlas.prototype.get = function (id) {
            return this._characters.get(id);
        };
        DynamicSDFFontAtlas.prototype.update = function () {
            if (this._isDirty) {
                var canvas = this._canvas;
                var generator = this._generator;
                if (canvas != null && generator != null) {
                    var context_1 = canvas.getContext("2d");
                    if (context_1 != null) {
                        this._isDirty = false;
                        var font = this._font;
                        var fontSize_1 = font.size + 14;
                        var characters = this._characters;
                        var width_1 = this.toPowerOf2(Math.ceil(Math.sqrt(characters.size)) * fontSize_1);
                        this._width = width_1;
                        var fontStyle = (font.italic ? "italic " : "") + (font.size + "px ") + font.id;
                        context_1.font = fontStyle;
                        context_1.textAlign = "left";
                        context_1.textBaseline = "alphabetic";
                        context_1.lineWidth = 0;
                        context_1.lineCap = "round";
                        context_1.lineJoin = "miter";
                        context_1.miterLimit = 10;
                        context_1.fillStyle = "#FFFFFF";
                        UtilFont.measure(context_1, font);
                        var offsetX_1 = 7;
                        var offsetY_1 = Math.round((fontSize_1 - (font.ascent + font.descent)) * 0.5 + font.ascent);
                        var x_1 = 0;
                        var y_1 = 0;
                        characters.forEach(function (character) {
                            var advance = context_1.measureText(character.character).width;
                            var characterWidth = Math.ceil(offsetX_1 + advance + offsetX_1);
                            var characterHeight = fontSize_1;
                            if (width_1 <= x_1 + characterWidth) {
                                x_1 = 0;
                                y_1 += fontSize_1;
                            }
                            character.x = x_1;
                            character.y = y_1;
                            character.width = characterWidth;
                            character.height = characterHeight;
                            character.advance = advance;
                            character.origin.x = x_1 + offsetX_1;
                            character.origin.y = y_1 + offsetY_1;
                            x_1 += characterWidth;
                        });
                        var height = (this._height = y_1 + fontSize_1);
                        // Make a input canvas
                        // Here, we need to reset the context because
                        // context settings will be lost when we set the width/height.
                        canvas.width = width_1;
                        canvas.height = height;
                        context_1.font = fontStyle;
                        context_1.textAlign = "left";
                        context_1.textBaseline = "alphabetic";
                        context_1.lineWidth = 0;
                        context_1.lineCap = "round";
                        context_1.lineJoin = "miter";
                        context_1.miterLimit = 10;
                        context_1.fillStyle = "#FFFFFF";
                        context_1.clearRect(0, 0, width_1, height);
                        characters.forEach(function (character) {
                            context_1.fillText(character.character, character.origin.x, character.origin.y);
                        });
                        // Convert to SDF font texture
                        generator.updateTexture(width_1, height, canvas);
                        generator.render();
                        generator.read(canvas);
                        return true;
                    }
                }
            }
            return false;
        };
        Object.defineProperty(DynamicSDFFontAtlas.prototype, "length", {
            get: function () {
                return this._characters.size;
            },
            enumerable: false,
            configurable: true
        });
        DynamicSDFFontAtlas.prototype.toJson = function () {
            return {
                width: this._width,
                height: this._height,
                font: this._font,
                characters: this._characters
            };
        };
        DynamicSDFFontAtlas.prototype.toString = function () {
            return JSON.stringify(this.toJson());
        };
        DynamicSDFFontAtlas.prototype.destroy = function () {
            var generator = this._generator;
            if (generator != null) {
                this._generator = null;
            }
            var canvas = this._canvas;
            if (canvas != null) {
                this._canvas = null;
            }
            this._characters.clear();
        };
        DynamicSDFFontAtlas.prototype.toPowerOf2 = function (size) {
            var result = 32;
            while (result < size) {
                result <<= 1;
            }
            return result;
        };
        return DynamicSDFFontAtlas;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DynamicSDFFontAtlases = /** @class */ (function () {
        function DynamicSDFFontAtlases() {
            this._atlases = new Map();
        }
        DynamicSDFFontAtlases.prototype.begin = function () {
            this._atlases.forEach(function (atlas) {
                atlas.begin();
            });
        };
        DynamicSDFFontAtlases.prototype.end = function () {
            var atlases = this._atlases;
            atlases.forEach(function (atlas, family) {
                atlas.end();
                if (atlas.length <= 0) {
                    atlas.destroy();
                    atlases.delete(family);
                }
            });
        };
        DynamicSDFFontAtlases.prototype.add = function (family, characters, nacharacters) {
            var atlases = this._atlases;
            var atlas = atlases.get(family);
            if (atlas != null) {
                atlas.add(characters, nacharacters);
            }
            else {
                var newAtlas = new DynamicSDFFontAtlas(family);
                newAtlas.add(characters, nacharacters);
                atlases.set(family, newAtlas);
            }
        };
        DynamicSDFFontAtlases.prototype.get = function (family) {
            var atlas = this._atlases.get(family);
            if (atlas != null) {
                return atlas;
            }
            return null;
        };
        DynamicSDFFontAtlases.prototype.update = function (baseAtlas) {
            var baseTexture = baseAtlas.getBaseTexture();
            this._atlases.forEach(function (atlas) {
                var atlasId = atlas.id;
                if (atlas.update()) {
                    var item = baseAtlas.get(atlasId);
                    if (item != null) {
                        var width = atlas.width;
                        var height = atlas.height;
                        var resolution = baseTexture.resolution;
                        item.frame.width = width;
                        item.frame.height = height;
                        item.width = width / resolution;
                        item.height = height / resolution;
                        baseAtlas.toDirty();
                    }
                    else {
                        baseAtlas.set(atlasId, new DynamicAtlasItemFontAtlas(atlas, baseTexture));
                    }
                }
                else {
                    if (!baseAtlas.contains(atlasId)) {
                        baseAtlas.set(atlasId, new DynamicAtlasItemFontAtlas(atlas, baseTexture));
                    }
                }
            });
        };
        DynamicSDFFontAtlases.prototype.destroy = function () {
            var atlases = this._atlases;
            atlases.forEach(function (atlas) {
                atlas.destroy();
            });
            atlases.clear();
        };
        return DynamicSDFFontAtlases;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DynamicAtlasItemImage = /** @class */ (function (_super) {
        __extends(DynamicAtlasItemImage, _super);
        function DynamicAtlasItemImage(src, width, height, source, baseTexture) {
            var _this = _super.call(this, src, width / baseTexture.resolution, height / baseTexture.resolution, 0, baseTexture) || this;
            _this.source = source;
            return _this;
        }
        DynamicAtlasItemImage.prototype.render = function (context) {
            var frame = this.frame;
            var x = frame.x;
            var y = frame.y;
            var w = frame.width;
            var h = frame.height;
            var source = this.source;
            if (source instanceof ImageData) {
                context.putImageData(source, x, y);
                context.putImageData(source, x - 1, y, 0, 0, 1, h);
                context.putImageData(source, x, y - 1, 0, 0, w, 1);
                context.putImageData(source, x + w, y, w - 1, 0, 1, h);
                context.putImageData(source, x, y + h, 0, h - 1, w, 1);
            }
            else {
                context.drawImage(source, x, y, w, h);
                context.drawImage(source, 0, 0, 1, h, x - 1, y - 1, 1, h + 2);
                context.drawImage(source, 0, 0, w, 1, x, y - 1, w, 1);
                context.drawImage(source, w - 1, 0, 1, h, x + w, y - 1, 1, h + 2);
                context.drawImage(source, 0, h - 1, w, 1, x, y + h, w, 1);
            }
        };
        return DynamicAtlasItemImage;
    }(DynamicAtlasItem));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeBufferUnit = /** @class */ (function () {
        function EShapeBufferUnit(texture, indexOffset) {
            this.texture = texture;
            this.indexOffset = indexOffset;
        }
        return EShapeBufferUnit;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeBufferUnitBuilder = /** @class */ (function () {
        function EShapeBufferUnitBuilder() {
            this.index = 0;
            this.baseTexture = null;
            this.units = [];
        }
        EShapeBufferUnitBuilder.prototype.begin = function () {
            this.index = 0;
            this.baseTexture = null;
        };
        EShapeBufferUnitBuilder.prototype.push = function (texture, indexOffset) {
            if (this.index < this.units.length) {
                var unit = this.units[this.index];
                unit.texture = texture;
                unit.indexOffset = indexOffset;
            }
            else {
                this.units.push(new EShapeBufferUnit(texture, indexOffset));
            }
            this.index += 1;
        };
        EShapeBufferUnitBuilder.prototype.end = function () {
            if (this.units.length !== this.index) {
                this.units.length = this.index;
            }
        };
        EShapeBufferUnitBuilder.prototype.destroy = function () {
            this.units.length = 0;
        };
        return EShapeBufferUnitBuilder;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeBuffer = /** @class */ (function () {
        function EShapeBuffer(ntriangles, renderer) {
            var nindices = ntriangles * 3;
            var nvertices = nindices;
            this.vertices = new Float32Array(nvertices * 2);
            this._vertexCapacity = nvertices;
            this._vertexCount = 0;
            this._vertexBuffer = null;
            this.steps = new Float32Array(nvertices * 6);
            this._stepBuffer = null;
            this.colors = new Float32Array(nvertices * 3);
            this._colorBuffer = null;
            this.uvs = new Float32Array(nvertices * 2);
            this._uvBuffer = null;
            var isIndicesShort = nvertices <= 65535;
            this.indices = isIndicesShort ? new Uint16Array(nindices) : new Uint32Array(nindices);
            this._indexCapacity = ntriangles;
            this._indexCount = 0;
            this.indexCountRequested = 0;
            this._indexBuffer = null;
            this._renderer = renderer;
            this._builder = new EShapeBufferUnitBuilder();
            this._geometry = null;
        }
        EShapeBuffer.prototype.updateVertices = function () {
            var vertexBuffer = this._vertexBuffer;
            if (vertexBuffer) {
                vertexBuffer.update();
            }
        };
        EShapeBuffer.prototype.updateSteps = function () {
            var stepBuffer = this._stepBuffer;
            if (stepBuffer) {
                stepBuffer.update();
            }
        };
        EShapeBuffer.prototype.updateColors = function () {
            var colorBuffer = this._colorBuffer;
            if (colorBuffer) {
                colorBuffer.update();
            }
        };
        EShapeBuffer.prototype.updateUvs = function () {
            var uvBuffer = this._uvBuffer;
            if (uvBuffer) {
                uvBuffer.update();
            }
        };
        EShapeBuffer.prototype.updateIndices = function () {
            var indexBuffer = this._indexBuffer;
            if (indexBuffer) {
                indexBuffer.update();
            }
        };
        EShapeBuffer.prototype.getGeometry = function () {
            var result = this._geometry;
            if (result == null) {
                this._vertexBuffer = new pixi_js.Buffer(this.vertices, false, false);
                this._stepBuffer = new pixi_js.Buffer(this.steps, false, false);
                this._colorBuffer = new pixi_js.Buffer(this.colors, false, false);
                this._uvBuffer = new pixi_js.Buffer(this.uvs, false, false);
                this._indexBuffer = new pixi_js.Buffer(this.indices, false, true);
                this._geometry = result = new pixi_js.Geometry()
                    .addIndex(this._indexBuffer)
                    .addAttribute("aPosition", this._vertexBuffer, 2)
                    .addAttribute("aStepA", this._stepBuffer, 2)
                    .addAttribute("aStepB", this._stepBuffer, 4)
                    .addAttribute("aColor", this._colorBuffer, 3)
                    .addAttribute("aUv", this._uvBuffer, 2);
            }
            return result;
        };
        EShapeBuffer.prototype.upload = function () {
            this._renderer.geometry.bind(this.getGeometry());
        };
        EShapeBuffer.prototype.render = function (shader) {
            var renderer = this._renderer;
            renderer.geometry.bind(this.getGeometry());
            var units = this._builder.units;
            var unitCount = units.length;
            if (0 < unitCount) {
                var type = pixi_js.DRAW_MODES.TRIANGLES;
                var unit0 = null;
                var unit1 = units[0];
                var ioffset0 = 0;
                var ioffset1 = unit1.indexOffset * 3;
                var vcount = 0;
                var texture = pixi_js.Texture.WHITE;
                for (var i = 0, imax = unitCount - 1; i < imax; ++i) {
                    unit0 = unit1;
                    unit1 = units[i + 1];
                    ioffset0 = ioffset1;
                    ioffset1 = unit1.indexOffset * 3;
                    vcount = ioffset1 - ioffset0;
                    texture = unit0.texture || pixi_js.Texture.WHITE;
                    if (0 < vcount && texture.valid) {
                        shader.uniforms.sampler = renderer.texture.bind(texture);
                        renderer.geometry.draw(type, vcount, ioffset0);
                    }
                }
                vcount = this._indexCount * 3 - ioffset1;
                texture = unit1.texture || pixi_js.Texture.WHITE;
                if (0 < vcount && texture.valid) {
                    shader.uniforms.sampler = renderer.texture.bind(texture);
                    renderer.geometry.draw(type, vcount, ioffset1);
                }
            }
        };
        EShapeBuffer.prototype.update = function (iterator, antialiasWeight, noMoreThanOne) {
            var builder = this._builder;
            builder.begin();
            var vindex = 0;
            var iindex = 0;
            var shape = iterator.get();
            for (; shape != null; shape = iterator.next()) {
                var uploaded = shape.uploaded;
                if (uploaded == null) {
                    var creator = EShapeUploadeds[shape.type] || EShapeUploadeds[EShapeType.GROUP];
                    if (creator == null) {
                        break;
                    }
                    var newUploaded = creator(this, shape, vindex, iindex, antialiasWeight);
                    if (newUploaded == null) {
                        break;
                    }
                    uploaded = newUploaded;
                }
                else if (!uploaded.reinit(this, shape, vindex, iindex)) {
                    break;
                }
                uploaded.buildUnit(builder);
                vindex += uploaded.getVertexCount();
                iindex += uploaded.getIndexCount();
                if (noMoreThanOne) {
                    iterator.next();
                    break;
                }
            }
            builder.end();
            this._vertexCount = vindex;
            this._indexCount = iindex;
            return 0 < builder.units.length;
        };
        EShapeBuffer.prototype.check = function (vindex, ioffset, vcount, icount) {
            this.indexCountRequested = icount;
            return vindex + vcount <= this._vertexCapacity && ioffset + icount <= this._indexCapacity;
        };
        EShapeBuffer.prototype.destroy = function () {
            var geometry = this._geometry;
            if (geometry) {
                geometry.destroy();
            }
            this._builder.destroy();
        };
        return EShapeBuffer;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DUMMY_SHAPES = [];
    var EShapeRendererIteratorDatum = /** @class */ (function () {
        function EShapeRendererIteratorDatum() {
            this.index = 0;
            this.shapes = DUMMY_SHAPES;
            this.current = null;
        }
        return EShapeRendererIteratorDatum;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeRendererIterator = /** @class */ (function () {
        function EShapeRendererIterator() {
            this._index = -1;
            this._datum = new EShapeRendererIteratorDatum();
            this._data = [this._datum];
            this._current = null;
        }
        EShapeRendererIterator.prototype.reset = function (shape, shapes) {
            this._index = 0;
            var datum = this._data[0];
            datum.index = -1;
            datum.shapes = shapes;
            datum.current = null;
            this._datum = datum;
            if (shape != null) {
                this._current = shape;
                return shape;
            }
            return this.next();
        };
        EShapeRendererIterator.prototype.get = function () {
            return this._current;
        };
        EShapeRendererIterator.prototype.next = function () {
            while (true) {
                var datum = this._datum;
                var shapeIndex = (datum.index += 1);
                var shapes = datum.shapes;
                var shape = shapeIndex < shapes.length
                    ? (datum.current = shapes[shapeIndex])
                    : (datum.current = null);
                if (shape != null) {
                    var children = shape.children;
                    if (0 < children.length) {
                        var dataIndex = (this._index += 1);
                        var data = this._data;
                        if (dataIndex < data.length) {
                            var newDatum = data[dataIndex];
                            newDatum.index = -1;
                            newDatum.shapes = children;
                            newDatum.current = null;
                            this._datum = newDatum;
                        }
                        else {
                            var newDatum = new EShapeRendererIteratorDatum();
                            data.push(newDatum);
                            newDatum.index = -1;
                            newDatum.shapes = children;
                            newDatum.current = null;
                            this._datum = newDatum;
                        }
                    }
                    else {
                        this._current = shape;
                        return shape;
                    }
                }
                else {
                    var dataIndex = (this._index -= 1);
                    var data = this._data;
                    if (0 <= dataIndex) {
                        var newDatum = data[dataIndex];
                        this._datum = newDatum;
                        return (this._current = newDatum.current);
                    }
                    else {
                        return (this._current = null);
                    }
                }
            }
        };
        return EShapeRendererIterator;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var VERTEX_SHADER$1 = "\nattribute highp vec2 aPosition;\nattribute highp vec2 aStepA;\nattribute highp vec4 aStepB;\nattribute highp vec3 aColor;\nattribute highp vec2 aUv;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mediump float shapeScale;\nuniform mediump float antialiasWeight;\n\nvarying mediump float vType;\nvarying mediump vec2 vStepA;\nvarying mediump vec4 vStepB;\nvarying mediump vec4 vColorFill;\nvarying mediump vec4 vColorStroke;\nvarying mediump vec2 vUv;\n\nvec2 toInverse(in vec2 v) {\n\treturn vec2(-v.y, v.x);\n}\n\nvec4 toGeneral(in float v) {\n\tvec4 c = vec4(1.0, 1.0/64.0, 1.0/64.0/64.0, 1.0/64.0/64.0/64.0) * v;\n\tc -= fract(c);\n\tc -= c.yzwx * vec4(64.0, 64.0, 64.0, 0.0);\n\treturn c;\n}\n\nfloat toStrokeWidthScale(in float scale) {\n\treturn (\n\t\tscale == 3.0 || scale == 7.0 ?\n\t\tshapeScale : (\n\t\t\tscale == 1.0 || scale == 5.0 ?\n\t\t\tmin(1.0, shapeScale) : (\n\t\t\t\tscale == 2.0 || scale == 6.0 ?\n\t\t\t\tmax(1.0, shapeScale) : 1.0\n\t\t\t)\n\t\t)\n\t);\n}\n\nvec2 toUnpackedF2x1024(in float v) {\n\tvec2 c = vec2(1.0, 1.0/1024.0) * v;\n\tc -= fract(c);\n\tc -= c.yx * vec2(1024.0, 0.0);\n\tc /= vec2(1023.0, 1023.0);\n\treturn c;\n}\n\nvec3 toUnpackedF3x256(in float v) {\n\tvec3 c = vec3(1.0, 1.0/256.0, 1.0/256.0/256.0) * v;\n\tc -= fract(c);\n\tc -= c.yzx * vec3(256.0, 256.0, 0.0);\n\tc /= 255.0;\n\treturn c;\n}\n\nvec2 toPosition012(in vec2 v) {\n\treturn (projectionMatrix * translationMatrix * vec3(v, 1.0)).xy;\n}\n\nvec4 toStepB01(in vec4 sb) {\n\treturn vec4(sb.xy, toUnpackedF2x1024(sb.z));\n}\n\nvec4 toStepB2(in vec4 sb, in float strokeWidth) {\n\tfloat x = min(0.4, 0.4 / 12.0 * sb.x * antialiasWeight);\n\tfloat w = clamp(strokeWidth, 0.0, 1.0) * 0.4;\n\tfloat p = w * sb.y + sb.z;\n\tfloat y = 0.5 - p;\n\tfloat z = 0.5 - p - w;\n\treturn vec4(y, z, y - max(0.01, y - x), z - max(0.01, z - x));\n}\n\nvec2 toPosition3(in float type, in vec2 p, in float npacked, in float length, in float strokeWidth, out float shift) {\n\tvec3 t = vec3(1.0, 1.0/1024.0, 1.0/1024.0/1024.0) * npacked;\n\tt -= fract(t);\n\tt -= t.yzx * vec3(1024.0, 1024.0, 0.0);\n\tt *= vec3(1.0/511.5, 1.0/511.5, 1.0);\n\tt -= vec3(1.0, 1.0, 0.0);\n\tvec2 n0 = vec2(t.x, ((0.5 < t.z && t.z < 1.5) || 2.5 < t.z ? +1.0 : -1.0) * sqrt(max(0.0, 1.0 - t.x * t.x)));\n\tvec2 n1 = vec2(t.y, (1.5 < t.z ? +1.0 : -1.0) * sqrt(max(0.0, 1.0 - t.y * t.y)));\n\n\tvec2 n0i = toInverse(n0);\n\tvec2 n1i = toInverse(n1);\n\tfloat direction = sign(4.5 - type);\n\n\t// Offset\n\tfloat cross = dot(n0i, n1);\n\tbool bcross = 0.00001 < abs(cross);\n\tfloat crossi = (bcross ? 1.0 / cross : 0.0);\n\tfloat b = dot(n1 - n0, n0) * crossi;\n\tfloat offsetSize = direction * strokeWidth * 0.5;\n\tvec2 offset = n1 + n1i * b;\n\n\t// Miter\n\tvec2 pmiter = p + offsetSize * offset;\n\tfloat miterAngle0 = dot( n0i, offsetSize * offset - length * n0i );\n\tfloat miterAngle1 = dot( n1i, offsetSize * offset + length * n1i );\n\tfloat miterLength = dot( offset, offset );\n\tfloat miterSide = direction * cross;\n\n\t// Bevel\n\tvec2 n = (type == 4.0 || type == 6.0 ? n1 : n0);\n\tvec2 pbevel = p + offsetSize * n;\n\n\t//\n\tvec2 presult = (\n\t\t0.0 <= miterSide ?\n\t\t(miterAngle0 < 0.0 && 0.0 <= miterAngle1 && bcross ? pmiter : pbevel) :\n\t\t(miterLength < 6.0 && bcross ? pmiter : pbevel)\n\t);\n\tvec2 ni = (type == 4.0 || type == 6.0 ? n1i : n0i);\n\tshift = dot(ni, p - presult);\n\treturn toPosition012(presult);\n}\n\nvec2 toStepA3(in float type, in float strokeWidth) {\n\treturn vec2(type < 4.5 ? 1.0 : 0.0, strokeWidth);\n}\n\nvec4 toStepB3(in float shift, in float dash, in float strokeScaling, in float strokeWidthScale) {\n\tfloat l = aStepB.y + shift;\n\tfloat s = aStepA.x * (\n\t\tstrokeScaling == 4.0 || strokeScaling == 5.0 ||\n\t\tstrokeScaling == 6.0 || strokeScaling == 7.0 ?\n\t\tstrokeWidthScale : 1.0\n\t);\n\tfloat lt = aStepB.z;\n\treturn (dash < 0.5 ?\n\t\tvec4(l, 2.0 * abs(lt), 0.0, lt) :\n\t\t(dash < 3.5 ?\n\t\t\t(dash < 1.5 ?\n\t\t\t\tvec4(l, s, s, lt) :\n\t\t\t\t(2.5 < dash ?\n\t\t\t\t\tvec4(l, s, 2.0 * s, lt) :\n\t\t\t\t\tvec4(l, s, 0.5 * s, lt)\n\t\t\t\t)\n\t\t\t) :\n\t\t\t(dash < 4.5 ?\n\t\t\t\tvec4(l, 2.0 * s, s, lt) :\n\t\t\t\t(5.5 < dash ?\n\t\t\t\t\tvec4(l, 2.0 * s, 2.0 * s, lt) :\n\t\t\t\t\tvec4(l, 2.0 * s, 0.5 * s, lt)\n\t\t\t\t)\n\t\t\t)\n\t\t)\n\t);\n}\n\nvoid toColors(in vec3 source, out vec4 fillColor, out vec4 strokeColor) {\n\tvec2 a = toUnpackedF2x1024(source.z);\n\tfillColor.xyz = toUnpackedF3x256(source.x).zyx * a.x;\n\tfillColor.w = a.x;\n\tstrokeColor.xyz = toUnpackedF3x256(source.y).zyx * a.y;\n\tstrokeColor.w = a.y;\n}\n\nvoid main(void) {\n\tvec4 general = toGeneral(aStepA.y);\n\tfloat type = general.x;\n\tfloat strokeScaling = general.y;\n\tfloat strokeWidthScale = toStrokeWidthScale(strokeScaling);\n\tfloat strokeWidth = strokeWidthScale * aStepA.x;\n\n\t// Type 0, 1\n\tvec2 p012 = toPosition012(aPosition);\n\tvec2 sa012 = strokeWidth * general.zw;\n\tvec4 sb01 = toStepB01(aStepB);\n\n\t// Type 2\n\tvec4 sb2 = toStepB2(aStepB, strokeWidth);\n\n\t// Type 3 ~ 6\n\tfloat shift3 = 0.0;\n\tvec2 p3 = toPosition3(type, aPosition, aStepB.x, aStepB.w, strokeWidth, shift3);\n\tvec2 sa3 = toStepA3(type, strokeWidth);\n\tvec4 sb3 = toStepB3(shift3, general.z, strokeScaling, strokeWidthScale);\n\n\t//\n\tgl_Position = vec4((2.5 < type ? p3 : p012), 0.0, 1.0);\n\tvType = type;\n\tvStepA = (2.5 < type ? sa3 : sa012);\n\tvStepB = (1.5 < type ? (2.5 < type ? sb3 : sb2) : sb01);\n\ttoColors(aColor, vColorFill, vColorStroke);\n\tvUv = aUv;\n}";
    var FRAGMENT_SHADER$1 = "\nvarying mediump float vType;\nvarying mediump vec2 vStepA;\nvarying mediump vec4 vStepB;\nvarying mediump vec4 vColorFill;\nvarying mediump vec4 vColorStroke;\nvarying mediump vec2 vUv;\n\nuniform sampler2D sampler;\nuniform mediump float antialiasWeight;\n\nvec4 toColor0(in vec4 texture) {\n\tvec2 d = vStepB.xy;\n\tvec2 c = vStepB.zw;\n\tvec2 awd = antialiasWeight / d;\n\tvec2 swd = vStepA / d;\n\tvec2 one = vec2(1.0);\n\tvec2 zero = vec2(0.0);\n\tvec2 p0 = clamp(one - awd, zero, one);\n\tvec2 p1 = clamp(one - swd, zero, one);\n\tvec2 p2 = clamp(one - swd - awd, zero, one);\n\tvec2 s0 = smoothstep(p0, one, c);\n\tvec2 s1 = smoothstep(p2, p1, c);\n\tfloat s2 = max(s0.x, s0.y);\n\tfloat s3 = max(s1.x, s1.y);\n\treturn texture * (\n\t\tvColorStroke * (s3 - s2) +\n\t\tvColorFill * (1.0 - s3)\n\t);\n}\n\nvec4 toColor1(in vec4 texture) {\n\tvec2 d = vStepB.xy;\n\tvec2 c = vStepB.zw;\n\tvec2 awd = antialiasWeight / d;\n\tvec2 swd = vStepA / d;\n\tvec2 one = vec2(1.0);\n\tvec2 zero = vec2(0.0);\n\tfloat s0 = smoothstep(length(c), length(c/clamp(one - awd, zero, one)), 1.0);\n\tfloat s1 = smoothstep(length(c/clamp(one - swd, zero, one)), length(c/clamp(one - swd - awd, zero, one)), 1.0);\n\treturn texture * (\n\t\tvColorStroke * (s0 - s1) +\n\t\tvColorFill * s1\n\t);\n}\n\nvec4 toColor2(in vec4 texture) {\n\tvec2 p0 = vStepB.xy;\n\tvec2 p1 = vStepB.zw;\n\tvec2 d = vec2(dot(texture, vec4(1.0, 1.0/255.0, 1.0/255.0/255.0, 0.0)));\n\tvec2 s = smoothstep(p0 - p1, p0 + p1, d);\n\treturn vColorStroke * (s.y - s.x) + vColorFill * s.x;\n}\n\nvec4 toColor3(in vec4 texture) {\n\tfloat l = vStepB.x;\n\tfloat lp0 = vStepB.y;\n\tfloat lp1 = vStepB.z;\n\tfloat lt = vStepB.w;\n\tfloat ld = antialiasWeight;\n\tfloat lm = mod(l, lp0 + lp1);\n\tfloat ls0 = (0.0 < lp1 ? smoothstep(0.0, ld, lm) - smoothstep(lp0, lp0 + ld, lm) : 1.0);\n\tfloat ls1 = (0.0 <= lt ? smoothstep(0.0, ld, l) - smoothstep(lt - ld, lt, l) : 1.0);\n\n\tfloat c = vStepA.x;\n\tfloat awd = antialiasWeight / vStepA.y;\n\tfloat p0 = clamp(awd, 0.0, 1.0);\n\tfloat p1 = clamp(1.0 - awd, 0.0, 1.0);\n\tfloat s0 = smoothstep(0.0, p0, c);\n\tfloat s1 = smoothstep(p1, 1.0, c);\n\treturn texture * vColorStroke * (s0 - s1) * ls0 * ls1;\n}\n\nvoid main(void) {\n\tvec4 texture = texture2D(sampler, vUv);\n\tgl_FragColor = (vType < 1.5 ?\n\t\t(vType < 0.5 ?\n\t\t\ttoColor0(texture) :\n\t\t\ttoColor1(texture)\n\t\t) :\n\t\t(vType < 2.5 ?\n\t\t\ttoColor2(texture) :\n\t\t\ttoColor3(texture)\n\t\t)\n\t);\n}";
    var EShapeRenderer = /** @class */ (function (_super) {
        __extends(EShapeRenderer, _super);
        function EShapeRenderer(renderer) {
            var _this = _super.call(this, renderer) || this;
            EShapeRenderer.SHADER =
                EShapeRenderer.SHADER || pixi_js.Shader.from(VERTEX_SHADER$1, FRAGMENT_SHADER$1);
            _this._shader = EShapeRenderer.SHADER;
            _this._iterator = new EShapeRendererIterator();
            _this._bufferSizeMax = _this.getBufferSizeMax(renderer);
            return _this;
        }
        EShapeRenderer.prototype.getBufferSizeMax = function (renderer) {
            var context = renderer.context;
            var extensions = context.extensions;
            if (1 < context.webGLVersion || !!extensions.uint32ElementIndex) {
                return 1431655765; // 2^32 / 3
            }
            return 21845; // 2^16 / 3
        };
        EShapeRenderer.prototype.updateAtlas = function (shape, atlas, fontAtlases, defaultTexture, baseTexture) {
            // Texture
            // Do not access the shape.image.source here.
            // It slows down the rendering speed significantly.
            var image = shape.image;
            if (image != null) {
                var textureItem = atlas.get(image.url);
                if (textureItem != null) {
                    shape.texture = textureItem.texture;
                }
                else {
                    var newTextureItem = new DynamicAtlasItemImage(image.url, image.width, image.height, image.source, baseTexture);
                    shape.texture = newTextureItem.texture;
                    atlas.set(newTextureItem.id, newTextureItem);
                }
            }
            else {
                shape.texture = defaultTexture;
            }
            // Font texture atlas
            var text = shape.text;
            var textCharacters = text.characters;
            if (0 < textCharacters.length) {
                fontAtlases.add(text.family, textCharacters, text.nacharacters);
            }
        };
        EShapeRenderer.prototype.updateAtlases = function (shapes, atlas, fontAtlases, defaultTexture, baseTexture) {
            for (var i = 0, imax = shapes.length; i < imax; ++i) {
                var shape = shapes[i];
                this.updateAtlas(shape, atlas, fontAtlases, defaultTexture, baseTexture);
                var children = shape.children;
                for (var j = 0, jmax = children.length; j < jmax; ++j) {
                    var child = children[j];
                    this.updateAtlas(child, atlas, fontAtlases, defaultTexture, baseTexture);
                    this.updateAtlases(child.children, atlas, fontAtlases, defaultTexture, baseTexture);
                }
            }
        };
        EShapeRenderer.prototype.updateFontAtlas = function (shape, atlas, fontAtlases, defaultTexture) {
            var text = shape.text;
            var fontAtlas = fontAtlases.get(text.family);
            if (fontAtlas != null) {
                var textureItem = atlas.get(fontAtlas.id);
                if (textureItem != null) {
                    text.atlas = fontAtlas;
                    text.texture = textureItem.texture;
                }
                else {
                    text.atlas = undefined;
                    text.texture = defaultTexture;
                }
            }
            else {
                text.atlas = undefined;
                text.texture = defaultTexture;
            }
        };
        EShapeRenderer.prototype.updateFontAtlases = function (shapes, atlas, fontAtlases, defaultTexture) {
            for (var i = 0, imax = shapes.length; i < imax; ++i) {
                var shape = shapes[i];
                this.updateFontAtlas(shape, atlas, fontAtlases, defaultTexture);
                var children = shape.children;
                for (var j = 0, jmax = children.length; j < jmax; ++j) {
                    var child = children[j];
                    this.updateFontAtlas(child, atlas, fontAtlases, defaultTexture);
                    this.updateFontAtlases(child.children, atlas, fontAtlases, defaultTexture);
                }
            }
        };
        EShapeRenderer.prototype.render_ = function (container, shape, shapes, isDirty) {
            var renderer = this.renderer;
            var shader = this._shader;
            if (shader != null && (shape != null || 0 < shapes.length)) {
                var resolution = renderer.resolution;
                var buffers = container.getBuffers();
                var antialiasWeight = container.toAntialiasWeight(resolution);
                // Update textures
                if (isDirty) {
                    // Atlases
                    var atlas = container.getAtlas(resolution);
                    var fontAtlases = container.getFontAtlases();
                    atlas.begin();
                    fontAtlases.begin();
                    var defaultTexture = atlas.getDefaultTexture();
                    var baseTexture = atlas.getBaseTexture();
                    this.updateAtlases(shapes, atlas, fontAtlases, defaultTexture, baseTexture);
                    fontAtlases.end();
                    fontAtlases.update(atlas);
                    this.updateFontAtlases(shapes, atlas, fontAtlases, defaultTexture);
                    atlas.end();
                    atlas.repack();
                    // Update buffers
                    this.updateBuffers(shape, shapes, buffers, renderer, antialiasWeight);
                }
                // Render buffers
                shader.uniforms.shapeScale = container.toShapeScale();
                shader.uniforms.antialiasWeight = container.toPixelScale(resolution) * antialiasWeight;
                shader.uniforms.translationMatrix = container.worldTransform.toArray(true);
                renderer.shader.bind(shader, false);
                renderer.state.setBlendMode(pixi_js.utils.correctBlendMode(pixi_js.BLEND_MODES.NORMAL, true));
                var buffersLength = buffers.length;
                if (1 < buffersLength) {
                    for (var i = 0; i < buffersLength; ++i) {
                        buffers[i].upload();
                    }
                }
                for (var i = 0; i < buffersLength; ++i) {
                    buffers[i].render(shader);
                }
            }
        };
        EShapeRenderer.prototype.updateBuffers = function (shape, shapes, buffers, renderer, antialiasWeight) {
            var iterator = this._iterator;
            iterator.reset(shape, shapes);
            var ib = 0;
            var bufferSize = 0;
            var bufferSizeBase = 5000;
            var bufferSizeMax = this._bufferSizeMax;
            while (iterator.get() != null) {
                var buffer = null;
                var noMoreThanOne = false;
                if (0 < bufferSize) {
                    buffer = new EShapeBuffer(bufferSize, renderer);
                    buffers.splice(ib, 0, buffer);
                    noMoreThanOne = true;
                }
                else if (ib < buffers.length) {
                    buffer = buffers[ib];
                    noMoreThanOne = false;
                }
                else {
                    buffer = new EShapeBuffer(bufferSizeBase, renderer);
                    buffers.push(buffer);
                    noMoreThanOne = false;
                }
                if (buffer.update(iterator, antialiasWeight, noMoreThanOne)) {
                    bufferSize = 0;
                    ib += 1;
                }
                else {
                    bufferSize = buffer.indexCountRequested;
                    if (bufferSize <= bufferSizeMax) {
                        bufferSize = Math.ceil(bufferSize / bufferSizeBase) * bufferSizeBase;
                        bufferSize = Math.min(bufferSize, bufferSizeMax);
                    }
                    else {
                        // No way to render
                        break;
                    }
                }
            }
            if (ib < buffers.length) {
                for (var jb = ib, ibmax = buffers.length; jb < ibmax; ++jb) {
                    buffers[jb].destroy();
                }
                buffers.length = ib;
            }
        };
        EShapeRenderer.SHADER = null;
        return EShapeRenderer;
    }(pixi_js.ObjectRenderer));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeContainer = /** @class */ (function (_super) {
        __extends(EShapeContainer, _super);
        function EShapeContainer() {
            var _this = _super.call(this) || this;
            _this._shapeRenderer = null;
            _this.children = [];
            _this._shape = null;
            _this._childrenId = 0;
            _this._childrenIdRendered = -1;
            _this._atlas = null;
            _this._fontAtlases = new DynamicSDFFontAtlases();
            _this._pixelScale = 1;
            _this._pixelScaleId = -2; // Since this._shapeScaleId starts from -1.
            _this._shapeScale = 1;
            _this._shapeScaleId = -1; // Since Transform._worldID starts from zero.
            _this._work = new pixi_js.Point();
            _this._buffers = [];
            return _this;
        }
        EShapeContainer.prototype.calculateBounds = function () {
            this._bounds.clear();
        };
        EShapeContainer.prototype.onChildTransformChange = function () {
            // DO NOTHING
        };
        EShapeContainer.prototype.toDirty = function () {
            return (this._childrenId += 1);
        };
        EShapeContainer.prototype.isDirty = function () {
            return this._childrenIdRendered < this._childrenId;
        };
        EShapeContainer.prototype.render = function (renderer) {
            if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {
                return;
            }
            var childrenId = this._childrenId;
            var childrenIdRendered = this._childrenIdRendered;
            this._childrenIdRendered = childrenId;
            var isChildrenDirty = childrenIdRendered < childrenId;
            var shapeRenderer = this._shapeRenderer;
            if (shapeRenderer == null) {
                shapeRenderer = this._shapeRenderer = new EShapeRenderer(renderer);
            }
            renderer.batch.setObjectRenderer(shapeRenderer);
            var mask = this.mask;
            var shape = this._shape;
            var shapes = this.children;
            if (mask) {
                renderer.mask.push(this, mask);
                shapeRenderer.render_(this, shape, shapes, isChildrenDirty);
                renderer.mask.pop(this);
            }
            else {
                shapeRenderer.render_(this, shape, shapes, isChildrenDirty);
            }
        };
        EShapeContainer.prototype.containsPoint = function (point) {
            return false;
        };
        EShapeContainer.prototype.getFontAtlases = function () {
            return this._fontAtlases;
        };
        EShapeContainer.prototype.getAtlas = function (resolution) {
            var atlas = this._atlas;
            if (atlas == null) {
                atlas = new DynamicAtlas(resolution);
                this._atlas = atlas;
            }
            return atlas;
        };
        EShapeContainer.prototype.getBuffers = function () {
            return this._buffers;
        };
        EShapeContainer.prototype.toShapeScale = function () {
            this.updateTransform();
            var transform = this.transform;
            var worldID = transform._worldID;
            if (worldID !== this._shapeScaleId) {
                this._shapeScaleId = worldID;
                var worldTransform = transform.worldTransform;
                var a = worldTransform.a;
                var b = worldTransform.b;
                this._shapeScale = 1 / Math.sqrt(a * a + b * b);
            }
            return this._shapeScale;
        };
        EShapeContainer.prototype.getShapeScale = function () {
            return this._shapeScale;
        };
        EShapeContainer.prototype.toPixelScale = function (resolution) {
            var shapeScale = this.toShapeScale();
            var shapeScaleId = this._shapeScaleId;
            if (this._pixelScaleId !== shapeScaleId) {
                this._pixelScaleId = shapeScaleId;
                this._pixelScale = (1 / resolution) * shapeScale;
            }
            return this._pixelScale;
        };
        EShapeContainer.prototype.getPixelScale = function () {
            return this._pixelScale;
        };
        EShapeContainer.prototype.toAntialiasWeight = function (resolution) {
            return 1.25 / resolution;
        };
        EShapeContainer.prototype.hitTest = function (global, onHit) {
            var local = this._work;
            var children = this.children;
            for (var i = children.length - 1; 0 <= i; --i) {
                var child = children[i];
                if (child.visible) {
                    child.toLocal(global, undefined, local);
                    var result = child.contains(local.x, local.y);
                    if (result != null) {
                        if (onHit == null || onHit(result)) {
                            return result;
                        }
                    }
                }
            }
            return null;
        };
        EShapeContainer.prototype.hitTestBBox = function (global, onHit) {
            var local = this._work;
            var children = this.children;
            for (var i = children.length - 1; 0 <= i; --i) {
                var child = children[i];
                if (child.visible) {
                    child.toLocal(global, undefined, local);
                    if (child.containsBBox(local.x, local.y)) {
                        if (onHit == null || onHit(child)) {
                            return child;
                        }
                    }
                }
            }
            return null;
        };
        EShapeContainer.prototype.destroy = function () {
            // Buffer
            var buffers = this._buffers;
            if (buffers != null) {
                for (var i = 0, imax = buffers.length; i < imax; ++i) {
                    buffers[i].destroy();
                }
            }
            this._buffers.length = 0;
            // Shapes
            var children = this.children;
            for (var i = children.length - 1; 0 <= i; --i) {
                children[i].destroy();
            }
            children.length = 0;
            // Atlas
            var atlas = this._atlas;
            if (atlas != null) {
                atlas.destroy();
            }
            // Font Atlas
            this._fontAtlases.destroy();
            //
            _super.prototype.destroy.call(this);
        };
        return EShapeContainer;
    }(pixi_js.DisplayObject));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeEmbeddedLayer = /** @class */ (function (_super) {
        __extends(EShapeEmbeddedLayer, _super);
        function EShapeEmbeddedLayer(name, mode, depth, type) {
            if (type === void 0) { type = EShapeType.EMBEDDED_LAYER; }
            var _this = _super.call(this, mode, depth, type) || this;
            _this._name = name;
            return _this;
        }
        Object.defineProperty(EShapeEmbeddedLayer.prototype, "name", {
            get: function () {
                return this._name;
            },
            enumerable: false,
            configurable: true
        });
        EShapeEmbeddedLayer.prototype.newGroupFill = function () {
            return new EShapeFillImpl(this, false, 0xffffff, 1);
        };
        EShapeEmbeddedLayer.prototype.isGroupSizeFittable = function () {
            return false;
        };
        EShapeEmbeddedLayer.prototype.newGroupSize = function (mode, depth) {
            var sizeX = EShapeDefaults.SIZE_X;
            var sizeY = EShapeDefaults.SIZE_Y;
            return new EShapeGroupSizeViewer(this, sizeX, sizeY, sizeX, sizeY);
        };
        EShapeEmbeddedLayer.prototype.clone = function () {
            var result = this.newClone().copy(this);
            var children = this.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                var clone = children[i].clone();
                clone.parent = result;
                result.children.push(clone);
            }
            result.onChildTransformChange();
            result.toDirty();
            var size = this.size;
            if (size instanceof EShapeGroupSizeViewer) {
                var base = size.base;
                result.size.set(base.x, base.y).init().set(size.x, size.y);
            }
            else {
                result.size.init();
            }
            return result;
        };
        EShapeEmbeddedLayer.prototype.newClone = function () {
            var constructor = this.constructor;
            return new constructor(this._name, this._mode, this._depth, this.type);
        };
        EShapeEmbeddedLayer.prototype.serializeChildren = function (manager) {
            return [];
        };
        EShapeEmbeddedLayer.prototype.serializeImage = function (manager) {
            return -1;
        };
        EShapeEmbeddedLayer.prototype.serializeGradient = function (manager) {
            return -1;
        };
        return EShapeEmbeddedLayer;
    }(EShapeGroupViewer));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDiagramLayers = /** @class */ (function () {
        function DDiagramLayers() {
        }
        DDiagramLayers.toLayers = function (shape, indices) {
            var result = [];
            var layer = this.toLayer(shape);
            if (layer) {
                var container = layer.parent;
                if (container) {
                    var children = container.children;
                    var childrenLength = children.length;
                    for (var i = 0, imax = indices.length; i < imax; ++i) {
                        var index = indices[i];
                        if (0 <= index && index < childrenLength) {
                            result.push(children[index]);
                        }
                    }
                }
            }
            return result;
        };
        DDiagramLayers.toLayer = function (shape) {
            var parent = shape.parent;
            while (parent != null) {
                if (parent instanceof EShapeContainer) {
                    return parent;
                }
                if (parent instanceof EShapeEmbeddedLayer) {
                    return parent;
                }
                parent = parent.parent;
            }
            return null;
        };
        DDiagramLayers.show = function (target) {
            if (!target.visible) {
                target.visible = true;
                return true;
            }
            return false;
        };
        DDiagramLayers.showAll = function (targets) {
            var isChanged = false;
            for (var i = 0, imax = targets.length; i < imax; ++i) {
                var layer = targets[i];
                if (!layer.visible) {
                    layer.visible = true;
                    isChanged = true;
                }
            }
            return isChanged;
        };
        DDiagramLayers.hide = function (target) {
            if (target.visible) {
                target.visible = false;
                return true;
            }
            return false;
        };
        DDiagramLayers.hideAll = function (targets) {
            var isChanged = false;
            for (var i = 0, imax = targets.length; i < imax; ++i) {
                var layer = targets[i];
                if (layer.visible) {
                    layer.visible = false;
                    isChanged = true;
                }
            }
            return isChanged;
        };
        DDiagramLayers.bringToFront = function (target) {
            var parent = target.parent;
            if (parent) {
                return this.doBringToFront(target, parent.children, 0);
            }
            return false;
        };
        DDiagramLayers.bringAllToFront = function (targets) {
            var targetsLength = targets.length;
            if (0 < targetsLength) {
                var parent_1 = targets[0].parent;
                if (parent_1) {
                    var isChanged = false;
                    var layers = parent_1.children;
                    for (var i = 0; i < targetsLength; ++i) {
                        var layer = targets[targetsLength - 1 - i];
                        if (this.doBringToFront(layer, layers, i)) {
                            isChanged = true;
                        }
                    }
                    return isChanged;
                }
            }
            return false;
        };
        DDiagramLayers.doBringToFront = function (target, layers, offset) {
            var layersLength = layers.length;
            var ito = layersLength - 1 - offset;
            for (var i = ito; 0 <= i; --i) {
                var child = layers[i];
                if (child === target) {
                    if (i !== ito) {
                        for (var j = i + 1; j <= ito; ++j) {
                            layers[j - 1] = layers[j];
                        }
                        layers[ito] = child;
                        return true;
                    }
                    return false;
                }
            }
            return false;
        };
        return DDiagramLayers;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var CTRL = 1;
    var SHIFT = 2;
    var ALT = 4;
    var AND = 8;
    var OR = 16;
    var UtilGestureModifier = {
        NONE: 0,
        CTRL: CTRL,
        SHIFT: SHIFT,
        ALT: ALT,
        AND: AND,
        OR: OR,
        NOT_NONE: CTRL | SHIFT | ALT | OR
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var UtilGestureModifiers = /** @class */ (function () {
        function UtilGestureModifiers() {
        }
        UtilGestureModifiers.from = function (e) {
            var oe = "data" in e ? e.data.originalEvent : e;
            return ((oe.ctrlKey ? UtilGestureModifier.CTRL : UtilGestureModifier.NONE) |
                (oe.altKey ? UtilGestureModifier.ALT : UtilGestureModifier.NONE) |
                (oe.shiftKey ? UtilGestureModifier.SHIFT : UtilGestureModifier.NONE));
        };
        UtilGestureModifiers.match = function (e, modifier) {
            if (modifier & UtilGestureModifier.OR) {
                return !!(UtilGestureModifiers.from(e) & modifier);
            }
            else {
                return UtilGestureModifiers.from(e) === modifier;
            }
        };
        return UtilGestureModifiers;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var UtilPointerEvent = /** @class */ (function () {
        function UtilPointerEvent() {
        }
        Object.defineProperty(UtilPointerEvent, "touchable", {
            get: function () {
                return "ontouchstart" in document;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UtilPointerEvent, "tap", {
            get: function () {
                return "pointertap";
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UtilPointerEvent, "down", {
            get: function () {
                return "pointerdown";
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UtilPointerEvent, "enter", {
            get: function () {
                return "pointerenter";
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UtilPointerEvent, "leave", {
            get: function () {
                return "pointerleave";
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UtilPointerEvent, "move", {
            get: function () {
                return "pointermove";
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UtilPointerEvent, "out", {
            get: function () {
                return "pointerout";
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UtilPointerEvent, "over", {
            get: function () {
                return "pointerover";
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UtilPointerEvent, "up", {
            get: function () {
                return "pointerup";
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UtilPointerEvent, "upoutside", {
            get: function () {
                return "pointerupoutside";
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UtilPointerEvent, "cancel", {
            get: function () {
                return "pointercancel";
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UtilPointerEvent, "righttap", {
            get: function () {
                return "rightclick";
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UtilPointerEvent, "rightdown", {
            get: function () {
                return "rightdown";
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UtilPointerEvent, "rightup", {
            get: function () {
                return "rightup";
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UtilPointerEvent, "rightupoutside", {
            get: function () {
                return "rightupoutside";
            },
            enumerable: false,
            configurable: true
        });
        UtilPointerEvent.toGlobal = function (e, interactionManager, result) {
            if ("touches" in e) {
                var touches = e.changedTouches;
                var touch = touches[touches.length - 1];
                if (touch != null) {
                    interactionManager.mapPositionToPoint(result, touch.clientX, touch.clientY);
                }
                else {
                    interactionManager.mapPositionToPoint(result, 0, 0);
                }
            }
            else {
                interactionManager.mapPositionToPoint(result, e.clientX, e.clientY);
            }
            return result;
        };
        UtilPointerEvent.onDblClick = function (target, onDblClick) {
            var _this = this;
            target.addEventListener("dblclick", function (e) { return onDblClick(e, false); });
            if (this.touchable) {
                var isDowned_1 = 0;
                var downX_1 = 0;
                var downY_1 = 0;
                var clickTime_1 = 0;
                target.addEventListener("touchstart", function (e) {
                    if (isDowned_1 !== 0 && isDowned_1 !== 2) {
                        isDowned_1 = 0;
                        return;
                    }
                    var touches = e.touches;
                    var touchesLength = touches.length;
                    if (touchesLength <= 0) {
                        isDowned_1 = 0;
                        return;
                    }
                    var touch = touches.item(touchesLength - 1);
                    if (touch == null) {
                        isDowned_1 = 0;
                        return;
                    }
                    isDowned_1 += 1;
                    downX_1 = touch.clientX;
                    downY_1 = touch.clientY;
                });
                target.addEventListener("touchend", function (e) {
                    if (isDowned_1 !== 1 && isDowned_1 !== 3) {
                        isDowned_1 = 0;
                        return;
                    }
                    var touches = e.changedTouches;
                    var touchesLength = touches.length;
                    if (touchesLength <= 0) {
                        isDowned_1 = 0;
                        return;
                    }
                    var touch = touches[touchesLength - 1];
                    if (touch == null) {
                        isDowned_1 = 0;
                        return;
                    }
                    var dx = downX_1 - touch.clientX;
                    var dy = downY_1 - touch.clientY;
                    if (_this.CLICK_DISTANCE_THRESHOLD <= Math.abs(dx) + Math.abs(dy)) {
                        isDowned_1 = 0;
                        return;
                    }
                    if (isDowned_1 === 1) {
                        clickTime_1 = e.timeStamp;
                        isDowned_1 = 2;
                    }
                    else {
                        var elapsedTime = e.timeStamp - clickTime_1;
                        if (elapsedTime < _this.DBLCLICK_INTERVAL_THRESHOLD) {
                            isDowned_1 = 0;
                            onDblClick(e, true);
                        }
                        else {
                            clickTime_1 = e.timeStamp;
                            isDowned_1 = 2;
                        }
                    }
                });
                target.addEventListener("touchcancel", function () {
                    isDowned_1 = 0;
                });
            }
        };
        UtilPointerEvent.contains = function (target, targetOrChild) {
            var current = targetOrChild;
            while (current != null && current !== target) {
                current = current.parent;
            }
            return current === target;
        };
        UtilPointerEvent.CLICK_DISTANCE_THRESHOLD = 10;
        UtilPointerEvent.DBLCLICK_INTERVAL_THRESHOLD = 333;
        UtilPointerEvent.LONG_CLICK_THRESHOLD = 750;
        return UtilPointerEvent;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var UtilGestureData = /** @class */ (function () {
        function UtilGestureData() {
            this.pointers = new Map();
            this.center = new pixi_js.Point();
            this.scale = 0;
            this.time = 0;
            this.distance = 0;
        }
        UtilGestureData.prototype.start = function (e) {
            var oe = e.data.originalEvent;
            if ("pointerId" in oe) {
                this.pointers.set(oe.pointerId, oe);
            }
            this.doUpdate(e);
        };
        UtilGestureData.prototype.isUpdatable = function (e) {
            var oe = e.data.originalEvent;
            if ("pointerId" in oe) {
                return this.pointers.has(oe.pointerId);
            }
            return true;
        };
        UtilGestureData.prototype.update = function (e) {
            var oe = e.data.originalEvent;
            if ("pointerId" in oe) {
                this.pointers.set(oe.pointerId, oe);
            }
            this.doUpdate(e);
        };
        UtilGestureData.prototype.end = function (e) {
            var result = true;
            var oe = e.data.originalEvent;
            if ("touches" in oe) {
                result = oe.touches.length <= 0;
            }
            else if ("pointerId" in oe) {
                var pointers = this.pointers;
                pointers.delete(oe.pointerId);
                result = pointers.size <= 0;
            }
            this.doUpdate(e);
            return result;
        };
        UtilGestureData.prototype.bind = function (e) {
            var interactionManager = this.interactionManager;
            if (interactionManager) {
                var onMove = this.onMove;
                if (onMove) {
                    interactionManager.on(UtilPointerEvent.move, onMove);
                }
                var onEnd = this.onEnd;
                if (onEnd) {
                    interactionManager.on(UtilPointerEvent.up, onEnd);
                    interactionManager.on(UtilPointerEvent.upoutside, onEnd);
                    interactionManager.on(UtilPointerEvent.cancel, onEnd);
                }
            }
        };
        UtilGestureData.prototype.unbind = function () {
            var interactionManager = this.interactionManager;
            if (interactionManager) {
                var onMove = this.onMove;
                if (onMove) {
                    interactionManager.off(UtilPointerEvent.move, onMove);
                }
                var onEnd = this.onEnd;
                if (onEnd) {
                    interactionManager.off(UtilPointerEvent.up, onEnd);
                    interactionManager.off(UtilPointerEvent.upoutside, onEnd);
                    interactionManager.off(UtilPointerEvent.cancel, onEnd);
                }
            }
        };
        UtilGestureData.prototype.doUpdate = function (e) {
            var interactionManager = this.interactionManager;
            var center = this.center;
            var oe = e.data.originalEvent;
            this.scale = 0;
            this.time = oe.timeStamp;
            if ("touches" in oe) {
                var touches = oe.touches;
                var touchesLength = touches.length;
                if (0 < touchesLength) {
                    // Update the center
                    var centerX = 0;
                    var centerY = 0;
                    for (var i = 0, imax = touches.length; i < imax; ++i) {
                        var touch = touches[i];
                        centerX += touch.clientX;
                        centerY += touch.clientY;
                    }
                    centerX /= touchesLength;
                    centerY /= touchesLength;
                    if (interactionManager) {
                        interactionManager.mapPositionToPoint(center, centerX, centerY);
                    }
                    else {
                        center.set(centerX, centerY);
                    }
                    if (1 < touchesLength) {
                        // Calculate the maximum distance from the center
                        var squareDistance = 0;
                        for (var i = 1, imax = touches.length; i < imax; ++i) {
                            var touch = touches[i];
                            var dx = touch.clientX - centerX;
                            var dy = touch.clientY - centerY;
                            squareDistance = Math.max(squareDistance, dx * dx + dy * dy);
                        }
                        this.scale = Math.sqrt(squareDistance);
                    }
                }
            }
            else if ("pointerId" in oe) {
                var pointers = this.pointers;
                var pointersSize = pointers.size;
                if (0 < pointersSize) {
                    // Update the center
                    var centerX_1 = 0;
                    var centerY_1 = 0;
                    pointers.forEach(function (pointer) {
                        centerX_1 += pointer.clientX;
                        centerY_1 += pointer.clientY;
                    });
                    centerX_1 /= pointersSize;
                    centerY_1 /= pointersSize;
                    if (interactionManager) {
                        interactionManager.mapPositionToPoint(center, centerX_1, centerY_1);
                    }
                    else {
                        center.set(centerX_1, centerY_1);
                    }
                    if (1 < pointersSize) {
                        // Calculate the maximum distance from the center
                        var squareDistance_1 = 0;
                        pointers.forEach(function (pointer) {
                            var dx = pointer.clientX - centerX_1;
                            var dy = pointer.clientY - centerY_1;
                            squareDistance_1 = Math.max(squareDistance_1, dx * dx + dy * dy);
                        });
                        this.scale = Math.sqrt(squareDistance_1);
                    }
                }
            }
            else {
                center.copyFrom(e.data.global);
            }
        };
        return UtilGestureData;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DAnimationTimings = /** @class */ (function () {
        function DAnimationTimings() {
        }
        DAnimationTimings.LINEAR = function (t) {
            return t;
        };
        DAnimationTimings.ELASTIC = function (t) {
            return t * (3 * (1 - t) * (1 - t) + t * (3 * (1 - t) + t));
        };
        DAnimationTimings.QUAD_IN_OUT = function (t) {
            return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
        };
        return DAnimationTimings;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DAnimationBase = /** @class */ (function (_super) {
        __extends(DAnimationBase, _super);
        function DAnimationBase(options) {
            var _a, _b, _c;
            var _this = _super.call(this) || this;
            _this._id = null;
            _this._target = (_a = options === null || options === void 0 ? void 0 : options.target) !== null && _a !== void 0 ? _a : null;
            _this._startTime = 0;
            _this._duration = (_b = options === null || options === void 0 ? void 0 : options.duration) !== null && _b !== void 0 ? _b : 200;
            _this._durationInverse = 1 / Math.max(1, _this._duration);
            _this._reverse = false;
            _this._onTime = options === null || options === void 0 ? void 0 : options.onTime;
            _this._onTimeBaseBound = function () {
                _this.onTimeBase();
            };
            _this._onStart = options === null || options === void 0 ? void 0 : options.onStart;
            _this._onEnd = options === null || options === void 0 ? void 0 : options.onEnd;
            _this._onStop = options === null || options === void 0 ? void 0 : options.onStop;
            _this._timing = (_c = options === null || options === void 0 ? void 0 : options.timing) !== null && _c !== void 0 ? _c : DAnimationTimings.ELASTIC;
            // Events
            var on = options === null || options === void 0 ? void 0 : options.on;
            if (on) {
                for (var name_1 in on) {
                    var handler = on[name_1];
                    if (handler) {
                        _this.on(name_1, handler);
                    }
                }
            }
            return _this;
        }
        Object.defineProperty(DAnimationBase.prototype, "target", {
            get: function () {
                return this._target;
            },
            set: function (target) {
                this._target = target;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DAnimationBase.prototype, "duration", {
            get: function () {
                return this._duration;
            },
            set: function (duration) {
                this._duration = duration;
                this._durationInverse = 1 / Math.max(1, duration);
            },
            enumerable: false,
            configurable: true
        });
        DAnimationBase.prototype.start = function (reverse) {
            if (reverse === void 0) { reverse = false; }
            this.stop();
            this._startTime = Date.now();
            this._reverse = reverse;
            this._id = window.setTimeout(this._onTimeBaseBound, 0);
            // onStart
            this.onStart(reverse);
            // onTime
            var duration = this._duration;
            var time = this.toTime(reverse ? duration : 0);
            this.onTime(time, reverse, 0);
        };
        DAnimationBase.prototype.onStart = function (isReverse) {
            var onStart = this._onStart;
            if (onStart != null) {
                onStart(isReverse, this);
            }
            this.emit("start", isReverse, this);
        };
        DAnimationBase.prototype.onTime = function (time, isReverse, elapsedTime) {
            var onTime = this._onTime;
            if (onTime != null) {
                onTime(time, isReverse, elapsedTime, this);
            }
            this.emit("time", time, isReverse, elapsedTime, this);
        };
        DAnimationBase.prototype.onEnd = function (isReverse) {
            var onEnd = this._onEnd;
            if (onEnd != null) {
                onEnd(isReverse, this);
            }
            this.emit("end", isReverse, this);
        };
        DAnimationBase.prototype.onStop = function (isReverse) {
            var onStop = this._onStop;
            if (onStop != null) {
                onStop(isReverse, this);
            }
            this.emit("stop", isReverse, this);
        };
        DAnimationBase.prototype.isStarted = function () {
            return this._id != null;
        };
        DAnimationBase.prototype.isReverse = function () {
            return this._reverse;
        };
        DAnimationBase.prototype.onTimeBase = function () {
            var id = this._id;
            if (id != null) {
                this._id = null;
                var elapsedTime = Date.now() - this._startTime;
                var duration = this._duration;
                var reverse = this._reverse;
                if (elapsedTime < duration) {
                    this._id = window.setTimeout(this._onTimeBaseBound, 0);
                    // OnTime
                    var time = this.toTime(reverse ? duration - elapsedTime : elapsedTime);
                    this.onTime(time, reverse, elapsedTime);
                }
                else {
                    // OnTime
                    var time = this.toTime(reverse ? 0 : duration);
                    this.onTime(time, reverse, elapsedTime);
                    // OnEnd
                    this.onEnd(reverse);
                }
            }
        };
        DAnimationBase.prototype.toTime = function (elapsedTime) {
            return this._timing(elapsedTime * this._durationInverse, this);
        };
        DAnimationBase.prototype.stop = function () {
            var id = this._id;
            if (id != null) {
                this._id = null;
                window.clearTimeout(id);
                // OnStop
                this.onStop(this._reverse);
            }
        };
        DAnimationBase.prototype.end = function () {
            var id = this._id;
            if (id != null) {
                this._id = null;
                window.clearTimeout(id);
                // OnTime
                var reverse = this._reverse;
                var elapsedTime = Date.now() - this._startTime;
                var duration = this._duration;
                var time = this.toTime(reverse ? 0 : duration);
                this.onTime(time, reverse, elapsedTime);
                // OnEnd
                this.onEnd(reverse);
            }
        };
        return DAnimationBase;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var UtilGestureEasingHistory = /** @class */ (function () {
        function UtilGestureEasingHistory(dx, dy, ds, dt) {
            this.dx = dx;
            this.dy = dy;
            this.ds = ds;
            this.dt = dt;
        }
        UtilGestureEasingHistory.prototype.set = function (dx, dy, ds, dt) {
            this.dx = dx;
            this.dy = dy;
            this.ds = ds;
            this.dt = dt;
        };
        return UtilGestureEasingHistory;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var UtilGestureEasing = /** @class */ (function () {
        function UtilGestureEasing(onMove, onEnd, options) {
            var _this = this;
            var _a;
            this._histories = [];
            this._historiesSorted = [];
            this._historyBegin = 0;
            this._historyEnd = -1;
            this._dx = 0;
            this._dy = 0;
            this._ds = 0;
            this._dt = 0;
            this._dtw = 0;
            this._t = 0;
            this._duration = 333 * ((_a = options === null || options === void 0 ? void 0 : options.duration) !== null && _a !== void 0 ? _a : 1);
            this._animation = new DAnimationBase({
                onTime: function (t) {
                    _this.onEase(t);
                },
                onEnd: function () {
                    _this.onEaseEnd();
                },
                timing: DAnimationTimings.LINEAR,
                duration: this._duration
            });
            this._onMove = onMove;
            this._onEnd = onEnd;
        }
        UtilGestureEasing.prototype.onStart = function () {
            // History
            var histories = this._histories;
            for (var i = histories.length, imax = UtilGestureEasing.HISTORY_CAPACITY; i < imax; ++i) {
                histories.push(new UtilGestureEasingHistory(0, 0, 1, 0));
            }
            this._historyBegin = 0;
            this._historyEnd = -1;
            // Stop animation
            this._animation.stop();
        };
        UtilGestureEasing.prototype.onMove = function (dx, dy, ds, dt) {
            var capacity = UtilGestureEasing.HISTORY_CAPACITY;
            var oldHistoryEnd = this._historyEnd;
            var newHistoryEnd = (oldHistoryEnd + 1) % capacity;
            this._historyEnd = newHistoryEnd;
            var oldHistoryBegin = this._historyBegin;
            if (newHistoryEnd < oldHistoryEnd ||
                (0 <= oldHistoryEnd && oldHistoryEnd < oldHistoryBegin)) {
                this._historyBegin = (oldHistoryBegin + 1) % capacity;
            }
            this._histories[newHistoryEnd].set(dx, dy, ds, dt);
        };
        UtilGestureEasing.prototype.updateHistoriesSorted = function (dt) {
            var unsorted = this._histories;
            var sorted = this._historiesSorted;
            var begin = this._historyBegin;
            var end = this._historyEnd;
            var length = unsorted.length;
            var threshold = 160;
            if (end < 0) {
                sorted.length = 0;
                return dt;
            }
            else if (end < begin) {
                var total = dt;
                sorted.length = 0;
                for (var i = end; 0 <= i; --i) {
                    var history_1 = unsorted[i];
                    if (total + history_1.dt < threshold) {
                        total += history_1.dt;
                        sorted.push(history_1);
                    }
                    else {
                        return total;
                    }
                }
                for (var i = length - 1; begin <= i; --i) {
                    var history_2 = unsorted[i];
                    if (total + history_2.dt < threshold) {
                        total += history_2.dt;
                        sorted.push(history_2);
                    }
                    else {
                        return total;
                    }
                }
                return total;
            }
            else {
                var total = dt;
                sorted.length = 0;
                for (var i = end; begin <= i; --i) {
                    var history_3 = unsorted[i];
                    if (total + history_3.dt < threshold) {
                        total += history_3.dt;
                        sorted.push(history_3);
                    }
                    else {
                        return total;
                    }
                }
                return total;
            }
        };
        UtilGestureEasing.prototype.onEnd = function (ldt) {
            var d0 = this._duration;
            var d = d0 - ldt;
            if (d <= 0) {
                return this.onEaseEnd();
            }
            this.updateHistoriesSorted(ldt);
            var sorted = this._historiesSorted;
            var sortedLength = sorted.length;
            if (sortedLength <= 0) {
                return this.onEaseEnd();
            }
            var dx = 0;
            var dy = 0;
            var ds = 0;
            var dt = 0;
            for (var i = 0; i < sortedLength; ++i) {
                var history_4 = sorted[i];
                dx += history_4.dx;
                dy += history_4.dy;
                ds += history_4.ds;
                dt += history_4.dt;
            }
            if (dt <= 0) {
                return this.onEaseEnd();
            }
            var w = 1 / sortedLength;
            dx *= w;
            dy *= w;
            ds *= w;
            dt *= w * (d0 / d); // Effectively, this lowers the velocity (dx, dy, ds) by d / d0.
            this._dx = dx;
            this._dy = dy;
            this._ds = ds;
            this._dt = dt;
            // Start animation
            var animation = this._animation;
            animation.duration = d;
            this._t = 0;
            this._dtw = d / dt;
            animation.start();
        };
        UtilGestureEasing.prototype.onEase = function (t) {
            var ot = this._t;
            this._t = t;
            // Note: Integral_{x=ot...t} (1-x) dx
            //       = [x (1 - 0.5 x)]_{x=ot...t}
            //       = t (1 - 0.5 t) - ot (1 - 0.5 ot)
            //       = t - ot - 0.5 t t + 0.5 ot ot
            //       = (t - ot) - 0.5 (t + ot) (t - ot)
            //       = (1 - 0.5 (t + ot)) * (t - ot)
            var w = (1 - 0.5 * (t + ot)) * (t - ot) * this._dtw;
            this._onMove(this._dx * w, this._dy * w, 1 + (this._ds - 1) * w, t);
        };
        UtilGestureEasing.prototype.onEaseEnd = function () {
            this._onEnd();
        };
        UtilGestureEasing.prototype.stop = function () {
            this._animation.stop();
        };
        UtilGestureEasing.HISTORY_CAPACITY = 5;
        return UtilGestureEasing;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var UtilGestureTap = /** @class */ (function () {
        function UtilGestureTap(on, options) {
            if (on != null) {
                this._onTap = on.tap;
                this._onLongPress = on.longpress;
            }
            this._threshold = this.toThreshold(options);
            this._unused = [];
            this._used = new Map();
        }
        UtilGestureTap.prototype.toThreshold = function (options) {
            var _a, _b;
            if (options != null) {
                var threshold = options.threshold;
                if (threshold != null) {
                    return {
                        distance: (_a = threshold.distance) !== null && _a !== void 0 ? _a : 10,
                        long: (_b = threshold.long) !== null && _b !== void 0 ? _b : 500
                    };
                }
            }
            return {
                distance: 10,
                long: 500
            };
        };
        UtilGestureTap.prototype.newData = function (target) {
            var used = this._used;
            var result = used.get(target);
            if (result != null) {
                return result;
            }
            var poped = this._unused.pop();
            if (poped != null) {
                used.set(target, poped);
                return poped;
            }
            var created = new UtilGestureData();
            created.easing = undefined;
            created.onMove = this.newOnMove(created);
            created.onEnd = this.newOnEnd(created);
            used.set(target, created);
            return created;
        };
        UtilGestureTap.prototype.deleteData = function (data) {
            var target = data.target;
            if (target) {
                if (this._used.delete(target)) {
                    var timeoutId = data.timeoutId;
                    if (timeoutId != null) {
                        data.timeoutId = undefined;
                        window.clearTimeout(timeoutId);
                    }
                    data.target = undefined;
                    data.pointers.clear();
                    this._unused.push(data);
                }
            }
        };
        UtilGestureTap.prototype.newOnMove = function (data) {
            var _this = this;
            return function (e) {
                _this.onMove(e, data);
            };
        };
        UtilGestureTap.prototype.newOnEnd = function (data) {
            var _this = this;
            return function (e) {
                _this.onEnd(e, data);
            };
        };
        UtilGestureTap.prototype.onDown = function (target, e) {
            var _a;
            if (this._onTap == null && this._onLongPress == null) {
                return;
            }
            var layer = DApplications.getLayer(target);
            if (layer == null) {
                return;
            }
            e.stopPropagation();
            if (target.state.isGesturing) {
                (_a = this._used.get(target)) === null || _a === void 0 ? void 0 : _a.start(e);
            }
            else {
                var data = this.newData(target);
                data.target = target;
                data.distance = 0;
                target.state.isGesturing = true;
                // Interaction manager
                var interactionManager = layer.renderer.plugins.interaction;
                data.interactionManager = interactionManager;
                // Update the center
                data.start(e);
                // Event handler
                data.bind(e);
                // Long press
                this.start(target, data, e);
            }
        };
        UtilGestureTap.prototype.onMove = function (e, data) {
            var target = data.target;
            if (target == null || !target.state.isGesturing) {
                return;
            }
            if (!data.isUpdatable(e)) {
                return;
            }
            // Update the center
            var center = data.center;
            var oldCenterX = center.x;
            var oldCenterY = center.y;
            data.update(e);
            var newCenterX = center.x;
            var newCenterY = center.y;
            // Calculate the position
            var dx = newCenterX - oldCenterX;
            var dy = newCenterY - oldCenterY;
            // Distance
            data.distance += Math.abs(dx) + Math.abs(dy);
        };
        UtilGestureTap.prototype.onEnd = function (e, data) {
            var target = data.target;
            if (target == null || !target.state.isGesturing) {
                return;
            }
            if (!data.end(e)) {
                return;
            }
            // State
            target.state.isGesturing = false;
            // Remove event handlers
            var interactionManager = data.interactionManager;
            data.interactionManager = undefined;
            if (interactionManager) {
                var onMoveBound = data.onMove;
                if (onMoveBound) {
                    interactionManager.off(UtilPointerEvent.move, onMoveBound);
                }
                var onEndBound = data.onEnd;
                if (onEndBound) {
                    interactionManager.off(UtilPointerEvent.up, onEndBound);
                    interactionManager.off(UtilPointerEvent.cancel, onEndBound);
                }
            }
            // Tap
            this.end(target, data, e);
            // Delete this data
            this.deleteData(data);
        };
        UtilGestureTap.prototype.onLongPress = function (target, data, e) {
            data.timeoutId = undefined;
            if (data.distance < this._threshold.distance) {
                data.distance = this._threshold.distance;
                var onLongPress = this._onLongPress;
                if (onLongPress != null) {
                    onLongPress(target, e);
                }
            }
        };
        UtilGestureTap.prototype.start = function (target, data, e) {
            var _this = this;
            var thresholdLong = this._threshold.long;
            if (0 <= thresholdLong) {
                data.timeoutId = window.setTimeout(function () {
                    _this.onLongPress(target, data, e);
                }, thresholdLong);
            }
        };
        UtilGestureTap.prototype.end = function (target, data, e) {
            var timeoutId = data.timeoutId;
            if (timeoutId != null) {
                data.timeoutId = undefined;
                window.clearTimeout(timeoutId);
            }
            if (data.distance < this._threshold.distance) {
                var onTap = this._onTap;
                if (onTap) {
                    onTap(target, e);
                }
            }
        };
        UtilGestureTap.prototype.stop = function (target) {
            var data = this._used.get(target);
            if (data != null) {
                this.deleteData(data);
            }
        };
        return UtilGestureTap;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var UtilGesture = /** @class */ (function () {
        function UtilGesture(options) {
            var _a, _b, _c;
            var on = options.on;
            if (on) {
                this._onStart = on.start;
                this._onMove = on.move;
                this._onEnd = on.end;
                this._onStop = on.stop;
                var easing = on.easing;
                if (easing != null) {
                    this._onEasingStart = easing.start;
                    this._onEasingEnd = easing.end;
                }
            }
            this._modifier = (_a = options === null || options === void 0 ? void 0 : options.modifier) !== null && _a !== void 0 ? _a : UtilGestureModifier.NONE;
            var checker = options.checker;
            var defaultChecker = UtilGestureModifiers.match;
            this._checkerStart = (_b = checker === null || checker === void 0 ? void 0 : checker.start) !== null && _b !== void 0 ? _b : defaultChecker;
            this._checkerMove = (_c = checker === null || checker === void 0 ? void 0 : checker.move) !== null && _c !== void 0 ? _c : defaultChecker;
            this._easing = options.easing;
            this._touch = !!options.touch;
            this._unused = [];
            this._used = new Map();
            this._tap = new UtilGestureTap(options.on, options.tap);
            var bind = options.bind;
            if (bind != null) {
                this.bind(bind);
            }
        }
        UtilGesture.prototype.newData = function (target) {
            var used = this._used;
            var result = used.get(target);
            if (result != null) {
                return result;
            }
            var poped = this._unused.pop();
            if (poped != null) {
                used.set(target, poped);
                return poped;
            }
            var created = new UtilGestureData();
            created.easing = this.newEasing(created);
            created.onMove = this.newOnMove(created);
            created.onEnd = this.newOnEnd(created);
            used.set(target, created);
            return created;
        };
        UtilGesture.prototype.newEasing = function (data) {
            var _this = this;
            var easing = this._easing;
            if (easing == null || easing !== false) {
                var onEasingMoveBound = function (dx, dy, ds, time) {
                    _this.onEasingMove(dx, dy, ds, time, data);
                };
                var onEasingEndBound = function () {
                    _this.onEasingEnd(data);
                };
                return new UtilGestureEasing(onEasingMoveBound, onEasingEndBound, this.toEasingOptions(easing));
            }
            return undefined;
        };
        UtilGesture.prototype.toEasingOptions = function (options) {
            return options == null || options === true ? undefined : options;
        };
        UtilGesture.prototype.deleteData = function (data) {
            var target = data.target;
            if (target) {
                if (this._used.delete(target)) {
                    data.target = undefined;
                    data.pointers.clear();
                    this._unused.push(data);
                }
            }
        };
        UtilGesture.prototype.bind = function (target) {
            var _this = this;
            target.on(UtilPointerEvent.down, function (e) {
                _this.onDown(target, e);
            });
            return this;
        };
        UtilGesture.prototype.isTouch = function (e) {
            var oe = e.data.originalEvent;
            if ("touches" in oe) {
                return true;
            }
            else if ("pointerId" in oe) {
                return oe.pointerType !== "mouse";
            }
            else {
                return false;
            }
        };
        UtilGesture.prototype.onDown = function (target, e) {
            var _a;
            if (this._touch && !this.isTouch(e)) {
                return;
            }
            if (!this._checkerStart(e, this._modifier, target)) {
                return this._tap.onDown(target, e);
            }
            var layer = DApplications.getLayer(target);
            if (layer == null) {
                return;
            }
            e.stopPropagation();
            if (target.state.isGesturing) {
                (_a = this._used.get(target)) === null || _a === void 0 ? void 0 : _a.start(e);
            }
            else {
                // User-defined handler
                var onStart = this._onStart;
                if (onStart != null) {
                    onStart(target);
                }
                var data = this.newData(target);
                data.target = target;
                data.distance = 0;
                target.state.isGesturing = true;
                // Interaction manager
                var interactionManager = layer.renderer.plugins.interaction;
                data.interactionManager = interactionManager;
                // Update the center
                data.start(e);
                // Easing util
                var easing = data.easing;
                if (easing) {
                    easing.onStart();
                }
                // Event handler
                data.bind(e);
                // Tap
                this._tap.start(target, data, e);
            }
        };
        UtilGesture.prototype.newOnMove = function (data) {
            var _this = this;
            return function (e) {
                _this.onMove(e, data);
            };
        };
        UtilGesture.prototype.newOnEnd = function (data) {
            var _this = this;
            return function (e) {
                _this.onEnd(e, data);
            };
        };
        UtilGesture.prototype.onMove = function (e, data) {
            var target = data.target;
            if (target == null || !target.state.isGesturing) {
                return;
            }
            if (!data.isUpdatable(e) || !this._checkerMove(e, this._modifier, target)) {
                return;
            }
            // Update the center
            var center = data.center;
            var oldCenterX = center.x;
            var oldCenterY = center.y;
            var oldScale = data.scale;
            var oldTime = data.time;
            data.update(e);
            var newCenterX = center.x;
            var newCenterY = center.y;
            var newScale = data.scale;
            var newTime = data.time;
            // Calculate the position
            var dx = newCenterX - oldCenterX;
            var dy = newCenterY - oldCenterY;
            var dt = newTime - oldTime;
            var epsilon = 0.00001;
            var ds = epsilon < oldScale && epsilon < newScale ? newScale / oldScale : 1;
            // Distance
            data.distance += Math.abs(dx) + Math.abs(dy);
            // Easing
            var easing = data.easing;
            if (easing) {
                easing.onMove(dx, dy, ds, dt);
            }
            // Call the user-defined handler
            var onMove = this._onMove;
            if (onMove != null) {
                if (dx !== 0 || dy !== 0 || ds !== 1) {
                    onMove(target, dx, dy, newCenterX, newCenterY, ds);
                }
            }
        };
        UtilGesture.prototype.onEnd = function (e, data) {
            var target = data.target;
            if (target == null || !target.state.isGesturing) {
                return;
            }
            var oldTime = data.time;
            if (!data.end(e)) {
                return;
            }
            // State
            target.state.isGesturing = false;
            // Remove event handlers
            var interactionManager = data.interactionManager;
            data.interactionManager = undefined;
            if (interactionManager) {
                var onMoveBound = data.onMove;
                if (onMoveBound) {
                    interactionManager.off(UtilPointerEvent.move, onMoveBound);
                }
                var onEndBound = data.onEnd;
                if (onEndBound) {
                    interactionManager.off(UtilPointerEvent.up, onEndBound);
                    interactionManager.off(UtilPointerEvent.cancel, onEndBound);
                }
            }
            // Call the user-defined handler
            var onEnd = this._onEnd;
            if (onEnd != null) {
                onEnd(target);
            }
            // Tap
            this._tap.end(target, data, e);
            // Start the Easing
            var onEasingStart = this._onEasingStart;
            if (onEasingStart) {
                onEasingStart(data.target);
            }
            var easing = data.easing;
            if (easing) {
                easing.onEnd(data.time - oldTime);
            }
            else {
                this.deleteData(data);
                var onEasingEnd = this._onEasingEnd;
                if (onEasingEnd) {
                    onEasingEnd(data.target);
                }
            }
        };
        UtilGesture.prototype.onEasingMove = function (dx, dy, ds, time, data) {
            var target = data.target;
            if (target == null) {
                return;
            }
            var onMove = this._onMove;
            if (onMove == null) {
                return;
            }
            if (dx === 0 && dy === 0 && ds === 1) {
                return;
            }
            var center = data.center;
            var x = center.x + dx;
            var y = center.y + dy;
            center.set(x, y);
            onMove(target, dx, dy, x, y, ds);
        };
        UtilGesture.prototype.onEasingEnd = function (data) {
            var target = data.target;
            this.deleteData(data);
            if (target != null) {
                var onEasingEnd = this._onEasingEnd;
                if (onEasingEnd) {
                    onEasingEnd(target);
                }
            }
        };
        UtilGesture.prototype.stop = function (target) {
            this._tap.stop(target);
            var data = this._used.get(target);
            if (data != null) {
                var easing = data.easing;
                if (easing != null) {
                    easing.stop();
                }
                this.deleteData(data);
                var onStop = this._onStop;
                if (onStop) {
                    onStop(target);
                }
            }
        };
        return UtilGesture;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DRAG = 1;
    var PINCH = 2;
    var EShapeActionValueGestureOperationType = {
        NONE: 0,
        DRAG: DRAG,
        PINCH: PINCH,
        ALL: DRAG | PINCH
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeGestureLayer = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeGestureLayer, _super);
        function EShapeActionRuntimeGestureLayer(value) {
            var _this = _super.call(this, value, EShapeRuntimeReset.NONE) || this;
            _this._layers = new Map();
            _this._operationType = value.operationType;
            _this._scaleMin = value.scaleMin;
            _this._scaleMax = value.scaleMax;
            return _this;
        }
        EShapeActionRuntimeGestureLayer.prototype.initialize = function (shape, runtime) {
            _super.prototype.initialize.call(this, shape, runtime);
            var layers = this._layers;
            var layer = layers.get(shape);
            if (layer == null) {
                var newLayer = DDiagramLayers.toLayer(shape);
                if (newLayer != null) {
                    this._layers.set(shape, newLayer);
                }
            }
        };
        EShapeActionRuntimeGestureLayer.prototype.onDown = function (shape, runtime, e) {
            _super.prototype.onDown.call(this, shape, runtime, e);
            if (e instanceof pixi_js.InteractionEvent) {
                var layer = this._layers.get(shape);
                var time = e.data.originalEvent.timeStamp;
                if (layer && this.condition(shape, time, EShapeActionEnvironment)) {
                    this.getGestureUtil().onDown(layer, e);
                }
            }
        };
        EShapeActionRuntimeGestureLayer.prototype.getGestureUtil = function () {
            var _a;
            return ((_a = EShapeActionRuntimeGestureLayer.GESTURE_UTIL) !== null && _a !== void 0 ? _a : (EShapeActionRuntimeGestureLayer.GESTURE_UTIL = this.newGestureUtil()));
        };
        EShapeActionRuntimeGestureLayer.prototype.newGestureUtil = function () {
            var _this = this;
            var work = new pixi_js.Point();
            return new UtilGesture({
                on: {
                    move: function (target, dx, dy, x, y, ds) {
                        _this.onGestureMove(target, dx, dy, x, y, ds, work);
                    }
                }
            });
        };
        EShapeActionRuntimeGestureLayer.prototype.onGestureMove = function (layer, dx, dy, x, y, ds, work) {
            var parent = layer.parent;
            if (parent) {
                var transform = layer.transform;
                var gestureType = this._operationType;
                var isChanged = false;
                // Scale
                var scaleRatio = 1;
                if (gestureType & EShapeActionValueGestureOperationType.PINCH) {
                    var scale = transform.scale;
                    var oldScale = scale.y;
                    var newScale = Math.min(this._scaleMax, Math.max(this._scaleMin, oldScale * ds));
                    scaleRatio = newScale / oldScale;
                    scale.set(newScale, newScale);
                    isChanged = true;
                }
                // Position
                if (gestureType & EShapeActionValueGestureOperationType.DRAG) {
                    parent.toLocal(work.set(x, y), undefined, work);
                    var lx = work.x;
                    var ly = work.y;
                    var cx = x - dx;
                    var cy = y - dy;
                    parent.toLocal(work.set(cx, cy), undefined, work);
                    var lcx = work.x;
                    var lcy = work.y;
                    var position = transform.position;
                    var newX = (position.x - lcx) * scaleRatio + lx;
                    var newY = (position.y - lcy) * scaleRatio + ly;
                    position.set(newX, newY);
                    isChanged = true;
                }
                // Update
                if (isChanged) {
                    DApplications.update(layer);
                }
            }
        };
        EShapeActionRuntimeGestureLayer.prototype.toSize = function (layer, result) {
            if ("size" in layer) {
                result.copyFrom(layer.size);
            }
            else {
                result.set(layer.width, layer.height);
            }
            return result;
        };
        return EShapeActionRuntimeGestureLayer;
    }(EShapeActionRuntimeConditional));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeGestureShape = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeGestureShape, _super);
        function EShapeActionRuntimeGestureShape(value) {
            var _this = _super.call(this, value, EShapeRuntimeReset.NONE) || this;
            _this._operationType = value.operationType;
            _this._scaleMin = value.scaleMin;
            _this._scaleMax = value.scaleMax;
            return _this;
        }
        EShapeActionRuntimeGestureShape.prototype.onDown = function (shape, runtime, e) {
            _super.prototype.onDown.call(this, shape, runtime, e);
            if (e instanceof pixi_js.InteractionEvent) {
                if (this.condition(shape, e.data.originalEvent.timeStamp, EShapeActionEnvironment)) {
                    this.getGestureUtil().onDown(shape, e);
                }
            }
        };
        EShapeActionRuntimeGestureShape.prototype.getGestureUtil = function () {
            var _a;
            return ((_a = EShapeActionRuntimeGestureShape.GESTURE_UTIL) !== null && _a !== void 0 ? _a : (EShapeActionRuntimeGestureShape.GESTURE_UTIL = this.newGestureUtil()));
        };
        EShapeActionRuntimeGestureShape.prototype.newGestureUtil = function () {
            var _this = this;
            var work = new pixi_js.Point();
            return new UtilGesture({
                on: {
                    move: function (target, dx, dy, x, y, ds) {
                        _this.onGestureMove(target, dx, dy, x, y, ds, work);
                    }
                }
            });
        };
        EShapeActionRuntimeGestureShape.prototype.onGestureMove = function (target, dx, dy, x, y, ds, work) {
            var parent = target.parent;
            if (parent) {
                var transform = target.transform;
                var gestureType = this._operationType;
                var isChanged = false;
                // Scale
                var scaleRatio = 1;
                if (gestureType & EShapeActionValueGestureOperationType.PINCH) {
                    var scale = transform.scale;
                    var oldScale = scale.y;
                    var newScale = Math.min(this._scaleMax, Math.max(this._scaleMin, oldScale * ds));
                    scaleRatio = newScale / oldScale;
                    scale.set(newScale, newScale);
                    isChanged = true;
                }
                // Position
                if (gestureType & EShapeActionValueGestureOperationType.DRAG) {
                    parent.toLocal(work.set(x, y), undefined, work);
                    var lx = work.x;
                    var ly = work.y;
                    var cx = x - dx;
                    var cy = y - dy;
                    parent.toLocal(work.set(cx, cy), undefined, work);
                    var lcx = work.x;
                    var lcy = work.y;
                    var position = transform.position;
                    var newX = (position.x - lcx) * scaleRatio + lx;
                    var newY = (position.y - lcy) * scaleRatio + ly;
                    position.set(newX, newY);
                    isChanged = true;
                }
                // Update
                if (isChanged) {
                    DApplications.update(target);
                }
            }
        };
        return EShapeActionRuntimeGestureShape;
    }(EShapeActionRuntimeConditional));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueGestureType = {
        SHAPE: 0,
        LAYER: 1
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueMiscType = {
        INPUT_TEXT: 0,
        INPUT_INTEGER: 1,
        INPUT_REAL: 2,
        EMIT_EVENT: 3,
        WRITE_BOTH: 4,
        WRITE_LOCAL: 5,
        WRITE_REMOTE: 6,
        HTML_ELEMENT: 7,
        HTML_ELEMENT_WITHOUT_POINTER_EVENTS: 8,
        /** @deprecated in favor of {@link EShapeActionValueShowHideType}'s LAYER */
        SHOW_HIDE_LAYER: 9,
        /** @deprecated in favor of {@link EShapeActionValueType}'s GESTURE */
        GESTURE_LAYER: 10,
        /** @deprecated in favor of {@link EShapeActionValueType}'s GESTURE */
        GESTURE: 11,
        EXECUTE: 12,
        EXTENSION: 1000
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueGesture = /** @class */ (function (_super) {
        __extends(EShapeActionValueGesture, _super);
        function EShapeActionValueGesture(condition, subtype, operationType, scaleMin, scaleMax) {
            if (condition === void 0) { condition = ""; }
            if (scaleMin === void 0) { scaleMin = 0.05; }
            if (scaleMax === void 0) { scaleMax = 20; }
            var _this = _super.call(this, EShapeActionValueType.GESTURE, condition, subtype) || this;
            _this.operationType = operationType;
            _this.scaleMin = scaleMin;
            _this.scaleMax = scaleMax;
            return _this;
        }
        EShapeActionValueGesture.prototype.toRuntime = function () {
            switch (this.subtype) {
                case EShapeActionValueGestureType.SHAPE:
                    return new EShapeActionRuntimeGestureShape(this);
                case EShapeActionValueGestureType.LAYER:
                    return new EShapeActionRuntimeGestureLayer(this);
            }
        };
        EShapeActionValueGesture.prototype.serialize = function (manager) {
            var conditionId = manager.addResource(this.condition);
            return manager.addResource("[".concat(this.type, ",").concat(conditionId, ",").concat(this.subtype, ",").concat(this.operationType, ",").concat(this.scaleMin, ",").concat(this.scaleMax, "]"));
        };
        EShapeActionValueGesture.deserialize = function (serialized, manager) {
            var condition = EShapeActionValues.toResource(1, serialized, manager.resources);
            var subtype = this.toSubType(serialized);
            var operationType = serialized[3];
            var scaleMin = serialized[4];
            var scaleMax = serialized[5];
            return new EShapeActionValueGesture(condition, subtype, operationType, scaleMin, scaleMax);
        };
        EShapeActionValueGesture.toSubType = function (serialized) {
            if (serialized[0] === EShapeActionValueType.MISC) {
                switch (serialized[2]) {
                    case EShapeActionValueMiscType.GESTURE:
                        return EShapeActionValueGestureType.SHAPE;
                    case EShapeActionValueMiscType.GESTURE_LAYER:
                        return EShapeActionValueGestureType.LAYER;
                }
            }
            else {
                return serialized[2];
            }
        };
        return EShapeActionValueGesture;
    }(EShapeActionValueSubtyped));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeLayerState = {
        INVISIBLE: "INVISIBLE",
        INTERACTIVE: "INTERACTIVE",
        DRAGGABLE: "DRAGGABLE",
        PINCHABLE: "PINCHABLE"
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var deserializeEmbeddedLayerName = function (target, manager) {
        if (isString(target)) {
            return target;
        }
        else {
            var resources = manager.resources;
            if (0 <= target && target <= resources.length) {
                return resources[target];
            }
            return "";
        }
    };
    var deserializeEmbeddedLayer = function (serialized, manager, width, height, creator) {
        var _a, _b, _c;
        var name = deserializeEmbeddedLayerName(serialized[0], manager);
        var result = creator
            ? creator(name, manager)
            : new EShapeEmbeddedLayer(name, manager.mode, manager.depth);
        var visibility = serialized[1];
        var visible = visibility == null || !!(visibility & 0x2);
        if (!visible) {
            result.visible = false;
            result.state.add(EShapeLayerState.INVISIBLE);
        }
        var positionX = -0.5 * width + (serialized[2] || 0);
        var positionY = -0.5 * height + (serialized[3] || 0);
        result.transform.position.set(positionX, positionY);
        var sizeX = (_a = serialized[4]) !== null && _a !== void 0 ? _a : width;
        var sizeY = (_b = serialized[5]) !== null && _b !== void 0 ? _b : height;
        result.size.set(sizeX, sizeY);
        result.size.init();
        var fillId = serialized[6];
        if (fillId != null) {
            result.fill.deserialize(fillId, manager);
        }
        if (manager.mode === EShapeResourceManagerDeserializationMode.VIEWER) {
            var state = (_c = serialized[7]) !== null && _c !== void 0 ? _c : 1;
            var isInteractive = state & 0x1;
            var isDraggable = state & 0x2;
            var isPinchable = state & 0x4;
            if (isDraggable || isPinchable) {
                var gestureType = (isDraggable
                    ? EShapeActionValueGestureOperationType.DRAG
                    : EShapeActionValueGestureOperationType.NONE) |
                    (isPinchable
                        ? EShapeActionValueGestureOperationType.PINCH
                        : EShapeActionValueGestureOperationType.NONE);
                result.action.add(new EShapeActionValueGesture("", EShapeActionValueGestureType.LAYER, gestureType));
            }
            if (isInteractive || isDraggable || isPinchable) {
                result.interactive = true;
            }
        }
        return result;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeEmbeddedLayerContainer = /** @class */ (function () {
        function EShapeEmbeddedLayerContainer(width, height) {
            this.children = [];
            this._width = width;
            this._height = height;
        }
        EShapeEmbeddedLayerContainer.prototype.hasConnectors = function (shapes) {
            for (var i = 0, imax = shapes.length; i < imax; ++i) {
                var shape = shapes[i];
                if (shape instanceof EShapeConnectorLine) {
                    return true;
                }
                var children = shape.children;
                if (0 < children.length) {
                    if (this.hasConnectors(children)) {
                        return true;
                    }
                }
            }
            return false;
        };
        EShapeEmbeddedLayerContainer.prototype.newHasConnectors = function () {
            var result = new Map();
            var layers = this.children;
            for (var i = 0, imax = layers.length; i < imax; ++i) {
                var layer = layers[i];
                result.set(layer, this.hasConnectors(layer.children));
            }
            return result;
        };
        EShapeEmbeddedLayerContainer.prototype.copyTo = function (destination) {
            var _a;
            var hasConnectors = ((_a = this._hasConnectors) !== null && _a !== void 0 ? _a : (this._hasConnectors = this.newHasConnectors()));
            var layers = this.children;
            var children = destination.children;
            for (var i = 0, imax = layers.length; i < imax; ++i) {
                var layer = layers[i];
                var clone = layer.clone();
                clone.parent = destination;
                children.push(clone);
                if (hasConnectors.get(layer)) {
                    EShapeConnectors.move(layer, clone);
                }
            }
            destination.onChildTransformChange();
            destination.toDirty();
            destination.onAttach();
        };
        EShapeEmbeddedLayerContainer.prototype.deserialize = function (serializedLayers, manager) {
            var serializedLayersLength = serializedLayers.length;
            if (0 < serializedLayersLength) {
                var width = this._width;
                var height = this._height;
                for (var i = 0; i < serializedLayersLength; ++i) {
                    this.children.push(deserializeEmbeddedLayer(serializedLayers[i], manager, width, height));
                }
            }
        };
        return EShapeEmbeddedLayerContainer;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDiagrams = /** @class */ (function () {
        function DDiagrams() {
        }
        DDiagrams.parse = function (target) {
            if (target != null && isString(target)) {
                try {
                    var parsed = JSON.parse(target);
                    if (parsed != null && isNumber(parsed.version) && isString(parsed.name)) {
                        if (isNumber(parsed.width) &&
                            isNumber(parsed.height) &&
                            isArray(parsed.items) &&
                            isArray(parsed.resources)) {
                            return parsed;
                        }
                        else if (isString(parsed.data)) {
                            return this.toSerialized(parsed);
                        }
                    }
                }
                catch (e) {
                    // DO NOTHING
                }
            }
            return null;
        };
        DDiagrams.toSimple = function (serialized) {
            return {
                version: serialized.version,
                id: serialized.id,
                name: serialized.name,
                label: serialized.label,
                category: serialized.category,
                summary: serialized.summary,
                description: serialized.description,
                thumbnail: serialized.thumbnail,
                data: JSON.stringify({
                    width: serialized.width,
                    height: serialized.height,
                    background: serialized.background,
                    tile: serialized.tile,
                    resources: serialized.resources,
                    data: serialized.data || serialized.tags,
                    pieces: serialized.pieces,
                    layers: serialized.layers,
                    items: serialized.items,
                    snap: serialized.snap
                })
            };
        };
        DDiagrams.toSerialized = function (target) {
            if (!("items" in target)) {
                var data = JSON.parse(target.data);
                var result = {
                    version: target.version,
                    id: target.id,
                    name: target.name,
                    label: target.label,
                    width: data.width,
                    height: data.height,
                    category: target.category,
                    summary: target.summary,
                    description: target.description,
                    background: data.background,
                    tile: data.tile,
                    resources: data.resources,
                    data: data.data || data.tags,
                    pieces: data.pieces,
                    layers: data.layers,
                    items: data.items,
                    snap: data.snap,
                    thumbnail: target.thumbnail
                };
                if (result.data == null) {
                    var tags = target.tags;
                    if (tags != null) {
                        result.data = JSON.parse(tags);
                    }
                }
                if (result.pieces == null) {
                    var pieces = target.pieces;
                    if (pieces != null) {
                        result.pieces = JSON.parse(pieces);
                    }
                }
                return result;
            }
            return target;
        };
        DDiagrams.newLayer = function (serialized, container, manager) {
            // Layers
            container.deserialize(serialized.layers, manager);
            // Items
            var serializedItems = serialized.items;
            var shapePromises = deserializeAll(serializedItems, manager);
            if (shapePromises != null) {
                return shapePromises.then(function (shapes) {
                    var layers = container.children;
                    for (var i = 0, imax = shapes.length; i < imax; ++i) {
                        var serializedItem = serializedItems[i];
                        var shape = shapes[i];
                        var layer = layers[serializedItem[16]];
                        if (layer != null) {
                            shape.parent = layer;
                            shape.uploaded = undefined;
                            layer.children.push(shape);
                        }
                    }
                    for (var i = 0, imax = layers.length; i < imax; ++i) {
                        var layer = layers[i];
                        layer.onChildTransformChange();
                        layer.toDirty();
                        var children = layer.children;
                        for (var j = 0, jmax = children.length; j < jmax; ++j) {
                            children[j].onAttach();
                        }
                    }
                    return shapes;
                });
            }
            else {
                return Promise.resolve([]);
            }
        };
        DDiagrams.toPieceData = function (controller, pieces, mode) {
            var pieceToDatum = new Map();
            var pieceToPromise = new Map();
            var onFulfilled = function () {
                return pieceToDatum;
            };
            return this.toPieceData_(controller, pieces, pieceToDatum, pieceToPromise, mode, 0).then(onFulfilled, onFulfilled);
        };
        DDiagrams.toPieceData_ = function (controller, pieces, pieceToDatum, pieceToPromise, mode, depth) {
            var _this = this;
            var promises = [];
            if (pieces && 0 < pieces.length && controller) {
                var _loop_1 = function (i, imax) {
                    var piece = pieces[i];
                    var promise = pieceToPromise.get(piece);
                    if (promise != null) {
                        promises.push(promise);
                    }
                    else {
                        var newPromise = controller.piece.getByName(piece).then(function (found) {
                            return _this.toPieceData__(controller, piece, found, mode, depth + 1, pieceToDatum, pieceToPromise);
                        }, function () {
                            return null;
                        });
                        pieceToPromise.set(piece, newPromise);
                        promises.push(newPromise);
                    }
                };
                for (var i = 0, imax = pieces.length; i < imax; ++i) {
                    _loop_1(i, imax);
                }
            }
            return Promise.all(promises);
        };
        DDiagrams.toPieceData__ = function (controller, name, serializedOrSimple, mode, depth, pieceToDatum, pieceToPromise) {
            var _this = this;
            var serialized = this.toSerialized(serializedOrSimple);
            var width = serialized.width;
            var height = serialized.height;
            var container = new EShapeEmbeddedLayerContainer(width, height);
            pieceToDatum.set(name, new EShapeEmbeddedDatum(name, width, height, container));
            var pieces = serialized.pieces;
            return this.toPieceData_(controller, pieces, pieceToDatum, pieceToPromise, mode, depth).then(function () {
                return _this.newLayer(serialized, container, new EShapeResourceManagerDeserialization(serialized, pieces, pieceToDatum, mode, depth));
            });
        };
        return DDiagrams;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionOpenOpeners = {};

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DBaseBackground = /** @class */ (function () {
        function DBaseBackground(theme, options, callback) {
            this._theme = theme;
            this._callback = callback;
            var background = options === null || options === void 0 ? void 0 : options.background;
            if (background) {
                this._color = background.color;
                this._alpha = background.alpha;
            }
        }
        DBaseBackground.prototype.getTheme = function () {
            return this._theme;
        };
        DBaseBackground.prototype.setTheme = function (theme) {
            this._theme = theme;
        };
        DBaseBackground.prototype.getColor = function (state) {
            var color = this._color;
            if (color !== undefined) {
                if (isFunction(color)) {
                    var result = color(state);
                    if (result !== undefined) {
                        return result;
                    }
                }
                else {
                    return color;
                }
            }
            return this._theme.getBackgroundColor(state);
        };
        Object.defineProperty(DBaseBackground.prototype, "color", {
            get: function () {
                return this._color;
            },
            set: function (color) {
                if (this._color !== color) {
                    this._color = color;
                    this.onChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        DBaseBackground.prototype.getAlpha = function (state) {
            var alpha = this._alpha;
            if (alpha !== undefined) {
                if (isFunction(alpha)) {
                    var result = alpha(state);
                    if (result !== undefined) {
                        return result;
                    }
                }
                else {
                    return alpha;
                }
            }
            return this._theme.getBackgroundAlpha(state);
        };
        Object.defineProperty(DBaseBackground.prototype, "alpha", {
            get: function () {
                return this._alpha;
            },
            set: function (alpha) {
                if (this._alpha !== alpha) {
                    this._alpha = alpha;
                    this.onChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        DBaseBackground.prototype.onChange = function () {
            var callback = this._callback;
            if (callback != null) {
                callback();
            }
        };
        return DBaseBackground;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var TOP = 1;
    var RIGHT = 2;
    var BOTTOM = 4;
    var LEFT = 8;
    /**
     * A border mask.
     * Borders on masked parts are not rendered.
     */
    var DBorderMask = {
        NONE: 0,
        TOP: TOP,
        RIGHT: RIGHT,
        BOTTOM: BOTTOM,
        LEFT: LEFT,
        TOP_RIGHT: TOP | RIGHT,
        TOP_BOTTOM: TOP | BOTTOM,
        TOP_LEFT: TOP | LEFT,
        RIGHT_BOTTOM: RIGHT | BOTTOM,
        RIGHT_LEFT: RIGHT | LEFT,
        BOTTOM_LEFT: BOTTOM | LEFT,
        NOT_TOP: RIGHT | BOTTOM | LEFT,
        NOT_RIGHT: TOP | BOTTOM | LEFT,
        NOT_BOTTOM: TOP | RIGHT | LEFT,
        NOT_LEFT: TOP | RIGHT | BOTTOM,
        ALL: TOP | RIGHT | BOTTOM | LEFT
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DBaseBorder = /** @class */ (function () {
        function DBaseBorder(theme, options, callback) {
            this._theme = theme;
            this._callback = callback;
            var border = options === null || options === void 0 ? void 0 : options.border;
            if (border) {
                this._color = border.color;
                this._alpha = border.alpha;
                this._width = border.width;
                this._align = border.align;
                this._mask = toEnum(border.mask, DBorderMask);
            }
        }
        DBaseBorder.prototype.getTheme = function () {
            return this._theme;
        };
        DBaseBorder.prototype.setTheme = function (theme) {
            this._theme = theme;
        };
        DBaseBorder.prototype.getColor = function (state) {
            var color = this._color;
            if (color !== undefined) {
                if (isFunction(color)) {
                    var result = color(state);
                    if (result !== undefined) {
                        return result;
                    }
                }
                else {
                    return color;
                }
            }
            return this._theme.getBorderColor(state);
        };
        Object.defineProperty(DBaseBorder.prototype, "color", {
            get: function () {
                return this._color;
            },
            set: function (color) {
                if (this._color !== color) {
                    this._color = color;
                    this.onChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        DBaseBorder.prototype.getAlpha = function (state) {
            var alpha = this._alpha;
            if (alpha !== undefined) {
                if (isFunction(alpha)) {
                    var result = alpha(state);
                    if (result !== undefined) {
                        return result;
                    }
                }
                else {
                    return alpha;
                }
            }
            return this._theme.getBorderAlpha(state);
        };
        Object.defineProperty(DBaseBorder.prototype, "alpha", {
            get: function () {
                return this._alpha;
            },
            set: function (alpha) {
                if (this._alpha !== alpha) {
                    this._alpha = alpha;
                    this.onChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        DBaseBorder.prototype.getWidth = function (state) {
            var width = this._width;
            if (width !== undefined) {
                if (isFunction(width)) {
                    var result = width(state);
                    if (result !== undefined) {
                        return result;
                    }
                }
                else {
                    return width;
                }
            }
            return this._theme.getBorderWidth(state);
        };
        Object.defineProperty(DBaseBorder.prototype, "width", {
            get: function () {
                return this._width;
            },
            set: function (width) {
                if (this._width !== width) {
                    this._width = width;
                    this.onChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        DBaseBorder.prototype.getAlign = function (state) {
            var align = this._align;
            if (align !== undefined) {
                if (isFunction(align)) {
                    var result = align(state);
                    if (result !== undefined) {
                        return result;
                    }
                }
                else {
                    return align;
                }
            }
            return this._theme.getBorderAlign(state);
        };
        Object.defineProperty(DBaseBorder.prototype, "align", {
            get: function () {
                return this._align;
            },
            set: function (align) {
                if (this._align !== align) {
                    this._align = align;
                    this.onChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        DBaseBorder.prototype.getMask = function (state) {
            var mask = this._mask;
            if (mask !== undefined) {
                if (isFunction(mask)) {
                    var result = mask(state);
                    if (result !== undefined) {
                        return result;
                    }
                }
                else {
                    return mask;
                }
            }
            return this._theme.getBorderMask(state);
        };
        Object.defineProperty(DBaseBorder.prototype, "mask", {
            get: function () {
                return this._mask;
            },
            set: function (mask) {
                if (this._mask !== mask) {
                    this._mask = mask;
                    this.onChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        DBaseBorder.prototype.onChange = function () {
            var callback = this._callback;
            if (callback != null) {
                callback();
            }
        };
        return DBaseBorder;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var TOP_LEFT = 1;
    var TOP_RIGHT = 2;
    var BOTTOM_LEFT = 4;
    var BOTTOM_RIGHT = 8;
    /**
     * A corner mask.
     * Masked corners are rendered as if the corner radius is zero.
     */
    var DCornerMask = {
        NONE: 0,
        TOP_LEFT: TOP_LEFT,
        TOP_RIGHT: TOP_RIGHT,
        BOTTOM_LEFT: BOTTOM_LEFT,
        BOTTOM_RIGHT: BOTTOM_RIGHT,
        TOP: TOP_LEFT | TOP_RIGHT,
        BOTTOM: BOTTOM_LEFT | BOTTOM_RIGHT,
        LEFT: TOP_LEFT | BOTTOM_LEFT,
        RIGHT: TOP_RIGHT | BOTTOM_RIGHT,
        ALL: TOP_LEFT | TOP_RIGHT | BOTTOM_LEFT | BOTTOM_RIGHT
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DBaseCorner = /** @class */ (function () {
        function DBaseCorner(theme, options, callback) {
            this._theme = theme;
            this._callback = callback;
            var corner = options === null || options === void 0 ? void 0 : options.corner;
            if (corner) {
                if (isNumber(corner)) {
                    this._radius = corner;
                    this._mask = undefined;
                }
                else {
                    this._radius = corner.radius;
                    this._mask = toEnum(corner.mask, DCornerMask);
                }
            }
        }
        DBaseCorner.prototype.getTheme = function () {
            return this._theme;
        };
        DBaseCorner.prototype.setTheme = function (theme) {
            this._theme = theme;
        };
        DBaseCorner.prototype.getRadius = function () {
            var _a;
            return (_a = this._radius) !== null && _a !== void 0 ? _a : this._theme.getCornerRadius();
        };
        Object.defineProperty(DBaseCorner.prototype, "radius", {
            get: function () {
                return this._radius;
            },
            set: function (radius) {
                if (this._radius !== radius) {
                    this._radius = radius;
                    var callback = this._callback;
                    if (callback != null) {
                        callback();
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        DBaseCorner.prototype.getMask = function () {
            var _a;
            return (_a = this._mask) !== null && _a !== void 0 ? _a : this._theme.getCornerMask();
        };
        Object.defineProperty(DBaseCorner.prototype, "mask", {
            get: function () {
                return this._mask;
            },
            set: function (mask) {
                if (this._mask !== mask) {
                    this._mask = mask;
                    var callback = this._callback;
                    if (callback != null) {
                        callback();
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        DBaseCorner.prototype.set = function (radius, mask) {
            var isChanged = false;
            if (this._radius !== radius) {
                this._radius = radius;
                isChanged = true;
            }
            if (this._mask !== mask) {
                this._mask = mask;
                isChanged = true;
            }
            var callback = this._callback;
            if (isChanged && callback != null) {
                callback();
            }
        };
        return DBaseCorner;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var SELF = 1;
    var CHILDREN = 2;
    /**
     * DBase interactivity.
     * Mouse / touch events are triggered only on interactive objects.
     */
    var DBaseInteractive = {
        /**
         * Not interactive.
         */
        NONE: 0,
        /**
         * Interactive.
         */
        SELF: SELF,
        /**
         * Children are interactive.
         */
        CHILDREN: CHILDREN,
        /**
         * Interactive.
         * And also children are interactive.
         */
        BOTH: SELF | CHILDREN
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DBaseOutline = /** @class */ (function () {
        function DBaseOutline(theme, options, callback) {
            this._theme = theme;
            this._callback = callback;
            var outline = options === null || options === void 0 ? void 0 : options.outline;
            if (outline) {
                this._color = outline.color;
                this._alpha = outline.alpha;
                this._width = outline.width;
                this._offset = outline.offset;
                this._align = outline.align;
                this._mask = toEnum(outline.mask, DBorderMask);
            }
        }
        DBaseOutline.prototype.getTheme = function () {
            return this._theme;
        };
        DBaseOutline.prototype.setTheme = function (theme) {
            this._theme = theme;
        };
        DBaseOutline.prototype.getColor = function (state) {
            var color = this._color;
            if (color !== undefined) {
                if (isFunction(color)) {
                    var result = color(state);
                    if (result !== undefined) {
                        return result;
                    }
                }
                else {
                    return color;
                }
            }
            return this._theme.getOutlineColor(state);
        };
        Object.defineProperty(DBaseOutline.prototype, "color", {
            get: function () {
                return this._color;
            },
            set: function (color) {
                if (this._color !== color) {
                    this._color = color;
                    var callback = this._callback;
                    if (callback != null) {
                        callback();
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        DBaseOutline.prototype.getAlpha = function (state) {
            var alpha = this._alpha;
            if (alpha !== undefined) {
                if (isFunction(alpha)) {
                    var result = alpha(state);
                    if (result !== undefined) {
                        return result;
                    }
                }
                else {
                    return alpha;
                }
            }
            return this._theme.getOutlineAlpha(state);
        };
        Object.defineProperty(DBaseOutline.prototype, "alpha", {
            get: function () {
                return this._alpha;
            },
            set: function (alpha) {
                if (this._alpha !== alpha) {
                    this._alpha = alpha;
                    var callback = this._callback;
                    if (callback != null) {
                        callback();
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        DBaseOutline.prototype.getWidth = function (state) {
            var width = this._width;
            if (width !== undefined) {
                if (isFunction(width)) {
                    var result = width(state);
                    if (result !== undefined) {
                        return result;
                    }
                }
                else {
                    return width;
                }
            }
            return this._theme.getOutlineWidth(state);
        };
        Object.defineProperty(DBaseOutline.prototype, "width", {
            get: function () {
                return this._width;
            },
            set: function (width) {
                if (this._width !== width) {
                    this._width = width;
                    var callback = this._callback;
                    if (callback != null) {
                        callback();
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        DBaseOutline.prototype.getOffset = function (state) {
            var offset = this._offset;
            if (offset !== undefined) {
                if (isFunction(offset)) {
                    var result = offset(state);
                    if (result !== undefined) {
                        return result;
                    }
                }
                else {
                    return offset;
                }
            }
            return this._theme.getOutlineOffset(state);
        };
        Object.defineProperty(DBaseOutline.prototype, "offset", {
            get: function () {
                return this._offset;
            },
            set: function (offset) {
                if (this._offset !== offset) {
                    this._offset = offset;
                    var callback = this._callback;
                    if (callback != null) {
                        callback();
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        DBaseOutline.prototype.getAlign = function (state) {
            var align = this._align;
            if (align !== undefined) {
                if (isFunction(align)) {
                    var result = align(state);
                    if (result !== undefined) {
                        return result;
                    }
                }
                else {
                    return align;
                }
            }
            return this._theme.getOutlineAlign(state);
        };
        Object.defineProperty(DBaseOutline.prototype, "align", {
            get: function () {
                return this._align;
            },
            set: function (align) {
                if (this._align !== align) {
                    this._align = align;
                    var callback = this._callback;
                    if (callback != null) {
                        callback();
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        DBaseOutline.prototype.getMask = function (state) {
            var mask = this._mask;
            if (mask !== undefined) {
                if (isFunction(mask)) {
                    var result = mask(state);
                    if (result !== undefined) {
                        return result;
                    }
                }
                else {
                    return mask;
                }
            }
            return this._theme.getOutlineMask(state);
        };
        Object.defineProperty(DBaseOutline.prototype, "mask", {
            get: function () {
                return this._mask;
            },
            set: function (mask) {
                if (this._mask !== mask) {
                    this._mask = mask;
                    var callback = this._callback;
                    if (callback != null) {
                        callback();
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        return DBaseOutline;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DBasePadding = /** @class */ (function () {
        function DBasePadding(theme, options, callback) {
            this._theme = theme;
            this._callback = callback;
            var padding = options === null || options === void 0 ? void 0 : options.padding;
            if (padding != null) {
                if (isNumber(padding)) {
                    this._left = padding;
                    this._top = padding;
                    this._right = padding;
                    this._bottom = padding;
                }
                else {
                    this._left = padding.left;
                    this._top = padding.top;
                    this._right = padding.right;
                    this._bottom = padding.bottom;
                }
            }
        }
        DBasePadding.prototype.getTheme = function () {
            return this._theme;
        };
        DBasePadding.prototype.setTheme = function (theme) {
            this._theme = theme;
        };
        DBasePadding.prototype.getCallback = function () {
            return this._callback;
        };
        DBasePadding.prototype.getLeft = function () {
            var _a;
            return (_a = this._left) !== null && _a !== void 0 ? _a : this._theme.getPaddingLeft();
        };
        Object.defineProperty(DBasePadding.prototype, "left", {
            get: function () {
                return this._left;
            },
            set: function (left) {
                if (this._left !== left) {
                    this._left = left;
                    if (this._callback != null) {
                        this._callback();
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        DBasePadding.prototype.getTop = function () {
            var _a;
            return (_a = this._top) !== null && _a !== void 0 ? _a : this._theme.getPaddingTop();
        };
        Object.defineProperty(DBasePadding.prototype, "top", {
            get: function () {
                return this._top;
            },
            set: function (top) {
                if (this._top !== top) {
                    this._top = top;
                    if (this._callback != null) {
                        this._callback();
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        DBasePadding.prototype.getRight = function () {
            var _a;
            return (_a = this._right) !== null && _a !== void 0 ? _a : this._theme.getPaddingRight();
        };
        Object.defineProperty(DBasePadding.prototype, "right", {
            get: function () {
                return this._right;
            },
            set: function (right) {
                if (this._right !== right) {
                    this._right = right;
                    if (this._callback != null) {
                        this._callback();
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        DBasePadding.prototype.getBottom = function () {
            var _a;
            return (_a = this._bottom) !== null && _a !== void 0 ? _a : this._theme.getPaddingBottom();
        };
        Object.defineProperty(DBasePadding.prototype, "bottom", {
            get: function () {
                return this._bottom;
            },
            set: function (bottom) {
                if (this._bottom !== bottom) {
                    this._bottom = bottom;
                    if (this._callback != null) {
                        this._callback();
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        DBasePadding.prototype.set = function (top, right, bottom, left) {
            if (right == null) {
                this.top = top;
                this.right = top;
                this.bottom = top;
                this.left = top;
            }
            else if (bottom == null) {
                this.top = top;
                this.right = right;
                this.bottom = top;
                this.left = right;
            }
            else if (left == null) {
                this.top = top;
                this.right = right;
                this.bottom = bottom;
                this.left = right;
            }
            else {
                this.top = top;
                this.right = right;
                this.bottom = bottom;
                this.left = left;
            }
            if (this._callback != null) {
                this._callback();
            }
        };
        return DBasePadding;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DBasePoint = /** @class */ (function () {
        function DBasePoint(point, onChange) {
            this._point = point;
            this._onChange = onChange;
        }
        Object.defineProperty(DBasePoint.prototype, "x", {
            get: function () {
                return this._point.x;
            },
            set: function (x) {
                var point = this._point;
                var oldX = point.x;
                if (oldX !== x) {
                    point.x = x;
                    var y = point.y;
                    this._onChange(x, y, oldX, y);
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBasePoint.prototype, "y", {
            get: function () {
                return this._point.y;
            },
            set: function (y) {
                var point = this._point;
                var oldY = point.y;
                if (oldY !== y) {
                    point.y = y;
                    var x = point.x;
                    this._onChange(x, y, x, oldY);
                }
            },
            enumerable: false,
            configurable: true
        });
        DBasePoint.prototype.set = function (x, y) {
            var point = this._point;
            var oldX = point.x;
            var oldY = point.y;
            if (oldX !== x || oldY !== y) {
                point.set(x, y);
                this._onChange(x, y, oldX, oldY);
            }
            return this;
        };
        DBasePoint.prototype.copyFrom = function (target) {
            var x = target.x;
            var y = target.y;
            var point = this._point;
            var oldX = point.x;
            var oldY = point.y;
            if (oldX !== x || oldY !== y) {
                point.copyFrom(target);
                this._onChange(x, y, oldX, oldY);
            }
            return this;
        };
        DBasePoint.prototype.copyTo = function (target) {
            return target.copyFrom(this._point);
        };
        DBasePoint.prototype.copy = function () {
            // eslint-disable-next-line prefer-rest-params
            return this.copyFrom(arguments[0]);
        };
        DBasePoint.prototype.clone = function (onChange) {
            return new DBasePoint(this._point, onChange || this._onChange);
        };
        DBasePoint.prototype.equals = function (p) {
            return this._point.equals(p);
        };
        return DBasePoint;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DBaseMeshGeometry = /** @class */ (function (_super) {
        __extends(DBaseMeshGeometry, _super);
        function DBaseMeshGeometry(vertices, uvs, indices) {
            var _this = _super.call(this, vertices, uvs, indices) || this;
            _this._width = 100;
            _this._height = 100;
            _this._cornerRadius = 0;
            _this._cornerMask = DCornerMask.NONE;
            _this._isDirty = true;
            _this._resolution = 1;
            _this._vertexBuffer = _this.getBuffer("aVertexPosition");
            _this._vertices = _this._vertexBuffer.data;
            _this._uvBuffer = _this.getBuffer("aTextureCoord");
            _this._uvs = _this._uvBuffer.data;
            _this._indexBuffer = _this.getIndex();
            _this._indices = _this._indexBuffer.data;
            return _this;
        }
        Object.defineProperty(DBaseMeshGeometry.prototype, "width", {
            get: function () {
                return this._width;
            },
            set: function (width) {
                if (this._width !== width) {
                    this._width = width;
                    this._isDirty = true;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseMeshGeometry.prototype, "height", {
            get: function () {
                return this._height;
            },
            set: function (height) {
                if (this._height !== height) {
                    this._height = height;
                    this._isDirty = true;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseMeshGeometry.prototype, "cornerRadius", {
            get: function () {
                return this._cornerRadius;
            },
            set: function (borderSize) {
                if (this._cornerRadius !== borderSize) {
                    this._cornerRadius = borderSize;
                    this._isDirty = true;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseMeshGeometry.prototype, "cornerMask", {
            get: function () {
                return this._cornerMask;
            },
            set: function (cornerMask) {
                if (this._cornerMask !== cornerMask) {
                    this._cornerMask = cornerMask;
                    this._isDirty = true;
                }
            },
            enumerable: false,
            configurable: true
        });
        DBaseMeshGeometry.prototype.getTables = function () {
            var result = DBaseMeshGeometry.TABLES;
            if (result == null) {
                result = this.newTables(DBaseMeshGeometry.N);
                DBaseMeshGeometry.TABLES = result;
            }
            return result;
        };
        DBaseMeshGeometry.prototype.newTables = function (n) {
            var dp = 1.0 / (n - 1);
            var da = 0.5 * dp;
            return [
                this.newTable(n, 1.0, da),
                this.newTable(n, 0.5, da),
                this.newTable(n, 0.0, da),
                this.newTable(n, 1.5, da)
            ];
        };
        DBaseMeshGeometry.prototype.newTable = function (n, a0, da) {
            var cos = [];
            var sin = [];
            var pi = Math.PI;
            for (var i = 0, a = a0; i < n; i += 1, a -= da) {
                var t = a * pi;
                var c = +Math.cos(t);
                var s = -Math.sin(t);
                cos.push(c);
                sin.push(s);
            }
            return {
                cos: cos,
                sin: sin
            };
        };
        /** Note that this must be an odd number. */
        DBaseMeshGeometry.N = 5;
        return DBaseMeshGeometry;
    }(pixi_js.MeshGeometry));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DBaseBackgroundMeshGeometry = /** @class */ (function (_super) {
        __extends(DBaseBackgroundMeshGeometry, _super);
        function DBaseBackgroundMeshGeometry() {
            return _super.call(this, new Float32Array(16 * DBaseMeshGeometry.N), new Float32Array(16 * DBaseMeshGeometry.N), new Uint16Array(3 * (12 * DBaseMeshGeometry.N - 2))) || this;
        }
        DBaseBackgroundMeshGeometry.prototype.fillVertices = function (vertices, uvs, iv, iuv, n, x, y, r, dr, table) {
            var cos = table.cos;
            var sin = table.sin;
            var r1 = r + dr;
            for (var i = 0; i < n; ++i) {
                var c = cos[i];
                var s = sin[i];
                vertices[++iv] = x + c * r;
                vertices[++iv] = y + s * r;
                vertices[++iv] = x + c * r1;
                vertices[++iv] = y + s * r1;
                uvs[++iuv] = 0.5;
                uvs[++iuv] = 0.5;
                uvs[++iuv] = 0.5 * (1 + c);
                uvs[++iuv] = 0.5 * (1 + s);
            }
        };
        DBaseBackgroundMeshGeometry.prototype.fillIndices = function (indices, ia, ii, n) {
            for (var i = 0; i < n; ++i) {
                indices[++ii] = ia + 0;
                indices[++ii] = ia + 1;
                indices[++ii] = ia + 2;
                indices[++ii] = ia + 2;
                indices[++ii] = ia + 1;
                indices[++ii] = ia + 3;
                ia += 2;
            }
        };
        DBaseBackgroundMeshGeometry.prototype.fillIndicesEnd = function (indices, ia, ii, n) {
            for (var i = 0, imax = n - 1; i < imax; ++i) {
                indices[++ii] = ia + 0;
                indices[++ii] = ia + 1;
                indices[++ii] = ia + 2;
                indices[++ii] = ia + 2;
                indices[++ii] = ia + 1;
                indices[++ii] = ia + 3;
                ia += 2;
            }
            indices[++ii] = ia + 0;
            indices[++ii] = ia + 1;
            indices[++ii] = 0;
            indices[++ii] = 0;
            indices[++ii] = ia + 1;
            indices[++ii] = 1;
            ia += 2;
        };
        DBaseBackgroundMeshGeometry.prototype.update = function (renderer) {
            var resolution = renderer.resolution;
            if (this._isDirty || this._resolution !== resolution) {
                this._isDirty = false;
                this._resolution = resolution;
                var vertices = this._vertices;
                var uvs = this._uvs;
                var indices = this._indices;
                var w = this._width;
                var h = this._height;
                var r = Math.min(0.5 * w, 0.5 * h, this._cornerRadius);
                var a = 0.5 / resolution;
                var x0 = 0;
                var x1 = r;
                var x2 = w - r;
                var x3 = w;
                var y0 = 0;
                var y1 = r;
                var y2 = h - r;
                var y3 = h;
                var cornerMask = this._cornerMask;
                var ctl = !(cornerMask & DCornerMask.TOP_LEFT);
                var ctr = !(cornerMask & DCornerMask.TOP_RIGHT);
                var cbl = !(cornerMask & DCornerMask.BOTTOM_LEFT);
                var cbr = !(cornerMask & DCornerMask.BOTTOM_RIGHT);
                // Vertices & UVs
                var iv = -1;
                var iuv = -1;
                var ia = 0;
                var ii = -1;
                var n = DBaseMeshGeometry.N;
                var n4 = n << 2;
                var n2 = n << 1;
                var n6 = 6 * n;
                var tables = this.getTables();
                var tlt = tables[0];
                var ttr = tables[1];
                var trb = tables[2];
                var tbl = tables[3];
                // left -> top
                if (ctl) {
                    this.fillVertices(vertices, uvs, iv, iuv, n, x1, y1, r, a, tlt);
                }
                else {
                    this.fillVertices(vertices, uvs, iv, iuv, n, x0, y0, 0, a, tlt);
                }
                this.fillIndices(indices, ia, ii, n);
                iv += n4;
                iuv += n4;
                ia += n2;
                ii += n6;
                // top -> right
                if (ctr) {
                    this.fillVertices(vertices, uvs, iv, iuv, n, x2, y1, r, a, ttr);
                }
                else {
                    this.fillVertices(vertices, uvs, iv, iuv, n, x3, y0, 0, a, ttr);
                }
                this.fillIndices(indices, ia, ii, n);
                iv += n4;
                iuv += n4;
                ia += n2;
                ii += n6;
                // right -> bottom
                if (cbr) {
                    this.fillVertices(vertices, uvs, iv, iuv, n, x2, y2, r, a, trb);
                }
                else {
                    this.fillVertices(vertices, uvs, iv, iuv, n, x3, y3, 0, a, trb);
                }
                this.fillIndices(indices, ia, ii, n);
                iv += n4;
                iuv += n4;
                ia += n2;
                ii += n6;
                // bottom -> left
                if (cbl) {
                    this.fillVertices(vertices, uvs, iv, iuv, n, x1, y2, r, a, tbl);
                }
                else {
                    this.fillVertices(vertices, uvs, iv, iuv, n, x0, y3, 0, a, tbl);
                }
                this.fillIndicesEnd(indices, ia, ii, n);
                iv += n4;
                iuv += n4;
                ia += n2;
                ii += n6;
                // Center
                ia = 2;
                for (var i = 1, imax = 4 * n - 1; i < imax; i += 1, ia += 2) {
                    indices[++ii] = 0;
                    indices[++ii] = ia;
                    indices[++ii] = ia + 2;
                }
                this._vertexBuffer.update();
                this._uvBuffer.update();
                this._indexBuffer.update();
            }
        };
        return DBaseBackgroundMeshGeometry;
    }(DBaseMeshGeometry));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DBaseBackgroundMesh = /** @class */ (function (_super) {
        __extends(DBaseBackgroundMesh, _super);
        function DBaseBackgroundMesh(texture) {
            var _this = _super.call(this, new DBaseBackgroundMeshGeometry(), new pixi_js.MeshMaterial(texture)) || this;
            texture.on("update", function () {
                DApplications.update(_this);
            });
            return _this;
        }
        Object.defineProperty(DBaseBackgroundMesh.prototype, "width", {
            // @ts-ignore
            get: function () {
                return this.geometry.width;
            },
            set: function (width) {
                this.geometry.width = width;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseBackgroundMesh.prototype, "height", {
            // @ts-ignore
            get: function () {
                return this.geometry.height;
            },
            set: function (height) {
                this.geometry.height = height;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseBackgroundMesh.prototype, "cornerRadius", {
            get: function () {
                return this.geometry.cornerRadius;
            },
            set: function (cornerRadius) {
                this.geometry.cornerRadius = cornerRadius;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseBackgroundMesh.prototype, "cornerMask", {
            get: function () {
                return this.geometry.cornerMask;
            },
            set: function (cornerMask) {
                this.geometry.cornerMask = cornerMask;
            },
            enumerable: false,
            configurable: true
        });
        DBaseBackgroundMesh.prototype._render = function (renderer) {
            this.geometry.update(renderer);
            _super.prototype._render.call(this, renderer);
        };
        return DBaseBackgroundMesh;
    }(pixi_js.Mesh));

    /*
     * Copyright (C) 2020 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DBaseBackgroundSnippet = /** @class */ (function () {
        function DBaseBackgroundSnippet() {
        }
        DBaseBackgroundSnippet.prototype.get = function (base, theme) {
            var result = this._mesh;
            if (result == null) {
                result = new DBaseBackgroundMesh(theme.getBackgroundTexture());
                result.parent = base;
                this._mesh = result;
            }
            return result;
        };
        DBaseBackgroundSnippet.prototype.hide = function () {
            var mesh = this._mesh;
            if (mesh != null) {
                mesh.visible = false;
            }
        };
        DBaseBackgroundSnippet.prototype.onReflow = function (base, width, height, theme, state, cornerRadius, cornerMask) {
            var background = base.background;
            var backgroundColor = background.getColor(state);
            if (backgroundColor != null) {
                var backgroundAlpha = background.getAlpha(state);
                if (0 < backgroundAlpha) {
                    var backgroundMesh = this.get(base, theme);
                    backgroundMesh.tint = backgroundColor;
                    backgroundMesh.alpha = backgroundAlpha;
                    backgroundMesh.width = width;
                    backgroundMesh.height = height;
                    backgroundMesh.cornerRadius = cornerRadius;
                    backgroundMesh.cornerMask = cornerMask;
                    backgroundMesh.visible = true;
                }
                else {
                    this.hide();
                }
            }
            else {
                this.hide();
            }
        };
        DBaseBackgroundSnippet.prototype.render = function (renderer) {
            var _a;
            (_a = this._mesh) === null || _a === void 0 ? void 0 : _a.render(renderer);
        };
        DBaseBackgroundSnippet.prototype.updateTransform = function () {
            var _a;
            (_a = this._mesh) === null || _a === void 0 ? void 0 : _a.updateTransform();
        };
        return DBaseBackgroundSnippet;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DBaseBorderMeshGeometry = /** @class */ (function (_super) {
        __extends(DBaseBorderMeshGeometry, _super);
        function DBaseBorderMeshGeometry() {
            var _this = _super.call(this, new Float32Array(32 * DBaseMeshGeometry.N), new Float32Array(32 * DBaseMeshGeometry.N), new Uint16Array(4 * 18 * DBaseMeshGeometry.N)) || this;
            _this._borderWidth = 0;
            _this._borderMask = DBorderMask.NONE;
            return _this;
        }
        Object.defineProperty(DBaseBorderMeshGeometry.prototype, "borderWidth", {
            get: function () {
                return this._borderWidth;
            },
            set: function (borderWidth) {
                if (this._borderWidth !== borderWidth) {
                    this._borderWidth = borderWidth;
                    this._isDirty = true;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseBorderMeshGeometry.prototype, "borderMask", {
            get: function () {
                return this._borderMask;
            },
            set: function (borderMask) {
                if (this._borderMask !== borderMask) {
                    this._borderMask = borderMask;
                    this._isDirty = true;
                }
            },
            enumerable: false,
            configurable: true
        });
        DBaseBorderMeshGeometry.prototype.fillVertices = function (vertices, uvs, iv, iuv, n, x, y, r, dr, borderWidth, table) {
            var hw = 0.5 * borderWidth;
            var r1 = r - hw;
            var r2 = r + hw;
            var r0 = r1 - dr;
            var r3 = r2 + dr;
            var cos = table.cos;
            var sin = table.sin;
            if (r0 <= 0) {
                var c0 = cos[0] + cos[n - 1];
                var s0 = sin[0] + sin[n - 1];
                if (r1 <= 0) {
                    if (r <= 0) {
                        for (var i = 0; i < n; ++i) {
                            var c = cos[i];
                            var s = sin[i];
                            vertices[++iv] = x + c0 * r0;
                            vertices[++iv] = y + s0 * r0;
                            vertices[++iv] = x + c0 * r1;
                            vertices[++iv] = y + s0 * r1;
                            vertices[++iv] = x + c0 * r2;
                            vertices[++iv] = y + s0 * r2;
                            vertices[++iv] = x + c0 * r3;
                            vertices[++iv] = y + s0 * r3;
                            uvs[++iuv] = 0.5 * (1 + c);
                            uvs[++iuv] = 0.5 * (1 + s);
                            uvs[++iuv] = 0.5;
                            uvs[++iuv] = 0.5;
                            uvs[++iuv] = 0.5;
                            uvs[++iuv] = 0.5;
                            uvs[++iuv] = 0.5 * (1 + c);
                            uvs[++iuv] = 0.5 * (1 + s);
                        }
                    }
                    else {
                        for (var i = 0; i < n; ++i) {
                            var c = cos[i];
                            var s = sin[i];
                            vertices[++iv] = x + c0 * r0;
                            vertices[++iv] = y + s0 * r0;
                            vertices[++iv] = x + c0 * r1;
                            vertices[++iv] = y + s0 * r1;
                            vertices[++iv] = x + c * r2;
                            vertices[++iv] = y + s * r2;
                            vertices[++iv] = x + c * r3;
                            vertices[++iv] = y + s * r3;
                            uvs[++iuv] = 0.5 * (1 + c);
                            uvs[++iuv] = 0.5 * (1 + s);
                            uvs[++iuv] = 0.5;
                            uvs[++iuv] = 0.5;
                            uvs[++iuv] = 0.5;
                            uvs[++iuv] = 0.5;
                            uvs[++iuv] = 0.5 * (1 + c);
                            uvs[++iuv] = 0.5 * (1 + s);
                        }
                    }
                }
                else {
                    for (var i = 0; i < n; ++i) {
                        var c = cos[i];
                        var s = sin[i];
                        vertices[++iv] = x + c0 * r0;
                        vertices[++iv] = y + s0 * r0;
                        vertices[++iv] = x + c * r1;
                        vertices[++iv] = y + s * r1;
                        vertices[++iv] = x + c * r2;
                        vertices[++iv] = y + s * r2;
                        vertices[++iv] = x + c * r3;
                        vertices[++iv] = y + s * r3;
                        uvs[++iuv] = 0.5 * (1 + c);
                        uvs[++iuv] = 0.5 * (1 + s);
                        uvs[++iuv] = 0.5;
                        uvs[++iuv] = 0.5;
                        uvs[++iuv] = 0.5;
                        uvs[++iuv] = 0.5;
                        uvs[++iuv] = 0.5 * (1 + c);
                        uvs[++iuv] = 0.5 * (1 + s);
                    }
                }
            }
            else {
                for (var i = 0; i < n; ++i) {
                    var c = cos[i];
                    var s = sin[i];
                    vertices[++iv] = x + c * r0;
                    vertices[++iv] = y + s * r0;
                    vertices[++iv] = x + c * r1;
                    vertices[++iv] = y + s * r1;
                    vertices[++iv] = x + c * r2;
                    vertices[++iv] = y + s * r2;
                    vertices[++iv] = x + c * r3;
                    vertices[++iv] = y + s * r3;
                    uvs[++iuv] = 0.5 * (1 + c);
                    uvs[++iuv] = 0.5 * (1 + s);
                    uvs[++iuv] = 0.5;
                    uvs[++iuv] = 0.5;
                    uvs[++iuv] = 0.5;
                    uvs[++iuv] = 0.5;
                    uvs[++iuv] = 0.5 * (1 + c);
                    uvs[++iuv] = 0.5 * (1 + s);
                }
            }
        };
        DBaseBorderMeshGeometry.prototype.fillIndices = function (indices, ia, ii, n, end, loop) {
            for (var i = 0, imax = n - 1; i < imax; ++i) {
                indices[++ii] = ia + 0;
                indices[++ii] = ia + 1;
                indices[++ii] = ia + 4;
                indices[++ii] = ia + 4;
                indices[++ii] = ia + 1;
                indices[++ii] = ia + 5;
                ia += 1;
                indices[++ii] = ia + 0;
                indices[++ii] = ia + 1;
                indices[++ii] = ia + 4;
                indices[++ii] = ia + 4;
                indices[++ii] = ia + 1;
                indices[++ii] = ia + 5;
                ia += 1;
                indices[++ii] = ia + 0;
                indices[++ii] = ia + 1;
                indices[++ii] = ia + 4;
                indices[++ii] = ia + 4;
                indices[++ii] = ia + 1;
                indices[++ii] = ia + 5;
                ia += 2;
            }
            if (end) {
                if (loop) {
                    indices[++ii] = ia + 0;
                    indices[++ii] = ia + 1;
                    indices[++ii] = 0;
                    indices[++ii] = 0;
                    indices[++ii] = ia + 1;
                    indices[++ii] = 1;
                    ia += 1;
                    indices[++ii] = ia + 0;
                    indices[++ii] = ia + 1;
                    indices[++ii] = 1;
                    indices[++ii] = 1;
                    indices[++ii] = ia + 1;
                    indices[++ii] = 2;
                    ia += 1;
                    indices[++ii] = ia + 0;
                    indices[++ii] = ia + 1;
                    indices[++ii] = 2;
                    indices[++ii] = 2;
                    indices[++ii] = ia + 1;
                    indices[++ii] = 3;
                    ia += 2;
                }
                else {
                    indices[++ii] = ia + 0;
                    indices[++ii] = ia + 1;
                    indices[++ii] = ia + 4;
                    indices[++ii] = ia + 4;
                    indices[++ii] = ia + 1;
                    indices[++ii] = ia + 5;
                    ia += 1;
                    indices[++ii] = ia + 0;
                    indices[++ii] = ia + 1;
                    indices[++ii] = ia + 4;
                    indices[++ii] = ia + 4;
                    indices[++ii] = ia + 1;
                    indices[++ii] = ia + 5;
                    ia += 1;
                    indices[++ii] = ia + 0;
                    indices[++ii] = ia + 1;
                    indices[++ii] = ia + 4;
                    indices[++ii] = ia + 4;
                    indices[++ii] = ia + 1;
                    indices[++ii] = ia + 5;
                    ia += 2;
                }
            }
            else {
                indices[++ii] = ia;
                indices[++ii] = ia;
                indices[++ii] = ia;
                indices[++ii] = ia;
                indices[++ii] = ia;
                indices[++ii] = ia;
                ia += 1;
                indices[++ii] = ia;
                indices[++ii] = ia;
                indices[++ii] = ia;
                indices[++ii] = ia;
                indices[++ii] = ia;
                indices[++ii] = ia;
                ia += 1;
                indices[++ii] = ia;
                indices[++ii] = ia;
                indices[++ii] = ia;
                indices[++ii] = ia;
                indices[++ii] = ia;
                indices[++ii] = ia;
                ia += 2;
            }
        };
        DBaseBorderMeshGeometry.prototype.update = function (renderer) {
            var resolution = renderer.resolution;
            if (this._isDirty || this._resolution !== resolution) {
                this._isDirty = false;
                this._resolution = resolution;
                var vrtcs = this._vertices;
                var uvs = this._uvs;
                var indices = this._indices;
                var w = this._width;
                var h = this._height;
                var bw = this._borderWidth;
                var r = Math.min(0.5 * w, 0.5 * h, this._cornerRadius);
                var a = 0.5 / resolution;
                var x0 = 0;
                var x1 = r;
                var x2 = w - r;
                var x3 = w;
                var y0 = 0;
                var y1 = r;
                var y2 = h - r;
                var y3 = h;
                var borderMask = this._borderMask;
                var bt = !(borderMask & DBorderMask.TOP);
                var bb = !(borderMask & DBorderMask.BOTTOM);
                var bl = !(borderMask & DBorderMask.LEFT);
                var br = !(borderMask & DBorderMask.RIGHT);
                var cornerMask = this._cornerMask;
                var ctl = !(cornerMask & DCornerMask.TOP_LEFT);
                var ctr = !(cornerMask & DCornerMask.TOP_RIGHT);
                var cbl = !(cornerMask & DCornerMask.BOTTOM_LEFT);
                var cbr = !(cornerMask & DCornerMask.BOTTOM_RIGHT);
                // Vertices & UVs
                var iv = -1;
                var iuv = -1;
                var ia = 0;
                var ii = -1;
                var n = DBaseMeshGeometry.N;
                var n4 = n << 2;
                var n8 = n << 3;
                var n18 = 18 * n;
                var tables = this.getTables();
                var tlt = tables[0];
                var ttr = tables[1];
                var trb = tables[2];
                var tbl = tables[3];
                // left -> top
                if (ctl) {
                    if (bl || bt) {
                        this.fillVertices(vrtcs, uvs, iv, iuv, n, x1, y1, r, a, bw, tlt);
                    }
                    else {
                        this.fillVertices(vrtcs, uvs, iv, iuv, n, x1, y1, r, a, 0, tlt);
                    }
                }
                else {
                    if (bl || bt) {
                        this.fillVertices(vrtcs, uvs, iv, iuv, n, x0, y0, 0, a, bw, tlt);
                    }
                    else {
                        this.fillVertices(vrtcs, uvs, iv, iuv, n, x0, y0, 0, a, 0, tlt);
                    }
                }
                this.fillIndices(indices, ia, ii, n, bt, false);
                iv += n8;
                iuv += n8;
                ia += n4;
                ii += n18;
                // top -> right
                if (ctr) {
                    if (bt || br) {
                        this.fillVertices(vrtcs, uvs, iv, iuv, n, x2, y1, r, a, bw, ttr);
                    }
                    else {
                        this.fillVertices(vrtcs, uvs, iv, iuv, n, x2, y1, r, a, 0, ttr);
                    }
                }
                else {
                    if (bt || br) {
                        this.fillVertices(vrtcs, uvs, iv, iuv, n, x3, y0, 0, a, bw, ttr);
                    }
                    else {
                        this.fillVertices(vrtcs, uvs, iv, iuv, n, x3, y0, 0, a, 0, ttr);
                    }
                }
                this.fillIndices(indices, ia, ii, n, br, false);
                iv += n8;
                iuv += n8;
                ia += n4;
                ii += n18;
                // right -> bottom
                if (cbr) {
                    if (br || bb) {
                        this.fillVertices(vrtcs, uvs, iv, iuv, n, x2, y2, r, a, bw, trb);
                    }
                    else {
                        this.fillVertices(vrtcs, uvs, iv, iuv, n, x2, y2, r, a, 0, trb);
                    }
                }
                else {
                    if (br || bb) {
                        this.fillVertices(vrtcs, uvs, iv, iuv, n, x3, y3, 0, a, bw, trb);
                    }
                    else {
                        this.fillVertices(vrtcs, uvs, iv, iuv, n, x3, y3, 0, a, 0, trb);
                    }
                }
                this.fillIndices(indices, ia, ii, n, bb, false);
                iv += n8;
                iuv += n8;
                ia += n4;
                ii += n18;
                // bottom -> left
                if (cbl) {
                    if (bb || bl) {
                        this.fillVertices(vrtcs, uvs, iv, iuv, n, x1, y2, r, a, bw, tbl);
                    }
                    else {
                        this.fillVertices(vrtcs, uvs, iv, iuv, n, x1, y2, r, a, 0, tbl);
                    }
                }
                else {
                    if (bb || bl) {
                        this.fillVertices(vrtcs, uvs, iv, iuv, n, x0, y3, 0, a, bw, tbl);
                    }
                    else {
                        this.fillVertices(vrtcs, uvs, iv, iuv, n, x0, y3, 0, a, 0, tbl);
                    }
                }
                this.fillIndices(indices, ia, ii, n, bl, true);
                iv += n8;
                iuv += n8;
                ia += n4;
                ii += n18;
                this._vertexBuffer.update();
                this._uvBuffer.update();
                this._indexBuffer.update();
            }
        };
        return DBaseBorderMeshGeometry;
    }(DBaseMeshGeometry));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DBaseBorderMesh = /** @class */ (function (_super) {
        __extends(DBaseBorderMesh, _super);
        function DBaseBorderMesh(texture) {
            var _this = _super.call(this, new DBaseBorderMeshGeometry(), new pixi_js.MeshMaterial(texture)) || this;
            texture.on("update", function () {
                DApplications.update(_this);
            });
            return _this;
        }
        Object.defineProperty(DBaseBorderMesh.prototype, "width", {
            // @ts-ignore
            get: function () {
                return this.geometry.width;
            },
            set: function (width) {
                this.geometry.width = width;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseBorderMesh.prototype, "height", {
            // @ts-ignore
            get: function () {
                return this.geometry.height;
            },
            set: function (height) {
                this.geometry.height = height;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseBorderMesh.prototype, "cornerRadius", {
            get: function () {
                return this.geometry.cornerRadius;
            },
            set: function (cornerRadius) {
                this.geometry.cornerRadius = cornerRadius;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseBorderMesh.prototype, "cornerMask", {
            get: function () {
                return this.geometry.cornerMask;
            },
            set: function (cornerMask) {
                this.geometry.cornerMask = cornerMask;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseBorderMesh.prototype, "borderWidth", {
            get: function () {
                return this.geometry.borderWidth;
            },
            set: function (borderWidth) {
                this.geometry.borderWidth = borderWidth;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseBorderMesh.prototype, "borderMask", {
            get: function () {
                return this.geometry.borderMask;
            },
            set: function (borderMask) {
                this.geometry.borderMask = borderMask;
            },
            enumerable: false,
            configurable: true
        });
        DBaseBorderMesh.prototype._render = function (renderer) {
            this.geometry.update(renderer);
            _super.prototype._render.call(this, renderer);
        };
        return DBaseBorderMesh;
    }(pixi_js.Mesh));

    /*
     * Copyright (C) 2020 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DBaseBorderSnippet = /** @class */ (function () {
        function DBaseBorderSnippet() {
        }
        DBaseBorderSnippet.prototype.get = function (base, theme) {
            var result = this._mesh;
            if (result == null) {
                result = new DBaseBorderMesh(theme.getBorderTexture());
                result.parent = base;
                this._mesh = result;
            }
            return result;
        };
        DBaseBorderSnippet.prototype.hide = function () {
            var mesh = this._mesh;
            if (mesh != null) {
                mesh.visible = false;
            }
        };
        DBaseBorderSnippet.prototype.onReflow = function (base, width, height, theme, state, cornerRadius, cornerMask) {
            var border = base.border;
            var borderColor = border.getColor(state);
            if (borderColor != null) {
                var borderAlpha = border.getAlpha(state);
                if (0 < borderAlpha) {
                    var borderWidth = border.getWidth(state);
                    var borderMask = border.getMask(state);
                    var borderMesh = this.get(base, theme);
                    var borderOffset = (border.getAlign(state) - 0.5) * borderWidth;
                    borderMesh.tint = borderColor;
                    borderMesh.alpha = borderAlpha;
                    borderMesh.x = -borderOffset;
                    borderMesh.y = -borderOffset;
                    borderMesh.width = width + borderOffset * 2;
                    borderMesh.height = height + borderOffset * 2;
                    borderMesh.cornerRadius = Math.max(0, cornerRadius + borderOffset);
                    borderMesh.cornerMask = cornerMask;
                    borderMesh.borderWidth = borderWidth;
                    borderMesh.borderMask = borderMask;
                    borderMesh.visible = true;
                }
                else {
                    this.hide();
                }
            }
            else {
                this.hide();
            }
        };
        DBaseBorderSnippet.prototype.render = function (renderer) {
            var _a;
            (_a = this._mesh) === null || _a === void 0 ? void 0 : _a.render(renderer);
        };
        DBaseBorderSnippet.prototype.updateTransform = function () {
            var _a;
            (_a = this._mesh) === null || _a === void 0 ? void 0 : _a.updateTransform();
        };
        return DBaseBorderSnippet;
    }());

    /*
     * Copyright (C) 2020 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DBaseOutlineSnippet = /** @class */ (function () {
        function DBaseOutlineSnippet() {
        }
        DBaseOutlineSnippet.prototype.get = function (base, theme) {
            var result = this._mesh;
            if (result == null) {
                result = new DBaseBorderMesh(theme.getBorderTexture());
                result.parent = base;
                this._mesh = result;
            }
            return result;
        };
        DBaseOutlineSnippet.prototype.hide = function () {
            var mesh = this._mesh;
            if (mesh != null) {
                mesh.visible = false;
            }
        };
        DBaseOutlineSnippet.prototype.onReflow = function (base, width, height, theme, state, cornerRadius, cornerMask) {
            var outline = base.outline;
            var outlineColor = outline.getColor(state);
            if (outlineColor != null) {
                var outlineAlpha = outline.getAlpha(state);
                if (0 < outlineAlpha) {
                    var outlineWidth = outline.getWidth(state);
                    var outlineMask = outline.getMask(state);
                    var outlineMesh = this.get(base, theme);
                    var outlineOffset = outline.getOffset(state) + (outline.getAlign(state) - 0.5) * outlineWidth;
                    outlineMesh.tint = outlineColor;
                    outlineMesh.alpha = outlineAlpha;
                    outlineMesh.x = -outlineOffset;
                    outlineMesh.y = -outlineOffset;
                    outlineMesh.width = width + outlineOffset * 2;
                    outlineMesh.height = height + outlineOffset * 2;
                    outlineMesh.cornerRadius = Math.max(0, cornerRadius + outlineOffset);
                    outlineMesh.cornerMask = cornerMask;
                    outlineMesh.borderWidth = outlineWidth;
                    outlineMesh.borderMask = outlineMask;
                    outlineMesh.visible = true;
                }
                else {
                    this.hide();
                }
            }
            else {
                this.hide();
            }
        };
        DBaseOutlineSnippet.prototype.render = function (renderer) {
            var _a;
            (_a = this._mesh) === null || _a === void 0 ? void 0 : _a.render(renderer);
        };
        DBaseOutlineSnippet.prototype.updateTransform = function () {
            var _a;
            (_a = this._mesh) === null || _a === void 0 ? void 0 : _a.updateTransform();
        };
        return DBaseOutlineSnippet;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DBaseReflowableImpl = /** @class */ (function () {
        function DBaseReflowableImpl(base) {
            var background = new DBaseBackgroundSnippet();
            this._background = background;
            base.snippet.add(background, true);
            var border = new DBaseBorderSnippet();
            this._border = border;
            base.snippet.add(border, true);
            var outline = new DBaseOutlineSnippet();
            this._outline = outline;
            base.snippet.add(outline, false);
            base.reflowable.add(this);
        }
        DBaseReflowableImpl.prototype.onReflow = function (base, width, height) {
            var theme = base.theme;
            var state = base.state;
            var corner = base.corner;
            var cornerRadius = corner.getRadius();
            var cornerMask = corner.getMask();
            this._background.onReflow(base, width, height, theme, state, cornerRadius, cornerMask);
            this._border.onReflow(base, width, height, theme, state, cornerRadius, cornerMask);
            this._outline.onReflow(base, width, height, theme, state, cornerRadius, cornerMask);
        };
        return DBaseReflowableImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var BEFORE = 1;
    var AFTER = 2;
    var DLayoutClearType = {
        NONE: 0,
        BEFORE: BEFORE,
        AFTER: AFTER,
        BOTH: BEFORE | AFTER
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DScalarExpressionNodeType = {
        // Parensesis
        OPEN: 0,
        CLOSE: 1,
        PARENSESIS: 2,
        // Operations
        ADD_OR_PLUS: 3,
        SUB_OR_MINUS: 4,
        PLUS: 5,
        MINUS: 6,
        ADD: 7,
        SUB: 8,
        MUL: 9,
        DIV: 10,
        // Functions
        MIN: 11,
        MAX: 12,
        COMMA: 13,
        // Literals
        PARENT: 14,
        SELF: 15,
        PADDING: 16,
        CURRENT: 17,
        NUMBER: 18
    };
    /**
     * Parser and evaluator of the scalar expressions like `100% - 50s`.
     *
     * Literals
     *
     * * x%: 0.01 * x * parent value
     * * xs: 0.01 * x * self value
     * * xp: 0.01 * x * padding value
     * * xc: 0.01 * x * current value
     *
     * Operators
     *
     * * `+`
     * * `-`
     * * `*`
     * * `/`
     * * `(` and `)`
     *
     * Functions
     *
     * * min( a, b, ... )
     * * max( a, b, ... )
     *
     * Examples
     *
     * * `90%`: 0.9 * parent value
     * * `50s`: 0.5 * self value
     * * `90% - 50s`: 0.9 * parent value - 0.5 * self value
     * * `90% - (50s + 100) * 2`: 0.9 * parent value - ( 0.5 * self value + 100 ) * 2
     */
    var DScalarExpression = /** @class */ (function () {
        function DScalarExpression(expression) {
            var nodes = this.toToken(expression);
            var i = 0;
            do {
                i = this.toParensesis(nodes, i);
            } while (i < nodes.length);
            this.toUnary(nodes);
            this.toArithmetic(nodes, DScalarExpressionNodeType.MUL, DScalarExpressionNodeType.DIV);
            this.toArithmetic(nodes, DScalarExpressionNodeType.ADD, DScalarExpressionNodeType.SUB);
            if (nodes.length === 1) {
                var node = nodes[0];
                if (!isNumber(node)) {
                    this._node = node;
                    return;
                }
            }
            throw new Error("Failed to parse '".concat(expression, "'"));
        }
        DScalarExpression.prototype.toParensesis = function (nodes, ifrom) {
            var ito = nodes.length;
            for (var i = ifrom; i < ito; ++i) {
                var inode = nodes[i];
                if (inode === DScalarExpressionNodeType.OPEN) {
                    var istart = i;
                    var nodeType = DScalarExpressionNodeType.PARENSESIS;
                    if (0 < i) {
                        var nodeTypePrev = nodes[i - 1];
                        if (nodeTypePrev === DScalarExpressionNodeType.MIN ||
                            nodeTypePrev === DScalarExpressionNodeType.MAX) {
                            istart -= 1;
                            nodeType = nodeTypePrev;
                        }
                    }
                    for (var j = i + 1; j < ito; ++j) {
                        var jnode = nodes[j];
                        if (jnode === DScalarExpressionNodeType.CLOSE) {
                            nodes[istart] = [nodeType, this.toComma(nodes, i + 1, j)];
                            nodes.splice(istart + 1, j - istart);
                            return istart + 1;
                        }
                        else if (jnode === DScalarExpressionNodeType.OPEN) {
                            j = this.toParensesis(nodes, j) - 1;
                            ito = nodes.length;
                        }
                    }
                    throw new Error("Malformed parensesis");
                }
            }
            return ito;
        };
        DScalarExpression.prototype.toCommaOf = function (nodes, ifrom, ito) {
            var l = ito - ifrom;
            if (l <= 0) {
                return [DScalarExpressionNodeType.NUMBER, 0];
            }
            else if (l <= 1) {
                return nodes[ifrom];
            }
            else {
                var operand = [];
                for (var j = ifrom; j < ito; ++j) {
                    operand.push(nodes[j]);
                }
                return [DScalarExpressionNodeType.PARENSESIS, operand];
            }
        };
        DScalarExpression.prototype.toComma = function (nodes, ifrom, ito) {
            var result = null;
            var iprev = ifrom;
            for (var i = ifrom; i < ito; ++i) {
                var node = nodes[i];
                if (node === DScalarExpressionNodeType.COMMA) {
                    result = result || [];
                    result.push(this.toCommaOf(nodes, iprev, i));
                    iprev = i + 1;
                }
            }
            if (iprev < ito) {
                if (result == null) {
                    var operand = [];
                    for (var i = iprev; i < ito; ++i) {
                        operand.push(nodes[i]);
                    }
                    return operand;
                }
                else {
                    result.push(this.toCommaOf(nodes, iprev, ito));
                }
            }
            return result || [];
        };
        DScalarExpression.prototype.toUnaryNode = function (node) {
            if (!isNumber(node)) {
                if (node[0] === DScalarExpressionNodeType.PARENSESIS ||
                    node[0] === DScalarExpressionNodeType.MIN ||
                    node[0] === DScalarExpressionNodeType.MAX) {
                    this.toUnary(node[1]);
                }
            }
        };
        DScalarExpression.prototype.toUnary = function (nodes) {
            for (var i = 0, imax = nodes.length; i < imax; ++i) {
                var node = nodes[i];
                if (node === DScalarExpressionNodeType.ADD_OR_PLUS ||
                    node === DScalarExpressionNodeType.SUB_OR_MINUS) {
                    if (i <= 0 || isNumber(nodes[i - 1])) {
                        if (i + 1 < imax && !isNumber(nodes[i + 1])) {
                            var operand = nodes.splice(i + 1, 1)[0];
                            var type = node === DScalarExpressionNodeType.ADD_OR_PLUS
                                ? DScalarExpressionNodeType.PLUS
                                : DScalarExpressionNodeType.MINUS;
                            nodes[i] = [type, operand];
                            imax = nodes.length;
                            this.toUnaryNode(operand);
                        }
                        else {
                            throw new Error("Malformed unary operator");
                        }
                    }
                    else {
                        var type = node === DScalarExpressionNodeType.ADD_OR_PLUS
                            ? DScalarExpressionNodeType.ADD
                            : DScalarExpressionNodeType.SUB;
                        nodes[i] = type;
                    }
                }
                else {
                    this.toUnaryNode(node);
                    imax = nodes.length;
                }
            }
        };
        DScalarExpression.prototype.toArithmeticNode = function (node, operatorA, operatorB) {
            if (!isNumber(node)) {
                if (node[0] === DScalarExpressionNodeType.PARENSESIS ||
                    node[0] === DScalarExpressionNodeType.MIN ||
                    node[0] === DScalarExpressionNodeType.MAX) {
                    this.toArithmetic(node[1], operatorA, operatorB);
                }
                else if (node[0] === DScalarExpressionNodeType.PLUS ||
                    node[0] === DScalarExpressionNodeType.MINUS) {
                    this.toArithmeticNode(node[1], operatorA, operatorB);
                }
                else if (node[0] === DScalarExpressionNodeType.ADD ||
                    node[0] === DScalarExpressionNodeType.SUB ||
                    node[0] === DScalarExpressionNodeType.MUL ||
                    node[0] === DScalarExpressionNodeType.DIV) {
                    this.toArithmeticNode(node[1], operatorA, operatorB);
                    this.toArithmeticNode(node[2], operatorA, operatorB);
                }
            }
        };
        DScalarExpression.prototype.toArithmetic = function (nodes, operatorA, operatorB) {
            for (var i = 0, imax = nodes.length; i < imax; ++i) {
                var node = nodes[i];
                if (node === operatorA || node === operatorB) {
                    if (0 < i && i + 1 < imax) {
                        var left = nodes[i - 1];
                        var right = nodes[i + 1];
                        if (!isNumber(left) && !isNumber(right)) {
                            nodes.splice(i, 2);
                            nodes[i - 1] = [node, left, right];
                            i -= 1;
                            imax = nodes.length;
                            this.toArithmeticNode(left, operatorA, operatorB);
                            this.toArithmeticNode(right, operatorA, operatorB);
                            continue;
                        }
                    }
                    throw new Error("Malformed operands for the operator ".concat(node));
                }
                else {
                    this.toArithmeticNode(node, operatorA, operatorB);
                    imax = nodes.length;
                }
            }
        };
        DScalarExpression.prototype.toToken = function (expression) {
            var tokens = [];
            while (true) {
                var matched = DScalarExpression.TOKEN_REGEX.exec(expression);
                if (matched != null) {
                    var token = matched[0];
                    var tokenTypeOperator = this.toTokenOperator(token);
                    if (tokenTypeOperator != null) {
                        tokens.push(tokenTypeOperator);
                    }
                    else {
                        var parsedToken = parseFloat(token);
                        if (parsedToken !== parsedToken) {
                            throw new Error("Unexpected token '".concat(token, "' at ").concat(matched.index, " in '").concat(expression, "'"));
                        }
                        var tokenTypeLiteral = this.toTokenLiteral(token);
                        if (tokenTypeLiteral != null) {
                            tokens.push([tokenTypeLiteral, parsedToken * 0.01]);
                        }
                        else {
                            tokens.push([DScalarExpressionNodeType.NUMBER, parsedToken]);
                        }
                    }
                }
                else {
                    break;
                }
            }
            return tokens;
        };
        DScalarExpression.prototype.toTokenOperator = function (token) {
            switch (token) {
                case "+":
                    return DScalarExpressionNodeType.ADD_OR_PLUS;
                case "-":
                    return DScalarExpressionNodeType.SUB_OR_MINUS;
                case "*":
                    return DScalarExpressionNodeType.MUL;
                case "/":
                    return DScalarExpressionNodeType.DIV;
                case "(":
                    return DScalarExpressionNodeType.OPEN;
                case ")":
                    return DScalarExpressionNodeType.CLOSE;
                case ",":
                    return DScalarExpressionNodeType.COMMA;
                case "min":
                    return DScalarExpressionNodeType.MIN;
                case "max":
                    return DScalarExpressionNodeType.MAX;
            }
            return null;
        };
        DScalarExpression.prototype.toTokenLiteral = function (token) {
            var tokenLength = token.length;
            if (0 < tokenLength) {
                switch (token[tokenLength - 1]) {
                    case "%":
                        return DScalarExpressionNodeType.PARENT;
                    case "s":
                        return DScalarExpressionNodeType.SELF;
                    case "p":
                        return DScalarExpressionNodeType.PADDING;
                    case "c":
                        return DScalarExpressionNodeType.CURRENT;
                }
            }
            return null;
        };
        DScalarExpression.prototype.evaluate = function (node, parent, self, padding, current) {
            switch (node[0]) {
                case DScalarExpressionNodeType.PARENSESIS:
                    var nodes = node[1];
                    return this.evaluate(nodes[nodes.length - 1], parent, self, padding, current);
                // Unary operators
                case DScalarExpressionNodeType.PLUS:
                    return +this.evaluate(node[1], parent, self, padding, current);
                case DScalarExpressionNodeType.MINUS:
                    return -this.evaluate(node[1], parent, self, padding, current);
                // Four arithmetic operators
                case DScalarExpressionNodeType.ADD:
                    return (this.evaluate(node[1], parent, self, padding, current) +
                        this.evaluate(node[2], parent, self, padding, current));
                case DScalarExpressionNodeType.SUB:
                    return (this.evaluate(node[1], parent, self, padding, current) -
                        this.evaluate(node[2], parent, self, padding, current));
                case DScalarExpressionNodeType.MUL:
                    return (this.evaluate(node[1], parent, self, padding, current) *
                        this.evaluate(node[2], parent, self, padding, current));
                case DScalarExpressionNodeType.DIV:
                    return (this.evaluate(node[1], parent, self, padding, current) /
                        this.evaluate(node[2], parent, self, padding, current));
                // Functions
                case DScalarExpressionNodeType.MIN:
                    if (0 < node[1].length) {
                        var args = node[1];
                        var result = this.evaluate(args[0], parent, self, padding, current);
                        for (var i = 1, imax = args.length; i < imax; ++i) {
                            result = Math.min(result, this.evaluate(args[i], parent, self, padding, current));
                        }
                        return result;
                    }
                    return 0;
                case DScalarExpressionNodeType.MAX:
                    if (0 < node[1].length) {
                        var args = node[1];
                        var result = this.evaluate(args[0], parent, self, padding, current);
                        for (var i = 1, imax = args.length; i < imax; ++i) {
                            result = Math.max(result, this.evaluate(args[i], parent, self, padding, current));
                        }
                        return result;
                    }
                    return 0;
                // Literals
                case DScalarExpressionNodeType.PARENT:
                    return node[1] * parent;
                case DScalarExpressionNodeType.SELF:
                    return node[1] * self;
                case DScalarExpressionNodeType.PADDING:
                    return node[1] * padding;
                case DScalarExpressionNodeType.CURRENT:
                    return node[1] * current;
                case DScalarExpressionNodeType.NUMBER:
                    return node[1];
            }
            return 0;
        };
        DScalarExpression.prototype.calculate = function (parent, self, padding, current) {
            return this.evaluate(this._node, parent, self, padding, current);
        };
        DScalarExpression.TOKEN_REGEX = /(?:\+|-|\*|\/|\(|\)|min|max|,|(?:\d+(?:\.\d*)?[%psc]?))/g;
        return DScalarExpression;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var POSITION_CENTER = function (p, s) { return (p - s) * 0.5; };
    var POSITION_PADDING = function (p, s, d) { return d; };
    var SIZE_MAXIMIZED = function (p) { return p; };
    var SIZE_PADDING = function (p, s, d) { return p - d; };
    var DScalarFunctions = /** @class */ (function () {
        function DScalarFunctions() {
        }
        DScalarFunctions.position = function (coordinate) {
            if (coordinate == null || isNumber(coordinate)) {
                return null;
            }
            else if (isString(coordinate)) {
                switch (coordinate) {
                    case "center":
                    case "CENTER":
                        return POSITION_CENTER;
                    case "padding":
                    case "PADDING":
                        return POSITION_PADDING;
                }
                var scalarExpression_1 = new DScalarExpression(coordinate);
                return function (parent, self, padding, current) {
                    return scalarExpression_1.calculate(parent, self, padding, current);
                };
            }
            else if (isFunction(coordinate)) {
                return coordinate;
            }
            else {
                var scalar_1 = coordinate;
                return function (parent, self, padding, current) {
                    return scalar_1.calculate(parent, self, padding, current);
                };
            }
        };
        DScalarFunctions.size = function (coordinate) {
            if (coordinate == null || isNumber(coordinate)) {
                return null;
            }
            else if (isString(coordinate)) {
                switch (coordinate) {
                    case "100%":
                    case "maximized":
                    case "MAXIMIZED":
                        return SIZE_MAXIMIZED;
                    case "padding":
                    case "PADDING":
                        return SIZE_PADDING;
                }
                var scalarExpression_2 = new DScalarExpression(coordinate);
                return function (parent, self, padding, current) {
                    return scalarExpression_2.calculate(parent, self, padding, current);
                };
            }
            else if (isFunction(coordinate)) {
                return coordinate;
            }
            else {
                var scalar_2 = coordinate;
                return function (parent, self, padding, current) {
                    return scalar_2.calculate(parent, self, padding, current);
                };
            }
        };
        return DScalarFunctions;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var setShortcutKeyAndWhich = function (shortcut) {
        var key = shortcut.key;
        if (key.length <= 1) {
            if (shortcut.shift) {
                shortcut.key = key.toUpperCase();
            }
            var code = key.charCodeAt(0);
            shortcut.which = 97 <= code && code <= 122 ? code - 32 : code;
        }
        else {
            switch (key) {
                case "enter":
                    shortcut.key = "Enter";
                    shortcut.which = 13;
                    break;
                case "space":
                    shortcut.key = " ";
                    shortcut.which = 32;
                    break;
                case "escape":
                    shortcut.key = "Escape";
                    shortcut.which = 27;
                    break;
                case "f1":
                    shortcut.key = "F1";
                    shortcut.which = 112;
                    break;
                case "f2":
                    shortcut.key = "F2";
                    shortcut.which = 113;
                    break;
                case "f3":
                    shortcut.key = "F3";
                    shortcut.which = 114;
                    break;
                case "f4":
                    shortcut.key = "F4";
                    shortcut.which = 115;
                    break;
                case "f5":
                    shortcut.key = "F5";
                    shortcut.which = 116;
                    break;
                case "f6":
                    shortcut.key = "F6";
                    shortcut.which = 117;
                    break;
                case "f7":
                    shortcut.key = "F7";
                    shortcut.which = 118;
                    break;
                case "f8":
                    shortcut.key = "F8";
                    shortcut.which = 119;
                    break;
                case "f9":
                    shortcut.key = "F9";
                    shortcut.which = 120;
                    break;
                case "f10":
                    shortcut.key = "F10";
                    shortcut.which = 121;
                    break;
                case "f11":
                    shortcut.key = "F11";
                    shortcut.which = 122;
                    break;
                case "f12":
                    shortcut.key = "F12";
                    shortcut.which = 123;
                    break;
                case "capslock":
                    shortcut.key = "CapsLock";
                    if (shortcut.shift) {
                        shortcut.which = 20;
                    }
                    else {
                        shortcut.which = 240;
                    }
                    break;
                case "arrowup":
                    shortcut.key = "ArrowUp";
                    shortcut.which = 38;
                    break;
                case "arrowdown":
                    shortcut.key = "ArrowDown";
                    shortcut.which = 40;
                    break;
                case "arrowleft":
                    shortcut.key = "ArrowLeft";
                    shortcut.which = 37;
                    break;
                case "arrowright":
                    shortcut.key = "ArrowRight";
                    shortcut.which = 39;
                    break;
                case "insert":
                    shortcut.key = "Insert";
                    shortcut.which = 45;
                    break;
                case "delete":
                    shortcut.key = "Delete";
                    shortcut.which = 46;
                    break;
                case "pageup":
                    shortcut.key = "PageUp";
                    shortcut.which = 33;
                    break;
                case "pagedown":
                    shortcut.key = "PageDown";
                    shortcut.which = 34;
                    break;
                case "backspace":
                    shortcut.key = "Backspace";
                    shortcut.which = 8;
                    break;
                case "colon":
                    shortcut.key = ":";
                    shortcut.which = 186;
                    break;
                case "semicolon":
                    shortcut.key = ";";
                    shortcut.which = 187;
                    break;
                case "pause":
                    shortcut.key = "Pause";
                    shortcut.which = 19;
                    break;
                case "scrolllock":
                    shortcut.key = "ScrollLock";
                    shortcut.which = 145;
                    break;
                case "tab":
                    shortcut.key = "Tab";
                    shortcut.which = 9;
                    break;
                case "plus":
                    shortcut.key = "+";
                    shortcut.which = 187;
                    break;
                case "minus":
                    shortcut.key = "-";
                    shortcut.which = 189;
                    break;
            }
        }
        return shortcut;
    };
    var UtilKeyboardEvent = /** @class */ (function () {
        function UtilKeyboardEvent() {
        }
        UtilKeyboardEvent.isActivateKey = function (e) {
            return e.key === "Space" || e.key === "Enter" || e.which === 32 || e.which === 13;
        };
        UtilKeyboardEvent.isArrowUpKey = function (e) {
            return e.key === "ArrowUp" || e.which === 38;
        };
        UtilKeyboardEvent.isArrowDownKey = function (e) {
            return e.key === "ArrowDown" || e.which === 40;
        };
        UtilKeyboardEvent.isArrowLeftKey = function (e) {
            return e.key === "ArrowLeft" || e.which === 37;
        };
        UtilKeyboardEvent.isArrowRightKey = function (e) {
            return e.key === "ArrowRight" || e.which === 39;
        };
        UtilKeyboardEvent.isCancelKey = function (e) {
            return e.key === "Esc" || e.which === 27;
        };
        UtilKeyboardEvent.isFocusKey = function (e) {
            return e.key === "Tab" || e.which === 9;
        };
        UtilKeyboardEvent.isUndoKey = function (e) {
            return e.ctrlKey && (e.key === "z" || e.which === 90);
        };
        UtilKeyboardEvent.isRedoKey = function (e) {
            return e.ctrlKey && (e.key === "y" || e.which === 89);
        };
        UtilKeyboardEvent.isSaveKey = function (e) {
            return e.ctrlKey && !e.shiftKey && (e.key === "s" || e.which === 83);
        };
        UtilKeyboardEvent.isSaveAsKey = function (e) {
            return e.ctrlKey && e.shiftKey && (e.key === "S" || e.which === 83);
        };
        UtilKeyboardEvent.isDeleteKey = function (e) {
            return e.key === "Delete" || e.which === 46;
        };
        UtilKeyboardEvent.isSelectAllKey = function (e) {
            return e.ctrlKey && !e.shiftKey && (e.key === "a" || e.which === 65);
        };
        UtilKeyboardEvent.isOkKey = function (e) {
            return e.key === "Enter" || e.which === 13;
        };
        UtilKeyboardEvent.getFocusDirection = function (e) {
            return e.shiftKey !== true;
        };
        UtilKeyboardEvent.toShortcut = function (expressionOrShortcut) {
            if (!isString(expressionOrShortcut)) {
                return expressionOrShortcut;
            }
            else {
                var expression = expressionOrShortcut;
                var arrowIndex = expression.indexOf("->");
                var keyExpression = void 0;
                var event_1;
                if (0 <= arrowIndex) {
                    keyExpression = expression.substring(0, arrowIndex).trim().toLowerCase();
                    event_1 = expression.substring(arrowIndex + 2).trim();
                }
                else {
                    keyExpression = expression.trim().toLowerCase();
                }
                var alt = false;
                var ctrl = false;
                var shift = false;
                var key = "a";
                var length_1 = keyExpression.length;
                var i = 0;
                var j = 1;
                for (; j < length_1; ++j) {
                    var c = keyExpression.charAt(j);
                    if (c === "+") {
                        var part = keyExpression.substring(i, j);
                        switch (part) {
                            case "alt":
                                alt = true;
                                break;
                            case "ctrl":
                                ctrl = true;
                                break;
                            case "shift":
                                shift = true;
                                break;
                            default:
                                key = part;
                                break;
                        }
                        j += 1;
                        i = j;
                    }
                }
                if (i !== j) {
                    key = keyExpression.substring(i, j);
                }
                return setShortcutKeyAndWhich({
                    alt: alt,
                    ctrl: ctrl,
                    shift: shift,
                    key: key,
                    which: 0,
                    event: event_1
                });
            }
        };
        UtilKeyboardEvent.toString = function (shortcut) {
            var parts = [];
            if (shortcut.ctrl) {
                parts.push("Ctrl");
            }
            if (shortcut.shift) {
                parts.push("Shift");
            }
            if (shortcut.alt) {
                parts.push("Alt");
            }
            parts.push(shortcut.key.toUpperCase());
            return parts.join("+");
        };
        UtilKeyboardEvent.on = function (target, expressionOrShortcut, handler) {
            var shortcut = this.toShortcut(expressionOrShortcut);
            document.body.addEventListener("keydown", function (e) {
                if (e.altKey === shortcut.alt &&
                    e.ctrlKey === shortcut.ctrl &&
                    e.shiftKey === shortcut.shift &&
                    (e.key === shortcut.key || e.which === shortcut.which)) {
                    if (target.state.isActionable) {
                        if (shortcut.event != null) {
                            target.emit(shortcut.event);
                        }
                        else if (handler != null) {
                            handler(e);
                        }
                    }
                    e.preventDefault();
                }
            });
        };
        UtilKeyboardEvent.moveFocusVertically = function (e, target, picker) {
            if (target.state.isActionable) {
                var isBackward = UtilKeyboardEvent.isArrowUpKey(e);
                var isForward = UtilKeyboardEvent.isArrowDownKey(e);
                if (isBackward || isForward) {
                    return this.moveFocus(isForward, target, picker);
                }
            }
            return false;
        };
        UtilKeyboardEvent.moveFocusHorizontally = function (e, target, picker) {
            if (target.state.isActionable) {
                var isBackward = UtilKeyboardEvent.isArrowLeftKey(e);
                var isForward = UtilKeyboardEvent.isArrowRightKey(e);
                if (isBackward || isForward) {
                    return this.moveFocus(isForward, target, picker);
                }
            }
            return false;
        };
        UtilKeyboardEvent.moveFocus = function (direction, target, picker) {
            var _a;
            var layer = (_a = picker === null || picker === void 0 ? void 0 : picker.picked) !== null && _a !== void 0 ? _a : DApplications.getLayer(target);
            if (layer) {
                var focusController = layer.getFocusController();
                var focused = focusController.get();
                if (focused != null) {
                    var next = focusController.find(focused, false, focused.state.isFocusRoot || direction, direction, target);
                    if (next != null) {
                        focusController.focus(next);
                        return true;
                    }
                }
            }
            return false;
        };
        return UtilKeyboardEvent;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DBaseAuto = /** @class */ (function () {
        function DBaseAuto() {
            this._isOn = false;
        }
        Object.defineProperty(DBaseAuto.prototype, "isOff", {
            get: function () {
                return !this._isOn;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseAuto.prototype, "isOn", {
            get: function () {
                return this._isOn;
            },
            enumerable: false,
            configurable: true
        });
        DBaseAuto.prototype.toCoordinate = function (def) {
            return this._isOn ? "auto" : def;
        };
        /**
         * Update the auto settings by the given size.
         *
         * @param size a size
         * @returns True if the given size is "auto".
         */
        DBaseAuto.prototype.from = function (size) {
            if (size === "auto" || size === "AUTO") {
                this._isOn = true;
                return true;
            }
            this._isOn = false;
            return false;
        };
        return DBaseAuto;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DBaseAutoSet = /** @class */ (function () {
        function DBaseAutoSet() {
            this.width = new DBaseAuto();
            this.height = new DBaseAuto();
        }
        return DBaseAutoSet;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DBaseSnippetContainer = /** @class */ (function () {
        function DBaseSnippetContainer(parent) {
            this._parent = parent;
            this._befores = [];
            this._afters = [];
            this._renderable = true;
        }
        Object.defineProperty(DBaseSnippetContainer.prototype, "renderable", {
            get: function () {
                return this._renderable;
            },
            set: function (renderable) {
                this._renderable = renderable;
            },
            enumerable: false,
            configurable: true
        });
        DBaseSnippetContainer.prototype.add = function (snippet, phase) {
            var list = phase ? this._befores : this._afters;
            list.push(snippet);
            if ("parent" in snippet) {
                snippet.parent = this._parent;
            }
        };
        DBaseSnippetContainer.prototype.addAt = function (snippet, phase, index) {
            var list = phase ? this._befores : this._afters;
            if (index === 0) {
                list.unshift(snippet);
            }
            else if (0 < index && index < list.length) {
                list.splice(index, 0, snippet);
            }
            else {
                list.push(snippet);
            }
            if ("parent" in snippet) {
                snippet.parent = this._parent;
            }
        };
        DBaseSnippetContainer.prototype.remove = function (snippet, phase) {
            var list = phase ? this._befores : this._afters;
            var index = list.indexOf(snippet);
            if (0 <= index) {
                list.splice(index, 1);
                if ("parent" in snippet) {
                    snippet.parent = null;
                }
            }
        };
        DBaseSnippetContainer.prototype.render = function (renderer, phase) {
            if (this._renderable) {
                var list = phase ? this._befores : this._afters;
                for (var i = 0, imax = list.length; i < imax; ++i) {
                    list[i].render(renderer);
                }
            }
        };
        DBaseSnippetContainer.prototype.updateTransform = function () {
            var befores = this._befores;
            for (var i = 0, imax = befores.length; i < imax; ++i) {
                befores[i].updateTransform();
            }
            var afters = this._afters;
            for (var i = 0, imax = afters.length; i < imax; ++i) {
                afters[i].updateTransform();
            }
        };
        return DBaseSnippetContainer;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DBaseReflowableContainer = /** @class */ (function () {
        function DBaseReflowableContainer() {
            this._list = [];
        }
        DBaseReflowableContainer.prototype.add = function (reflowable) {
            this._list.push(reflowable);
        };
        DBaseReflowableContainer.prototype.remove = function (reflowable) {
            var list = this._list;
            var index = list.indexOf(reflowable);
            if (0 <= index) {
                list.splice(index, 1);
            }
        };
        DBaseReflowableContainer.prototype.onReflow = function (base, width, height) {
            var list = this._list;
            for (var i = 0, imax = list.length; i < imax; ++i) {
                list[i].onReflow(base, width, height);
            }
        };
        return DBaseReflowableContainer;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var toTheme = function (options) {
        var theme = options === null || options === void 0 ? void 0 : options.theme;
        if (theme) {
            if (isString(theme)) {
                return DThemes.getInstance().get(theme);
            }
            return theme;
        }
    };
    var toShortcuts = function (options) {
        if (options) {
            var shortcut = options.shortcut;
            var shortcuts = options.shortcuts;
            if (shortcuts != null || shortcut != null) {
                var result = [];
                if (shortcut != null) {
                    result.push(UtilKeyboardEvent.toShortcut(shortcut));
                }
                if (shortcuts != null) {
                    for (var i = 0, imax = shortcuts.length; i < imax; ++i) {
                        result.push(UtilKeyboardEvent.toShortcut(shortcuts[i]));
                    }
                }
                return result;
            }
        }
        return undefined;
    };
    /**
     * A base class for UI classes.
     * See {@link DBaseEvents} for event details.
     */
    var DBase = /** @class */ (function (_super) {
        __extends(DBase, _super);
        function DBase(options) {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j;
            var _this = _super.call(this) || this;
            // Transform
            var transform = _this.transform;
            _this._position = new DBasePoint(transform.position, function (newX, newY, oldX, oldY) {
                _this.onMove(newX, newY, oldX, oldY);
            });
            _this._scale = new DBasePoint(transform.scale, function (newX, newY, oldX, oldY) {
                _this.onScale(newX, newY, oldX, oldY);
            });
            _this._skew = new DBasePoint(transform.skew, function (newX, newY, oldX, oldY) {
                _this.onSkew(newX, newY, oldX, oldY);
            });
            //
            _this._options = options;
            var scalarSet = (_this._scalarSet = {});
            _this._auto = new DBaseAutoSet();
            _this._isDirty = true;
            _this._hasDirty = false;
            _this._isHierarchyDirty = false;
            _this._shadow = null;
            _this.name = (_a = options === null || options === void 0 ? void 0 : options.name) !== null && _a !== void 0 ? _a : "";
            var theme = toTheme(options) || _this.getThemeDefault();
            _this._theme = theme;
            _this._snippet = new DBaseSnippetContainer(_this);
            _this._reflowable = new DBaseReflowableContainer();
            _this._clearType = toEnum((_b = options === null || options === void 0 ? void 0 : options.clear) !== null && _b !== void 0 ? _b : theme.getClearType(), DLayoutClearType);
            _this._padding = _this.newPadding(theme, options, function () {
                _this.toDirty();
                _this.toParentResized();
                _this.toHierarchyDirty();
                DApplications.update(_this);
            });
            var toDirtyAndUpdate = function () {
                _this.toDirty();
                DApplications.update(_this);
            };
            _this._background = new DBaseBackground(theme, options, toDirtyAndUpdate);
            _this._border = new DBaseBorder(theme, options, toDirtyAndUpdate);
            _this._outline = new DBaseOutline(theme, options, toDirtyAndUpdate);
            _this._corner = new DBaseCorner(theme, options, toDirtyAndUpdate);
            // X
            var position = transform.position;
            var x = (_c = options === null || options === void 0 ? void 0 : options.x) !== null && _c !== void 0 ? _c : theme.getX();
            if (isNumber(x)) {
                position.x = x;
            }
            else {
                position.x = 0;
                scalarSet.x = DScalarFunctions.position(x);
            }
            // Y
            var y = (_d = options === null || options === void 0 ? void 0 : options.y) !== null && _d !== void 0 ? _d : theme.getY();
            if (isNumber(y)) {
                position.y = y;
            }
            else {
                position.y = 0;
                scalarSet.y = DScalarFunctions.position(y);
            }
            // Width
            var width = (_e = options === null || options === void 0 ? void 0 : options.width) !== null && _e !== void 0 ? _e : theme.getWidth();
            if (!_this._auto.width.from(width)) {
                if (isNumber(width)) {
                    _this._width = width;
                }
                else {
                    _this._width = 100;
                    scalarSet.width = DScalarFunctions.size(width);
                }
            }
            else {
                _this._width = 100;
            }
            // Height
            var height = (_f = options === null || options === void 0 ? void 0 : options.height) !== null && _f !== void 0 ? _f : theme.getHeight();
            if (!_this._auto.height.from(height)) {
                if (isNumber(height)) {
                    _this._height = height;
                }
                else {
                    _this._height = 100;
                    scalarSet.height = DScalarFunctions.size(height);
                }
            }
            else {
                _this._height = 100;
            }
            // Visibility
            if (options != null) {
                var visible = options.visible;
                if (visible != null) {
                    _this.visible = visible;
                }
            }
            // Renderability
            if (options != null) {
                var renderable = options.renderable;
                if (renderable != null) {
                    _this.renderable = renderable;
                }
            }
            // State
            _this._state = new DBaseStateSetImplObservable(function (newState, oldState) {
                _this.onStateChange(newState, oldState);
            });
            // Interactive
            var interactive = toEnum((_g = options === null || options === void 0 ? void 0 : options.interactive) !== null && _g !== void 0 ? _g : theme.getInteractive(), DBaseInteractive);
            _this.interactive = !!(interactive & DBaseInteractive.SELF);
            _this.interactiveChildren = !!(interactive & DBaseInteractive.CHILDREN);
            // Events
            if (options != null) {
                var on = options.on;
                if (on != null) {
                    for (var name_1 in on) {
                        var handler = on[name_1];
                        if (handler) {
                            _this.on(name_1, handler);
                        }
                    }
                }
            }
            // Title
            _this._title = (_h = options === null || options === void 0 ? void 0 : options.title) !== null && _h !== void 0 ? _h : theme.getTitle();
            // Weight
            _this._weight = (_j = options === null || options === void 0 ? void 0 : options.weight) !== null && _j !== void 0 ? _j : theme.getWeight();
            // Reflowable
            _this.initReflowable();
            // Shadow
            _this._onShadowUpdateBound = function () {
                DApplications.update(_this);
            };
            var shadow;
            if (options != null) {
                shadow = options.shadow;
            }
            if (shadow === undefined) {
                shadow = theme.getShadow();
            }
            if (shadow) {
                if (isString(shadow)) {
                    switch (shadow) {
                        case "WEAK":
                            _this.shadow = theme.newShadowWeak();
                            break;
                        case "DEFAULT":
                            _this.shadow = theme.newShadow();
                            break;
                    }
                }
                else {
                    _this.shadow = shadow;
                }
            }
            // Event handlers
            _this.on(UtilPointerEvent.over, function (e) {
                _this.onOver(e);
            });
            _this.on(UtilPointerEvent.out, function (e) {
                _this.onOut(e);
            });
            _this.on(UtilPointerEvent.down, function (e) {
                _this.onDown(e);
            });
            _this.on(UtilPointerEvent.up, function (e) {
                _this.onUp(e);
            });
            // Children change detection
            _this.on("added", function () {
                _this.toParentResized();
                if (_this.isDirty() || _this.hasDirty()) {
                    _this.toParentHasDirty();
                }
                if (_this._isHierarchyDirty) {
                    _this.toParentHierarchyDirty();
                }
                var newParent = _this.parent;
                if (newParent instanceof DBase) {
                    _this.state.parent = newParent.state;
                }
                DApplications.update(_this);
            });
            _this.on("removed", function () {
                _this.blur(true);
                _this.state.parent = null;
                DApplications.update(_this);
            });
            // Shortcut
            var shortcuts = toShortcuts(options);
            _this._shortcuts = shortcuts;
            if (shortcuts != null) {
                var onShortcutBound = function (e) {
                    _this.onShortcut(e);
                };
                for (var i = 0, imax = shortcuts.length; i < imax; ++i) {
                    UtilKeyboardEvent.on(_this, shortcuts[i], onShortcutBound);
                }
            }
            // Other initialization
            _this.init(options);
            // State Override
            theme.newState(_this._state);
            if (options != null) {
                var state = options.state;
                if (state != null) {
                    var s = _this._state;
                    if (isString(state)) {
                        s.add(state);
                    }
                    else if (isArray(state)) {
                        s.addAll(state);
                    }
                    else {
                        // Values
                        var values = state.values;
                        if (values != null) {
                            if (isString(values)) {
                                s.add(values);
                            }
                            else {
                                s.addAll(values);
                            }
                        }
                        // Blinker
                        var blinkers = state.blinkers;
                        if (blinkers != null) {
                            var b = s.blinker;
                            for (var i = 0, imax = blinkers.length; i < imax; ++i) {
                                var blinker = blinkers[i];
                                b.add(blinker.state, blinker.interval);
                            }
                        }
                        // Ticker
                        var tickers = state.tickers;
                        if (tickers != null) {
                            var t = s.ticker;
                            for (var i = 0, imax = tickers.length; i < imax; ++i) {
                                var ticker = tickers[i];
                                t.add(ticker.state, ticker.interval);
                            }
                        }
                    }
                }
            }
            // Parent
            if (options != null) {
                var parent_1 = options.parent;
                if (parent_1 != null) {
                    parent_1.addChild(_this);
                }
            }
            // Children
            if (options != null) {
                var children = options.children;
                if (children != null) {
                    for (var i = 0, imax = children.length; i < imax; ++i) {
                        var child = children[i];
                        if (child != null) {
                            _this.addChild(child);
                        }
                    }
                }
            }
            // Cursor
            var cursor;
            if (options != null) {
                cursor = options.cursor;
                _this._cursor = cursor;
            }
            _this.cursor = _this.toCursor(cursor, _this._state);
            // Done
            _this.emit("init", _this);
            return _this;
        }
        DBase.prototype.newPadding = function (theme, options, callback) {
            return new DBasePadding(theme, options, callback);
        };
        DBase.prototype.toCursor = function (cursor, state) {
            if (cursor) {
                if (isFunction(cursor)) {
                    var result = cursor(state);
                    if (result !== undefined) {
                        return result;
                    }
                }
                else if (cursor !== undefined) {
                    return cursor;
                }
            }
            return this.theme.getCursor(state);
        };
        Object.defineProperty(DBase.prototype, "snippet", {
            get: function () {
                return this._snippet;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBase.prototype, "reflowable", {
            get: function () {
                return this._reflowable;
            },
            enumerable: false,
            configurable: true
        });
        DBase.prototype.initReflowable = function () {
            new DBaseReflowableImpl(this);
        };
        DBase.prototype.onChildrenChange = function () {
            this.toHierarchyDirty();
            _super.prototype.onChildrenChange.call(this);
        };
        DBase.prototype.onShortcut = function (e) {
            this.emit("shortcut", e, this);
        };
        DBase.prototype.init = function (options) {
            // OTHER INITIALIZATIONS BEFORE `parent.addChild( this )`
        };
        Object.defineProperty(DBase.prototype, "weight", {
            get: function () {
                return this._weight;
            },
            set: function (weight) {
                if (this._weight !== weight) {
                    this._weight = weight;
                    this.toHierarchyDirty();
                    DApplications.update(this);
                }
            },
            enumerable: false,
            configurable: true
        });
        DBase.prototype.onMove = function (newX, newY, oldX, oldY) {
            var children = this.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                var child = children[i];
                if (child instanceof DBase) {
                    child.onParentMove(newX, newY, oldX, oldY);
                }
            }
            DApplications.update(this);
            this.emit("move", newX, newY, oldX, oldY, this);
        };
        DBase.prototype.resize = function (width, height) {
            var oldWidth = this._width;
            var oldHeight = this._height;
            var newWidth = width != null ? width : oldWidth;
            var newHeight = height != null ? height : oldHeight;
            var isWidthChanged = oldWidth !== newWidth;
            var isHeightChanged = oldHeight !== newHeight;
            if (isWidthChanged) {
                this._width = newWidth;
            }
            if (isHeightChanged) {
                this._height = newHeight;
            }
            var isChanged = isWidthChanged || isHeightChanged;
            if (isChanged) {
                this.onResize(newWidth, newHeight, oldWidth, oldHeight);
            }
            if (isWidthChanged) {
                var scalarSet = this._scalarSet;
                if (scalarSet.x != null) {
                    var position = this._position;
                    var parent_2 = this.getParentOfSize();
                    if (parent_2) {
                        this._position.x = scalarSet.x(parent_2.width, newWidth, parent_2.padding.getLeft(), position.x);
                    }
                }
            }
            if (isHeightChanged) {
                var scalarSet = this._scalarSet;
                if (scalarSet.y != null) {
                    var position = this._position;
                    var parent_3 = this.getParentOfSize();
                    if (parent_3) {
                        this._position.y = scalarSet.y(parent_3.height, newHeight, parent_3.padding.getTop(), position.y);
                    }
                }
            }
            return isChanged;
        };
        DBase.prototype.getClearType = function () {
            return this._clearType;
        };
        DBase.prototype.onResize = function (newWidth, newHeight, oldWidth, oldHeight) {
            this.toDirty();
            this.toHierarchyDirty();
            var padding = this._padding;
            var children = this.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                var child = children[i];
                if (child instanceof DBase) {
                    child.onParentResize(newWidth, newHeight, padding);
                }
            }
            DApplications.update(this);
            this.emit("resize", newWidth, newHeight, oldWidth, oldHeight, this);
        };
        DBase.prototype.onScale = function (newX, newY, oldX, oldY) {
            DApplications.update(this);
            this.emit("scale", newX, newY, oldX, oldY, this);
        };
        DBase.prototype.onSkew = function (newX, newY, oldX, oldY) {
            DApplications.update(this);
            this.emit("skew", newX, newY, oldX, oldY, this);
        };
        Object.defineProperty(DBase.prototype, "type", {
            get: function () {
                return this.getType();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBase.prototype, "x", {
            // @ts-ignore
            get: function () {
                return this._position.x;
            },
            set: function (x) {
                this.setX(x);
            },
            enumerable: false,
            configurable: true
        });
        DBase.prototype.getX = function () {
            var scalarSet = this._scalarSet;
            if (scalarSet.x != null) {
                return scalarSet.x;
            }
            else {
                return this._position.x;
            }
        };
        DBase.prototype.setX = function (x) {
            var scalarSet = this._scalarSet;
            if (isNumber(x)) {
                var position = this._position;
                if (position.x !== x) {
                    scalarSet.x = undefined;
                    position.x = x;
                }
                else {
                    if (scalarSet.x !== undefined) {
                        scalarSet.x = undefined;
                        this.toParentResized();
                    }
                }
            }
            else {
                var scalar = DScalarFunctions.position(x);
                if (scalarSet.x !== scalar) {
                    scalarSet.x = scalar;
                    this.toParentResized();
                }
            }
        };
        Object.defineProperty(DBase.prototype, "y", {
            // @ts-ignore
            get: function () {
                return this._position.y;
            },
            set: function (y) {
                this.setY(y);
            },
            enumerable: false,
            configurable: true
        });
        DBase.prototype.getY = function () {
            var scalarSet = this._scalarSet;
            if (scalarSet.y != null) {
                return scalarSet.y;
            }
            else {
                return this._position.y;
            }
        };
        DBase.prototype.setY = function (y) {
            var scalarSet = this._scalarSet;
            if (isNumber(y)) {
                var position = this._position;
                if (position.y !== y) {
                    scalarSet.y = undefined;
                    position.y = y;
                }
                else {
                    if (scalarSet.y !== undefined) {
                        scalarSet.y = undefined;
                        this.toParentResized();
                    }
                }
            }
            else {
                var scalar = DScalarFunctions.position(y);
                if (scalarSet.y !== scalar) {
                    scalarSet.y = scalar;
                    this.toParentResized();
                }
            }
        };
        Object.defineProperty(DBase.prototype, "width", {
            // @ts-ignore
            get: function () {
                return this._width;
            },
            set: function (width) {
                this.setWidth(width);
            },
            enumerable: false,
            configurable: true
        });
        DBase.prototype.getWidth = function () {
            return this._auto.width.toCoordinate(this._scalarSet.width || this._width);
        };
        DBase.prototype.setWidth = function (width) {
            var auto = this._auto.width;
            var isOn = auto.isOn;
            var isAuto = auto.from(width);
            if (auto.isOn !== isOn) {
                this.toHierarchyDirty();
                DApplications.update(this);
            }
            if (!isAuto) {
                var scalarSet = this._scalarSet;
                if (isNumber(width)) {
                    var oldWidth = this._width;
                    if (oldWidth !== width) {
                        scalarSet.width = undefined;
                        this._width = width;
                        var height = this._height;
                        this.onResize(width, height, oldWidth, height);
                        if (scalarSet.x != null) {
                            var position = this._position;
                            var parent_4 = this.getParentOfSize();
                            if (parent_4) {
                                position.x = scalarSet.x(parent_4.width, width, parent_4.padding.getLeft(), position.x);
                            }
                        }
                    }
                    else {
                        if (scalarSet.width !== undefined) {
                            scalarSet.width = undefined;
                            this.toParentResized();
                        }
                    }
                }
                else {
                    var scalar = DScalarFunctions.size(width);
                    if (scalarSet.width !== scalar) {
                        scalarSet.width = scalar;
                        this.toParentResized();
                    }
                }
            }
        };
        Object.defineProperty(DBase.prototype, "height", {
            // @ts-ignore
            get: function () {
                return this._height;
            },
            set: function (height) {
                this.setHeight(height);
            },
            enumerable: false,
            configurable: true
        });
        DBase.prototype.getHeight = function () {
            return this._auto.height.toCoordinate(this._scalarSet.height || this._height);
        };
        DBase.prototype.setHeight = function (height) {
            var auto = this._auto.height;
            var isOn = auto.isOn;
            var isAuto = auto.from(height);
            if (auto.isOn !== isOn) {
                this.toHierarchyDirty();
                DApplications.update(this);
            }
            if (!isAuto) {
                var scalarSet = this._scalarSet;
                if (isNumber(height)) {
                    var oldHeight = this._height;
                    if (oldHeight !== height) {
                        scalarSet.height = undefined;
                        this._height = height;
                        var width = this._width;
                        this.onResize(width, height, width, oldHeight);
                        if (scalarSet.y != null) {
                            var position = this._position;
                            var parent_5 = this.getParentOfSize();
                            if (parent_5) {
                                position.y = scalarSet.y(parent_5.height, height, parent_5.padding.getTop(), position.y);
                            }
                        }
                    }
                    else {
                        if (scalarSet.height !== undefined) {
                            scalarSet.height = undefined;
                            this.toParentResized();
                        }
                    }
                }
                else {
                    var scalar = DScalarFunctions.size(height);
                    if (scalarSet.height !== scalar) {
                        scalarSet.height = scalar;
                        this.toParentResized();
                    }
                }
            }
        };
        Object.defineProperty(DBase.prototype, "position", {
            // @ts-ignore
            get: function () {
                return this._position;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBase.prototype, "scale", {
            // @ts-ignore
            get: function () {
                return this._scale;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBase.prototype, "skew", {
            // @ts-ignore
            get: function () {
                return this._skew;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBase.prototype, "padding", {
            get: function () {
                return this._padding;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBase.prototype, "corner", {
            get: function () {
                return this._corner;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBase.prototype, "background", {
            get: function () {
                return this._background;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBase.prototype, "border", {
            get: function () {
                return this._border;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBase.prototype, "outline", {
            get: function () {
                return this._outline;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBase.prototype, "unsafe", {
            get: function () {
                return this.transform;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBase.prototype, "title", {
            get: function () {
                return this._title;
            },
            set: function (title) {
                if (this._title !== title) {
                    this._title = title;
                    if (this.state.isHovered) {
                        this.applyTitle();
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        DBase.prototype.applyTitle = function () {
            var layer = DApplications.getLayer(this);
            if (layer) {
                layer.view.title = this._title;
            }
        };
        DBase.prototype.show = function () {
            if (!this.visible) {
                this.visible = true;
                this.toParentHierarchyDirty();
                DApplications.update(this);
            }
            return this;
        };
        DBase.prototype.isShown = function () {
            return this.visible;
        };
        DBase.prototype.hide = function () {
            if (this.visible) {
                this.visible = false;
                this.toParentHierarchyDirty();
                this.blur(true);
                DApplications.update(this);
            }
            return this;
        };
        DBase.prototype.isHidden = function () {
            return !this.visible;
        };
        DBase.prototype.toDirty = function () {
            if (!this._isDirty) {
                this._isDirty = true;
                this.toParentHasDirty();
                return true;
            }
            return false;
        };
        DBase.prototype.toHasDirty = function () {
            if (!this._hasDirty) {
                this._hasDirty = true;
                this.toParentHasDirty();
                return true;
            }
            return false;
        };
        DBase.prototype.toParentHasDirty = function () {
            var parent = this.parent;
            if (parent instanceof DBase) {
                parent.toHasDirty();
            }
        };
        DBase.prototype.toHierarchyDirty = function () {
            if (!this._isHierarchyDirty) {
                this._isHierarchyDirty = true;
                this.onHierarchyDirty();
                this.toParentHierarchyDirty();
                return true;
            }
            return false;
        };
        DBase.prototype.toParentHierarchyDirty = function () {
            var parent = this.parent;
            if (parent instanceof DBase) {
                parent.toHierarchyDirty();
            }
        };
        DBase.prototype.isHierarchyDirty = function () {
            return this._isHierarchyDirty;
        };
        DBase.prototype.onHierarchyDirty = function () {
            // DO NOTHING
        };
        DBase.prototype.isDirty = function () {
            return this._isDirty;
        };
        DBase.prototype.hasDirty = function () {
            return this._hasDirty;
        };
        DBase.prototype.setFocused = function (isFocused) {
            if (this.state.isFocused !== isFocused) {
                var layer = DApplications.getLayer(this);
                if (layer) {
                    layer.getFocusController().set(this, isFocused);
                }
            }
            return this;
        };
        DBase.prototype.focus = function () {
            return this.setFocused(true);
        };
        DBase.prototype.blur = function (recursively) {
            if (recursively) {
                var layer = DApplications.getLayer(this);
                if (layer) {
                    var focusController = layer.getFocusController();
                    var focused = focusController.get();
                    if (focused instanceof DBase) {
                        var current = focused;
                        while (current) {
                            if (current === this) {
                                focused.setFocused(false);
                                break;
                            }
                            current = current.parent;
                        }
                    }
                }
            }
            else {
                this.setFocused(false);
            }
            return this;
        };
        DBase.prototype.onStateChange = function (newState, oldState) {
            var _this = this;
            this.toDirty();
            DApplications.update(this);
            this.emit("statechange", newState, oldState, this);
            var children = this.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                var child = children[i];
                if (child instanceof DBase) {
                    child.state.onParentChange(newState, oldState);
                }
            }
            if (newState.isFocused) {
                if (!oldState.isFocused) {
                    this.onFocus();
                }
                if (newState.inDisabled && !oldState.inDisabled) {
                    setTimeout(function () {
                        _this.blur();
                    }, 0);
                }
            }
            else if (oldState.isFocused) {
                this.onBlur();
            }
            this.cursor = this.toCursor(this._cursor, newState);
        };
        DBase.prototype.onChildFocus = function (focused) {
            var parent = this.parent;
            if (parent instanceof DBase) {
                parent.onChildFocus(focused);
            }
        };
        DBase.prototype.onFocus = function () {
            var parent = this.parent;
            if (parent instanceof DBase) {
                parent.onChildFocus(this);
            }
        };
        DBase.prototype.onChildBlur = function (blured) {
            var parent = this.parent;
            if (parent instanceof DBase) {
                parent.onChildBlur(blured);
            }
        };
        DBase.prototype.onBlur = function () {
            var parent = this.parent;
            if (parent instanceof DBase) {
                parent.onChildBlur(this);
            }
        };
        Object.defineProperty(DBase.prototype, "state", {
            get: function () {
                return this._state;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBase.prototype, "options", {
            get: function () {
                return this._options;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBase.prototype, "theme", {
            get: function () {
                return this._theme;
            },
            set: function (theme) {
                var result = this._theme;
                if (result !== theme) {
                    this._theme = theme;
                    this._padding.setTheme(theme);
                    this._background.setTheme(theme);
                    this._border.setTheme(theme);
                    this._outline.setTheme(theme);
                    this._corner.setTheme(theme);
                    this.toDirty();
                    DApplications.update(this);
                }
            },
            enumerable: false,
            configurable: true
        });
        DBase.prototype.reflow = function () {
            var isDirty = this._isDirty;
            if (isDirty) {
                this.onReflow();
                this._isDirty = false;
            }
            var hasDirty = this._hasDirty;
            var isHierarchyDirty = this._isHierarchyDirty;
            if (hasDirty || isHierarchyDirty) {
                this._hasDirty = false;
                this._isHierarchyDirty = false;
                var children = this.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    var child = children[i];
                    if (child instanceof DBase) {
                        child.reflow();
                    }
                }
            }
            if (isDirty || hasDirty || isHierarchyDirty) {
                this.onRefit();
            }
        };
        DBase.prototype.onRefit = function () {
            var auto = this._auto;
            var isWidthAuto = auto.width.isOn;
            var isHeightAuto = auto.height.isOn;
            if (isWidthAuto && isHeightAuto) {
                var width = 0;
                var height = 0;
                var children = this.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    var child = children[i];
                    if (child.visible) {
                        var rw = this.hasRefitableWidth(child);
                        var rh = this.hasRefitableHeight(child);
                        if (rw || rh) {
                            if (child instanceof DBase) {
                                if (rw) {
                                    width = Math.max(width, child.x + child.width);
                                }
                                if (rh) {
                                    height = Math.max(height, child.y + child.height);
                                }
                            }
                            else if (child instanceof pixi_js.Container) {
                                var bound = child.getLocalBounds(undefined, true);
                                if (rw) {
                                    width = Math.max(width, child.x + bound.x + bound.width);
                                }
                                if (rh) {
                                    height = Math.max(height, child.y + bound.y + bound.height);
                                }
                            }
                            else {
                                var bound = child.getLocalBounds();
                                if (rw) {
                                    width = Math.max(width, child.x + bound.x + bound.width);
                                }
                                if (rh) {
                                    height = Math.max(height, child.y + bound.y + bound.height);
                                }
                            }
                        }
                    }
                }
                var padding = this.padding;
                this.resize(width + padding.getRight(), height + padding.getBottom());
            }
            else if (isWidthAuto) {
                var width = 0;
                var children = this.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    var child = children[i];
                    if (child.visible && this.hasRefitableWidth(child)) {
                        if (child instanceof DBase) {
                            width = Math.max(width, child.x + child.width);
                        }
                        else if (child instanceof pixi_js.Container) {
                            var bound = child.getLocalBounds(undefined, true);
                            width = Math.max(width, child.x + bound.x + bound.width);
                        }
                        else {
                            var bound = child.getLocalBounds();
                            width = Math.max(width, child.x + bound.x + bound.width);
                        }
                    }
                }
                this.resize(width + this.padding.getRight(), undefined);
            }
            else if (isHeightAuto) {
                var height = 0;
                var children = this.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    var child = children[i];
                    if (child.visible && this.hasRefitableHeight(child)) {
                        if (child instanceof DBase) {
                            height = Math.max(height, child.y + child.height);
                        }
                        else if (child instanceof pixi_js.Container) {
                            var bound = child.getLocalBounds(undefined, true);
                            height = Math.max(height, child.y + bound.y + bound.height);
                        }
                        else {
                            var bound = child.getLocalBounds();
                            height = Math.max(height, child.y + bound.y + bound.height);
                        }
                    }
                }
                this.resize(undefined, height + this.padding.getBottom());
            }
        };
        DBase.prototype.isRefitable = function (target) {
            return target instanceof DBase;
        };
        /**
         * Returns true if the given target has a height that doesn't depend on its parent height.
         *
         * @param target a target
         * @returns true if the given target has a height that doesn't depend on its parent height.
         */
        DBase.prototype.hasRefitableHeight = function (target) {
            return (this.isRefitable(target) && !(target instanceof DBase && isFunction(target.getHeight())));
        };
        /**
         * Returns true if the given target has a width that doesn't depend on its parent width.
         *
         * @param target a target
         * @returns true if the given target has a width that doesn't depend on its parent width.
         */
        DBase.prototype.hasRefitableWidth = function (target) {
            return (this.isRefitable(target) && !(target instanceof DBase && isFunction(target.getWidth())));
        };
        DBase.prototype.onReflow = function () {
            this._reflowable.onReflow(this, this._width, this._height);
        };
        Object.defineProperty(DBase.prototype, "shadow", {
            get: function () {
                return this._shadow;
            },
            set: function (shadow) {
                var previous = this._shadow;
                if (previous !== shadow) {
                    var reflowable = this._reflowable;
                    var snippet = this._snippet;
                    var onShadowUpdateBound = this._onShadowUpdateBound;
                    if (previous != null) {
                        previous.off("update", onShadowUpdateBound);
                        reflowable.remove(previous);
                        snippet.remove(previous, true);
                    }
                    this._shadow = shadow;
                    if (shadow != null) {
                        shadow.on("update", onShadowUpdateBound);
                        reflowable.add(shadow);
                        snippet.addAt(shadow, true, 0);
                    }
                    DApplications.update(this);
                }
            },
            enumerable: false,
            configurable: true
        });
        DBase.prototype.toParentResized = function () {
            var parent = this.getParentOfSize();
            if (parent) {
                this.onParentResize(parent.width, parent.height, parent.padding);
            }
        };
        DBase.prototype.getParentOfSize = function () {
            var parent = this.parent;
            if (parent instanceof DBase) {
                return parent;
            }
            else {
                return DApplications.getLayer(this);
            }
        };
        /**
         * Called when a parent resized.
         *
         * @param parentWidth a parent's local width
         * @param parentHeight a parent's local height
         */
        DBase.prototype.onParentResize = function (parentWidth, parentHeight, parentPadding) {
            var scalarSet = this._scalarSet;
            var position = this.transform.position;
            var x = position.x;
            var y = position.y;
            var width = this._width;
            var height = this._height;
            // Width & height
            var paddingWidth = parentPadding.getLeft() + parentPadding.getRight();
            var paddingHeight = parentPadding.getTop() + parentPadding.getBottom();
            var newWidth = scalarSet.width != null
                ? scalarSet.width(parentWidth, width, paddingWidth, width)
                : width;
            var newHeight = scalarSet.height != null
                ? scalarSet.height(parentHeight, height, paddingHeight, height)
                : height;
            this.resize(newWidth, newHeight);
            // X & Y
            var newX = scalarSet.x != null
                ? scalarSet.x(parentWidth, this._width, parentPadding.getLeft(), x)
                : x;
            var newY = scalarSet.y != null
                ? scalarSet.y(parentHeight, this._height, parentPadding.getTop(), y)
                : y;
            this.position.set(newX, newY);
        };
        /**
         * Called when a parent moved.
         *
         * @param newX a new parent's local x position
         * @param newY a new parent's local y position
         * @param oldX an old parent's local x position
         * @param oldY an old parent's local y position
         */
        DBase.prototype.onParentMove = function (newX, newY, oldX, oldY) {
            // DO NOTHING
        };
        // Wheel
        DBase.prototype.onWheel = function (e, deltas, global) {
            this.emit("wheel", e, deltas, global, this);
            return false;
        };
        // Keydown
        DBase.prototype.onKeyDown = function (e) {
            this.emit("keydown", e, this);
            return false;
        };
        DBase.prototype.onKeyUp = function (e) {
            this.emit("keyup", e, this);
            return false;
        };
        // Down
        DBase.prototype.isEventTarget = function (e) {
            var target = e.target;
            if (target === this) {
                return true;
            }
            else if (target != null && !(target instanceof DBase && target.interactive)) {
                var parent_6 = target.parent;
                while (parent_6 != null && !(parent_6 instanceof DBase && parent_6.interactive)) {
                    parent_6 = parent_6.parent;
                }
                return parent_6 === this;
            }
            return false;
        };
        DBase.prototype.onDown = function (e) {
            if (this.isEventTarget(e)) {
                this.onDownThis(e);
            }
            this.emit("down", e, this);
        };
        DBase.prototype.onDownThis = function (e) {
            var _a;
            var oe = e.data.originalEvent;
            if ("touches" in oe) {
                var lastDownPoint = ((_a = this._lastDownPoint) !== null && _a !== void 0 ? _a : (this._lastDownPoint = new pixi_js.Point()));
                lastDownPoint.copyFrom(e.data.global);
            }
            else {
                this.focusOnClosest();
            }
        };
        DBase.prototype.onUp = function (e) {
            if (this.isEventTarget(e)) {
                this.onUpThis(e);
            }
            this.emit("up", e, this);
        };
        DBase.prototype.onUpThis = function (e) {
            var oe = e.data.originalEvent;
            if ("touches" in oe) {
                var lastDownPoint = this._lastDownPoint;
                if (lastDownPoint) {
                    var global_1 = e.data.global;
                    var dx = Math.abs(global_1.x - lastDownPoint.x);
                    var dy = Math.abs(global_1.y - lastDownPoint.y);
                    var threshold = UtilPointerEvent.CLICK_DISTANCE_THRESHOLD;
                    if (dx < threshold && dy < threshold) {
                        this.focusOnClosest();
                    }
                }
            }
        };
        DBase.prototype.focusOnClosest = function () {
            var layer = DApplications.getLayer(this);
            if (layer) {
                var focusController = layer.getFocusController();
                focusController.focus(focusController.findParent(this));
            }
        };
        // Over
        DBase.prototype.onOver = function (e) {
            // Update the hover state
            this.state.isHovered = true;
            // Update the title
            if (e.target === this) {
                this.applyTitle();
            }
            // Event
            this.emit("over", e, this);
        };
        // Out
        DBase.prototype.onOut = function (e) {
            // Update the hover state
            this.state.isHovered = false;
            // Event
            this.emit("out", e, this);
        };
        // Double click
        DBase.prototype.onDblClick = function (e, interactionManager) {
            this.emit("dblclick", e, interactionManager, this);
            return false;
        };
        //
        DBase.prototype.render = function (renderer) {
            if (this.visible && 0 < this.worldAlpha && this.renderable) {
                var snippet = this._snippet;
                snippet.render(renderer, true);
                _super.prototype.render.call(this, renderer);
                snippet.render(renderer, false);
            }
        };
        DBase.prototype.updateTransform = function () {
            _super.prototype.updateTransform.call(this);
            this._snippet.updateTransform();
        };
        //
        DBase.prototype.getThemeDefault = function () {
            return DThemes.getInstance().get(this.getType());
        };
        DBase.prototype.getType = function () {
            return "DBase";
        };
        //
        DBase.prototype._calculateBounds = function () {
            this._bounds.addFrame(this.transform, 0, 0, this._width, this._height);
            _super.prototype._calculateBounds.call(this);
        };
        DBase.prototype.containsPoint = function (point) {
            return (this.containsGlobalPoint(point) ||
                this.containsLocalPoint(this.worldTransform.applyInverse(point, DBase.WORK_CONTAINS_POINT)));
        };
        DBase.prototype.containsGlobalPoint = function (point) {
            return false;
        };
        DBase.prototype.containsLocalPoint = function (point) {
            var x = point.x;
            var y = point.y;
            var w = this._width;
            var h = this._height;
            return 0 <= x && x <= w && 0 <= y && y <= h;
        };
        /**
         * Returns a clipping rect.
         *
         * @param result a clipping rect
         */
        DBase.prototype.getClippingRect = function (target, result) {
            result.x = 0;
            result.y = 0;
            result.width = this._width;
            result.height = this._height;
        };
        DBase.prototype.destroy = function () {
            // Layout
            var scalarSet = this._scalarSet;
            scalarSet.x = null;
            scalarSet.y = null;
            scalarSet.width = null;
            scalarSet.height = null;
            // Shadow
            var shadow = this._shadow;
            if (shadow) {
                this._shadow = null;
                shadow.destroy();
            }
            // Children
            var children = this.children;
            for (var i = children.length - 1; 0 <= i; --i) {
                children[i].destroy();
            }
            children.length = 0;
            //
            _super.prototype.destroy.call(this);
        };
        DBase.WORK_CONTAINS_POINT = new pixi_js.Point();
        return DBase;
    }(pixi_js.Container));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DBaseOverflowMask = /** @class */ (function (_super) {
        __extends(DBaseOverflowMask, _super);
        function DBaseOverflowMask(parent) {
            var _this = _super.call(this) || this;
            _this.parent = parent;
            _this._isInitialized = false;
            _this._width = 0;
            _this._height = 0;
            _this._cornderRadius = 0;
            _this._cornerMask = DCornerMask.NONE;
            return _this;
        }
        DBaseOverflowMask.prototype.render = function (renderer) {
            this.updateTransform();
            _super.prototype.render.call(this, renderer);
        };
        DBaseOverflowMask.prototype.onReflow = function (base, width, height) {
            var corner = base.corner;
            var cornerRadius = Math.max(0, corner.getRadius() - 0.5);
            var cornerMask = corner.getMask();
            if (this._isInitialized &&
                this._width === width &&
                this._height === height &&
                this._cornderRadius === cornerRadius &&
                this._cornerMask === cornerMask) {
                return;
            }
            this._isInitialized = true;
            this._width = width;
            this._height = height;
            this._cornderRadius = cornerRadius;
            this._cornerMask = cornerMask;
            var x = 0;
            var y = 0;
            var tl = cornerMask & DCornerMask.TOP_LEFT ? 0 : cornerRadius;
            var tr = cornerMask & DCornerMask.TOP_RIGHT ? 0 : cornerRadius;
            var bl = cornerMask & DCornerMask.BOTTOM_LEFT ? 0 : cornerRadius;
            var br = cornerMask & DCornerMask.BOTTOM_RIGHT ? 0 : cornerRadius;
            this.clear();
            this.beginFill(0xffffff, 1);
            this.lineStyle(0, 0, 0, 0, false);
            if (tl <= 0 && tr <= 0 && bl <= 0 && br <= 0) {
                this.drawRect(x, y, width, height);
            }
            else {
                this.moveTo(x + tl, y);
                if (0 < tr) {
                    this.arcTo(x + width, y, x + width, y + height, tr);
                }
                else {
                    this.lineTo(x + width, y);
                }
                if (0 < br) {
                    this.arcTo(x + width, y + height, x, y + height, br);
                }
                else {
                    this.lineTo(x + width, y + height);
                }
                if (0 < bl) {
                    this.arcTo(x, y + height, x, y, bl);
                }
                else {
                    this.lineTo(x, y + height);
                }
                if (0 < tl) {
                    this.arcTo(x, y, x + width, y, tl);
                }
                else {
                    this.lineTo(x, y);
                }
            }
            this.endFill();
        };
        return DBaseOverflowMask;
    }(pixi_js.Graphics));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var UtilGestureMode = {
        OFF: 0,
        ON: 1,
        TOUCH: 2
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DViewGestureImpl = /** @class */ (function () {
        function DViewGestureImpl(owner, toTarget, parent, constraint, theme, options) {
            var _this = this;
            var _a, _b;
            this._owner = owner;
            this._parent = parent;
            this._constraint = constraint;
            var mode = toEnum((_a = options === null || options === void 0 ? void 0 : options.mode) !== null && _a !== void 0 ? _a : theme.getGestureMode(), UtilGestureMode);
            var modifier = toEnum((_b = options === null || options === void 0 ? void 0 : options.modifier) !== null && _b !== void 0 ? _b : theme.getGestureModifier(), UtilGestureModifier);
            if (mode === UtilGestureMode.ON || mode === UtilGestureMode.TOUCH) {
                var work_1 = new pixi_js.Point();
                this._gestureUtil = new UtilGesture({
                    touch: mode === UtilGestureMode.TOUCH,
                    modifier: modifier,
                    checker: options && options.checker,
                    easing: {
                        duration: options === null || options === void 0 ? void 0 : options.duration
                    },
                    on: {
                        start: function (target) {
                            _this.onStart(target);
                        },
                        move: function (target, dx, dy, x, y, ds) {
                            _this.onGestureMove(toTarget(owner), dx, dy, x, y, ds, work_1);
                        },
                        easing: {
                            end: function (target) {
                                _this.onEnd(target);
                            }
                        },
                        stop: function (target) {
                            _this.onStop(target);
                        },
                        tap: function (target, e) {
                            _this.onTap(target, e);
                        },
                        longpress: function (target, e) {
                            _this.onLongPress(target, e);
                        }
                    }
                });
            }
        }
        DViewGestureImpl.prototype.onStart = function (target) {
            var parent = this._parent;
            parent.stop();
            parent.emit("gesturestart", target, parent);
        };
        DViewGestureImpl.prototype.onEnd = function (target) {
            var parent = this._parent;
            parent.emit("gestureend", target, parent);
        };
        DViewGestureImpl.prototype.onStop = function (target) {
            var parent = this._parent;
            parent.emit("gesturestop", target, parent);
        };
        DViewGestureImpl.prototype.onTap = function (target, e) {
            var parent = this._parent;
            parent.emit("gesturetap", target, e, parent);
        };
        DViewGestureImpl.prototype.onLongPress = function (target, e) {
            var parent = this._parent;
            parent.emit("gesturelongpress", target, e, parent);
        };
        DViewGestureImpl.prototype.onGestureMove = function (target, dx, dy, x, y, ds, work) {
            if (target != null) {
                // Scale
                var parent_1 = this._parent;
                var oldScale = target.scale;
                var oldScaleX = oldScale.x;
                var oldScaleY = oldScale.y;
                var newScaleX = parent_1.toNormalizedScale(oldScaleX * ds);
                var newScaleY = parent_1.toNormalizedScale(oldScaleY * ds);
                var scaleRatioX = newScaleX / oldScaleX;
                var scaleRatioY = newScaleY / oldScaleY;
                var scaleRatio = ds < 1 ? Math.max(scaleRatioX, scaleRatioY) : Math.min(scaleRatioX, scaleRatioY);
                newScaleX = scaleRatio * oldScaleX;
                newScaleY = scaleRatio * oldScaleY;
                // Position
                var targetParent = target.parent;
                if (targetParent != null) {
                    targetParent.toLocal(work.set(x, y), undefined, work);
                    x = work.x;
                    y = work.y;
                }
                var cx = x - dx;
                var cy = y - dy;
                var position = target.position;
                var newX = (position.x - cx) * scaleRatio + x;
                var newY = (position.y - cy) * scaleRatio + y;
                // Update
                this._constraint(target, newX, newY, newScaleX, newScaleY);
            }
        };
        DViewGestureImpl.prototype.stop = function () {
            var _a;
            (_a = this._gestureUtil) === null || _a === void 0 ? void 0 : _a.stop(this._owner);
        };
        DViewGestureImpl.prototype.onDown = function (e) {
            var _a;
            (_a = this._gestureUtil) === null || _a === void 0 ? void 0 : _a.onDown(this._owner, e);
        };
        return DViewGestureImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DViewTransformImpl = /** @class */ (function () {
        function DViewTransformImpl(owner, toTarget, parent, constraint, duration) {
            var _this = this;
            this._owner = owner;
            this._toTarget = toTarget;
            this._constraint = constraint;
            this._newScaleX = 1;
            this._newScaleY = 1;
            this._newX = 0;
            this._newY = 0;
            this._oldScaleX = 1;
            this._oldScaleY = 1;
            this._oldX = 0;
            this._oldY = 0;
            this._isStarted = false;
            this._animation = new DAnimationBase({
                onStart: function () {
                    _this.onStart();
                },
                onTime: function (time) {
                    _this.onTime(time);
                },
                onEnd: function () {
                    _this.onEnd();
                },
                onStop: function () {
                    _this.onStop();
                },
                duration: duration
            });
            this._parent = parent;
            this._duration = duration;
        }
        DViewTransformImpl.prototype.onStart = function () {
            var parent = this._parent;
            parent.emit("transformstart", this._owner, parent);
        };
        DViewTransformImpl.prototype.onTime = function (time) {
            var w0 = 1 - time;
            var w1 = time;
            var scaleX = this._oldScaleX * w0 + this._newScaleX * w1;
            var scaleY = this._oldScaleY * w0 + this._newScaleY * w1;
            var x = this._oldX * w0 + this._newX * w1;
            var y = this._oldY * w0 + this._newY * w1;
            var target = this._toTarget(this._owner);
            if (target != null) {
                this._constraint(target, x, y, scaleX, scaleY);
            }
        };
        DViewTransformImpl.prototype.onEnd = function () {
            var parent = this._parent;
            parent.emit("transformend", this._owner, parent);
        };
        DViewTransformImpl.prototype.onStop = function () {
            var parent = this._parent;
            parent.emit("transformstop", this._owner, parent);
        };
        DViewTransformImpl.prototype.start = function (target, x, y, scaleX, scaleY, duration, stop) {
            var parent = this._parent;
            if (stop !== false) {
                parent.stop();
            }
            if (duration == null) {
                duration = this._duration;
            }
            if (duration <= 0) {
                this.onStart();
                this._constraint(target, x, y, scaleX, scaleY);
                this.onEnd();
            }
            else {
                var position = target.position;
                var scale = target.scale;
                this._oldX = position.x;
                this._oldY = position.y;
                this._oldScaleX = scale.x;
                this._oldScaleY = scale.y;
                this._newX = x;
                this._newY = y;
                this._newScaleX = scaleX;
                this._newScaleY = scaleY;
                this._animation.duration = duration;
                this._animation.start();
            }
        };
        DViewTransformImpl.prototype.stop = function () {
            this._animation.stop();
        };
        return DViewTransformImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DViewImpl = /** @class */ (function (_super) {
        __extends(DViewImpl, _super);
        function DViewImpl(parent, toTarget, options) {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s;
            var _this = _super.call(this) || this;
            _this._parent = parent;
            _this._toTarget = toTarget;
            _this._constraint = (options && options.constraint) || DViewImpl.CONSTRAINT;
            _this._workRect = new pixi_js.Rectangle();
            // Theme
            var theme = _this.toTheme(options) || _this.getThemeDefault();
            // Zoom
            var zoom = options === null || options === void 0 ? void 0 : options.zoom;
            _this._zoomPoint = new pixi_js.Point();
            _this._zoomMin = (_a = zoom === null || zoom === void 0 ? void 0 : zoom.min) !== null && _a !== void 0 ? _a : theme.getZoomMin();
            _this._zoomMax = (_b = zoom === null || zoom === void 0 ? void 0 : zoom.max) !== null && _b !== void 0 ? _b : theme.getZoomMax();
            _this._zoomKeepRatio = (_c = zoom === null || zoom === void 0 ? void 0 : zoom.keepRatio) !== null && _c !== void 0 ? _c : theme.getZoomKeepRatio();
            // Zoom: Wheel
            var wheelZoom = zoom === null || zoom === void 0 ? void 0 : zoom.wheel;
            _this._isWheelZoomEnabled = (_d = wheelZoom === null || wheelZoom === void 0 ? void 0 : wheelZoom.enable) !== null && _d !== void 0 ? _d : theme.isWheelZoomEnabled();
            _this._wheelZoomSpeed = (_e = wheelZoom === null || wheelZoom === void 0 ? void 0 : wheelZoom.speed) !== null && _e !== void 0 ? _e : theme.getWheelZoomSpeed();
            _this._wheelZoomModifier = toEnum((_f = wheelZoom === null || wheelZoom === void 0 ? void 0 : wheelZoom.modifier) !== null && _f !== void 0 ? _f : theme.getWheelZoomModifier(), UtilGestureModifier);
            _this._wheelZoomChecker = (_g = wheelZoom === null || wheelZoom === void 0 ? void 0 : wheelZoom.checker) !== null && _g !== void 0 ? _g : UtilGestureModifiers.match;
            // Zoom: Dbl click
            var dblClickZoom = zoom === null || zoom === void 0 ? void 0 : zoom.dblclick;
            _this._isDblClickZoomEnabled = (_h = dblClickZoom === null || dblClickZoom === void 0 ? void 0 : dblClickZoom.enable) !== null && _h !== void 0 ? _h : theme.isDblClickZoomEnabled();
            _this._dblClickZoomSpeed = (_j = dblClickZoom === null || dblClickZoom === void 0 ? void 0 : dblClickZoom.amount) !== null && _j !== void 0 ? _j : theme.getDblClickZoomSpeed();
            _this._dblClickZoomModifier = toEnum((_k = dblClickZoom === null || dblClickZoom === void 0 ? void 0 : dblClickZoom.modifier) !== null && _k !== void 0 ? _k : theme.getDblClickZoomModifier(), UtilGestureModifier);
            _this._dblClickZoomChecker = (_l = dblClickZoom === null || dblClickZoom === void 0 ? void 0 : dblClickZoom.checker) !== null && _l !== void 0 ? _l : UtilGestureModifiers.match;
            _this._dblclickZoomDuration = (_m = dblClickZoom === null || dblClickZoom === void 0 ? void 0 : dblClickZoom.duration) !== null && _m !== void 0 ? _m : theme.getDblClickZoomDuration();
            // Translation: Wheel
            var wheelTranslation = (_o = options === null || options === void 0 ? void 0 : options.translation) === null || _o === void 0 ? void 0 : _o.wheel;
            _this._isWheelTranslationEnabled =
                (_p = wheelTranslation === null || wheelTranslation === void 0 ? void 0 : wheelTranslation.enable) !== null && _p !== void 0 ? _p : theme.isWheelTranslationEnabled();
            _this._wheelTranslationSpeed = (_q = wheelTranslation === null || wheelTranslation === void 0 ? void 0 : wheelTranslation.speed) !== null && _q !== void 0 ? _q : theme.getWheelTranslationSpeed();
            _this._wheelTranslationModifier = toEnum((_r = wheelTranslation === null || wheelTranslation === void 0 ? void 0 : wheelTranslation.modifier) !== null && _r !== void 0 ? _r : theme.getWheelTranslationModifier(), UtilGestureModifier);
            _this._wheelTranslationChecker = (_s = wheelTranslation === null || wheelTranslation === void 0 ? void 0 : wheelTranslation.checker) !== null && _s !== void 0 ? _s : UtilGestureModifiers.match;
            // Gesture
            _this._gesture = new DViewGestureImpl(parent, toTarget, _this, _this._constraint, theme, options === null || options === void 0 ? void 0 : options.gesture);
            // Transform
            _this._transform = new DViewTransformImpl(parent, toTarget, _this, _this._constraint, _this._dblclickZoomDuration);
            // Events
            if (options != null) {
                var on = options.on;
                if (on != null) {
                    for (var name_1 in on) {
                        var handler = on[name_1];
                        if (handler) {
                            _this.on(name_1, handler);
                        }
                    }
                }
            }
            return _this;
        }
        Object.defineProperty(DViewImpl.prototype, "gesture", {
            get: function () {
                return this._gesture;
            },
            enumerable: false,
            configurable: true
        });
        DViewImpl.prototype.stop = function () {
            this._gesture.stop();
            this._transform.stop();
        };
        DViewImpl.prototype.reset = function (duration, stop) {
            var parent = this._parent;
            var target = this._toTarget(parent);
            if (target) {
                var padding = parent.padding;
                var pl = padding.getLeft();
                var pt = padding.getTop();
                var pr = padding.getRight();
                var pb = padding.getBottom();
                var w = parent.width;
                var h = parent.height;
                var sw = w - pl - pr;
                var sh = h - pt - pb;
                var trect = target.getLocalBounds(this._workRect);
                var tx = trect.x;
                var ty = trect.y;
                var tw = trect.width;
                var th = trect.height;
                var ntx = pl + (sw - tw) * 0.5 - tx;
                var nty = pt + (sh - th) * 0.5 - ty;
                this._transform.start(target, ntx, nty, 1, 1, duration, stop);
            }
        };
        DViewImpl.prototype.fit = function (duration, stop) {
            var parent = this._parent;
            var target = this._toTarget(parent);
            if (target) {
                var padding = parent.padding;
                var pl = padding.getLeft();
                var pt = padding.getTop();
                var pr = padding.getRight();
                var pb = padding.getBottom();
                var w = parent.width;
                var h = parent.height;
                var sw = w - pl - pr;
                var sh = h - pt - pb;
                var trect = target.getLocalBounds(this._workRect);
                var tx = trect.x;
                var ty = trect.y;
                var tw = trect.width;
                var th = trect.height;
                var ntsx = sw / tw;
                var ntsy = sh / th;
                if (this._zoomKeepRatio) {
                    var nts = this.toNormalizedScale(Math.min(ntsx, ntsy));
                    ntsx = nts;
                    ntsy = nts;
                }
                else {
                    ntsx = this.toNormalizedScale(ntsx);
                    ntsy = this.toNormalizedScale(ntsy);
                }
                var ntx = pl + (sw - tw * ntsx) * 0.5 - tx * ntsx;
                var nty = pt + (sh - th * ntsy) * 0.5 - ty * ntsy;
                this._transform.start(target, ntx, nty, ntsx, ntsy, duration, stop);
            }
        };
        DViewImpl.prototype.zoomIn = function (duration, stop) {
            var target = this._toTarget(this._parent);
            if (target) {
                var factor = this._dblClickZoomSpeed;
                var targetScale = target.scale;
                this.zoom(targetScale.x * factor, targetScale.y * factor, duration, stop);
            }
        };
        DViewImpl.prototype.zoomOut = function (duration, stop) {
            var target = this._toTarget(this._parent);
            if (target) {
                var factor = 1 / this._dblClickZoomSpeed;
                var targetScale = target.scale;
                this.zoom(targetScale.x * factor, targetScale.y * factor, duration, stop);
            }
        };
        DViewImpl.prototype.zoomAt = function (x, y, scaleX, scaleY, duration, stop) {
            var target = this._toTarget(this._parent);
            if (target) {
                // Scale
                var oldScaleX = target.scale.x;
                var oldScaleY = target.scale.y;
                var newScaleX = this.toNormalizedScale(scaleX);
                var newScaleY = this.toNormalizedScale(scaleY);
                var scaleRatioX = newScaleX / oldScaleX;
                var scaleRatioY = newScaleY / oldScaleY;
                // Position
                var newX = (target.position.x - x) * scaleRatioX + x;
                var newY = (target.position.y - y) * scaleRatioY + y;
                // Start
                this._transform.start(target, newX, newY, newScaleX, newScaleY, duration, stop);
            }
        };
        DViewImpl.prototype.zoomAtGlobal = function (x, y, scaleX, scaleY, duration, stop) {
            var local = this._zoomPoint;
            local.set(x, y);
            this.toLocal(local, local);
            this.zoomAt(local.x, local.y, scaleX, scaleY, duration, stop);
        };
        DViewImpl.prototype.zoom = function (scaleX, scaleY, duration, stop) {
            var parent = this._parent;
            this.zoomAt(parent.width * 0.5, parent.height * 0.5, scaleX, scaleY, duration, stop);
        };
        Object.defineProperty(DViewImpl.prototype, "scale", {
            get: function () {
                var target = this._toTarget(this._parent);
                if (target) {
                    return target.scale;
                }
                return new pixi_js.Point(1, 1);
            },
            set: function (scale) {
                var target = this._toTarget(this._parent);
                if (target) {
                    var newScaleX = this.toNormalizedScale(scale.x);
                    var newScaleY = this.toNormalizedScale(scale.y);
                    var targetPosition = target.position;
                    this._constraint(target, targetPosition.x, targetPosition.y, newScaleX, newScaleY);
                }
            },
            enumerable: false,
            configurable: true
        });
        DViewImpl.prototype.moveTo = function (x, y, duration, stop) {
            var target = this._toTarget(this._parent);
            if (target) {
                var targetScale = target.scale;
                this._transform.start(target, x, y, targetScale.x, targetScale.y, duration, stop);
            }
        };
        Object.defineProperty(DViewImpl.prototype, "position", {
            get: function () {
                var target = this._toTarget(this._parent);
                if (target) {
                    return target.position;
                }
                return new pixi_js.Point(0, 0);
            },
            set: function (position) {
                var target = this._toTarget(this._parent);
                if (target) {
                    var targetScale = target.scale;
                    this._constraint(target, position.x, position.y, targetScale.x, targetScale.y);
                }
            },
            enumerable: false,
            configurable: true
        });
        DViewImpl.prototype.transform = function (x, y, scaleX, scaleY, duration, stop) {
            var target = this._toTarget(this._parent);
            if (target) {
                this._transform.start(target, x, y, scaleX, scaleY, duration, stop);
            }
        };
        DViewImpl.prototype.toLocal = function (global, local, skipUpdate) {
            return this._parent.toLocal(global, undefined, local, skipUpdate);
        };
        DViewImpl.prototype.toGlobal = function (local, global, skipUpdate) {
            return this._parent.toGlobal(local, global, skipUpdate);
        };
        DViewImpl.prototype.toNormalizedScale = function (scale) {
            return Math.min(this._zoomMax, Math.max(this._zoomMin, scale));
        };
        DViewImpl.prototype.onWheel = function (e, deltas, global) {
            if (this._isWheelZoomEnabled &&
                this._wheelZoomChecker(e, this._wheelZoomModifier, this._parent)) {
                if (deltas.deltaY !== 0) {
                    var target = this._toTarget(this._parent);
                    if (target) {
                        var speed = deltas.lowest * this._wheelZoomSpeed;
                        var factor = 1 + deltas.deltaY * speed;
                        var targetScale = target.scale;
                        this.zoomAtGlobal(global.x, global.y, targetScale.x * factor, targetScale.y * factor, 0);
                        return true;
                    }
                }
            }
            if (this._isWheelTranslationEnabled &&
                this._wheelTranslationChecker(e, this._wheelTranslationModifier, this._parent)) {
                var target = this._toTarget(this._parent);
                if (target) {
                    this.stop();
                    this.emit("wheeltranslationstart", this._parent, this);
                    var speed = deltas.lowest * this._wheelTranslationSpeed;
                    var targetPosition = target.position;
                    var newX = targetPosition.x - deltas.deltaX * speed;
                    var newY = targetPosition.y + deltas.deltaY * speed;
                    var targetScale = target.scale;
                    this._constraint(target, newX, newY, targetScale.x, targetScale.y);
                    this.emit("wheeltranslationend", this._parent, this);
                    return true;
                }
            }
            return false;
        };
        DViewImpl.prototype.onDown = function (e) {
            this._gesture.onDown(e);
        };
        DViewImpl.prototype.onDblClick = function (e, interactionManager) {
            if (this._isDblClickZoomEnabled &&
                this._dblClickZoomChecker(e, this._dblClickZoomModifier, this._parent)) {
                var target = this._toTarget(this._parent);
                if (target) {
                    var global_1 = this._zoomPoint;
                    UtilPointerEvent.toGlobal(e, interactionManager, global_1);
                    var factor = this._dblClickZoomSpeed;
                    var targetScale = target.scale;
                    this.zoomAtGlobal(global_1.x, global_1.y, targetScale.x * factor, targetScale.y * factor, this._dblclickZoomDuration);
                    return true;
                }
            }
            return false;
        };
        DViewImpl.prototype.toTheme = function (options) {
            if (options && options.theme) {
                var theme = options.theme;
                if (isString(theme)) {
                    return DThemes.getInstance().get(theme);
                }
                else {
                    return theme;
                }
            }
            return null;
        };
        DViewImpl.prototype.getThemeDefault = function () {
            return DThemes.getInstance().get(this.getType());
        };
        DViewImpl.prototype.getType = function () {
            return "DView";
        };
        DViewImpl.CONSTRAINT = function (target, x, y, scaleX, scaleY) {
            target.scale.set(scaleX, scaleY);
            target.position.set(x, y);
        };
        return DViewImpl;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A canvas container.
     */
    var DCanvasContainer = /** @class */ (function (_super) {
        __extends(DCanvasContainer, _super);
        function DCanvasContainer() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DCanvasContainer.prototype.init = function (options) {
            var _this = this;
            var _a;
            _super.prototype.init.call(this, options);
            this._canvas = null;
            var theme = this.theme;
            this._view = new DViewImpl(this, function () { return _this._canvas; }, options === null || options === void 0 ? void 0 : options.view);
            // Canvas
            var canvas = options === null || options === void 0 ? void 0 : options.canvas;
            if (canvas) {
                this.canvas = canvas;
            }
            // Overflow mask
            var mask = (_a = options === null || options === void 0 ? void 0 : options.mask) !== null && _a !== void 0 ? _a : theme.isOverflowMaskEnabled();
            if (mask) {
                this.mask = this.getOverflowMask();
            }
        };
        DCanvasContainer.prototype.getType = function () {
            return "DCanvasContainer";
        };
        DCanvasContainer.prototype.onResize = function (newWidth, newHeight, oldWidth, oldHeight) {
            _super.prototype.onResize.call(this, newWidth, newHeight, oldWidth, oldHeight);
            this.updateContentSize(newWidth, newHeight, oldWidth, oldHeight);
        };
        Object.defineProperty(DCanvasContainer.prototype, "canvas", {
            get: function () {
                return this._canvas;
            },
            set: function (canvas) {
                var previous = this._canvas;
                if (previous != null) {
                    this._canvas = null;
                    this.removeChild(previous);
                    this.emit("unset", previous, this);
                    previous.destroy();
                }
                this._canvas = canvas;
                if (canvas != null) {
                    this.addChild(canvas);
                    this._view.reset(0);
                    this.emit("set", canvas, this);
                }
                else {
                    DApplications.update(this);
                }
            },
            enumerable: false,
            configurable: true
        });
        DCanvasContainer.prototype.getOverflowMask = function () {
            if (this._overflowMask == null) {
                this._overflowMask = new DBaseOverflowMask(this);
                this._reflowable.add(this._overflowMask);
                this.toDirty();
            }
            return this._overflowMask;
        };
        DCanvasContainer.prototype.updateContentSize = function (newWidth, newHeight, oldWidth, oldHeight) {
            var canvas = this._canvas;
            if (canvas != null) {
                var canvasX = canvas.x + (newWidth - oldWidth) * 0.5;
                var canvasY = canvas.y + (newHeight - oldHeight) * 0.5;
                canvas.position.set(canvasX, canvasY);
            }
        };
        Object.defineProperty(DCanvasContainer.prototype, "view", {
            get: function () {
                return this._view;
            },
            enumerable: false,
            configurable: true
        });
        DCanvasContainer.prototype.onWheel = function (e, deltas, global) {
            var vresult = this._view.onWheel(e, deltas, global);
            var sresult = _super.prototype.onWheel.call(this, e, deltas, global);
            return vresult || sresult;
        };
        DCanvasContainer.prototype.onDblClick = function (e, interactionManager, skipView) {
            if (skipView !== true) {
                var vresult = this._view.onDblClick(e, interactionManager);
                var sresult = _super.prototype.onDblClick.call(this, e, interactionManager);
                return vresult || sresult;
            }
            else {
                return _super.prototype.onDblClick.call(this, e, interactionManager);
            }
        };
        DCanvasContainer.prototype.onDown = function (e, skipView) {
            if (skipView !== true) {
                this._view.onDown(e);
            }
            _super.prototype.onDown.call(this, e);
        };
        DCanvasContainer.prototype.destroy = function () {
            // Overflow mask
            var overflowMask = this._overflowMask;
            if (overflowMask != null) {
                this._overflowMask = null;
                overflowMask.destroy();
            }
            this.mask = null;
            _super.prototype.destroy.call(this);
        };
        return DCanvasContainer;
    }(DBase));

    var UtilExtractorCanvas = /** @class */ (function () {
        function UtilExtractorCanvas(width, height) {
            var element = document.createElement("canvas");
            this._element = element;
            var context = this._element.getContext("2d", {
                willReadFrequently: true
            });
            this._context = context;
            element.width = width;
            element.height = height;
        }
        Object.defineProperty(UtilExtractorCanvas.prototype, "element", {
            get: function () {
                var result = this._element;
                if (result != null) {
                    return result;
                }
                throw new Error("No Element Available");
            },
            enumerable: false,
            configurable: true
        });
        UtilExtractorCanvas.prototype.getElement = function () {
            return this._element;
        };
        Object.defineProperty(UtilExtractorCanvas.prototype, "canvas", {
            get: function () {
                return this.element;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UtilExtractorCanvas.prototype, "context", {
            get: function () {
                var result = this._context;
                if (result != null) {
                    return result;
                }
                throw new Error("No Context Available");
            },
            enumerable: false,
            configurable: true
        });
        UtilExtractorCanvas.prototype.getContext = function () {
            return this._context;
        };
        Object.defineProperty(UtilExtractorCanvas.prototype, "resolution", {
            get: function () {
                return 1;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UtilExtractorCanvas.prototype, "width", {
            get: function () {
                var element = this._element;
                if (element != null) {
                    return element.width;
                }
                return 0;
            },
            set: function (width) {
                var element = this._element;
                if (element != null) {
                    element.width = width;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UtilExtractorCanvas.prototype, "height", {
            get: function () {
                var element = this._element;
                if (element != null) {
                    return element.height;
                }
                return 0;
            },
            set: function (height) {
                var element = this._element;
                if (element != null) {
                    element.height = height;
                }
            },
            enumerable: false,
            configurable: true
        });
        UtilExtractorCanvas.prototype.clear = function () {
            var element = this._element;
            var context = this._context;
            if (element != null && context != null) {
                context.setTransform(1, 0, 0, 1, 0, 0);
                context.clearRect(0, 0, element.width, element.height);
            }
        };
        UtilExtractorCanvas.prototype.resize = function (width, height) {
            var element = this._element;
            if (element != null) {
                element.width = width;
                element.height = height;
            }
        };
        UtilExtractorCanvas.prototype.destroy = function () {
            this._context = null;
            this._element = null;
        };
        return UtilExtractorCanvas;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var UtilExtractor = /** @class */ (function () {
        function UtilExtractor() {
        }
        UtilExtractor.toTexture = function (target, resolution, clear, skipUpdateTransform) {
            var scale = target.transform.scale;
            var width = Math.max(1, Math.ceil(target.width * scale.x));
            var height = Math.max(1, Math.ceil(target.height * scale.y));
            var result = pixi_js.RenderTexture.create({
                width: width,
                height: height,
                scaleMode: pixi_js.SCALE_MODES.LINEAR,
                resolution: resolution
            });
            var matrix = new pixi_js.Matrix(undefined, undefined, undefined, undefined, -target.position.x, -target.position.y);
            var layer = DApplications.getLayer(target);
            if (layer) {
                layer.renderer.render(target, result, clear, matrix, skipUpdateTransform);
            }
            return result;
        };
        UtilExtractor.toPixels = function (renderTexture, renderer) {
            var baseTexture = renderTexture.baseTexture;
            var realWidth = baseTexture.realWidth;
            var realHeight = baseTexture.realHeight;
            var resolution = renderTexture.resolution;
            var frame = renderTexture.frame;
            var x0 = Math.floor(frame.x * resolution);
            var y0 = Math.floor(frame.y * resolution);
            var x1 = Math.floor((frame.x + frame.width) * resolution);
            var y1 = Math.floor((frame.y + frame.height) * resolution);
            var width = Math.min(x1 - x0, realWidth);
            var height = Math.min(y1 - y0, realHeight);
            var pixels = new Uint8Array(4 * width * height);
            if (0 < width && 0 < height) {
                var oldRenderTexture = renderer.renderTexture.current;
                renderer.renderTexture.bind(renderTexture);
                var gl = renderer.gl;
                gl.readPixels(x0, y0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
                renderer.renderTexture.bind(oldRenderTexture);
            }
            return {
                width: width,
                height: height,
                array: pixels
            };
        };
        UtilExtractor.toCanvas = function (pixels, scale, ignorePremutipliedAlpha, result) {
            var width = pixels.width;
            var height = pixels.height;
            var array = pixels.array;
            if (result == null) {
                result = new UtilExtractorCanvas(width, height);
            }
            else {
                result.resize(width, height);
            }
            if (width <= 0 || height <= 0) {
                return result;
            }
            var context = result.getContext();
            var element = result.getElement();
            if (context == null || element == null) {
                return result;
            }
            var imageData = context.getImageData(0, 0, width, height);
            if (ignorePremutipliedAlpha) {
                imageData.data.set(array);
            }
            else {
                pixi_js.Extract.arrayPostDivide(array, imageData.data);
            }
            context.putImageData(imageData, 0, 0);
            // Scale down
            if (scale != null && scale !== 1) {
                context.scale(scale, scale);
                context.drawImage(element, 0, 0);
                var scaledWidth = Math.floor(width * scale);
                var scaledHeight = Math.floor(height * scale);
                var scaledImageData = context.getImageData(0, 0, scaledWidth, scaledHeight);
                result.resize(scaledWidth, scaledHeight);
                context.putImageData(scaledImageData, 0, 0);
            }
            return result;
        };
        UtilExtractor.toBase64 = function (canvas, format, quality) {
            return canvas.toDataURL(format, quality);
        };
        return UtilExtractor;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var UtilFileDownloader = /** @class */ (function () {
        function UtilFileDownloader() {
        }
        /**
         * Downloads a file of the given name and URL.
         *
         * @param filename a file name
         * @param url a file URL
         */
        UtilFileDownloader.downloadUrl = function (filename, url) {
            var a = document.createElement("a");
            if ("download" in a) {
                a.href = url;
                a.setAttribute("download", filename);
                a.style.display = "none";
                document.body.appendChild(a);
                a.click();
                setTimeout(function () {
                    document.body.removeChild(a);
                }, 66);
            }
            else {
                if (!window.open(url)) {
                    location.href = url;
                }
            }
        };
        /**
         * Downloads a file of the given name with the given contents.
         *
         * @param filename a file name
         * @param contents file contents
         * @param insertBom false to stop the BOM insertion
         */
        UtilFileDownloader.download = function (filename, contents, insertBom) {
            var blob = new Blob(insertBom !== false ? ["\ufeff", contents] : [contents], {
                type: "text/plain"
            });
            var navigator = window.navigator;
            if ("msSaveBlob" in navigator) {
                // IE10 and 11
                navigator.msSaveBlob(blob, filename);
            }
            else {
                this.downloadUrl(filename, URL.createObjectURL(blob));
            }
        };
        return UtilFileDownloader;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var toResolution = function (options) {
        var _a;
        var target = options.target;
        var resolution = options.resolution;
        if (resolution != null) {
            if (isNumber(resolution)) {
                return resolution;
            }
            else {
                var scale = target.transform.scale;
                var size = Math.max(target.width * scale.x, target.height * scale.y);
                return Math.min(1, resolution.size / size);
            }
        }
        else {
            return (_a = window.devicePixelRatio) !== null && _a !== void 0 ? _a : 1;
        }
    };
    var toScale = function (pixels, options) {
        var scale = options.scale;
        if (scale != null) {
            if (isNumber(scale)) {
                return scale;
            }
            else {
                var size = scale.size;
                return Math.min(1, size / pixels.width, size / pixels.height);
            }
        }
    };
    var toRenderer = function (options) {
        var renderer = options.renderer;
        if (renderer) {
            return renderer;
        }
        var application = options.application;
        if (application) {
            return application.getLayerBase().renderer;
        }
        var layer = options.layer || DApplications.getLayer(options.target);
        if (layer) {
            return layer.renderer;
        }
        throw new Error("No renderer / application / layer found.");
    };
    var UtilExtract = /** @class */ (function () {
        function UtilExtract() {
        }
        UtilExtract.texture = function (options) {
            var _a;
            var target = options.target;
            var resolution = toResolution(options);
            var skipUpdateTransform = (_a = options.transform) === null || _a === void 0 ? void 0 : _a.update;
            return UtilExtractor.toTexture(target, resolution, options.clear, skipUpdateTransform);
        };
        /**
         * Extracts pixels from the target.
         * This method internally creates one render texture and use that to extract pixels from the target.
         * To free the allocated render texture, please call {@link destroy()}.
         *
         * @param options an extraction options
         * @returns extracted pixels
         */
        UtilExtract.pixels = function (options) {
            var _a;
            var renderer = toRenderer(options);
            // Create a render texture
            var target = options.target;
            var scale = target.transform.scale;
            var width = Math.ceil(target.width * scale.x);
            var height = Math.ceil(target.height * scale.y);
            if (width <= 0 || height <= 0) {
                return {
                    width: width,
                    height: height,
                    array: new Uint8Array(0)
                };
            }
            var resolution = toResolution(options);
            var renderTexture = UtilExtract.WORK_RENDER_TEXTURE;
            if (renderTexture == null) {
                renderTexture = pixi_js.RenderTexture.create({
                    width: width,
                    height: height,
                    scaleMode: pixi_js.SCALE_MODES.LINEAR,
                    resolution: resolution
                });
                UtilExtract.WORK_RENDER_TEXTURE = renderTexture;
            }
            else {
                var baseTexture = renderTexture.baseTexture;
                var baseTextureWidth = baseTexture.width;
                var baseTextureHeight = baseTexture.height;
                var isWidthDirty = baseTextureWidth < width;
                var isHeightDirty = baseTextureHeight < height;
                var isResolutionDirty = renderTexture.resolution !== resolution;
                if (isResolutionDirty || isWidthDirty || isHeightDirty) {
                    if (isResolutionDirty) {
                        baseTexture.resolution = resolution;
                    }
                    renderTexture.resize(Math.max(width, baseTextureWidth), Math.max(height, baseTextureHeight), true);
                }
            }
            // Render to the render texture
            var frame = renderTexture.frame;
            if (frame.x !== 0 || frame.y !== 0 || frame.width !== width || frame.height !== height) {
                frame.x = 0;
                frame.y = 0;
                frame.width = width;
                frame.height = height;
                renderTexture.frame = frame;
            }
            var targetPosition = target.position;
            var matrix = new pixi_js.Matrix(1, 0, 0, 1, -targetPosition.x, -targetPosition.y);
            renderer.render(target, renderTexture, options.clear, matrix, (_a = options.transform) === null || _a === void 0 ? void 0 : _a.update);
            // Extract pixels
            return UtilExtractor.toPixels(renderTexture, renderer);
        };
        UtilExtract.canvas = function (options) {
            var _a, _b;
            var pixels = this.pixels(options);
            var ignorePremutipliedAlpha = (_b = (_a = options.alpha) === null || _a === void 0 ? void 0 : _a.premultiplied) === null || _b === void 0 ? void 0 : _b.ignore;
            var scale = toScale(pixels, options);
            return UtilExtractor.toCanvas(pixels, scale, ignorePremutipliedAlpha);
        };
        /**
         * Extracts Base64 data URL from the target.
         * This method internally creates a render texture and a canvas render target.
         * They are used to extract pixels from the target.
         * To free the allocated render texture and canvas render target, please call {@link destroy()}.
         *
         * @param options an extraction options
         * @returns extracted Base64 data URL
         */
        UtilExtract.base64 = function (options) {
            var _a, _b, _c;
            var pixels = this.pixels(options);
            var ignorePremutipliedAlpha = (_b = (_a = options.alpha) === null || _a === void 0 ? void 0 : _a.premultiplied) === null || _b === void 0 ? void 0 : _b.ignore;
            var scale = toScale(pixels, options);
            var canvas = ((_c = this.WORK_CANVAS) !== null && _c !== void 0 ? _c : (this.WORK_CANVAS = new UtilExtractorCanvas(pixels.width, pixels.height)));
            UtilExtractor.toCanvas(pixels, scale, ignorePremutipliedAlpha, canvas);
            var element = canvas.getElement();
            if (element != null) {
                return UtilExtractor.toBase64(element, options.format, options.quality);
            }
            return "data:,";
        };
        UtilExtract.file = function (options) {
            UtilFileDownloader.downloadUrl(options.filename, this.base64(options));
        };
        /**
         * Clears all the memories.
         */
        UtilExtract.destroy = function () {
            var texture = this.WORK_RENDER_TEXTURE;
            if (texture != null) {
                this.WORK_RENDER_TEXTURE = undefined;
                texture.destroy(true);
            }
            var canvas = this.WORK_CANVAS;
            if (canvas != null) {
                this.WORK_CANVAS = undefined;
                canvas.destroy();
            }
        };
        return UtilExtract;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDiagramSnapshot = /** @class */ (function (_super) {
        __extends(DDiagramSnapshot, _super);
        function DDiagramSnapshot(parent, options) {
            var _this = _super.call(this) || this;
            _this._parent = parent;
            var on = options === null || options === void 0 ? void 0 : options.on;
            if (on) {
                for (var name_1 in on) {
                    var handler = on[name_1];
                    if (handler) {
                        _this.on(name_1, handler);
                    }
                }
            }
            return _this;
        }
        DDiagramSnapshot.prototype.createAsUrl = function (sizeOrOptions) {
            if (sizeOrOptions == null || isNumber(sizeOrOptions)) {
                return this.create({
                    size: sizeOrOptions,
                    extractor: function (canvas) {
                        return UtilExtract.base64({ target: canvas });
                    }
                });
            }
            else {
                return this.create({
                    size: sizeOrOptions.size,
                    cleanup: sizeOrOptions.cleanup,
                    extractor: function (canvas) {
                        return UtilExtract.base64({ target: canvas });
                    }
                });
            }
        };
        DDiagramSnapshot.prototype.createAsFile = function (sizeOrFilenameOrOptions, filename) {
            if (isString(sizeOrFilenameOrOptions)) {
                this.create({
                    extractor: function (canvas) {
                        UtilExtract.file({ target: canvas, filename: sizeOrFilenameOrOptions });
                    }
                });
            }
            else if (sizeOrFilenameOrOptions === null || isNumber(sizeOrFilenameOrOptions)) {
                this.create({
                    size: sizeOrFilenameOrOptions,
                    extractor: function (canvas) {
                        UtilExtract.file({ target: canvas, filename: filename });
                    }
                });
            }
            else {
                this.create({
                    size: sizeOrFilenameOrOptions.size,
                    cleanup: sizeOrFilenameOrOptions.cleanup,
                    extractor: function (canvas) {
                        UtilExtract.file({
                            target: canvas,
                            filename: sizeOrFilenameOrOptions.filename
                        });
                    }
                });
            }
        };
        DDiagramSnapshot.prototype.toScale = function (size, canvas) {
            if (size == null) {
                return 1;
            }
            return size / DApplications.getResolution(canvas) / Math.max(canvas.width, canvas.height);
        };
        DDiagramSnapshot.prototype.toCleanupSnap = function (options) {
            if (options == null) {
                return true;
            }
            var cleanup = options.cleanup;
            if (cleanup == null || cleanup === true) {
                return true;
            }
            return cleanup !== false && cleanup.snap !== false;
        };
        DDiagramSnapshot.prototype.toCleanupBackground = function (options) {
            if (options == null) {
                return false;
            }
            var cleanup = options.cleanup;
            if (cleanup == null || cleanup === false) {
                return false;
            }
            return cleanup === true || cleanup.background === true;
        };
        DDiagramSnapshot.prototype.toCleanupReflow = function (options) {
            if (options == null) {
                return true;
            }
            var cleanup = options.cleanup;
            if (cleanup == null || cleanup === true) {
                return true;
            }
            return cleanup !== false && cleanup.reflow !== false;
        };
        DDiagramSnapshot.prototype.create = function (options) {
            var parent = this._parent;
            var canvas = parent.canvas;
            if (canvas) {
                var view = parent.view;
                var viewPosition = view.position;
                var viewScale = view.scale;
                var oldPositionX = viewPosition.x;
                var oldPositionY = viewPosition.y;
                var oldScaleX = viewScale.x;
                var oldScaleY = viewScale.y;
                var newScale = this.toScale(options.size, canvas);
                view.transform(0, 0, newScale, newScale, 0);
                // Turns off the snap grid and targets
                var container = void 0;
                if (this.toCleanupSnap(options) && "snap" in canvas) {
                    var snap = canvas.snap;
                    if (snap != null) {
                        container = snap.container;
                        if (container.renderable) {
                            container.renderable = false;
                        }
                        else {
                            container = undefined;
                        }
                    }
                }
                // Turns off the canvas snippets
                var snippet = void 0;
                if (this.toCleanupBackground(options)) {
                    snippet = canvas.snippet;
                    if (snippet.renderable) {
                        snippet.renderable = false;
                    }
                    else {
                        snippet = undefined;
                    }
                }
                // Refit & reflow
                var reflow = this.toCleanupReflow(options);
                if (reflow) {
                    var layer = DApplications.getLayer(canvas);
                    if (layer) {
                        layer.reflow();
                    }
                }
                // Extracts
                this.emit("taking", canvas, this);
                var result = options.extractor(canvas);
                this.emit("took", canvas, null, this);
                // Turn on the canvas snippets
                if (snippet) {
                    snippet.renderable = true;
                }
                // Turn on the snap grid and targets
                if (container != null) {
                    container.renderable = true;
                }
                view.transform(oldPositionX, oldPositionY, oldScaleX, oldScaleY, 0);
                return result;
            }
        };
        return DDiagramSnapshot;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDiagramBase = /** @class */ (function (_super) {
        __extends(DDiagramBase, _super);
        function DDiagramBase(options) {
            var _a;
            var _this = _super.call(this, options) || this;
            _this._serialized = null;
            _this._tileFactory = options === null || options === void 0 ? void 0 : options.tile;
            _this._controller = options === null || options === void 0 ? void 0 : options.controller;
            _this._isAmbient = (_a = options === null || options === void 0 ? void 0 : options.ambient) !== null && _a !== void 0 ? _a : _this.theme.isAmbient();
            _this._snapshot = new DDiagramSnapshot(_this, options === null || options === void 0 ? void 0 : options.snapshot);
            _this._mode = _this.toMode(options);
            return _this;
        }
        Object.defineProperty(DDiagramBase.prototype, "snapshot", {
            get: function () {
                return this._snapshot;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDiagramBase.prototype, "controller", {
            get: function () {
                return this._controller || null;
            },
            enumerable: false,
            configurable: true
        });
        DDiagramBase.prototype.set = function (serialized) {
            var _this = this;
            var oldSerialized = this._serialized;
            if (oldSerialized !== serialized) {
                if (oldSerialized) {
                    this._serialized = null;
                    var canvas = this.canvas;
                    if (canvas) {
                        this.canvas = null;
                    }
                    this.onUnset();
                }
                this._serialized = serialized;
                if (serialized) {
                    var canvas_1 = this.newCanvas(serialized);
                    var pieces_1 = serialized.pieces;
                    var mode_1 = this._mode;
                    var result = DDiagrams.toPieceData(this._controller, pieces_1, mode_1).then(function (pieceData) {
                        return _this.newLayer(serialized, canvas_1, mode_1, pieces_1, pieceData);
                    });
                    this.onSet(serialized, canvas_1);
                    this.canvas = canvas_1;
                    return result;
                }
                else {
                    return Promise.resolve(null);
                }
            }
            else {
                return Promise.resolve(this.canvas);
            }
        };
        DDiagramBase.prototype.onSet = function (serialized, canvas) {
            // DO NOTHING
        };
        DDiagramBase.prototype.newLayer = function (serialized, canvas, mode, pieces, pieceData) {
            var _this = this;
            var manager = new EShapeResourceManagerDeserialization(serialized, pieces, pieceData, mode, 0);
            var result = DDiagrams.newLayer(serialized, canvas.layer, manager).then(function (shapes) {
                return _this.initLayer(canvas, shapes);
            });
            if (this._isAmbient) {
                var background = this.toCanvasBaseBackgroundOptions(serialized, this.theme, false);
                this.background.color = background.color;
                this.background.alpha = background.alpha;
            }
            return result;
        };
        DDiagramBase.prototype.initLayer = function (canvas, shapes, mapper) {
            canvas.layer.init();
            canvas.initialize(shapes, mapper);
            DApplications.update(this);
            this.emit("ready", this);
            return canvas;
        };
        DDiagramBase.prototype.toCanvasBaseOptions = function (serialized) {
            var _a;
            var theme = this.theme;
            var isAmbient = this._isAmbient;
            return {
                name: serialized.name,
                label: serialized.label,
                width: serialized.width,
                height: serialized.height,
                category: serialized.category,
                summary: serialized.summary,
                description: serialized.description,
                background: this.toCanvasBaseBackgroundOptions(serialized, theme, isAmbient),
                border: isAmbient ? { color: null } : undefined,
                outline: isAmbient ? { color: null } : undefined,
                shadow: isAmbient ? null : theme.getCanvasShadow(),
                tile: {
                    factory: this._tileFactory,
                    mapping: (_a = serialized.tile) === null || _a === void 0 ? void 0 : _a.mapping
                },
                ambient: isAmbient
            };
        };
        DDiagramBase.prototype.toCanvasBaseBackgroundOptions = function (serialized, theme, isAmbient) {
            var _a, _b;
            if (isAmbient) {
                return {
                    color: null
                };
            }
            var background = serialized.background;
            return {
                color: (_a = background === null || background === void 0 ? void 0 : background.color) !== null && _a !== void 0 ? _a : theme.getCanvasBackgroundColor(),
                alpha: (_b = background === null || background === void 0 ? void 0 : background.alpha) !== null && _b !== void 0 ? _b : theme.getCanvasBackgroundAlpha()
            };
        };
        DDiagramBase.prototype.onUnset = function () {
            // DO NOTHING
        };
        DDiagramBase.prototype.get = function () {
            return this._serialized;
        };
        Object.defineProperty(DDiagramBase.prototype, "layer", {
            get: function () {
                var canvas = this.canvas;
                if (canvas) {
                    return canvas.layer.active;
                }
                return null;
            },
            enumerable: false,
            configurable: true
        });
        DDiagramBase.prototype.getType = function () {
            return "DDiagramBase";
        };
        return DDiagramBase;
    }(DCanvasContainer));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DCanvas = /** @class */ (function (_super) {
        __extends(DCanvas, _super);
        function DCanvas() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DCanvas.prototype.getType = function () {
            return "DCanvas";
        };
        return DCanvas;
    }(DBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDiagramCanvasEditorBackground = /** @class */ (function () {
        function DDiagramCanvasEditorBackground(target, base) {
            this._target = target;
            this._base = base;
        }
        DDiagramCanvasEditorBackground.prototype.getTheme = function () {
            return this._target.getTheme();
        };
        DDiagramCanvasEditorBackground.prototype.setTheme = function (theme) {
            this._target.setTheme(theme);
        };
        DDiagramCanvasEditorBackground.prototype.getBaseColor = function () {
            return this._base;
        };
        DDiagramCanvasEditorBackground.prototype.setBaseColor = function (baseColor) {
            this._base = baseColor;
        };
        DDiagramCanvasEditorBackground.prototype.getColor = function (state) {
            var target = this._target;
            var base = this._base;
            var color = target.getColor(state);
            if (base != null) {
                if (color != null) {
                    return UtilRgb.blend(base, color, target.getAlpha(state));
                }
                return base;
            }
            return color;
        };
        Object.defineProperty(DDiagramCanvasEditorBackground.prototype, "color", {
            get: function () {
                return this._target.color;
            },
            set: function (color) {
                this._target.color = color;
            },
            enumerable: false,
            configurable: true
        });
        DDiagramCanvasEditorBackground.prototype.getAlpha = function (state) {
            var base = this._base;
            if (base != null) {
                return 1;
            }
            return this._target.getAlpha(state);
        };
        Object.defineProperty(DDiagramCanvasEditorBackground.prototype, "alpha", {
            get: function () {
                return this._target.alpha;
            },
            set: function (alpha) {
                this._target.alpha = alpha;
            },
            enumerable: false,
            configurable: true
        });
        return DDiagramCanvasEditorBackground;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDiagramCanvasTileMappingPointImpl = /** @class */ (function (_super) {
        __extends(DDiagramCanvasTileMappingPointImpl, _super);
        function DDiagramCanvasTileMappingPointImpl() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(DDiagramCanvasTileMappingPointImpl.prototype, "lon", {
            get: function () {
                return this.x;
            },
            set: function (lon) {
                this.x = lon;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDiagramCanvasTileMappingPointImpl.prototype, "lat", {
            get: function () {
                return this.y;
            },
            set: function (lat) {
                this.y = lat;
            },
            enumerable: false,
            configurable: true
        });
        DDiagramCanvasTileMappingPointImpl.prototype.toObject = function () {
            return {
                lon: this.x,
                lat: this.y
            };
        };
        return DDiagramCanvasTileMappingPointImpl;
    }(pixi_js.ObservablePoint));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDiagramCanvasTileMappingImpl = /** @class */ (function () {
        function DDiagramCanvasTileMappingImpl(cb, mappingOrEnable, lon0, lat0, lon1, lat1) {
            this._cb = cb;
            if (mappingOrEnable === true || mappingOrEnable === false) {
                this._enable = mappingOrEnable;
                this._from = new DDiagramCanvasTileMappingPointImpl(cb, null, lon0, lat0);
                this._to = new DDiagramCanvasTileMappingPointImpl(cb, null, lon1, lat1);
            }
            else if (mappingOrEnable != null) {
                this._enable = mappingOrEnable.enable;
                var from = mappingOrEnable.from;
                var to = mappingOrEnable.to;
                this._from = new DDiagramCanvasTileMappingPointImpl(cb, null, from.lon, from.lat);
                this._to = new DDiagramCanvasTileMappingPointImpl(cb, null, to.lon, to.lat);
            }
            else {
                this._enable = false;
                this._from = new DDiagramCanvasTileMappingPointImpl(cb, null, -180, +85.05112877980659);
                this._to = new DDiagramCanvasTileMappingPointImpl(cb, null, +180, -85.05112877980659);
            }
        }
        Object.defineProperty(DDiagramCanvasTileMappingImpl.prototype, "enable", {
            get: function () {
                return this._enable;
            },
            set: function (enable) {
                if (this._enable !== enable) {
                    this._enable = enable;
                    this._cb();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDiagramCanvasTileMappingImpl.prototype, "from", {
            get: function () {
                return this._from;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDiagramCanvasTileMappingImpl.prototype, "to", {
            get: function () {
                return this._to;
            },
            enumerable: false,
            configurable: true
        });
        DDiagramCanvasTileMappingImpl.prototype.serialize = function () {
            return {
                enable: this._enable,
                from: this._from.toObject(),
                to: this._to.toObject()
            };
        };
        return DDiagramCanvasTileMappingImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDiagramCanvasTile = /** @class */ (function () {
        function DDiagramCanvasTile(canvas, options) {
            var _this = this;
            this._canvas = canvas;
            this._factory = options === null || options === void 0 ? void 0 : options.factory;
            this._mapping = new DDiagramCanvasTileMappingImpl(function () {
                _this.onMappingChange();
            }, options === null || options === void 0 ? void 0 : options.mapping);
        }
        DDiagramCanvasTile.prototype.init = function () {
            this.onMappingChange();
        };
        DDiagramCanvasTile.prototype.onMappingChange = function () {
            var factory = this._factory;
            if (factory) {
                var mapping = this._mapping;
                if (mapping.enable) {
                    var pyramid = this._pyramid;
                    if (pyramid) {
                        pyramid.mapping = mapping;
                    }
                    else {
                        this._pyramid = factory(this._canvas).fit();
                    }
                }
                else {
                    var pyramid = this._pyramid;
                    if (pyramid) {
                        this._pyramid = undefined;
                        pyramid.destroy();
                    }
                }
            }
        };
        Object.defineProperty(DDiagramCanvasTile.prototype, "pyramid", {
            get: function () {
                return this._pyramid;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDiagramCanvasTile.prototype, "factory", {
            get: function () {
                return this._factory;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDiagramCanvasTile.prototype, "mapping", {
            get: function () {
                return this._mapping;
            },
            enumerable: false,
            configurable: true
        });
        DDiagramCanvasTile.prototype.serialize = function () {
            return {
                mapping: this._mapping.serialize()
            };
        };
        DDiagramCanvasTile.prototype.destroy = function () {
            var pyramid = this._pyramid;
            if (pyramid != null) {
                this._pyramid = undefined;
                pyramid.destroy();
            }
        };
        return DDiagramCanvasTile;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeRuntimeImpl = /** @class */ (function () {
        function EShapeRuntimeImpl(shape) {
            var transform = shape.transform;
            var position = transform.position;
            this.x = position.x;
            this.y = position.y;
            var size = shape.size;
            this.sizeX = size.x;
            this.sizeY = size.y;
            this.rotation = transform.rotation;
            this.actions = [];
            this.fill = shape.fill.toObject();
            this.stroke = shape.stroke.toObject();
            this.text = shape.text.toObject();
            this.cursor = shape.cursor;
            this.reset = EShapeRuntimeReset.NONE;
            this.written = EShapeRuntimeReset.NONE;
            this.effect = -1;
            this.isStateChanged = false;
            this.interactive = false;
        }
        EShapeRuntimeImpl.prototype.initialize = function (shape) {
            shape.lock(EShapeLockPart.UPLOADED);
            var actions = this.actions;
            for (var i = 0, imax = actions.length; i < imax; ++i) {
                actions[i].initialize(shape, this);
            }
            shape.unlock(EShapeLockPart.UPLOADED, true);
        };
        EShapeRuntimeImpl.prototype.isActionable = function () {
            return 0 < this.actions.length;
        };
        EShapeRuntimeImpl.prototype.onResize = function (shape) {
            // Actions
            var actions = this.actions;
            for (var i = 0, imax = actions.length; i < imax; ++i) {
                actions[i].onResize(shape, this);
            }
        };
        EShapeRuntimeImpl.prototype.onClick = function (shape, e) {
            // State
            var state = shape.state;
            if (state.isActionable) {
                state.isClicked = true;
            }
            // Actions
            var actions = this.actions;
            for (var i = 0, imax = actions.length; i < imax; ++i) {
                actions[i].onClick(shape, this, e);
            }
        };
        EShapeRuntimeImpl.prototype.onDblClick = function (shape, e, interactionManager) {
            // State
            var state = shape.state;
            if (state.isActionable) {
                state.isDblClicked = true;
            }
            // Actions
            var actions = this.actions;
            for (var i = 0, imax = actions.length; i < imax; ++i) {
                actions[i].onDblClick(shape, this, e, interactionManager);
            }
            // Done
            return false;
        };
        EShapeRuntimeImpl.prototype.onOver = function (shape, e) {
            var state = shape.state;
            if (!state.isHovered) {
                // State
                state.isHovered = true;
                // Actions
                var actions = this.actions;
                for (var i = 0, imax = actions.length; i < imax; ++i) {
                    actions[i].onOver(shape, this, e);
                }
            }
        };
        EShapeRuntimeImpl.prototype.onOut = function (shape, e) {
            var state = shape.state;
            if (state.isHovered) {
                // State
                shape.state.isHovered = false;
                // Actions
                var actions = this.actions;
                for (var i = 0, imax = actions.length; i < imax; ++i) {
                    actions[i].onOut(shape, this, e);
                }
            }
        };
        EShapeRuntimeImpl.prototype.onDown = function (shape, e) {
            // Actions
            var actions = this.actions;
            for (var i = 0, imax = actions.length; i < imax; ++i) {
                actions[i].onDowning(shape, this, e);
            }
            var state = shape.state;
            if (!state.isDown) {
                if (!state.isPressed) {
                    // State
                    state.addAll(EShapeState.DOWN, DBaseState.PRESSED);
                    // Focus
                    var layer = DApplications.getLayer(shape);
                    if (layer) {
                        // Focus
                        var focusController = layer.getFocusController();
                        focusController.focus(focusController.findParent(shape));
                    }
                    // Actions
                    for (var i = 0, imax = actions.length; i < imax; ++i) {
                        var action = actions[i];
                        action.onDown(shape, this, e);
                        action.onPressed(shape, this, e);
                    }
                }
                else {
                    // State
                    state.isDown = true;
                    // Focus
                    var layer = DApplications.getLayer(shape);
                    if (layer) {
                        var focusController = layer.getFocusController();
                        focusController.focus(focusController.findParent(shape));
                    }
                    // Actions
                    for (var i = 0, imax = actions.length; i < imax; ++i) {
                        actions[i].onDown(shape, this, e);
                    }
                }
            }
        };
        EShapeRuntimeImpl.prototype.onUp = function (shape, e) {
            var state = shape.state;
            if (!state.isUp) {
                if (state.isPressed) {
                    // State
                    state.set(EShapeState.UP, DBaseState.PRESSED);
                    // Actions
                    var actions = this.actions;
                    for (var i = 0, imax = actions.length; i < imax; ++i) {
                        var action = actions[i];
                        action.onUp(shape, this, e);
                        action.onUnpressed(shape, this, e);
                    }
                }
                else {
                    // State
                    state.isUp = true;
                    // Actions
                    var actions = this.actions;
                    for (var i = 0, imax = actions.length; i < imax; ++i) {
                        actions[i].onUp(shape, this, e);
                    }
                }
            }
        };
        EShapeRuntimeImpl.prototype.onUpOutside = function (shape, e) {
            var state = shape.state;
            if (state.isPressed) {
                // State
                state.set(EShapeState.UP_OUTSIDE, DBaseState.PRESSED);
                // Actions
                var actions = this.actions;
                for (var i = 0, imax = actions.length; i < imax; ++i) {
                    var action = actions[i];
                    action.onUpOutside(shape, this, e);
                    action.onUnpressed(shape, this, e);
                }
            }
            else {
                // State
                state.isUpOutside = true;
                // Actions
                var actions = this.actions;
                for (var i = 0, imax = actions.length; i < imax; ++i) {
                    actions[i].onUpOutside(shape, this, e);
                }
            }
        };
        EShapeRuntimeImpl.prototype.onMove = function (shape, e) {
            // Actions
            var actions = this.actions;
            for (var i = 0, imax = actions.length; i < imax; ++i) {
                actions[i].onMove(shape, this, e);
            }
        };
        EShapeRuntimeImpl.prototype.onKeyDown = function (shape, e) {
            // State
            if (UtilKeyboardEvent.isActivateKey(e)) {
                this.onDown(shape, e);
            }
            // Actions
            var actions = this.actions;
            for (var i = 0, imax = actions.length; i < imax; ++i) {
                actions[i].onKeyDown(shape, this, e);
            }
            // Done
            return false;
        };
        EShapeRuntimeImpl.prototype.onKeyUp = function (shape, e) {
            // State
            if (UtilKeyboardEvent.isActivateKey(e)) {
                var state = shape.state;
                if (state.isPressed) {
                    var wasUp = state.isUp;
                    this.onUp(shape, e);
                    if (!wasUp && state.isUp) {
                        this.onClick(shape, e);
                    }
                }
            }
            // Actions
            var actions = this.actions;
            for (var i = 0, imax = actions.length; i < imax; ++i) {
                actions[i].onKeyUp(shape, this, e);
            }
            // Done
            return false;
        };
        EShapeRuntimeImpl.prototype.onStateChange = function (shape, newState, oldState) {
            this.isStateChanged = true;
            DApplications.update(shape);
            if (newState.isFocused) {
                if (!oldState.isFocused) {
                    this.onFocus(shape);
                }
            }
            else if (oldState.isFocused) {
                this.onBlur(shape);
            }
        };
        EShapeRuntimeImpl.prototype.onFocus = function (shape) {
            // Actions
            var actions = this.actions;
            for (var i = 0, imax = actions.length; i < imax; ++i) {
                actions[i].onFocus(shape, this);
            }
        };
        EShapeRuntimeImpl.prototype.onBlur = function (shape) {
            // Actions
            var actions = this.actions;
            for (var i = 0, imax = actions.length; i < imax; ++i) {
                actions[i].onBlur(shape, this);
            }
        };
        EShapeRuntimeImpl.prototype.onRightClick = function (shape, e) {
            // State
            var state = shape.state;
            if (state.isActionable) {
                state.isRightClicked = true;
            }
            // Actions
            var actions = this.actions;
            for (var i = 0, imax = actions.length; i < imax; ++i) {
                actions[i].onRightClick(shape, this, e);
            }
        };
        EShapeRuntimeImpl.prototype.onRightDown = function (shape, e) {
            // Actions
            var actions = this.actions;
            for (var i = 0, imax = actions.length; i < imax; ++i) {
                actions[i].onRightDowning(shape, this, e);
            }
            var state = shape.state;
            if (!state.isRightDown) {
                if (state.isRightPressed) {
                    // State
                    state.addAll(EShapeState.RIGHT_DOWN, EShapeState.RIGHT_PRESSED);
                    // Focus
                    var layer = DApplications.getLayer(shape);
                    if (layer) {
                        // Focus
                        var focusController = layer.getFocusController();
                        focusController.focus(focusController.findParent(shape));
                    }
                    // Actions
                    for (var i = 0, imax = actions.length; i < imax; ++i) {
                        var action = actions[i];
                        action.onRightDown(shape, this, e);
                        action.onRightPressed(shape, this, e);
                    }
                }
                else {
                    // State
                    state.isRightDown = false;
                    // Focus
                    var layer = DApplications.getLayer(shape);
                    if (layer) {
                        var focusController = layer.getFocusController();
                        focusController.focus(focusController.findParent(shape));
                    }
                    // Actions
                    for (var i = 0, imax = actions.length; i < imax; ++i) {
                        actions[i].onRightDown(shape, this, e);
                    }
                }
            }
        };
        EShapeRuntimeImpl.prototype.onRightUp = function (shape, e) {
            var state = shape.state;
            if (!state.isRightUp) {
                if (state.isRightPressed) {
                    // State
                    state.set(EShapeState.RIGHT_UP, EShapeState.RIGHT_PRESSED);
                    // Actions
                    var actions = this.actions;
                    for (var i = 0, imax = actions.length; i < imax; ++i) {
                        var action = actions[i];
                        action.onRightUp(shape, this, e);
                        action.onRightUnpressed(shape, this, e);
                    }
                }
                else {
                    // State
                    state.isRightUp = true;
                    // Actions
                    var actions = this.actions;
                    for (var i = 0, imax = actions.length; i < imax; ++i) {
                        actions[i].onRightUp(shape, this, e);
                    }
                }
            }
        };
        EShapeRuntimeImpl.prototype.onRightUpOutside = function (shape, e) {
            var state = shape.state;
            if (state.isRightPressed) {
                // State
                state.set(EShapeState.RIGHT_UP_OUTSIDE, EShapeState.RIGHT_PRESSED);
                // Actions
                var actions = this.actions;
                for (var i = 0, imax = actions.length; i < imax; ++i) {
                    var action = actions[i];
                    action.onRightUpOutside(shape, this, e);
                    action.onRightUnpressed(shape, this, e);
                }
            }
            else {
                // State
                state.isRightUpOutside = true;
                // Actions
                var actions = this.actions;
                for (var i = 0, imax = actions.length; i < imax; ++i) {
                    actions[i].onRightUpOutside(shape, this, e);
                }
            }
        };
        EShapeRuntimeImpl.prototype.update = function (shape, time) {
            var data = shape.data;
            var effect = this.effect;
            var isEffectTimeUp = 0 <= effect && effect <= time;
            if (data.isChanged || this.isStateChanged || isEffectTimeUp) {
                this.isStateChanged = false;
                data.isChanged = false;
                if (isEffectTimeUp) {
                    this.effect = -1;
                }
                shape.lock(EShapeLockPart.UPLOADED);
                this.onUpdate(shape, time);
                shape.unlock(EShapeLockPart.UPLOADED, true);
                var wasStateChanged = this.isStateChanged;
                shape.state.removeAll(EShapeRuntimeImpl.TRANSIENT_STATES);
                this.isStateChanged = wasStateChanged;
            }
        };
        EShapeRuntimeImpl.prototype.onRender = function (shape, time, renderer) {
            var actions = this.actions;
            for (var i = 0, imax = actions.length; i < imax; ++i) {
                actions[i].onRender(shape, this, time, renderer);
            }
            this.update(shape, time);
        };
        EShapeRuntimeImpl.prototype.onUpdate = function (shape, time) {
            var actions = this.actions;
            if (0 < actions.length) {
                this.written = EShapeRuntimeReset.NONE;
                for (var i = 0, imax = actions.length; i < imax; ++i) {
                    actions[i].execute(shape, this, time);
                }
                this.doReset(shape);
            }
        };
        EShapeRuntimeImpl.prototype.doReset = function (shape) {
            var target = ~this.written & this.reset;
            if (target !== EShapeRuntimeReset.NONE) {
                if (target & EShapeRuntimeReset.POSITION_X) {
                    shape.transform.position.x = this.x;
                }
                if (target & EShapeRuntimeReset.POSITION_Y) {
                    shape.transform.position.y = this.y;
                }
                if (target & EShapeRuntimeReset.VISIBILITY) {
                    shape.visible = true;
                }
                if (target & EShapeRuntimeReset.COLOR_FILL) {
                    var fill = this.fill;
                    shape.fill.set(undefined, fill.color, fill.alpha);
                }
                if (target & EShapeRuntimeReset.COLOR_STROKE) {
                    var stroke = this.stroke;
                    shape.stroke.set(undefined, stroke.color, stroke.alpha);
                }
                if (target & EShapeRuntimeReset.COLOR_TEXT) {
                    var text = this.text;
                    shape.text.set(undefined, text.color, text.alpha);
                }
                if (target & EShapeRuntimeReset.COLOR_TEXT_OUTLINE) {
                    var outline = this.text.outline;
                    shape.text.outline.set(undefined, outline.color, outline.alpha);
                }
                if (target & EShapeRuntimeReset.HEIGHT) {
                    shape.size.y = this.sizeY;
                }
                if (target & EShapeRuntimeReset.WIDTH) {
                    shape.size.x = this.sizeX;
                }
                if (target & EShapeRuntimeReset.ROTATION) {
                    shape.transform.rotation = this.rotation;
                }
                if (target & EShapeRuntimeReset.TEXT) {
                    shape.text.value = this.text.value;
                }
                if (target & EShapeRuntimeReset.CURSOR) {
                    shape.cursor = this.cursor;
                }
            }
        };
        EShapeRuntimeImpl.TRANSIENT_STATES = [
            EShapeState.CLICKED,
            EShapeState.DBL_CLICKED,
            EShapeState.DOWN,
            EShapeState.UP,
            EShapeState.UP_OUTSIDE,
            EShapeState.RIGHT_CLICKED,
            EShapeState.RIGHT_DOWN,
            EShapeState.RIGHT_UP,
            EShapeState.RIGHT_UP_OUTSIDE,
            EShapeState.ACTIVATED,
            EShapeState.DEACTIVATED
        ];
        return EShapeRuntimeImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeRectangle = /** @class */ (function (_super) {
        __extends(EShapeRectangle, _super);
        function EShapeRectangle(type) {
            if (type === void 0) { type = EShapeType.RECTANGLE; }
            return _super.call(this, type) || this;
        }
        EShapeRectangle.prototype.clone = function () {
            return new EShapeRectangle(this.type).copy(this);
        };
        EShapeRectangle.prototype.containsAbs = function (x, y, ax, ay, sw, ss, sa) {
            if (_super.prototype.containsAbsBBox.call(this, x, y, ax, ay)) {
                return hitTestRectangle(this, x, y, ax, ay, sw, ss);
            }
            return false;
        };
        return EShapeRectangle;
    }(EShapePrimitive));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeRectanglePivoted = /** @class */ (function (_super) {
        __extends(EShapeRectanglePivoted, _super);
        function EShapeRectanglePivoted(type) {
            if (type === void 0) { type = EShapeType.RECTANGLE_PIVOTED; }
            return _super.call(this, type) || this;
        }
        EShapeRectanglePivoted.prototype.toHitTestData = function (x, y) {
            var result = _super.prototype.toHitTestData.call(this, x, y);
            result.x -= result.width;
            result.y -= result.height;
            return result;
        };
        return EShapeRectanglePivoted;
    }(EShapeRectangle));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDiagramLayer = /** @class */ (function (_super) {
        __extends(DDiagramLayer, _super);
        function DDiagramLayer(name) {
            var _this = _super.call(this) || this;
            _this.name = name;
            _this.interactive = false;
            _this.reference = 0;
            var shape = _this.newShape();
            shape.parent = _this;
            _this._shape = shape;
            _this.interactives = [];
            return _this;
        }
        Object.defineProperty(DDiagramLayer.prototype, "width", {
            get: function () {
                return this._shape.size.x;
            },
            set: function (width) {
                this._shape.size.x = width;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDiagramLayer.prototype, "height", {
            get: function () {
                return this._shape.size.y;
            },
            set: function (height) {
                this._shape.size.y = height;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDiagramLayer.prototype, "background", {
            get: function () {
                return this._shape.fill;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDiagramLayer.prototype, "state", {
            get: function () {
                return this._shape.state;
            },
            enumerable: false,
            configurable: true
        });
        DDiagramLayer.prototype.newShape = function () {
            var result = new EShapeRectanglePivoted();
            result.fill.set(false, 0xffffff, 1);
            result.stroke.set(false);
            result.state.add(EShapeLayerState.INTERACTIVE);
            return result;
        };
        DDiagramLayer.prototype.initialize = function (actionables) {
            var interactives = this.interactives;
            var shape = this._shape;
            var isInteractive = shape.state.is(EShapeLayerState.INTERACTIVE);
            var isDraggable = shape.state.is(EShapeLayerState.DRAGGABLE);
            var isPinchable = shape.state.is(EShapeLayerState.PINCHABLE);
            if (isDraggable || isPinchable) {
                var runtime = new EShapeRuntimeImpl(shape);
                shape.runtime = runtime;
                var gestureType = (isDraggable
                    ? EShapeActionValueGestureOperationType.DRAG
                    : EShapeActionValueGestureOperationType.NONE) |
                    (isPinchable
                        ? EShapeActionValueGestureOperationType.PINCH
                        : EShapeActionValueGestureOperationType.NONE);
                runtime.actions.push(new EShapeActionValueGesture("", EShapeActionValueGestureType.LAYER, gestureType).toRuntime());
                actionables.push(shape);
                runtime.initialize(shape);
            }
            if (isInteractive || isDraggable || isPinchable) {
                shape.interactive = true;
                interactives.push(shape);
            }
            this.doInitialize(this.children, interactives);
        };
        DDiagramLayer.prototype.doInitialize = function (shapes, interactives) {
            for (var i = 0, imax = shapes.length; i < imax; ++i) {
                var shape = shapes[i];
                var runtime = shape.runtime;
                if (runtime) {
                    // Interactives
                    if (shape.interactive || runtime.interactive) {
                        interactives.push(shape);
                    }
                    else {
                        var cursor = shape.cursor;
                        if (cursor != null && 0 < cursor.length) {
                            interactives.push(shape);
                        }
                    }
                }
                // Children
                var children = shape.children;
                if (0 < children.length) {
                    this.doInitialize(children, interactives);
                }
            }
        };
        DDiagramLayer.prototype.update = function (time) {
            this.doUpdate(this.children, time);
        };
        DDiagramLayer.prototype.doUpdate = function (shapes, time) {
            for (var i = 0, imax = shapes.length; i < imax; ++i) {
                var shape = shapes[i];
                shape.update(time);
                // Children
                var children = shape.children;
                if (0 < children.length) {
                    this.doUpdate(children, time);
                }
            }
        };
        DDiagramLayer.prototype.hitTestInteractives = function (global) {
            var local = this._work;
            var interactives = this.interactives;
            for (var i = interactives.length - 1; 0 <= i; --i) {
                var interactive = interactives[i];
                if (interactive.visible) {
                    interactive.toLocal(global, undefined, local);
                    if (interactive.contains(local.x, local.y) != null) {
                        return interactive;
                    }
                }
            }
            return null;
        };
        DDiagramLayer.prototype.addUuid = function (manager) {
            var children = this.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                children[i].addUuid(manager);
            }
        };
        DDiagramLayer.prototype.updateUuid = function (manager) {
            var children = this.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                children[i].updateUuid(manager);
            }
        };
        DDiagramLayer.prototype.destroy = function () {
            if (!this._destroyed) {
                var children = this.children;
                for (var i = children.length - 1; 0 <= i; --i) {
                    children[i].destroy();
                }
                children.length = 0;
                _super.prototype.destroy.call(this);
            }
        };
        DDiagramLayer.prototype.serialize = function (layer, manager, items) {
            var children = this.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                var shape_1 = children[i];
                var item = shape_1.serialize(manager);
                item[16] = layer;
                items.push(item);
            }
            var shape = this._shape;
            var nameId = manager.addResource(this.name || "");
            var visible = (this.visible ? 1 : 0) | (shape.state.is(EShapeLayerState.INVISIBLE) ? 0 : 2);
            var position = this.position;
            var size = shape.size;
            var fill = shape.fill.serialize(manager);
            var isInteractive = shape.state.is(EShapeLayerState.INTERACTIVE) ? 1 : 0;
            var isDraggable = shape.state.is(EShapeLayerState.DRAGGABLE) ? 2 : 0;
            var isPinchable = shape.state.is(EShapeLayerState.PINCHABLE) ? 4 : 0;
            return [
                nameId,
                visible,
                position.x,
                position.y,
                size.x,
                size.y,
                fill,
                isInteractive | isDraggable | isPinchable
            ];
        };
        DDiagramLayer.deserialize = function (serialized, manager, width, height) {
            var _a, _b, _c;
            var result = new DDiagramLayer(this.deserializeName(serialized[0], manager));
            var shape = result._shape;
            var visibility = serialized[1];
            if (visibility != null) {
                var isEditorMode = manager.mode !== EShapeResourceManagerDeserializationMode.VIEWER;
                if (isEditorMode && !(visibility & 0x1)) {
                    result.visible = false;
                }
                if (!(visibility & 0x2)) {
                    shape.state.add(EShapeLayerState.INVISIBLE);
                    if (!isEditorMode) {
                        result.visible = false;
                    }
                }
            }
            var positionX = serialized[2];
            var positionY = serialized[3];
            result.position.set(positionX, positionY);
            var sizeX = (_a = serialized[4]) !== null && _a !== void 0 ? _a : width;
            var sizeY = (_b = serialized[5]) !== null && _b !== void 0 ? _b : height;
            shape.size.set(sizeX, sizeY);
            var fillId = serialized[6];
            if (fillId != null) {
                shape.fill.deserialize(fillId, manager);
            }
            var state = (_c = serialized[7]) !== null && _c !== void 0 ? _c : 1;
            shape.state.set(EShapeLayerState.INTERACTIVE, !!(state & 0x1));
            shape.state.set(EShapeLayerState.DRAGGABLE, !!(state & 0x2));
            shape.state.set(EShapeLayerState.PINCHABLE, !!(state & 0x4));
            return result;
        };
        DDiagramLayer.deserializeName = function (target, manager) {
            if (isString(target)) {
                return target;
            }
            else {
                var resources = manager.resources;
                if (0 <= target && target <= resources.length) {
                    return resources[target];
                }
                return "";
            }
        };
        return DDiagramLayer;
    }(EShapeContainer));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDiagramLayerContainer = /** @class */ (function (_super) {
        __extends(DDiagramLayerContainer, _super);
        function DDiagramLayerContainer(width, height) {
            var _this = _super.call(this) || this;
            _this._active = null;
            _this._width = width;
            _this._height = height;
            _this.interactive = false;
            _this.interactiveChildren = false;
            return _this;
        }
        DDiagramLayerContainer.prototype.init = function () {
            if (this._active == null) {
                var children = this.children;
                var childrenLength = children.length;
                if (0 < childrenLength) {
                    this._active = children[childrenLength - 1];
                }
            }
        };
        Object.defineProperty(DDiagramLayerContainer.prototype, "active", {
            get: function () {
                return this._active;
            },
            set: function (layer) {
                if (this._active !== layer && (layer == null || 0 <= this.children.indexOf(layer))) {
                    this._active = layer;
                    this.onLayerChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        DDiagramLayerContainer.prototype.create = function (name, activate) {
            var result = new DDiagramLayer(name);
            this.attach(result, activate);
            return result;
        };
        /**
         * Adds the specified layer and activates it if the `activate` is true.
         *
         * @param layer
         * @param activate
         */
        DDiagramLayerContainer.prototype.attach = function (layer, activate) {
            this.addChild(layer);
            if (activate === true) {
                this._active = layer;
            }
            this.onLayerChange();
            DApplications.update(this);
        };
        DDiagramLayerContainer.prototype.attachAt = function (layer, index, activate) {
            this.addChildAt(layer, index);
            if (activate === true) {
                this._active = layer;
            }
            this.onLayerChange();
            DApplications.update(this);
        };
        /**
         * Removes the specified layer from this container and activates the specified layer.
         * This method does not destroy the secified layer.
         *
         * @param layer
         */
        DDiagramLayerContainer.prototype.detach = function (layer, active) {
            var children = this.children;
            var index = children.indexOf(layer);
            if (0 <= index) {
                this._active = active;
                children.splice(index, 1);
                layer.parent = undefined;
                this.onLayerChange();
                DApplications.update(this);
            }
        };
        /**
         * Removes the specified layer and activate the next layer.
         * This method does not destroy the specified layer.
         *
         * @param layer
         * @param activateNext
         */
        DDiagramLayerContainer.prototype.delete = function (layer, activateNext) {
            var children = this.children;
            var index = children.indexOf(layer);
            if (0 <= index) {
                children.splice(index, 1);
                layer.parent = undefined;
                if (this._active === layer) {
                    if (activateNext === true) {
                        if (index < children.length) {
                            this._active = children[index];
                        }
                        else if (0 < children.length) {
                            this._active = children[index - 1];
                        }
                        else {
                            this._active = null;
                        }
                    }
                    else {
                        this._active = null;
                    }
                }
                this.onLayerChange();
                DApplications.update(this);
            }
            return index;
        };
        DDiagramLayerContainer.prototype.get = function (index) {
            var child = this.children[index];
            if (child != null) {
                return child;
            }
            return null;
        };
        DDiagramLayerContainer.prototype.clear = function () {
            var children = this.children;
            if (0 < children.length) {
                for (var i = children.length - 1; 0 <= i; --i) {
                    var child = children[i];
                    child.parent = null;
                    child.destroy();
                }
                children.length = 0;
                this.onLayerChange();
                DApplications.update(this);
            }
        };
        DDiagramLayerContainer.prototype.destroy = function () {
            if (!this._destroyed) {
                this.clear();
                _super.prototype.destroy.call(this);
            }
        };
        DDiagramLayerContainer.prototype.size = function () {
            return this.children.length;
        };
        DDiagramLayerContainer.prototype.onLayerChange = function () {
            this.emit("change", this);
        };
        DDiagramLayerContainer.prototype.serialize = function (manager, items) {
            var result = [];
            var children = this.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                children[i].addUuid(manager);
            }
            for (var i = 0, imax = children.length; i < imax; ++i) {
                children[i].updateUuid(manager);
            }
            for (var i = 0, imax = children.length; i < imax; ++i) {
                result.push(children[i].serialize(i, manager, items));
            }
            return result;
        };
        DDiagramLayerContainer.prototype.deserialize = function (serializedLayers, manager) {
            var serializedLayersLength = serializedLayers.length;
            if (0 < serializedLayersLength) {
                var width = this._width;
                var height = this._height;
                for (var i = 0; i < serializedLayersLength; ++i) {
                    this.addChild(DDiagramLayer.deserialize(serializedLayers[i], manager, width, height));
                }
                this.onLayerChange();
                DApplications.update(this);
            }
        };
        return DDiagramLayerContainer;
    }(pixi_js.Container));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDiagramCanvasBase = /** @class */ (function (_super) {
        __extends(DDiagramCanvasBase, _super);
        function DDiagramCanvasBase(options) {
            var _a, _b, _c, _d;
            var _this = _super.call(this, options) || this;
            // Background
            var theme = _this.theme;
            if (!_this.isAmbient(theme, options)) {
                _this._background = new DDiagramCanvasEditorBackground(_this._background, _this.toBackgroundBase(theme, options));
            }
            // Layer
            var layer = new DDiagramLayerContainer(_this.width, _this.height);
            _this._layer = layer;
            _this.addChild(layer);
            // Label, Category, Summary and Description
            if (options != null) {
                _this._label = (_a = options.label) !== null && _a !== void 0 ? _a : "";
                _this._category = (_b = options.category) !== null && _b !== void 0 ? _b : null;
                _this._summary = (_c = options.summary) !== null && _c !== void 0 ? _c : "";
                _this._description = (_d = options.description) !== null && _d !== void 0 ? _d : "";
            }
            else {
                _this._label = "";
                _this._category = null;
                _this._summary = "";
                _this._description = "";
            }
            // Tile
            var tile = new DDiagramCanvasTile(_this, options === null || options === void 0 ? void 0 : options.tile);
            _this._tile = tile;
            tile.init();
            // Local bounds limit
            _this._localBoundsLimit = theme.getLocalBoundsLimit();
            return _this;
        }
        DDiagramCanvasBase.prototype.isAmbient = function (theme, options) {
            var _a;
            return (_a = options === null || options === void 0 ? void 0 : options.ambient) !== null && _a !== void 0 ? _a : theme.isAmbient();
        };
        DDiagramCanvasBase.prototype.toBackgroundBase = function (theme, options) {
            var _a, _b;
            return (_b = (_a = options === null || options === void 0 ? void 0 : options.background) === null || _a === void 0 ? void 0 : _a.base) !== null && _b !== void 0 ? _b : theme.getBackgroundBase();
        };
        Object.defineProperty(DDiagramCanvasBase.prototype, "label", {
            get: function () {
                return this._label;
            },
            set: function (label) {
                this._label = label;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDiagramCanvasBase.prototype, "category", {
            get: function () {
                return this._category;
            },
            set: function (category) {
                this._category = category;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDiagramCanvasBase.prototype, "summary", {
            get: function () {
                return this._summary;
            },
            set: function (summary) {
                this._summary = summary;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDiagramCanvasBase.prototype, "description", {
            get: function () {
                return this._description;
            },
            set: function (description) {
                this._description = description;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDiagramCanvasBase.prototype, "tile", {
            get: function () {
                return this._tile;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDiagramCanvasBase.prototype, "layer", {
            get: function () {
                return this._layer;
            },
            enumerable: false,
            configurable: true
        });
        DDiagramCanvasBase.prototype.initialize = function (shapes, mapper) {
            // DO NOTHING
        };
        DDiagramCanvasBase.prototype.destroy = function () {
            if (!this._destroyed) {
                this.onDestroy();
                _super.prototype.destroy.call(this);
            }
        };
        DDiagramCanvasBase.prototype.onDestroy = function () {
            this._tile.destroy();
            this._layer.destroy();
        };
        DDiagramCanvasBase.prototype.hitTest = function (global, onHit) {
            var layers = this._layer.children;
            for (var i = layers.length - 1; 0 <= i; --i) {
                var layer = layers[i];
                if (layer.visible) {
                    var shape = layer.hitTest(global, onHit);
                    if (shape != null) {
                        return shape;
                    }
                }
            }
            return null;
        };
        DDiagramCanvasBase.prototype.getLocalBounds = function (result) {
            var _a, _b;
            var _c;
            if (result == null) {
                result = ((_a = (_c = this)._localBoundsRect) !== null && _a !== void 0 ? _a : (_c._localBoundsRect = new pixi_js.Rectangle()));
            }
            result.x = 0;
            result.y = 0;
            result.width = this.width;
            result.height = this.height;
            var limit = this._localBoundsLimit;
            if (limit === 0) {
                return result;
            }
            var layers = this.layer.children;
            var layersLength = layers.length;
            var work = ((_b = DDiagramCanvasBase.WORK_LOCAL_BOUNDS) !== null && _b !== void 0 ? _b : (DDiagramCanvasBase.WORK_LOCAL_BOUNDS = new pixi_js.Rectangle()));
            if (0 < limit) {
                var shapeCount = 0;
                for (var i = 0; i < layersLength; ++i) {
                    var layer = layers[i];
                    var p = layer.transform.position;
                    work.x = p.x;
                    work.y = p.y;
                    work.width = layer.width;
                    work.height = layer.height;
                    result.enlarge(work);
                    shapeCount += layer.children.length;
                }
                if (limit < shapeCount) {
                    return result;
                }
                for (var i = 0; i < layersLength; ++i) {
                    var layer = layers[i];
                    var p = layer.transform.position;
                    var px = p.x;
                    var py = p.y;
                    var shapes = layer.children;
                    for (var j = 0, jmax = shapes.length; j < jmax; ++j) {
                        var shape = shapes[j];
                        shape.getBoundsInternal(true, work);
                        work.x += px;
                        work.y += py;
                        result.enlarge(work);
                    }
                }
            }
            else {
                for (var i = 0; i < layersLength; ++i) {
                    var layer = layers[i];
                    var p = layer.transform.position;
                    var px = p.x;
                    var py = p.y;
                    work.x = px;
                    work.y = py;
                    work.width = layer.width;
                    work.height = layer.height;
                    result.enlarge(work);
                    var shapes = layer.children;
                    for (var j = 0, jmax = shapes.length; j < jmax; ++j) {
                        var shape = shapes[j];
                        shape.getBoundsInternal(true, work);
                        work.x += px;
                        work.y += py;
                        result.enlarge(work);
                    }
                }
            }
            return result;
        };
        DDiagramCanvasBase.prototype.getType = function () {
            return "DDiagramCanvasBase";
        };
        return DDiagramCanvasBase;
    }(DCanvas));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeRuntimes = {};

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDiagramCanvasDataImpl = /** @class */ (function () {
        function DDiagramCanvasDataImpl() {
        }
        Object.defineProperty(DDiagramCanvasDataImpl.prototype, "private", {
            get: function () {
                var result = this._private;
                if (result == null) {
                    result = this.newPrivate();
                    this._private = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DDiagramCanvasDataImpl.prototype.newPrivate = function () {
            return new EShapeDataScopedImpl();
        };
        Object.defineProperty(DDiagramCanvasDataImpl.prototype, "protected", {
            get: function () {
                var result = this._protected;
                if (result == null) {
                    result = this.newProtected();
                    this._protected = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DDiagramCanvasDataImpl.prototype.newProtected = function () {
            return new EShapeDataScopedImpl();
        };
        Object.defineProperty(DDiagramCanvasDataImpl.prototype, "extended", {
            get: function () {
                var result = this._extended;
                if (result == null) {
                    result = this.newExtended();
                    this._extended = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DDiagramCanvasDataImpl.prototype.newExtended = function () {
            return new EShapeDataScopedImpl();
        };
        Object.defineProperty(DDiagramCanvasDataImpl.prototype, "ids", {
            get: function () {
                var data = this._data;
                if (data == null) {
                    return [];
                }
                var result = [];
                data.forEach(function (value, id) {
                    result.push(id);
                });
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DDiagramCanvasDataImpl.prototype.each = function (iteratee) {
            var data = this._data;
            if (data == null) {
                return null;
            }
            var result = null;
            data.forEach(function (value, id) {
                if (result == null) {
                    if (iteratee(id) === false) {
                        result = id;
                    }
                }
            });
            return result;
        };
        DDiagramCanvasDataImpl.prototype.add = function (id, value) {
            var _a;
            var data = ((_a = this._data) !== null && _a !== void 0 ? _a : (this._data = new Map()));
            var list = data.get(id);
            if (list == null) {
                data.set(id, [value]);
            }
            else {
                list.push(value);
            }
        };
        DDiagramCanvasDataImpl.prototype.set = function (id, value, time, state, from, to) {
            var data = this._data;
            if (data == null) {
                return false;
            }
            var datum = data.get(id);
            if (datum == null) {
                return false;
            }
            var size = datum.length;
            if (size <= 0) {
                return false;
            }
            for (var i = 0; i < size; ++i) {
                var datumValue = datum[i];
                var range = datumValue.range;
                // Range
                range.set(from, to);
                // Time
                if (time !== undefined) {
                    datumValue.time = time;
                }
                // State
                if (state !== undefined) {
                    datumValue.state = state;
                }
                // Value
                if (value !== undefined) {
                    datumValue.value = value;
                }
            }
            return true;
        };
        DDiagramCanvasDataImpl.prototype.get = function (id) {
            var data = this._data;
            if (data == null) {
                return null;
            }
            var datum = data.get(id);
            if (datum == null) {
                return null;
            }
            return datum;
        };
        DDiagramCanvasDataImpl.prototype.clear = function (id) {
            var data = this._data;
            if (data == null) {
                return false;
            }
            var datum = data.get(id);
            if (datum == null) {
                return false;
            }
            var size = datum.length;
            if (size <= 0) {
                return false;
            }
            for (var i = 0; i < size; ++i) {
                datum[i].clear();
            }
            return true;
        };
        DDiagramCanvasDataImpl.prototype.toDirty = function (id) {
            var data = this._data;
            if (data == null) {
                return false;
            }
            var datum = data.get(id);
            if (datum == null) {
                return false;
            }
            var size = datum.length;
            if (size <= 0) {
                return false;
            }
            for (var i = 0; i < size; ++i) {
                datum[i].toDirty();
            }
            return true;
        };
        DDiagramCanvasDataImpl.prototype.setAll = function (id, values, times, states, from, to) {
            var data = this._data;
            if (data == null) {
                return false;
            }
            var datum = data.get(id);
            if (datum == null) {
                return false;
            }
            var size = datum.length;
            if (size <= 0) {
                return false;
            }
            for (var i = 0; i < size; ++i) {
                var datumValue = datum[i];
                var range = datumValue.range;
                // Range
                range.set(from, to);
                // Time
                if (times !== undefined) {
                    datumValue.times = times;
                }
                // State
                if (states !== undefined) {
                    datumValue.states = states;
                }
                // Value
                if (values !== undefined) {
                    datumValue.values = values;
                }
            }
            return true;
        };
        DDiagramCanvasDataImpl.prototype.setValue = function (id, value) {
            var data = this._data;
            if (data == null) {
                return false;
            }
            var datum = data.get(id);
            if (datum == null) {
                return false;
            }
            var size = datum.length;
            if (size <= 0) {
                return false;
            }
            for (var i = 0; i < size; ++i) {
                datum[i].value = value;
            }
            return true;
        };
        DDiagramCanvasDataImpl.prototype.setValues = function (id, values) {
            var data = this._data;
            if (data == null) {
                return false;
            }
            var datum = data.get(id);
            if (datum == null) {
                return false;
            }
            var size = datum.length;
            if (size <= 0) {
                return false;
            }
            for (var i = 0; i < size; ++i) {
                datum[i].values = values;
            }
            return true;
        };
        DDiagramCanvasDataImpl.prototype.setTime = function (id, time) {
            var data = this._data;
            if (data == null) {
                return false;
            }
            var datum = data.get(id);
            if (datum == null) {
                return false;
            }
            var size = datum.length;
            if (size <= 0) {
                return false;
            }
            for (var i = 0; i < size; ++i) {
                datum[i].time = time;
            }
            return true;
        };
        DDiagramCanvasDataImpl.prototype.setTimes = function (id, times) {
            var data = this._data;
            if (data == null) {
                return false;
            }
            var datum = data.get(id);
            if (datum == null) {
                return false;
            }
            var size = datum.length;
            if (size <= 0) {
                return false;
            }
            for (var i = 0; i < size; ++i) {
                datum[i].times = times;
            }
            return true;
        };
        DDiagramCanvasDataImpl.prototype.setState = function (id, state) {
            var data = this._data;
            if (data == null) {
                return false;
            }
            var datum = data.get(id);
            if (datum == null) {
                return false;
            }
            var size = datum.length;
            if (size <= 0) {
                return false;
            }
            for (var i = 0; i < size; ++i) {
                datum[i].state = state;
            }
            return true;
        };
        DDiagramCanvasDataImpl.prototype.setStates = function (id, states) {
            var data = this._data;
            if (data == null) {
                return false;
            }
            var datum = data.get(id);
            if (datum == null) {
                return false;
            }
            var size = datum.length;
            if (size <= 0) {
                return false;
            }
            for (var i = 0; i < size; ++i) {
                datum[i].states = states;
            }
            return true;
        };
        DDiagramCanvasDataImpl.prototype.setRange = function (id, from, to) {
            var data = this._data;
            if (data == null) {
                return false;
            }
            var datum = data.get(id);
            if (datum == null) {
                return false;
            }
            var size = datum.length;
            if (size <= 0) {
                return false;
            }
            for (var i = 0; i < size; ++i) {
                var range = datum[i].range;
                if (from !== undefined) {
                    if (from !== null) {
                        range.type |= EShapeDataValueRangeType.FROM;
                        range.from = from;
                    }
                    else {
                        range.type &= ~EShapeDataValueRangeType.FROM;
                    }
                }
                if (to !== undefined) {
                    if (to !== null) {
                        range.type |= EShapeDataValueRangeType.TO;
                        range.to = to;
                    }
                    else {
                        range.type &= ~EShapeDataValueRangeType.TO;
                    }
                }
            }
            return true;
        };
        return DDiagramCanvasDataImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDiagramCanvasBaseShapeImpl = /** @class */ (function () {
        function DDiagramCanvasBaseShapeImpl(canvas) {
            this._canvas = canvas;
        }
        DDiagramCanvasBaseShapeImpl.prototype.each = function (iteratee, ignoreCapability) {
            var canvas = this._canvas;
            var layers = canvas.layer.children;
            for (var i = 0, imax = layers.length; i < imax; ++i) {
                if (this.each_(layers[i].children, iteratee, ignoreCapability) === false) {
                    break;
                }
            }
            return this;
        };
        DDiagramCanvasBaseShapeImpl.prototype.each_ = function (shapes, iteratee, ignoreCapability) {
            for (var i = 0, imax = shapes.length; i < imax; ++i) {
                var shape = shapes[i];
                if (iteratee(shape) === false) {
                    return false;
                }
                if (ignoreCapability || EShapeCapabilities.contains(shape, EShapeCapability.CHILDREN)) {
                    var children = shape.children;
                    if (0 < children.length) {
                        if (this.each_(children, iteratee, ignoreCapability) === false) {
                            return false;
                        }
                    }
                }
            }
        };
        return DDiagramCanvasBaseShapeImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDiagramCanvasShapeImpl = /** @class */ (function (_super) {
        __extends(DDiagramCanvasShapeImpl, _super);
        function DDiagramCanvasShapeImpl(canvas) {
            var _this = _super.call(this, canvas) || this;
            _this._data = new Map();
            return _this;
        }
        DDiagramCanvasShapeImpl.prototype.add = function (id, shape) {
            var data = this._data;
            var shapes = data.get(id);
            if (shapes == null) {
                data.set(id, [shape]);
            }
            else {
                shapes.push(shape);
            }
        };
        DDiagramCanvasShapeImpl.prototype.get = function (id) {
            var shapes = this._data.get(id);
            if (shapes && 0 < shapes.length) {
                return shapes[0];
            }
            return null;
        };
        DDiagramCanvasShapeImpl.prototype.getAll = function (id) {
            return this._data.get(id) || [];
        };
        return DDiagramCanvasShapeImpl;
    }(DDiagramCanvasBaseShapeImpl));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDiagramTicker = /** @class */ (function () {
        function DDiagramTicker(parent, interval) {
            var _this = this;
            this._parent = parent;
            this._values = [];
            this._interval = interval;
            this._onTimeBound = function () {
                _this.onTime();
            };
        }
        DDiagramTicker.prototype.add = function (value) {
            this._values.push(value);
        };
        DDiagramTicker.prototype.start = function () {
            if (this._timeoutId == null) {
                this.onTime();
            }
        };
        DDiagramTicker.prototype.getInterval = function () {
            var now = Date.now();
            var interval = this._interval;
            return Math.max(0, interval - (now % interval));
        };
        DDiagramTicker.prototype.onTime = function () {
            var values = this._values;
            if (0 < values.length) {
                var t = Date.now() / this._interval;
                for (var i = 0, imax = values.length; i < imax; ++i) {
                    values[i].value = t;
                }
                DApplications.update(this._parent);
            }
            this._timeoutId = window.setTimeout(this._onTimeBound, this.getInterval());
        };
        DDiagramTicker.prototype.stop = function () {
            var timeoutId = this._timeoutId;
            if (timeoutId != null) {
                clearTimeout(timeoutId);
                this._timeoutId = undefined;
            }
        };
        return DDiagramTicker;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDiagramCanvasTickerImpl = /** @class */ (function () {
        function DDiagramCanvasTickerImpl(parent) {
            this._parent = parent;
            this._data = new Map();
        }
        DDiagramCanvasTickerImpl.prototype.add = function (interval) {
            var data = this._data;
            var normalized = this.toNormalized(interval);
            var ticker = data.get(normalized);
            if (ticker != null) {
                return ticker;
            }
            var newTicker = new DDiagramTicker(this._parent, normalized);
            data.set(normalized, newTicker);
            return newTicker;
        };
        DDiagramCanvasTickerImpl.prototype.toNormalized = function (interval) {
            return isNumber(interval) ? Math.max(1, Math.round(interval)) : 1000;
        };
        DDiagramCanvasTickerImpl.prototype.start = function () {
            this._data.forEach(function (ticker) {
                ticker.start();
            });
        };
        DDiagramCanvasTickerImpl.prototype.stop = function () {
            this._data.forEach(function (ticker) {
                ticker.stop();
            });
        };
        return DDiagramCanvasTickerImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeDataValueExtensions = /** @class */ (function () {
        function EShapeDataValueExtensions() {
        }
        EShapeDataValueExtensions.add = function (extension) {
            var _a, _b, _c;
            ((_a = this._typeToDatum) !== null && _a !== void 0 ? _a : (this._typeToDatum = new Map())).set(extension.type, extension);
            ((_b = this._idToDatum) !== null && _b !== void 0 ? _b : (this._idToDatum = new Map())).set(extension.id, extension);
            ((_c = this._data) !== null && _c !== void 0 ? _c : (this._data = [])).push(extension);
        };
        EShapeDataValueExtensions.get = function (type) {
            var typeToDatum = this._typeToDatum;
            if (typeToDatum != null) {
                return typeToDatum.get(type);
            }
        };
        EShapeDataValueExtensions.getById = function (id) {
            var idToDatum = this._idToDatum;
            if (idToDatum != null) {
                return idToDatum.get(id);
            }
        };
        EShapeDataValueExtensions.each = function (iteratee) {
            var data = this._data;
            if (data != null) {
                for (var i = 0, imax = data.length; i < imax; ++i) {
                    iteratee(data[i]);
                }
            }
        };
        return EShapeDataValueExtensions;
    }());

    var EShapeActionRuntimes = /** @class */ (function () {
        function EShapeActionRuntimes() {
        }
        EShapeActionRuntimes.add = function (type, runtime) {
            var typeToRuntimes = this._typeToRuntimes;
            if (typeToRuntimes == null) {
                typeToRuntimes = new Map();
                this._typeToRuntimes = typeToRuntimes;
            }
            var runtimes = typeToRuntimes.get(type);
            if (runtimes == null) {
                runtimes = [runtime];
                typeToRuntimes.set(type, runtimes);
            }
            else {
                runtimes.push(runtime);
            }
        };
        EShapeActionRuntimes.get = function (type) {
            var typeToRuntimes = this._typeToRuntimes;
            if (typeToRuntimes != null) {
                return typeToRuntimes.get(type);
            }
        };
        return EShapeActionRuntimes;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var INITIAL_ZERO = "0";
    var INITIAL_ARRAY = "[]";
    var INITIAL_STRING = '""';
    var INITIAL_OBJECT = "{}";
    var INITIAL_FALSE = "false";
    var INITIALIZER_ZERO = function () {
        return 0;
    };
    var INITIALIZER_ARRAY = function () {
        return [];
    };
    var INITIALIZER_STRING = function () {
        return "";
    };
    var INITIALIZER_OBJECT = function () {
        return {};
    };
    var INITIALIZER_FALSE = function () {
        return false;
    };
    var DDiagramCanvas = /** @class */ (function (_super) {
        __extends(DDiagramCanvas, _super);
        function DDiagramCanvas(options) {
            var _this = _super.call(this, options) || this;
            _this._data = new DDiagramCanvasDataImpl();
            _this._shape = new DDiagramCanvasShapeImpl(_this);
            _this._ticker = new DDiagramCanvasTickerImpl(_this);
            _this._actionables = [];
            _this._downeds = new Set();
            _this._updateBound = function () {
                DApplications.update(_this);
            };
            return _this;
        }
        Object.defineProperty(DDiagramCanvas.prototype, "data", {
            get: function () {
                return this._data;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDiagramCanvas.prototype, "shape", {
            get: function () {
                return this._shape;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDiagramCanvas.prototype, "ticker", {
            get: function () {
                return this._ticker;
            },
            enumerable: false,
            configurable: true
        });
        DDiagramCanvas.prototype.initialize = function (shapes, mapper) {
            var _this = this;
            var actionables = this._actionables;
            var data = this._data;
            this.initialize_(shapes, null, null, mapper, new Map(), new Map(), new Map(), this._ticker, this._shape, data, actionables);
            var layers = this._layer.children;
            var layersLength = layers.length;
            for (var i = 0; i < layersLength; ++i) {
                layers[i].initialize(actionables);
            }
            EShapeActionEnvironment.isInitializing = true;
            var time = Date.now();
            for (var i = 0; i < layersLength; ++i) {
                layers[i].update(time);
            }
            EShapeActionEnvironment.isInitializing = false;
            data.extended.each(function (id) {
                var extension = EShapeDataValueExtensions.getById(id);
                if (extension) {
                    var start = extension.start;
                    if (start) {
                        start(_this);
                    }
                }
            });
            this._ticker.start();
        };
        DDiagramCanvas.prototype.initialize_ = function (shapes, dataShape, containerShape, mapper, formatters, initializers, actionValueToRuntime, canvasTicker, canvasShape, canvasData, actionables) {
            var _loop_1 = function (i, imax) {
                var shape = shapes[i];
                // ID
                var id = shape.id;
                if (0 < id.length) {
                    canvasShape.add(id, shape);
                }
                // Data
                this_1.initData(shape, dataShape, containerShape, mapper, formatters, initializers, canvasTicker, canvasData);
                // Runtime
                var runtime = new (EShapeRuntimes[shape.type] || EShapeRuntimeImpl)(shape);
                shape.runtime = runtime;
                // Action
                this_1.initActions(shape, runtime, actionValueToRuntime);
                // Init the runtime
                runtime.initialize(shape);
                // Shortcut
                var shortcut = shape.shortcut;
                if (shortcut != null) {
                    UtilKeyboardEvent.on(shape, shortcut, function (e) {
                        runtime.onClick(shape, e);
                    });
                }
                // Actionables
                if (runtime.isActionable()) {
                    actionables.push(shape);
                }
                // Children
                var children = shape.children;
                if (0 < children.length) {
                    var newDataShape = dataShape;
                    var newContainerShape = containerShape;
                    if (shape instanceof EShapeEmbedded) {
                        if (newDataShape == null) {
                            newDataShape = shape;
                        }
                        newContainerShape = shape;
                    }
                    this_1.initialize_(children, newDataShape, newContainerShape, mapper, formatters, initializers, actionValueToRuntime, canvasTicker, canvasShape, canvasData, actionables);
                }
            };
            var this_1 = this;
            for (var i = 0, imax = shapes.length; i < imax; ++i) {
                _loop_1(i);
            }
        };
        DDiagramCanvas.prototype.initData = function (shape, dataShape, containerShape, mapper, formatters, initializers, canvasTicker, canvasData) {
            var data = shape.data;
            for (var i = 0, imax = data.size(); i < imax; ++i) {
                var value = data.get(i);
                if (value == null) {
                    continue;
                }
                switch (value.type) {
                    case EShapeDataValueType.BOOLEAN:
                    case EShapeDataValueType.BOOLEAN_ARRAY:
                    case EShapeDataValueType.NUMBER:
                    case EShapeDataValueType.NUMBER_ARRAY:
                    case EShapeDataValueType.STRING:
                    case EShapeDataValueType.STRING_ARRAY:
                    case EShapeDataValueType.OBJECT:
                    case EShapeDataValueType.OBJECT_ARRAY:
                        this.initDataValue(value, shape, dataShape, containerShape, mapper, formatters, initializers, canvasData);
                        break;
                    case EShapeDataValueType.TICKER:
                        this.initDataTicker(value, initializers, canvasTicker);
                        break;
                    default:
                        this.initDataExtension(value, canvasData);
                        break;
                }
            }
        };
        DDiagramCanvas.prototype.initDataValue = function (value, shape, dataShape, containerShape, mapper, formatters, initializers, canvasData) {
            // Mapping
            if (value.scope === EShapeDataValueScope.PRIVATE) {
                var id = value.id;
                if (0 < id.length) {
                    if (containerShape) {
                        containerShape.data.private.add(id, value);
                    }
                    else {
                        canvasData.private.add(id, value);
                    }
                }
            }
            else if (value.scope === EShapeDataValueScope.PROTECTED) {
                var id = value.id;
                if (0 < id.length) {
                    canvasData.protected.add(id, value);
                }
            }
            else {
                if (mapper) {
                    mapper(value, dataShape || shape);
                }
                var id = value.id;
                if (0 < id.length) {
                    canvasData.add(id, value);
                }
            }
            // Format
            var format = value.format;
            var initial = value.initial;
            var formatToFormatter = formatters.get(value.type);
            if (formatToFormatter == null) {
                formatToFormatter = new Map();
                formatters.set(value.type, formatToFormatter);
            }
            var oldFormatter = formatToFormatter.get(format);
            if (oldFormatter != null) {
                value.formatter = oldFormatter;
            }
            else if (0 < format.length) {
                var newFormatter = this.calcFormatter(value, format, initial);
                formatToFormatter.set(format, newFormatter);
                value.formatter = newFormatter;
            }
            // Initial
            var initialToInitializer = initializers.get(value.type);
            if (initialToInitializer == null) {
                initialToInitializer = new Map();
                initializers.set(value.type, initialToInitializer);
            }
            var oldInitializer = initialToInitializer.get(initial);
            if (oldInitializer != null) {
                value.value = oldInitializer();
            }
            else {
                var newInitializer = this.calcInitial(value, initial);
                initialToInitializer.set(initial, newInitializer);
                value.value = newInitializer();
            }
        };
        DDiagramCanvas.prototype.initDataTicker = function (value, initializers, canvasTicker) {
            var initial = value.initial;
            var initialToInitializer = initializers.get(value.type);
            if (initialToInitializer == null) {
                initialToInitializer = new Map();
                initializers.set(value.type, initialToInitializer);
            }
            var oldInitializer = initialToInitializer.get(initial);
            if (oldInitializer !== undefined) {
                value.value = 0;
                canvasTicker.add(oldInitializer()).add(value);
            }
            else {
                var newInitializer = this.calcInitial(value, initial);
                initialToInitializer.set(initial, newInitializer);
                value.value = 0;
                canvasTicker.add(newInitializer()).add(value);
            }
        };
        DDiagramCanvas.prototype.initDataExtension = function (value, canvasData) {
            var extension = EShapeDataValueExtensions.get(value.type);
            if (extension) {
                canvasData.extended.add(extension.id, value);
                value.value = extension.initial;
            }
        };
        DDiagramCanvas.prototype.initActions = function (shape, shapeRuntime, valueToRuntime) {
            var values = shape.action.values;
            var runtimes = shapeRuntime.actions;
            var typeRuntimes = EShapeActionRuntimes.get(shape.type);
            if (typeRuntimes != null) {
                for (var i = 0, imax = typeRuntimes.length; i < imax; ++i) {
                    var typeRuntime = typeRuntimes[i];
                    runtimes.push(typeRuntime);
                    shapeRuntime.reset |= typeRuntime.reset;
                }
            }
            for (var i = 0, imax = values.length; i < imax; ++i) {
                var value = values[i];
                var runtime = valueToRuntime.get(value);
                if (runtime == null) {
                    runtime = value.toRuntime();
                    if (runtime != null) {
                        valueToRuntime.set(value, runtime);
                        runtimes.push(runtime);
                        shapeRuntime.reset |= runtime.reset;
                    }
                }
                else {
                    runtimes.push(runtime);
                    shapeRuntime.reset |= runtime.reset;
                }
            }
        };
        DDiagramCanvas.prototype.calcFormatter = function (value, format, initial) {
            var def = this.toInitial(value);
            try {
                return Function("value", 
                /* eslint-disable prettier/prettier */
                "try {" +
                    "return (".concat(format, ");") +
                    "} catch( e1 ) {" +
                    "try {" +
                    "return (".concat(0 < initial.length ? initial : def, ");") +
                    "} catch( e2 ) {" +
                    "return ".concat(def, ";") +
                    "}" +
                    "}"
                /* eslint-enable prettier/prettier */
                );
            }
            catch (e) {
                return this.toInitializer(value);
            }
        };
        DDiagramCanvas.prototype.calcInitial = function (value, initial) {
            if (initial.length <= 0) {
                return this.toInitializer(value);
            }
            try {
                return Function(
                /* eslint-disable prettier/prettier */
                "try {" +
                    "return (".concat(initial, ");") +
                    "} catch( e ) {" +
                    "return ".concat(this.toInitial(value), ";") +
                    "}"
                /* eslint-enable prettier/prettier */
                );
            }
            catch (e) {
                return this.toInitializer(value);
            }
        };
        DDiagramCanvas.prototype.toInitial = function (value) {
            var valueType = value.type;
            switch (valueType) {
                case EShapeDataValueType.BOOLEAN:
                    return INITIAL_FALSE;
                case EShapeDataValueType.BOOLEAN_ARRAY:
                    return INITIAL_ARRAY;
                case EShapeDataValueType.NUMBER:
                    return INITIAL_ZERO;
                case EShapeDataValueType.NUMBER_ARRAY:
                    return INITIAL_ARRAY;
                case EShapeDataValueType.STRING:
                    return INITIAL_STRING;
                case EShapeDataValueType.STRING_ARRAY:
                    return INITIAL_ARRAY;
                case EShapeDataValueType.OBJECT:
                    return INITIAL_OBJECT;
                case EShapeDataValueType.OBJECT_ARRAY:
                    return INITIAL_ARRAY;
                case EShapeDataValueType.TICKER:
                    return INITIAL_ZERO;
                default:
                    return INITIAL_ZERO;
            }
        };
        DDiagramCanvas.prototype.toInitializer = function (value) {
            var valueType = value.type;
            switch (valueType) {
                case EShapeDataValueType.BOOLEAN:
                    return INITIALIZER_FALSE;
                case EShapeDataValueType.BOOLEAN_ARRAY:
                    return INITIALIZER_ARRAY;
                case EShapeDataValueType.NUMBER:
                    return INITIALIZER_ZERO;
                case EShapeDataValueType.NUMBER_ARRAY:
                    return INITIALIZER_ARRAY;
                case EShapeDataValueType.STRING:
                    return INITIALIZER_STRING;
                case EShapeDataValueType.STRING_ARRAY:
                    return INITIALIZER_ARRAY;
                case EShapeDataValueType.OBJECT:
                    return INITIALIZER_OBJECT;
                case EShapeDataValueType.OBJECT_ARRAY:
                    return INITIALIZER_ARRAY;
                case EShapeDataValueType.TICKER:
                    return INITIALIZER_ZERO;
                default:
                    return INITIALIZER_ZERO;
            }
        };
        DDiagramCanvas.prototype.onDestroy = function () {
            var _this = this;
            this._data.extended.each(function (id) {
                var extension = EShapeDataValueExtensions.getById(id);
                if (extension) {
                    var stop_1 = extension.stop;
                    if (stop_1) {
                        stop_1(_this);
                    }
                }
            });
            this._ticker.stop();
            _super.prototype.onDestroy.call(this);
        };
        DDiagramCanvas.prototype.hitTestInteractives = function (global) {
            var layers = this._layer.children;
            for (var i = layers.length - 1; 0 <= i; --i) {
                var layer = layers[i];
                if (layer.visible) {
                    var result = layer.hitTestInteractives(global);
                    if (result != null) {
                        return result;
                    }
                }
            }
            return null;
        };
        DDiagramCanvas.prototype.onShapeMove = function (e) {
            var found = this.hitTestInteractives(e.data.global);
            // Cursor
            this.cursor = this._cursor = this.toShapeCursor(found);
            // TItle
            var layer = DApplications.getLayer(this);
            if (layer) {
                var title = this.toShapeTitle(found);
                var view = layer.view;
                if (view.title !== title) {
                    view.title = title;
                }
            }
            var overed = this._overed;
            this._overed = found;
            if (found === overed) {
                if (found != null) {
                    var runtime = found.runtime;
                    if (runtime) {
                        runtime.onMove(found, e);
                    }
                }
            }
            else {
                this.onShapeOut(e, overed, found);
                this.onShapeOver(e, found);
            }
            return found != null;
        };
        DDiagramCanvas.prototype.toShapeCursor = function (target) {
            if (target != null) {
                var current = target;
                while (true) {
                    var cursor = current.cursor;
                    if (cursor != null && 0 < cursor.length) {
                        return cursor;
                    }
                    var parent_1 = current.parent;
                    if (parent_1 instanceof EShapeBase) {
                        current = parent_1;
                    }
                    else {
                        break;
                    }
                }
            }
            return "auto";
        };
        DDiagramCanvas.prototype.toShapeTitle = function (target) {
            if (target != null) {
                var current = target;
                while (true) {
                    var title = current.title;
                    if (title != null && 0 < title.length) {
                        return title;
                    }
                    var parent_2 = current.parent;
                    if (parent_2 instanceof EShapeBase) {
                        current = parent_2;
                    }
                    else {
                        break;
                    }
                }
            }
            return "";
        };
        DDiagramCanvas.prototype.onShapeOut = function (e, target, except) {
            while (target != null && target !== except && target instanceof EShapeBase) {
                var runtime = target.runtime;
                if (runtime) {
                    runtime.onOut(target, e);
                }
                target = target.parent;
            }
        };
        DDiagramCanvas.prototype.onShapeOver = function (e, target, except) {
            while (target != null && target !== except && target instanceof EShapeBase) {
                var runtime = target.runtime;
                if (runtime) {
                    runtime.onOver(target, e);
                }
                target = target.parent;
            }
        };
        DDiagramCanvas.prototype.onShapeDown = function (e) {
            var found = this.hitTestInteractives(e.data.global);
            this._downed = found;
            if (found) {
                this._downeds.add(found);
                var target = found;
                while (true) {
                    var runtime = target.runtime;
                    if (runtime) {
                        runtime.onDown(target, e);
                    }
                    var parent_3 = target.parent;
                    if (parent_3 instanceof EShapeBase) {
                        target = parent_3;
                    }
                    else {
                        break;
                    }
                }
                return true;
            }
            return false;
        };
        DDiagramCanvas.prototype.onShapeUp = function (e) {
            var downeds = this._downeds;
            var found = this.hitTestInteractives(e.data.global);
            if (found) {
                downeds.delete(found);
                var target = found;
                while (true) {
                    var runtime = target.runtime;
                    if (runtime) {
                        runtime.onUp(target, e);
                    }
                    var parent_4 = target.parent;
                    if (parent_4 instanceof EShapeBase) {
                        target = parent_4;
                    }
                    else {
                        break;
                    }
                }
            }
            this.onShapeCancel(e);
            return found != null;
        };
        DDiagramCanvas.prototype.onShapeCancel = function (e) {
            var downeds = this._downeds;
            if (0 < downeds.size) {
                downeds.forEach(function (downed) {
                    var target = downed;
                    while (true) {
                        var runtime = target.runtime;
                        if (runtime) {
                            runtime.onUpOutside(target, e);
                        }
                        var parent_5 = target.parent;
                        if (parent_5 instanceof EShapeBase) {
                            target = parent_5;
                        }
                        else {
                            break;
                        }
                    }
                });
                downeds.clear();
                return true;
            }
            return false;
        };
        DDiagramCanvas.prototype.onShapeClick = function (e) {
            var found = this.hitTestInteractives(e.data.global);
            if (found && this._downed === found) {
                var target = found;
                while (true) {
                    var runtime = target.runtime;
                    if (runtime) {
                        runtime.onClick(target, e);
                    }
                    var parent_6 = target.parent;
                    if (parent_6 instanceof EShapeBase) {
                        target = parent_6;
                    }
                    else {
                        break;
                    }
                }
                return true;
            }
            return false;
        };
        DDiagramCanvas.prototype.onShapeDblClick = function (e, interactionManager) {
            var _a;
            var global = ((_a = DDiagramCanvas.WORK_DBLCLICK) !== null && _a !== void 0 ? _a : (DDiagramCanvas.WORK_DBLCLICK = new pixi_js.Point()));
            UtilPointerEvent.toGlobal(e, interactionManager, global);
            var found = this.hitTestInteractives(global);
            if (found) {
                var target = found;
                while (true) {
                    var runtime = target.runtime;
                    if (runtime) {
                        runtime.onDblClick(target, e, interactionManager);
                    }
                    var parent_7 = target.parent;
                    if (parent_7 instanceof EShapeBase) {
                        target = parent_7;
                    }
                    else {
                        break;
                    }
                }
                return true;
            }
            return false;
        };
        DDiagramCanvas.prototype.onShapeRightClick = function (e) {
            var found = this.hitTestInteractives(e.data.global);
            if (found && this._downed === found) {
                var target = found;
                while (true) {
                    var runtime = target.runtime;
                    if (runtime) {
                        runtime.onRightClick(target, e);
                    }
                    var parent_8 = target.parent;
                    if (parent_8 instanceof EShapeBase) {
                        target = parent_8;
                    }
                    else {
                        break;
                    }
                }
                return true;
            }
            return false;
        };
        DDiagramCanvas.prototype.onShapeRightDown = function (e) {
            var found = this.hitTestInteractives(e.data.global);
            this._downed = found;
            if (found) {
                this._downeds.add(found);
                var target = found;
                while (true) {
                    var runtime = target.runtime;
                    if (runtime) {
                        runtime.onRightDown(target, e);
                    }
                    var parent_9 = target.parent;
                    if (parent_9 instanceof EShapeBase) {
                        target = parent_9;
                    }
                    else {
                        break;
                    }
                }
                return true;
            }
            return false;
        };
        DDiagramCanvas.prototype.onShapeRightUp = function (e) {
            var downeds = this._downeds;
            var found = this.hitTestInteractives(e.data.global);
            if (found) {
                downeds.delete(found);
                var target = found;
                while (true) {
                    var runtime = target.runtime;
                    if (runtime) {
                        runtime.onRightUp(target, e);
                    }
                    var parent_10 = target.parent;
                    if (parent_10 instanceof EShapeBase) {
                        target = parent_10;
                    }
                    else {
                        break;
                    }
                }
            }
            this.onShapeRightCancel(e);
            return found != null;
        };
        DDiagramCanvas.prototype.onShapeRightCancel = function (e) {
            var downeds = this._downeds;
            if (0 < downeds.size) {
                downeds.forEach(function (downed) {
                    var target = downed;
                    while (true) {
                        var runtime = target.runtime;
                        if (runtime) {
                            runtime.onRightUpOutside(target, e);
                        }
                        var parent_11 = target.parent;
                        if (parent_11 instanceof EShapeBase) {
                            target = parent_11;
                        }
                        else {
                            break;
                        }
                    }
                });
                downeds.clear();
                return true;
            }
            return false;
        };
        DDiagramCanvas.prototype.update = function () {
            var actionables = this._actionables;
            if (0 < actionables.length) {
                var effect = -1;
                var time = Date.now();
                for (var i = 0, imax = actionables.length; i < imax; ++i) {
                    var actionable = actionables[i];
                    actionable.update(time);
                    var runtime = actionable.runtime;
                    if (runtime) {
                        var runtimeEffect = runtime.effect;
                        if (0 <= runtimeEffect && time < runtimeEffect) {
                            effect = effect < 0 ? runtimeEffect : Math.min(effect, runtimeEffect);
                        }
                    }
                }
                if (0 <= effect) {
                    window.setTimeout(this._updateBound, effect - Date.now());
                }
            }
        };
        DDiagramCanvas.prototype.onRender = function (renderer) {
            var actionables = this._actionables;
            if (0 < actionables.length) {
                var effect = -1;
                var time = Date.now();
                for (var i = 0, imax = actionables.length; i < imax; ++i) {
                    var actionable = actionables[i];
                    actionable.onRender(time, renderer);
                    var runtime = actionable.runtime;
                    if (runtime) {
                        var runtimeEffect = runtime.effect;
                        if (0 <= runtimeEffect && time < runtimeEffect) {
                            effect = effect < 0 ? runtimeEffect : Math.min(effect, runtimeEffect);
                        }
                    }
                }
                if (0 <= effect) {
                    window.setTimeout(this._updateBound, effect - Date.now());
                }
            }
        };
        DDiagramCanvas.prototype.getType = function () {
            return "DDiagramCanvas";
        };
        return DDiagramCanvas;
    }(DDiagramCanvasBase));

    /*
     * Copyright (C) 2021 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A shape helper class for diagrams.
     */
    var DDiagramShape = /** @class */ (function (_super) {
        __extends(DDiagramShape, _super);
        function DDiagramShape(diagram) {
            var _this = _super.call(this) || this;
            _this._diagram = diagram;
            _this._updateBound = function () {
                DApplications.update(diagram);
            };
            return _this;
        }
        DDiagramShape.prototype.update = function () {
            var canvas = this._diagram.canvas;
            if (canvas) {
                canvas.update();
            }
        };
        DDiagramShape.prototype.get = function (id) {
            var canvas = this._diagram.canvas;
            if (canvas) {
                return canvas.shape.get(id);
            }
            return null;
        };
        DDiagramShape.prototype.getAll = function (id) {
            var canvas = this._diagram.canvas;
            if (canvas) {
                return canvas.shape.getAll(id);
            }
            return [];
        };
        DDiagramShape.prototype.each = function (iteratee, reverse) {
            if (reverse === void 0) { reverse = false; }
            var canvas = this._diagram.canvas;
            if (canvas != null) {
                var layers = canvas.layer.children;
                if (!reverse) {
                    for (var i = 0, imax = layers.length; i < imax; ++i) {
                        var layer = layers[i];
                        var children = layer.children;
                        for (var j = 0, jmax = children.length; j < jmax; ++j) {
                            var child = children[j];
                            if (iteratee(child) === false) {
                                return child;
                            }
                        }
                    }
                }
                else {
                    for (var i = layers.length - 1; 0 <= i; --i) {
                        var layer = layers[i];
                        var children = layer.children;
                        for (var j = children.length - 1; 0 <= j; --j) {
                            var child = children[j];
                            if (iteratee(child) === false) {
                                return child;
                            }
                        }
                    }
                }
            }
            return null;
        };
        return DDiagramShape;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDiagramDataPrivateImpl = /** @class */ (function () {
        function DDiagramDataPrivateImpl(diagram) {
            this._diagram = diagram;
        }
        Object.defineProperty(DDiagramDataPrivateImpl.prototype, "ids", {
            get: function () {
                var canvas = this._diagram.canvas;
                if (canvas != null) {
                    return canvas.data.private.ids;
                }
                return [];
            },
            enumerable: false,
            configurable: true
        });
        DDiagramDataPrivateImpl.prototype.set = function (id, value, time, state, from, to) {
            var canvas = this._diagram.canvas;
            if (canvas != null) {
                return canvas.data.private.set(id, value, time, state, from, to);
            }
            return false;
        };
        DDiagramDataPrivateImpl.prototype.toDirty = function (id) {
            var canvas = this._diagram.canvas;
            if (canvas != null) {
                return canvas.data.private.toDirty(id);
            }
            return false;
        };
        DDiagramDataPrivateImpl.prototype.each = function (iteratee) {
            var canvas = this._diagram.canvas;
            if (canvas != null) {
                return canvas.data.private.each(iteratee);
            }
            return null;
        };
        return DDiagramDataPrivateImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDiagramDataProtectedImpl = /** @class */ (function () {
        function DDiagramDataProtectedImpl(diagram) {
            this._diagram = diagram;
        }
        Object.defineProperty(DDiagramDataProtectedImpl.prototype, "ids", {
            get: function () {
                var canvas = this._diagram.canvas;
                if (canvas != null) {
                    return canvas.data.protected.ids;
                }
                return [];
            },
            enumerable: false,
            configurable: true
        });
        DDiagramDataProtectedImpl.prototype.set = function (id, value, time, state, from, to) {
            var canvas = this._diagram.canvas;
            if (canvas != null) {
                return canvas.data.protected.set(id, value, time, state, from, to);
            }
            return false;
        };
        DDiagramDataProtectedImpl.prototype.toDirty = function (id) {
            var canvas = this._diagram.canvas;
            if (canvas != null) {
                return canvas.data.protected.toDirty(id);
            }
            return false;
        };
        DDiagramDataProtectedImpl.prototype.each = function (iteratee) {
            var canvas = this._diagram.canvas;
            if (canvas != null) {
                return canvas.data.protected.each(iteratee);
            }
            return null;
        };
        return DDiagramDataProtectedImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDiagramDataRemoteImpl = /** @class */ (function () {
        function DDiagramDataRemoteImpl(options) {
            this._controller = options && options.controller;
        }
        DDiagramDataRemoteImpl.prototype.set = function (id, value) {
            var controller = this._controller;
            if (controller) {
                controller.write(id, value);
                return true;
            }
            return false;
        };
        return DDiagramDataRemoteImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDiagramDataExtendedImpl = /** @class */ (function () {
        function DDiagramDataExtendedImpl(diagram) {
            this._diagram = diagram;
        }
        Object.defineProperty(DDiagramDataExtendedImpl.prototype, "ids", {
            get: function () {
                var canvas = this._diagram.canvas;
                if (canvas != null) {
                    return canvas.data.extended.ids;
                }
                return [];
            },
            enumerable: false,
            configurable: true
        });
        DDiagramDataExtendedImpl.prototype.set = function (id, value, time, state, from, to) {
            var canvas = this._diagram.canvas;
            if (canvas != null) {
                return canvas.data.extended.set(id, value, time, state, from, to);
            }
            return false;
        };
        DDiagramDataExtendedImpl.prototype.toDirty = function (id) {
            var canvas = this._diagram.canvas;
            if (canvas != null) {
                return canvas.data.extended.toDirty(id);
            }
            return false;
        };
        DDiagramDataExtendedImpl.prototype.each = function (iteratee) {
            var canvas = this._diagram.canvas;
            if (canvas != null) {
                return canvas.data.extended.each(iteratee);
            }
            return null;
        };
        return DDiagramDataExtendedImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A data helper class for diagrams.
     */
    var DDiagramDataImpl = /** @class */ (function () {
        function DDiagramDataImpl(diagram, options) {
            this._diagram = diagram;
            this._mapper = (options && options.mapper) || null;
            this._remote = new DDiagramDataRemoteImpl(options && options.remote);
            this._private = new DDiagramDataPrivateImpl(diagram);
            this._protected = new DDiagramDataProtectedImpl(diagram);
            this._extended = new DDiagramDataExtendedImpl(diagram);
        }
        DDiagramDataImpl.prototype.update = function () {
            // DO NOTHING
        };
        Object.defineProperty(DDiagramDataImpl.prototype, "mapper", {
            get: function () {
                return this._mapper;
            },
            set: function (mapper) {
                this._mapper = mapper;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDiagramDataImpl.prototype, "remote", {
            get: function () {
                return this._remote;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDiagramDataImpl.prototype, "private", {
            get: function () {
                return this._private;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDiagramDataImpl.prototype, "protected", {
            get: function () {
                return this._protected;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDiagramDataImpl.prototype, "extended", {
            get: function () {
                return this._extended;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDiagramDataImpl.prototype, "ids", {
            get: function () {
                var canvas = this._diagram.canvas;
                if (canvas) {
                    return canvas.data.ids;
                }
                return [];
            },
            enumerable: false,
            configurable: true
        });
        DDiagramDataImpl.prototype.each = function (iteratee) {
            var canvas = this._diagram.canvas;
            if (canvas != null) {
                return canvas.data.each(iteratee);
            }
            return null;
        };
        DDiagramDataImpl.prototype.set = function (id, value, time, state, from, to) {
            var canvas = this._diagram.canvas;
            if (canvas != null) {
                return canvas.data.set(id, value, time, state, from, to);
            }
            return false;
        };
        DDiagramDataImpl.prototype.get = function (id) {
            var canvas = this._diagram.canvas;
            if (canvas != null) {
                return canvas.data.get(id);
            }
            return null;
        };
        DDiagramDataImpl.prototype.clear = function (id) {
            var canvas = this._diagram.canvas;
            if (canvas != null) {
                return canvas.data.clear(id);
            }
            return false;
        };
        DDiagramDataImpl.prototype.toDirty = function (id) {
            var canvas = this._diagram.canvas;
            if (canvas != null) {
                return canvas.data.toDirty(id);
            }
            return false;
        };
        DDiagramDataImpl.prototype.setAll = function (id, values, times, states, from, to) {
            var canvas = this._diagram.canvas;
            if (canvas != null) {
                return canvas.data.setAll(id, values, times, states, from, to);
            }
            return false;
        };
        DDiagramDataImpl.prototype.setValue = function (id, value) {
            var canvas = this._diagram.canvas;
            if (canvas != null) {
                return canvas.data.setValue(id, value);
            }
            return false;
        };
        DDiagramDataImpl.prototype.setValues = function (id, values) {
            var canvas = this._diagram.canvas;
            if (canvas != null) {
                return canvas.data.setValues(id, values);
            }
            return false;
        };
        DDiagramDataImpl.prototype.setTime = function (id, time) {
            var canvas = this._diagram.canvas;
            if (canvas != null) {
                return canvas.data.setTime(id, time);
            }
            return false;
        };
        DDiagramDataImpl.prototype.setTimes = function (id, times) {
            var canvas = this._diagram.canvas;
            if (canvas != null) {
                return canvas.data.setTimes(id, times);
            }
            return false;
        };
        DDiagramDataImpl.prototype.setState = function (id, state) {
            var canvas = this._diagram.canvas;
            if (canvas != null) {
                return canvas.data.setState(id, state);
            }
            return false;
        };
        DDiagramDataImpl.prototype.setStates = function (id, states) {
            var canvas = this._diagram.canvas;
            if (canvas != null) {
                return canvas.data.setStates(id, states);
            }
            return false;
        };
        DDiagramDataImpl.prototype.setRange = function (id, from, to) {
            var canvas = this._diagram.canvas;
            if (canvas != null) {
                return canvas.data.setRange(id, from, to);
            }
            return false;
        };
        return DDiagramDataImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDiagram = /** @class */ (function (_super) {
        __extends(DDiagram, _super);
        function DDiagram(options) {
            var _this = _super.call(this, options) || this;
            // Event handlers
            _this.on(UtilPointerEvent.move, function (e) {
                _this.onShapeMove(e);
            });
            _this.on(UtilPointerEvent.up, function (e) {
                _this.onShapeUp(e);
            });
            _this.on(UtilPointerEvent.upoutside, function (e) {
                _this.onShapeCancel(e);
            });
            _this.on(UtilPointerEvent.cancel, function (e) {
                _this.onShapeCancel(e);
            });
            _this.on(UtilPointerEvent.tap, function (e) {
                _this.onShapeClick(e);
            });
            _this.on(UtilPointerEvent.righttap, function (e) {
                _this.onShapeRightClick(e);
            });
            _this.on(UtilPointerEvent.rightdown, function (e) {
                _this.onShapeRightDown(e);
            });
            _this.on(UtilPointerEvent.rightup, function (e) {
                _this.onShapeRightUp(e);
            });
            _this.on(UtilPointerEvent.rightupoutside, function (e) {
                _this.onShapeRightCancel(e);
            });
            // Data
            var data = new DDiagramDataImpl(_this, options && (options.data || options.tag));
            _this.data = data;
            _this.tag = data;
            // Shape
            _this.shape = new DDiagramShape(_this);
            return _this;
        }
        DDiagram.prototype.initLayer = function (canvas, shapes, mapper) {
            return _super.prototype.initLayer.call(this, canvas, shapes, mapper || this.data.mapper);
        };
        DDiagram.prototype.toMode = function (options) {
            return EShapeResourceManagerDeserializationMode.VIEWER;
        };
        DDiagram.prototype.newCanvas = function (serialized) {
            return new DDiagramCanvas(this.toCanvasOptions(serialized));
        };
        DDiagram.prototype.toCanvasOptions = function (serialized) {
            return this.toCanvasBaseOptions(serialized);
        };
        DDiagram.prototype.onDown = function (e) {
            var canvas = this.canvas;
            if (canvas) {
                var target = e.target;
                if (target === this || target === canvas) {
                    _super.prototype.onDown.call(this, e, canvas.onShapeDown(e));
                }
                else {
                    _super.prototype.onDown.call(this, e);
                }
            }
            else {
                _super.prototype.onDown.call(this, e);
            }
        };
        DDiagram.prototype.onShapeMove = function (e) {
            var canvas = this.canvas;
            if (canvas) {
                var target = e.target;
                if (target === this || target === canvas) {
                    canvas.onShapeMove(e);
                }
            }
        };
        DDiagram.prototype.onShapeUp = function (e) {
            var canvas = this.canvas;
            if (canvas) {
                var target = e.target;
                if (target === this || target === canvas) {
                    canvas.onShapeUp(e);
                }
            }
        };
        DDiagram.prototype.onShapeCancel = function (e) {
            var canvas = this.canvas;
            if (canvas) {
                var target = e.target;
                if (target === this || target === canvas) {
                    canvas.onShapeCancel(e);
                }
            }
        };
        DDiagram.prototype.onShapeClick = function (e) {
            var canvas = this.canvas;
            if (canvas) {
                var target = e.target;
                if (target === this || target === canvas) {
                    canvas.onShapeClick(e);
                }
            }
        };
        DDiagram.prototype.onShapeRightClick = function (e) {
            var canvas = this.canvas;
            if (canvas) {
                var target = e.target;
                if (target === this || target === canvas) {
                    canvas.onShapeRightClick(e);
                }
            }
        };
        DDiagram.prototype.onShapeRightDown = function (e) {
            var canvas = this.canvas;
            if (canvas) {
                var target = e.target;
                if (target === this || target === canvas) {
                    canvas.onShapeRightDown(e);
                }
            }
        };
        DDiagram.prototype.onShapeRightUp = function (e) {
            var canvas = this.canvas;
            if (canvas) {
                var target = e.target;
                if (target === this || target === canvas) {
                    canvas.onShapeRightUp(e);
                }
            }
        };
        DDiagram.prototype.onShapeRightCancel = function (e) {
            var canvas = this.canvas;
            if (canvas) {
                var target = e.target;
                if (target === this || target === canvas) {
                    canvas.onShapeRightCancel(e);
                }
            }
        };
        DDiagram.prototype.onDblClick = function (e, manager) {
            var canvas = this.canvas;
            if (canvas) {
                return _super.prototype.onDblClick.call(this, e, manager, canvas.onShapeDblClick(e, manager));
            }
            else {
                return _super.prototype.onDblClick.call(this, e, manager);
            }
        };
        DDiagram.prototype.onPrerender = function (renderer) {
            var canvas = this._canvas;
            if (canvas) {
                canvas.onRender(renderer);
            }
        };
        DDiagram.prototype.render = function (newRenderer) {
            var _this = this;
            var _a;
            var oldRenderer = this._rendererBound;
            if (oldRenderer !== newRenderer) {
                var onPrerenderBound = ((_a = this._onPrerenderBound) !== null && _a !== void 0 ? _a : (this._onPrerenderBound = function (r) {
                    _this.onPrerender(r);
                }));
                if (oldRenderer != null) {
                    oldRenderer.off("prerender", onPrerenderBound);
                }
                this._rendererBound = newRenderer;
                if (newRenderer != null) {
                    newRenderer.on("prerender", onPrerenderBound);
                    var canvas = this._canvas;
                    if (canvas != null) {
                        // Request the update to call `canvas.onRender(Renderer)`
                        DApplications.update(this);
                    }
                }
            }
            _super.prototype.render.call(this, newRenderer);
        };
        DDiagram.prototype.destroy = function () {
            // Renderer
            var renderer = this._rendererBound;
            if (renderer != null) {
                this._rendererBound = undefined;
                var onPrerenderBound = this._onPrerenderBound;
                if (onPrerenderBound != null) {
                    renderer.off("prerender", onPrerenderBound);
                }
            }
            _super.prototype.destroy.call(this);
        };
        DDiagram.prototype.getType = function () {
            return "DDiagram";
        };
        return DDiagram;
    }(DDiagramBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActions = /** @class */ (function () {
        function EShapeActions() {
        }
        EShapeActions.isDiagram = function (target) {
            return target instanceof DDiagram;
        };
        EShapeActions.isEmbedded = function (target) {
            return target instanceof EShapeEmbedded;
        };
        EShapeActions.toDiagram = function (shape) {
            var current = shape;
            while (current != null) {
                if (this.isDiagram(current)) {
                    return current;
                }
                current = current.parent;
            }
            return null;
        };
        EShapeActions.open = function (shape, type, target, inNewWindow, environment) {
            var opener = EShapeActionOpenOpeners[type];
            if (opener != null) {
                var diagram = this.toDiagram(shape);
                if (diagram) {
                    opener(target, inNewWindow, shape, diagram, environment);
                }
            }
            else if (isString(target)) {
                switch (type) {
                    case DDiagramBaseControllerOpenType.DIAGRAM:
                        var diagram_1 = this.toDiagram(shape);
                        if (diagram_1) {
                            var controller = diagram_1.controller;
                            if (controller) {
                                controller.getByName(target).then(function (found) {
                                    diagram_1.set(DDiagrams.toSerialized(found));
                                });
                            }
                        }
                        break;
                    case DDiagramBaseControllerOpenType.PAGE:
                        if (inNewWindow) {
                            window.open(target);
                        }
                        else {
                            window.location.href = target;
                        }
                        break;
                }
            }
        };
        EShapeActions.writeLocal = function (shape, id, value, time, state) {
            var _a;
            if (state === void 0) { state = EShapeDataValueState.FOUND; }
            var current = shape;
            while (current != null) {
                if (this.isDiagram(current)) {
                    if (current.data.private.set(id, value, time, state)) {
                        DApplications.update(current);
                        return true;
                    }
                    else if (current.data.protected.set(id, value, time, state)) {
                        DApplications.update(current);
                        return true;
                    }
                    else {
                        if (current.data.set(id, value, time, state)) {
                            DApplications.update(current);
                            return true;
                        }
                    }
                    return false;
                }
                else if (this.isEmbedded(current)) {
                    if ((_a = current.data.getPrivate()) === null || _a === void 0 ? void 0 : _a.set(id, value, time, state)) {
                        DApplications.update(current);
                        return true;
                    }
                }
                current = current.parent;
            }
            return false;
        };
        EShapeActions.writeRemote = function (shape, id, value) {
            var diagram = this.toDiagram(shape);
            if (diagram) {
                return diagram.data.remote.set(id, value);
            }
            return false;
        };
        EShapeActions.emit = function (shape, name, value, time) {
            var diagram = EShapeActions.toDiagram(shape);
            if (time === undefined) {
                shape.emit(name, shape);
                if (diagram) {
                    diagram.shape.emit(name, shape);
                }
            }
            else {
                shape.emit(name, value, time, shape);
                if (diagram) {
                    diagram.shape.emit(name, value, time, shape);
                }
            }
        };
        return EShapeActions;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeEmitEvent = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeEmitEvent, _super);
        function EShapeActionRuntimeEmitEvent(value) {
            var _this = _super.call(this, value, EShapeRuntimeReset.NONE) || this;
            _this.name = EShapeActionExpressions.ofStringOrNull(value.name);
            return _this;
        }
        EShapeActionRuntimeEmitEvent.prototype.execute = function (shape, runtime, time) {
            if (this.condition(shape, time, EShapeActionEnvironment)) {
                var name_1 = this.name(shape, time, EShapeActionEnvironment);
                if (name_1 != null) {
                    EShapeActions.emit(shape, name_1);
                }
            }
        };
        return EShapeActionRuntimeEmitEvent;
    }(EShapeActionRuntimeConditional));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueEmitEvent = /** @class */ (function (_super) {
        __extends(EShapeActionValueEmitEvent, _super);
        function EShapeActionValueEmitEvent(condition, name) {
            var _this = _super.call(this, EShapeActionValueType.EMIT_EVENT, condition) || this;
            _this.name = name;
            return _this;
        }
        EShapeActionValueEmitEvent.prototype.isEquals = function (value) {
            return (_super.prototype.isEquals.call(this, value) &&
                value instanceof EShapeActionValueEmitEvent &&
                this.name === value.name);
        };
        EShapeActionValueEmitEvent.prototype.toRuntime = function () {
            return new EShapeActionRuntimeEmitEvent(this);
        };
        EShapeActionValueEmitEvent.prototype.serialize = function (manager) {
            var conditionId = manager.addResource(this.condition);
            var nameId = manager.addResource(this.name);
            return manager.addResource("[".concat(this.type, ",").concat(conditionId, ",").concat(nameId, "]"));
        };
        EShapeActionValueEmitEvent.deserialize = function (serialized, manager) {
            var condition = EShapeActionValues.toResource(1, serialized, manager.resources);
            var name = EShapeActionValues.toResource(2, serialized, manager.resources);
            return new EShapeActionValueEmitEvent(condition, name);
        };
        return EShapeActionValueEmitEvent;
    }(EShapeActionValueBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeMiscEmitEvent = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeMiscEmitEvent, _super);
        function EShapeActionRuntimeMiscEmitEvent(value) {
            var _this = _super.call(this, value, EShapeRuntimeReset.NONE) || this;
            _this.target = EShapeActionExpressions.ofStringOrNull(value.target);
            return _this;
        }
        EShapeActionRuntimeMiscEmitEvent.prototype.execute = function (shape, runtime, time) {
            if (this.condition(shape, time, EShapeActionEnvironment)) {
                var target = this.target(shape, time, EShapeActionEnvironment);
                if (target != null) {
                    EShapeActions.emit(shape, target);
                }
            }
        };
        return EShapeActionRuntimeMiscEmitEvent;
    }(EShapeActionRuntimeConditional));

    /*
     * Copyright (C) 2021 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DHtmlElementState = {
        NO_POINTER_EVENTS: "NO_POINTER_EVENTS"
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var UtilHtmlElementClipperExImpl = /** @class */ (function () {
        function UtilHtmlElementClipperExImpl(container) {
            var SVG_XMLNS = "http://www.w3.org/2000/svg";
            var element = document.createElementNS(SVG_XMLNS, "svg");
            element.setAttribute("style", "position: absolute;");
            element.setAttribute("width", "0px");
            element.setAttribute("height", "0px");
            var defs = document.createElementNS(SVG_XMLNS, "defs");
            var clipPath = document.createElementNS(SVG_XMLNS, "clipPath");
            var clipPathId = "clipper_ex_".concat(Math.random().toString(32).substring(2));
            clipPath.setAttribute("id", clipPathId);
            clipPath.setAttribute("clipPathUnits", "objectBoundingBox");
            var path = document.createElementNS(SVG_XMLNS, "path");
            this._path = path;
            this._pathD = "";
            path.setAttribute("clip-rule", "evenodd");
            clipPath.appendChild(path);
            defs.appendChild(clipPath);
            element.appendChild(defs);
            this._id = clipPathId;
            container.appendChild(element);
        }
        Object.defineProperty(UtilHtmlElementClipperExImpl.prototype, "id", {
            get: function () {
                return this._id;
            },
            enumerable: false,
            configurable: true
        });
        UtilHtmlElementClipperExImpl.prototype.update = function (elementRect, elementMatrix, clipperExRects) {
            var d = this.toD(elementRect, elementMatrix, clipperExRects);
            if (this._pathD != d) {
                this._path.setAttribute("d", d);
                this._pathD = d;
            }
        };
        UtilHtmlElementClipperExImpl.prototype.toD = function (elementRect, elementMatrix, clipperExRects) {
            var _a, _b;
            if (elementRect == null) {
                return "";
            }
            var w = elementRect.width;
            var h = elementRect.height;
            var threshold = 0.0001;
            if (w < threshold || h < threshold) {
                return "";
            }
            var clipperExRectsSize = clipperExRects.size;
            if (clipperExRectsSize <= 0) {
                return "M0,0 h1 v1 h-1z";
            }
            var matrix = ((_a = UtilHtmlElementClipperExImpl.WORK_MATRIX) !== null && _a !== void 0 ? _a : (UtilHtmlElementClipperExImpl.WORK_MATRIX = new pixi_js.Matrix()));
            if (elementMatrix != null) {
                matrix.copyFrom(elementMatrix);
                matrix.invert();
            }
            else {
                matrix.identity();
            }
            matrix.translate(-elementRect.x, -elementRect.y);
            matrix.scale(1 / w, 1 / h);
            var xmin = -1;
            var xmax = +2;
            var ymin = -1;
            var ymax = +2;
            var result = "";
            var a = matrix.a;
            var b = matrix.b;
            var c = matrix.c;
            var d = matrix.d;
            var tx = matrix.tx;
            var ty = matrix.ty;
            var rects = ((_b = UtilHtmlElementClipperExImpl.WORK_RECTS) !== null && _b !== void 0 ? _b : (UtilHtmlElementClipperExImpl.WORK_RECTS = []));
            var rectsLength = this.toRects(clipperExRects, rects);
            var precision = 5;
            for (var i = 0; i < rectsLength; i += 4) {
                var x0 = rects[i + 0];
                var y0 = rects[i + 1];
                var x1 = rects[i + 2];
                var y1 = rects[i + 3];
                var x2 = a * x0 + c * y0 + tx;
                var y2 = b * x0 + d * y0 + ty;
                var x3 = a * x1 + c * y0 + tx;
                var y3 = b * x1 + d * y0 + ty;
                var x4 = a * x1 + c * y1 + tx;
                var y4 = b * x1 + d * y1 + ty;
                var x5 = a * x0 + c * y1 + tx;
                var y5 = b * x0 + d * y1 + ty;
                xmin = Math.min(xmin, x2, x3, x4, x5);
                xmax = Math.max(xmax, x2, x3, x4, x5);
                ymin = Math.min(ymin, y2, y3, y4, y5);
                ymax = Math.max(ymax, y2, y3, y4, y5);
                var x2s = x2.toFixed(precision);
                var y2s = y2.toFixed(precision);
                var x3s = x3.toFixed(precision);
                var y3s = y3.toFixed(precision);
                var x4s = x4.toFixed(precision);
                var y4s = y4.toFixed(precision);
                var x5s = x5.toFixed(precision);
                var y5s = y5.toFixed(precision);
                result += " M".concat(x2s, ",").concat(y2s, " L").concat(x3s, ",").concat(y3s, " L").concat(x4s, ",").concat(y4s, " L").concat(x5s, ",").concat(y5s, "Z");
            }
            return "M".concat(xmin, ",").concat(ymin, " L").concat(xmax, ",").concat(ymin, " L").concat(xmax, ",").concat(ymax, " L").concat(xmin, ",").concat(ymax, "Z") + result;
        };
        UtilHtmlElementClipperExImpl.prototype.toRects = function (clipperExRects, result) {
            var data = clipperExRects.data;
            var size = clipperExRects.size;
            // Copy all rectangles
            var imax = size << 2;
            for (var i = 0; i < imax; i += 4) {
                var x0 = data[i + 0];
                var y0 = data[i + 1];
                var x1 = data[i + 2];
                var y1 = data[i + 3];
                if (x0 < x1) {
                    result[i + 0] = x0;
                    result[i + 2] = x1;
                }
                else {
                    result[i + 0] = x1;
                    result[i + 2] = x0;
                }
                if (y0 < y1) {
                    result[i + 1] = y0;
                    result[i + 3] = y1;
                }
                else {
                    result[i + 1] = y1;
                    result[i + 3] = y0;
                }
            }
            // Subdivide all rectangles if they have intersections
            for (var i = 4; i < imax; i += 4) {
                var x0 = result[i + 0];
                var y0 = result[i + 1];
                var x1 = result[i + 2];
                var y1 = result[i + 3];
                for (var j = 0; j < i; j += 4) {
                    var x2 = result[j + 0];
                    var y2 = result[j + 1];
                    var x3 = result[j + 2];
                    var y3 = result[j + 3];
                    // Check if there are intersections along the X axis.
                    // Here, ix represents which edges of the i-th rectangle are in the j-th rectangle as follows:
                    //
                    // * 0: No edge is in the j-th rectangle,
                    // * 1: The left edge is in the j-th rectangle,
                    // * 2: The right edge is in the j-th rectangle, and
                    // * 3: Both edges are in the j-th rectangle.
                    //
                    // The same spplies to the variable jx.
                    var ix = 0;
                    var jx = 0;
                    if (x0 <= x2) {
                        if (x1 <= x3) {
                            if (x1 <= x2) {
                                // x0--x1
                                //         x2--x3
                                // In this case, there is no intersection.
                                continue;
                            }
                            else {
                                // x0----x1
                                //    x2----x3
                                ix = 2;
                                jx = 1;
                            }
                        }
                        else {
                            // x0--------x1
                            //    x2--x3
                            jx = 3;
                        }
                    }
                    else {
                        if (x1 <= x3) {
                            //    x0--x1
                            // x2--------x3
                            ix = 3;
                        }
                        else {
                            if (x3 <= x0) {
                                //         x0--x1
                                // x2--x3
                                // In this case, there is no intersection.
                                continue;
                            }
                            else {
                                //    x0----x1
                                // x2----x3
                                ix = 1;
                                jx = 2;
                            }
                        }
                    }
                    // Check if there are intersections along the Y axis.
                    //
                    // * 0: No edge is in a rectangle,
                    // * 1: The bottom edge is in a rectangle,
                    // * 2: The top edge is in a rectangle, and
                    // * 3: Both edges are in a rectangle.
                    var iy = 0;
                    var jy = 0;
                    if (y0 <= y2) {
                        if (y1 <= y3) {
                            if (y1 <= y2) {
                                // y0--y1
                                //         y2--y3
                                // In this case, there is no intersection.
                                continue;
                            }
                            else {
                                // y0----y1
                                //    y2----y3
                                iy = 2;
                                jy = 1;
                            }
                        }
                        else {
                            // y0--------y1
                            //    y2--y3
                            jy = 3;
                        }
                    }
                    else {
                        if (y1 <= y3) {
                            //    y0--y1
                            // y2--------y3
                            iy = 3;
                        }
                        else {
                            if (y3 <= y0) {
                                //         y0--y1
                                // y2--y3
                                // In this case, there is no intersection.
                                continue;
                            }
                            else {
                                //    y0----y1
                                // y2----y3
                                iy = 1;
                                jy = 2;
                            }
                        }
                    }
                    // Count number of i-th rectangle vertices in j-th rectangle.
                    var ic = 0;
                    if (ix === 0 || iy === 0) {
                        ic = 0;
                    }
                    else if (ix === 1 || ix === 2) {
                        if (iy === 3) {
                            ic = 2;
                        }
                        else {
                            ic = 1;
                        }
                    }
                    else {
                        if (iy === 3) {
                            ic = 4;
                        }
                        else {
                            ic = 2;
                        }
                    }
                    // If all the vertices of the i-th rectangle are in j-th rectangle, remove the i-th rectangle.
                    if (ic === 4) {
                        if (i + 4 < imax) {
                            result[i + 0] = result[imax + 0];
                            result[i + 1] = result[imax + 1];
                            result[i + 2] = result[imax + 2];
                            result[i + 3] = result[imax + 3];
                        }
                        i -= 4;
                        imax -= 4;
                        break;
                    }
                    // Count number of j-th rectangle vertices in i-th rectangle.
                    var jc = 0;
                    if (jx === 0 || jy === 0) {
                        jc = 0;
                    }
                    else if (jx === 1 || jx === 2) {
                        if (jy === 3) {
                            jc = 2;
                        }
                        else {
                            jc = 1;
                        }
                    }
                    else {
                        if (jy === 3) {
                            jc = 4;
                        }
                        else {
                            jc = 2;
                        }
                    }
                    // If all the vertices of the j-th rectangle are in the i-th rectangle, remove the j-th rectangle.
                    if (jc === 4) {
                        for (var k = j + 4; k < imax; k += 4) {
                            result[k - 4] = result[k + 0];
                            result[k - 3] = result[k + 1];
                            result[k - 2] = result[k + 2];
                            result[k - 1] = result[k + 3];
                        }
                        i -= 4;
                        imax -= 4;
                        j -= 4;
                        continue;
                    }
                    // Other cases
                    if (ic === 0) {
                        if (jc === 0) {
                            for (var k = imax - 4; j < k; k -= 4) {
                                result[k + 4] = result[k + 0];
                                result[k + 5] = result[k + 1];
                                result[k + 6] = result[k + 2];
                                result[k + 7] = result[k + 3];
                            }
                            if (jx === 0) {
                                //      +-----+      y1
                                // +----|     |----+ y3
                                // | i  |  j  |    |
                                // +----|     |----+ y2
                                //      +-----+      y0
                                // x0   x2    x3   x1
                                result[j + 3] = y0;
                                result[j + 4] = x2;
                                result[j + 5] = y1;
                                result[j + 6] = x3;
                                result[j + 7] = y3;
                            }
                            else {
                                //      +-----+      y1
                                // +----|     |----+ y3
                                // | j  |  i  |    |
                                // +----|     |----+ y2
                                //      +-----+      y0
                                // x2   x0    x1   x3
                                result[j + 2] = x0;
                                result[j + 4] = x1;
                                result[j + 5] = y2;
                                result[j + 6] = x3;
                                result[j + 7] = y3;
                            }
                            i += 4;
                            imax += 4;
                            j += 4;
                        }
                        else if (jc === 2) {
                            if (jx === 1) {
                                // +---------+
                                // |         |-----+
                                // |    i    |  j  |
                                // |         |-----+
                                // +---------+
                                result[j + 0] = x1;
                            }
                            else if (jx === 2) {
                                //       +---------+
                                // +-----|         |
                                // |  j  |    i    |
                                // +-----|         |
                                //       +---------+
                                result[j + 2] = x0;
                            }
                            else if (jy === 1) {
                                //   +-----+
                                //   |  j  |
                                // +---------+
                                // |         |
                                // |    i    |
                                // |         |
                                // +---------+
                                result[j + 1] = y1;
                            }
                            else if (jy === 2) {
                                // +---------+
                                // |         |
                                // |    i    |
                                // |         |
                                // +---------+
                                //   |  j  |
                                //   +-----+
                                result[j + 3] = y0;
                            }
                        }
                    }
                    else if (ic === 1) {
                        for (var k = imax - 4; j < k; k -= 4) {
                            result[k + 4] = result[k + 0];
                            result[k + 5] = result[k + 1];
                            result[k + 6] = result[k + 2];
                            result[k + 7] = result[k + 3];
                        }
                        if (jx === 1) {
                            if (jy === 1) {
                                //         +---------+
                                //         |         |
                                //         |    j    |
                                // +---------+       |
                                // |         |-------+
                                // |    i    |
                                // |         |
                                // +---------+
                                result[j + 0] = x1;
                                result[j + 4] = x2;
                                result[j + 5] = y1;
                                result[j + 6] = x1;
                                result[j + 7] = y3;
                            }
                            else {
                                // +---------+
                                // |         |
                                // |    i    |
                                // |       +---------+
                                // +-------|         |
                                //         |    j    |
                                //         |         |
                                //         +---------+
                                result[j + 0] = x1;
                                result[j + 4] = x2;
                                result[j + 5] = y2;
                                result[j + 6] = x1;
                                result[j + 7] = y0;
                            }
                        }
                        else {
                            if (jy === 1) {
                                // +---------+
                                // |         |
                                // |    j    |
                                // |         |-------+
                                // +---------+       |
                                //         |    i    |
                                //         |         |
                                //         +---------+
                                result[j + 2] = x0;
                                result[j + 4] = x0;
                                result[j + 5] = y1;
                                result[j + 6] = x3;
                                result[j + 7] = y3;
                            }
                            else {
                                //         +---------+
                                //         |         |
                                //         |    i    |
                                // +---------+       |
                                // |         |-------+
                                // |    j    |
                                // |         |
                                // +---------+
                                result[j + 2] = x0;
                                result[j + 4] = x0;
                                result[j + 5] = y2;
                                result[j + 6] = x3;
                                result[j + 7] = y0;
                            }
                        }
                        i += 4;
                        imax += 4;
                        j += 4;
                    }
                    else if (ic === 2) {
                        if (ix === 1) {
                            // +---------+
                            // |         |-----+
                            // |    j    |  i  |
                            // |         |-----+
                            // +---------+
                            result[i + 0] = x3;
                            x0 = x3;
                        }
                        else if (ix === 2) {
                            //       +---------+
                            // +-----|         |
                            // |  i  |    j    |
                            // +-----|         |
                            //       +---------+
                            result[i + 2] = x2;
                            x1 = x2;
                        }
                        else if (iy === 1) {
                            //   +-----+
                            //   |  i  |
                            // +---------+
                            // |         |
                            // |    j    |
                            // |         |
                            // +---------+
                            result[i + 1] = y3;
                            y0 = y3;
                        }
                        else if (iy === 2) {
                            // +---------+
                            // |         |
                            // |    j    |
                            // |         |
                            // +---------+
                            //   |  i  |
                            //   +-----+
                            result[i + 3] = y2;
                            y1 = y2;
                        }
                    }
                }
            }
            return imax;
        };
        return UtilHtmlElementClipperExImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var UtilHtmlElementClipperExRectsImpl = /** @class */ (function () {
        function UtilHtmlElementClipperExRectsImpl() {
            this._data = [];
            this._size = 0;
            this._index = 0;
            this._isDirty = true;
        }
        Object.defineProperty(UtilHtmlElementClipperExRectsImpl.prototype, "data", {
            get: function () {
                return this._data;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UtilHtmlElementClipperExRectsImpl.prototype, "size", {
            get: function () {
                return this._size;
            },
            enumerable: false,
            configurable: true
        });
        UtilHtmlElementClipperExRectsImpl.prototype.isDirty = function () {
            return this._isDirty;
        };
        UtilHtmlElementClipperExRectsImpl.prototype.toClean = function () {
            this._isDirty = false;
        };
        UtilHtmlElementClipperExRectsImpl.prototype.begin = function () {
            this._index = 0;
            return this;
        };
        UtilHtmlElementClipperExRectsImpl.prototype.end = function () {
            var index = this._index;
            this._size = index;
            var data = this._data;
            var newDataLength = index << 2;
            if (data.length !== newDataLength) {
                data.length = newDataLength;
                this._isDirty = true;
            }
            return this;
        };
        UtilHtmlElementClipperExRectsImpl.prototype.add = function (x0, y0, x1, y1) {
            var index = this._index << 2;
            this._index += 1;
            var data = this._data;
            if (index < data.length) {
                if (data[index + 0] !== x0 ||
                    data[index + 1] !== y0 ||
                    data[index + 2] !== x1 ||
                    data[index + 3] !== y1) {
                    data[index + 0] = x0;
                    data[index + 1] = y0;
                    data[index + 2] = x1;
                    data[index + 3] = y1;
                    this._isDirty = true;
                }
            }
            else {
                data.push(x0, y0, x1, y1);
                this._isDirty = true;
            }
            return this;
        };
        return UtilHtmlElementClipperExRectsImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * {@link DHtmlElement} option when to show a HTML element
     */
    var UtilHtmlElementWhen = {
        /**
         * Shows a HTML element when clicked.
         */
        CLICKED: 0,
        /**
         * Shows a HTML element when double clicked.
         */
        DOUBLE_CLICKED: 1,
        /**
         * Shows a HTML element when focused.
         * And also shows when clicked if focused.
         */
        FOCUSED: 2,
        /**
         * Always shows a HTML element.
         */
        ALWAYS: 3
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var UtilHtmlElement = /** @class */ (function () {
        function UtilHtmlElement(target, operation, theme, options) {
            var _this = this;
            this._target = target;
            this._operation = operation;
            var data = this.toData(theme, options);
            this._data = data;
            this._isElementShown = false;
            this._onElementFocusBound = function (e) {
                _this.onElementFocus(e);
            };
            this._onBeforeFocusBound = function (e) {
                _this.onBeforeFocus(e);
            };
            this._onAfterFocusBound = function (e) {
                _this.onAfterFocus(e);
            };
            this._isStarted = false;
            this._wasStarted = false;
            this._doSelectBound = function () {
                _this.doSelect();
            };
            this._isStartRequested = this._data.when === UtilHtmlElementWhen.ALWAYS;
            this._onPostRenderBound = function () {
                _this.updateElement(_this._rendererBound);
            };
        }
        UtilHtmlElement.prototype.toData = function (theme, options) {
            var _a, _b;
            return {
                element: this.toElementData(theme, options === null || options === void 0 ? void 0 : options.element),
                clipper: this.toClipperData(theme, options === null || options === void 0 ? void 0 : options.clipper),
                before: this.toBeforeData(theme, options === null || options === void 0 ? void 0 : options.before),
                after: this.toAfterData(theme, options === null || options === void 0 ? void 0 : options.after),
                when: toEnum((_a = options === null || options === void 0 ? void 0 : options.when) !== null && _a !== void 0 ? _a : theme.getWhen(), UtilHtmlElementWhen),
                select: (_b = options === null || options === void 0 ? void 0 : options.select) !== null && _b !== void 0 ? _b : theme.getSelect()
            };
        };
        UtilHtmlElement.prototype.toElementData = function (theme, options) {
            var _a, _b;
            return {
                creator: (_a = options === null || options === void 0 ? void 0 : options.creator) !== null && _a !== void 0 ? _a : theme.getElementCreator(),
                styler: (_b = options === null || options === void 0 ? void 0 : options.styler) !== null && _b !== void 0 ? _b : this.newElementStyler(theme)
            };
        };
        UtilHtmlElement.prototype.newElementStyler = function (theme) {
            return function (target, state, padding, elementRect, elementMatrix, clipperRect, clipperEx) {
                return theme.setElementStyle(target, state, padding, elementRect, elementMatrix, clipperRect, clipperEx);
            };
        };
        UtilHtmlElement.prototype.toClipperData = function (theme, options) {
            var _a, _b, _c;
            return {
                creator: (_a = options === null || options === void 0 ? void 0 : options.creator) !== null && _a !== void 0 ? _a : theme.getClipperCreator(),
                styler: (_b = options === null || options === void 0 ? void 0 : options.styler) !== null && _b !== void 0 ? _b : this.newClipperStyler(theme),
                extended: (_c = options === null || options === void 0 ? void 0 : options.extended) !== null && _c !== void 0 ? _c : theme.isClipperExEnabled()
            };
        };
        UtilHtmlElement.prototype.newClipperStyler = function (theme) {
            return function (target, state, padding, elementRect, elementMatrix, clipperRect, clipperEx) {
                return theme.setClipperStyle(target, state, padding, elementRect, elementMatrix, clipperRect, clipperEx);
            };
        };
        UtilHtmlElement.prototype.toBeforeData = function (theme, options) {
            var _a, _b;
            return {
                creator: (_a = options === null || options === void 0 ? void 0 : options.creator) !== null && _a !== void 0 ? _a : theme.getBeforeCreator(),
                styler: (_b = options === null || options === void 0 ? void 0 : options.styler) !== null && _b !== void 0 ? _b : this.newBeforeStyler(theme)
            };
        };
        UtilHtmlElement.prototype.newBeforeStyler = function (theme) {
            return function (target) {
                theme.setBeforeStyle(target);
            };
        };
        UtilHtmlElement.prototype.toAfterData = function (theme, options) {
            var _a, _b;
            return {
                creator: (_a = options === null || options === void 0 ? void 0 : options.creator) !== null && _a !== void 0 ? _a : theme.getAfterCreator(),
                styler: (_b = options === null || options === void 0 ? void 0 : options.styler) !== null && _b !== void 0 ? _b : this.newAfterStyler(theme)
            };
        };
        UtilHtmlElement.prototype.newAfterStyler = function (theme) {
            return function (target) {
                theme.setAfterStyle(target);
            };
        };
        Object.defineProperty(UtilHtmlElement.prototype, "element", {
            get: function () {
                var _a;
                return (_a = this._element) !== null && _a !== void 0 ? _a : null;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UtilHtmlElement.prototype, "when", {
            get: function () {
                return this._data.when;
            },
            enumerable: false,
            configurable: true
        });
        UtilHtmlElement.prototype.onDowning = function (e) {
            this._wasStarted = this._isStarted;
            switch (this.when) {
                case UtilHtmlElementWhen.CLICKED:
                    this.start();
                    break;
                case UtilHtmlElementWhen.FOCUSED:
                    if (this._target.state.isFocused) {
                        this.start();
                    }
                    break;
            }
        };
        UtilHtmlElement.prototype.onDown = function (e) {
            if (!this._wasStarted && this._isStarted) {
                if ("data" in e) {
                    e.data.originalEvent.preventDefault();
                }
                else {
                    e.preventDefault();
                }
            }
        };
        UtilHtmlElement.prototype.onDblClick = function (e, interactionManager) {
            switch (this.when) {
                case UtilHtmlElementWhen.DOUBLE_CLICKED:
                    this.start();
                    break;
            }
        };
        UtilHtmlElement.prototype.onFocus = function () {
            var _a;
            switch (this.when) {
                case UtilHtmlElementWhen.FOCUSED:
                    this.start();
                    break;
                default:
                    (_a = this._element) === null || _a === void 0 ? void 0 : _a.focus();
                    break;
            }
        };
        UtilHtmlElement.prototype.onBlur = function () {
            var _a;
            switch (this.when) {
                case UtilHtmlElementWhen.CLICKED:
                case UtilHtmlElementWhen.DOUBLE_CLICKED:
                case UtilHtmlElementWhen.FOCUSED:
                    this.onEndByBlur();
                    this.cancel();
                    break;
                default:
                    (_a = this._element) === null || _a === void 0 ? void 0 : _a.blur();
                    break;
            }
        };
        UtilHtmlElement.prototype.isStartable = function () {
            switch (this.when) {
                case UtilHtmlElementWhen.CLICKED:
                case UtilHtmlElementWhen.DOUBLE_CLICKED:
                case UtilHtmlElementWhen.FOCUSED:
                    return this._target.state.isActionable;
                default:
                    return true;
            }
        };
        UtilHtmlElement.prototype.start = function () {
            if (!this._isStarted && this.isStartable()) {
                this._isStarted = true;
                if (this._target.worldVisible) {
                    this.doStart();
                }
                else {
                    this._isStartRequested = true;
                }
                DApplications.update(this._target);
            }
        };
        UtilHtmlElement.prototype.isShown = function () {
            return this._isElementShown;
        };
        UtilHtmlElement.prototype.onRender = function (renderer) {
            if (this._isStartRequested ||
                (!this._isElementShown && this.when === UtilHtmlElementWhen.ALWAYS)) {
                this._isStartRequested = false;
                this.doStart(renderer);
            }
            if (this._isStarted) {
                this._isStarted = false;
            }
        };
        UtilHtmlElement.prototype.getElementRect = function (resolution) {
            var point = this._point || new pixi_js.Point(0, 0);
            this._point = point;
            var result = this._elementRectResult || new pixi_js.Rectangle();
            this._elementRectResult = result;
            return this._operation.getElementRect(resolution, point, result);
        };
        UtilHtmlElement.prototype.getElementMatrix = function () {
            return this._operation.getElementMatrix();
        };
        UtilHtmlElement.prototype.getClipperRect = function (resolution) {
            var point = this._point || new pixi_js.Point(0, 0);
            this._point = point;
            var result = this._clipperRectResult || new pixi_js.Rectangle();
            this._clipperRectResult = result;
            return this._operation.getClipperRect(resolution, point, result);
        };
        UtilHtmlElement.prototype.fillClipperExRects = function (resolution, result) {
            var operation = this._operation;
            if (operation.getClipperExRects) {
                operation.getClipperExRects(result);
            }
            return result.isDirty();
        };
        UtilHtmlElement.prototype.doStart = function (renderer) {
            var _a, _b;
            if (!this._isElementShown) {
                this._isElementShown = true;
                var rendererBound = this._rendererBound;
                if (rendererBound != null) {
                    this._rendererBound = undefined;
                    rendererBound.off("postrender", this._onPostRenderBound);
                }
                var target = this._target;
                if (renderer == null) {
                    renderer = (_a = DApplications.getLayer(target)) === null || _a === void 0 ? void 0 : _a.renderer;
                }
                if (renderer) {
                    this._rendererBound = renderer;
                    renderer.on("postrender", this._onPostRenderBound);
                }
                this.onStart();
                var clipper = this.getClipper();
                if (clipper) {
                    var before = this.getBefore(clipper);
                    var element = this.getElement(clipper);
                    var after = this.getAfter(clipper);
                    var clipperEx = this.getClipperEx(clipper);
                    if (element) {
                        var resolution = (_b = renderer === null || renderer === void 0 ? void 0 : renderer.resolution) !== null && _b !== void 0 ? _b : DApplications.getResolution(target);
                        var elementRect = this.getElementRect(resolution);
                        var elementMatrix = this.getElementMatrix();
                        var clipperRect = this.toClipperRectAdjusted(elementRect, elementMatrix, this.getClipperRect(resolution));
                        var state = target.state;
                        var padding = this._operation.getPadding();
                        var options = this._data;
                        options.clipper.styler(clipper, state, padding, elementRect, elementMatrix, clipperRect, clipperEx);
                        options.element.styler(element, state, padding, elementRect, elementMatrix, clipperRect, clipperEx);
                        if (before) {
                            options.before.styler(before);
                        }
                        if (after) {
                            options.after.styler(after);
                        }
                        this.onElementAttached(element, before, after);
                        if (clipperEx) {
                            var clipperExRects = this.getClipperExRects();
                            if (clipperExRects) {
                                if (this.fillClipperExRects(resolution, clipperExRects)) {
                                    clipperEx.update(elementRect, elementMatrix, clipperExRects);
                                    clipperExRects.toClean();
                                }
                            }
                        }
                        // Show HTML elements
                        clipper.style.display = "";
                        if (state.isFocused) {
                            this.toElementFocused(element);
                        }
                        clipper.scrollTop = 0;
                        clipper.scrollLeft = 0;
                        // Select the element if required.
                        // Note that a selecting without the setTimeout causes a key stroke drop on Microsoft Edge.
                        if (this._data.select) {
                            setTimeout(this._doSelectBound, 0);
                        }
                    }
                }
            }
        };
        UtilHtmlElement.prototype.toElementFocused = function (element) {
            element.focus({
                preventScroll: true
            });
        };
        UtilHtmlElement.prototype.onStart = function () {
            this._operation.onStart();
        };
        UtilHtmlElement.prototype.doSelect = function () {
            var element = this._element;
            if (element) {
                if (element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement) {
                    // The following does not work on mobile devices.
                    // I think selecting texts on a tap is annoying.
                    // Therefore, I leave this untouched.
                    element.select();
                }
            }
        };
        UtilHtmlElement.prototype.cancel = function () {
            var _a;
            if (this._isElementShown) {
                this._isElementShown = false;
                var rendererBound = this._rendererBound;
                if (rendererBound != null) {
                    this._rendererBound = undefined;
                    rendererBound.off("postrender", this._onPostRenderBound);
                }
                this.onCancel();
                var target = this._target;
                var layer = DApplications.getLayer(target);
                if (layer) {
                    var view = layer.view;
                    switch (this.when) {
                        case UtilHtmlElementWhen.CLICKED:
                        case UtilHtmlElementWhen.DOUBLE_CLICKED:
                        case UtilHtmlElementWhen.FOCUSED:
                            if (document.activeElement === this._element) {
                                view.focus();
                            }
                            break;
                    }
                    var state = target.state;
                    var interactionManager = layer.renderer.plugins.interaction;
                    if (this._operation.containsPoint(interactionManager.mouse.global) &&
                        !state.isHovered) {
                        state.isHovered = true;
                        view.style.cursor = (_a = target.cursor) !== null && _a !== void 0 ? _a : "";
                    }
                    layer.update();
                }
                var element = this._element;
                if (element != null) {
                    this.onElementDetached(element, this._before, this._after);
                }
                var clipper = this._clipper;
                if (clipper != null) {
                    clipper.style.display = "none";
                }
            }
        };
        UtilHtmlElement.prototype.onCancel = function () {
            this._operation.onCancel();
        };
        UtilHtmlElement.prototype.onElementAttached = function (element, before, after) {
            before === null || before === void 0 ? void 0 : before.addEventListener("focus", this._onBeforeFocusBound);
            after === null || after === void 0 ? void 0 : after.addEventListener("focus", this._onAfterFocusBound);
            element.addEventListener("focus", this._onElementFocusBound, true);
        };
        UtilHtmlElement.prototype.onElementDetached = function (element, before, after) {
            before === null || before === void 0 ? void 0 : before.removeEventListener("focus", this._onBeforeFocusBound);
            after === null || after === void 0 ? void 0 : after.removeEventListener("focus", this._onAfterFocusBound);
            element.removeEventListener("focus", this._onElementFocusBound, true);
        };
        UtilHtmlElement.prototype.getClipper = function () {
            var result = this._clipper;
            if (result == null) {
                var layer = DApplications.getLayer(this._target);
                result = layer ? this._data.clipper.creator(layer.getElementContainer()) : null;
                this._clipper = result;
            }
            return result;
        };
        UtilHtmlElement.prototype.getClipperEx = function (clipper) {
            var result = this._clipperEx;
            if (result === undefined) {
                var clipperExRects = this.getClipperExRects();
                if (clipperExRects != null) {
                    result = new UtilHtmlElementClipperExImpl(clipper);
                }
                else {
                    result = null;
                }
                this._clipperEx = result;
            }
            return result;
        };
        UtilHtmlElement.prototype.getClipperExRects = function () {
            var result = this._clipperExRects;
            if (result === undefined) {
                if (this._data.clipper.extended) {
                    result = new UtilHtmlElementClipperExRectsImpl();
                }
                else {
                    result = null;
                }
                this._clipperExRects = result;
            }
            return result;
        };
        UtilHtmlElement.prototype.getElement = function (clipper) {
            var result = this._element;
            if (result == null) {
                result = this._data.element.creator(clipper);
                this._element = result;
            }
            return result;
        };
        UtilHtmlElement.prototype.getBefore = function (clipper) {
            var result = this._before;
            if (result == null) {
                result = this._data.before.creator(clipper);
                this._before = result;
            }
            return result;
        };
        UtilHtmlElement.prototype.getAfter = function (clipper) {
            var result = this._after;
            if (result == null) {
                result = this._data.after.creator(clipper);
                this._after = result;
            }
            return result;
        };
        UtilHtmlElement.prototype.onBeforeFocus = function (e) {
            var target = this._target;
            var layer = DApplications.getLayer(target);
            if (layer) {
                var focusController = layer.getFocusController();
                var focusable = focusController.find(target, false, false, false);
                layer.view.focus();
                focusController.focus(focusable);
                e.preventDefault();
                e.stopImmediatePropagation();
            }
        };
        UtilHtmlElement.prototype.onAfterFocus = function (e) {
            var target = this._target;
            var layer = DApplications.getLayer(target);
            if (layer) {
                var focusController = layer.getFocusController();
                var focusable = focusController.find(target, false, false, true);
                layer.view.focus();
                focusController.focus(focusable);
                e.preventDefault();
                e.stopImmediatePropagation();
            }
        };
        UtilHtmlElement.prototype.onElementFocus = function (e) {
            if (this.when === UtilHtmlElementWhen.ALWAYS) {
                var target = this._target;
                if (!target.state.isFocused) {
                    target.focus();
                }
            }
        };
        UtilHtmlElement.prototype.onEndByBlur = function () {
            this.onEnd();
        };
        UtilHtmlElement.prototype.onEnd = function () {
            this._operation.onEnd();
        };
        UtilHtmlElement.prototype.end = function () {
            this.onEnd();
            this.cancel();
        };
        UtilHtmlElement.prototype.select = function () {
            if (this._isElementShown && this._data.select) {
                this.doSelect();
            }
            return this;
        };
        UtilHtmlElement.prototype.toClipperRectAdjusted = function (elementRect, elementMatrix, clipperRect) {
            if (clipperRect && elementRect && elementMatrix == null) {
                var ex0 = elementRect.x;
                var ey0 = elementRect.y;
                var ex1 = ex0 + elementRect.width;
                var ey1 = ey0 + elementRect.height;
                var cx0 = clipperRect.x;
                var cy0 = clipperRect.y;
                var cx1 = cx0 + clipperRect.width;
                var cy1 = cy0 + clipperRect.height;
                var ncx0 = Math.min(Math.max(cx0, ex0), cx1);
                var ncx1 = Math.min(Math.max(cx0, ex1), cx1);
                var ncy0 = Math.min(Math.max(cy0, ey0), cy1);
                var ncy1 = Math.min(Math.max(cy0, ey1), cy1);
                clipperRect.x = ncx0;
                clipperRect.y = ncy0;
                clipperRect.width = ncx1 - ncx0;
                clipperRect.height = ncy1 - ncy0;
            }
            return clipperRect;
        };
        UtilHtmlElement.prototype.updateElement = function (renderer) {
            if (this._isElementShown) {
                var target = this._target;
                if (target.worldVisible) {
                    var element = this._element;
                    var clipper = this._clipper;
                    var clipperEx = this._clipperEx;
                    if (element && clipper) {
                        var resolution = renderer.resolution;
                        var elementRect = this.getElementRect(resolution);
                        var elementMatrix = this.getElementMatrix();
                        var clipperRect = this.toClipperRectAdjusted(elementRect, elementMatrix, this.getClipperRect(resolution));
                        var state = target.state;
                        var padding = this._operation.getPadding();
                        var options = this._data;
                        options.clipper.styler(clipper, state, padding, elementRect, elementMatrix, clipperRect, clipperEx);
                        options.element.styler(element, state, padding, elementRect, elementMatrix, clipperRect, clipperEx);
                        if (clipperEx) {
                            var clipperExRects = this.getClipperExRects();
                            if (clipperExRects) {
                                if (this.fillClipperExRects(resolution, clipperExRects)) {
                                    clipperEx.update(elementRect, elementMatrix, clipperExRects);
                                    clipperExRects.toClean();
                                }
                            }
                        }
                    }
                }
                else {
                    switch (this.when) {
                        case UtilHtmlElementWhen.ALWAYS:
                            var clipper = this._clipper;
                            if (clipper) {
                                clipper.style.display = "none";
                            }
                            break;
                        default:
                            this.cancel();
                            break;
                    }
                }
            }
        };
        UtilHtmlElement.getClipperRect = function (parent, target, resolution, point, result) {
            var isFirst = true;
            var x0 = 0;
            var y0 = 0;
            var x1 = 0;
            var y1 = 0;
            var current = parent;
            while (current instanceof DBase) {
                current.getClippingRect(target, result);
                point.set(result.x, result.y);
                current.toGlobal(point, point, false);
                var cx0 = ((point.x * resolution) | 0) / resolution;
                var cy0 = ((point.y * resolution) | 0) / resolution;
                point.set(result.x + result.width, result.y + result.height);
                current.toGlobal(point, point, true);
                var cx1 = point.x;
                var cy1 = point.y;
                var dx0 = Math.min(cx0, cx1);
                var dy0 = Math.min(cy0, cy1);
                var dx1 = Math.max(cx0, cx1);
                var dy1 = Math.max(cy0, cy1);
                if (isFirst) {
                    isFirst = false;
                    x0 = dx0;
                    y0 = dy0;
                    x1 = dx1;
                    y1 = dy1;
                }
                else {
                    x0 = Math.min(Math.max(x0, dx0), dx1);
                    y0 = Math.min(Math.max(y0, dy0), dy1);
                    x1 = Math.min(Math.max(x1, dx0), dx1);
                    y1 = Math.min(Math.max(y1, dy0), dy1);
                }
                current = current.parent;
            }
            if (isFirst) {
                return null;
            }
            result.x = x0;
            result.y = y0;
            result.width = x1 - x0;
            result.height = y1 - y0;
            return result;
        };
        return UtilHtmlElement;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var _isShapeClipperExLoaded = false;
    var loadShapeClipperEx = function () {
        _isShapeClipperExLoaded = true;
    };
    var isShapeClipperExLoaded = function () {
        return _isShapeClipperExLoaded;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeMiscHtmlElementBase = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeMiscHtmlElementBase, _super);
        function EShapeActionRuntimeMiscHtmlElementBase(value) {
            var _this = _super.call(this) || this;
            _this.condition = EShapeActionExpressions.ofString(value.condition);
            _this.utils = new Map();
            return _this;
        }
        EShapeActionRuntimeMiscHtmlElementBase.prototype.getUtil = function (shape, runtime) {
            var utils = this.utils;
            var result = utils.get(shape);
            if (result == null) {
                result = this.newUtil(shape, runtime);
                utils.set(shape, result);
            }
            return result;
        };
        EShapeActionRuntimeMiscHtmlElementBase.prototype.newUtil = function (shape, runtime) {
            return new UtilHtmlElement(shape, this.newOperation(shape, runtime), DThemes.getInstance().get("DHtmlElement"), this.newUtilOptions(shape, runtime));
        };
        EShapeActionRuntimeMiscHtmlElementBase.prototype.newOperation = function (shape, runtime) {
            var _this = this;
            return {
                getElementRect: function (resolution, work, result) {
                    return _this.getElementRect(shape, runtime, resolution, work, result);
                },
                getElementMatrix: function () {
                    return _this.getElementMatrix(shape, runtime);
                },
                getClipperRect: function (resolution, work, result) {
                    return _this.getClipperToRect(shape, runtime, resolution, work, result);
                },
                getClipperExRects: function (result) {
                    _this.getClipperExRects(shape, result);
                },
                getPadding: function () {
                    return _this.getPadding(shape, runtime);
                },
                containsPoint: function (point) {
                    return _this.containsPoint(shape, runtime, point);
                },
                onStart: function () {
                    // DO NOTHING
                },
                onCancel: function () {
                    // DO NOTHING
                },
                onEnd: function () {
                    // DO NOTHING
                }
            };
        };
        EShapeActionRuntimeMiscHtmlElementBase.prototype.newUtilOptions = function (shape, runtime) {
            return {
                element: {
                    creator: this.newElementCreator(shape, runtime)
                },
                when: this.toWhen(shape, runtime),
                clipper: {
                    extended: isShapeClipperExLoaded()
                }
            };
        };
        EShapeActionRuntimeMiscHtmlElementBase.prototype.toWhen = function (shape, runtime) {
            var value = this.condition(shape, Date.now(), EShapeActionEnvironment);
            if (value != null && value in UtilHtmlElementWhen) {
                return UtilHtmlElementWhen[value];
            }
            return undefined;
        };
        EShapeActionRuntimeMiscHtmlElementBase.prototype.containsPoint = function (shape, runtime, point) {
            var _a;
            if (shape.visible) {
                var local = ((_a = EShapeActionRuntimeMiscHtmlElementBase.WORK) !== null && _a !== void 0 ? _a : (EShapeActionRuntimeMiscHtmlElementBase.WORK = new pixi_js.Point()));
                shape.toLocal(point, undefined, local);
                return shape.contains(local.x, local.y) != null;
            }
            return false;
        };
        EShapeActionRuntimeMiscHtmlElementBase.prototype.getPadding = function (shape, runtime) {
            return null;
        };
        EShapeActionRuntimeMiscHtmlElementBase.prototype.getElementRect = function (shape, runtime, resolution, point, result) {
            var pivot = shape.transform.pivot;
            var size = shape.size;
            var sizeX = size.x;
            var sizeY = size.y;
            result.x = -0.5 * sizeX + pivot.x;
            result.y = -0.5 * sizeY + pivot.y;
            result.width = sizeX;
            result.height = sizeY;
            return result;
        };
        EShapeActionRuntimeMiscHtmlElementBase.prototype.getElementMatrix = function (shape, runtime) {
            shape.updateTransform();
            return shape.transform.worldTransform;
        };
        EShapeActionRuntimeMiscHtmlElementBase.prototype.getClipperToRect = function (shape, runtime, resolution, point, result) {
            var diagram = EShapeActions.toDiagram(shape);
            return UtilHtmlElement.getClipperRect(diagram, shape, resolution, point, result);
        };
        EShapeActionRuntimeMiscHtmlElementBase.prototype.getClipperExRects = function (shape, result) {
            result.begin();
            var target = shape.root.parent;
            if (target instanceof DDiagramLayer) {
                var layerContainer = target.parent;
                if (layerContainer != null) {
                    var layers = layerContainer.children;
                    var index = layers.indexOf(target);
                    if (0 <= index) {
                        for (var i = index + 1, imax = layers.length; i < imax; ++i) {
                            var layer = layers[i];
                            if (layer.visible) {
                                var w = layer.width;
                                var h = layer.height;
                                var t = layer.transform.worldTransform;
                                var a = t.a;
                                var b = t.b;
                                var c = t.c;
                                var d = t.d;
                                var tx = t.tx;
                                var ty = t.ty;
                                result.add(tx, ty, a * w + c * h + tx, b * w + d * h + ty);
                            }
                        }
                    }
                }
            }
            result.end();
        };
        EShapeActionRuntimeMiscHtmlElementBase.prototype.onRender = function (shape, runtime, time, renderer) {
            this.getUtil(shape, runtime).onRender(renderer);
        };
        EShapeActionRuntimeMiscHtmlElementBase.prototype.onFocus = function (shape, runtime) {
            this.getUtil(shape, runtime).onFocus();
        };
        EShapeActionRuntimeMiscHtmlElementBase.prototype.onBlur = function (shape, runtime) {
            this.getUtil(shape, runtime).onBlur();
        };
        EShapeActionRuntimeMiscHtmlElementBase.prototype.onDowning = function (shape, runtime, e) {
            this.getUtil(shape, runtime).onDowning(e);
        };
        EShapeActionRuntimeMiscHtmlElementBase.prototype.onDown = function (shape, runtime, e) {
            this.getUtil(shape, runtime).onDown(e);
        };
        EShapeActionRuntimeMiscHtmlElementBase.prototype.onDblClick = function (shape, runtime, e, interactionManager) {
            this.getUtil(shape, runtime).onDblClick(e, interactionManager);
        };
        return EShapeActionRuntimeMiscHtmlElementBase;
    }(EShapeActionRuntimeBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeMiscHtmlElement = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeMiscHtmlElement, _super);
        function EShapeActionRuntimeMiscHtmlElement(value) {
            var _this = _super.call(this, value) || this;
            _this.elementCreator = EShapeActionExpressions.ofElementOrNull(value.value);
            _this.noPointerEvent =
                value.subtype === EShapeActionValueMiscType.HTML_ELEMENT_WITHOUT_POINTER_EVENTS;
            return _this;
        }
        EShapeActionRuntimeMiscHtmlElement.prototype.newUtil = function (shape, runtime) {
            if (this.noPointerEvent) {
                shape.state.add(DHtmlElementState.NO_POINTER_EVENTS);
            }
            return _super.prototype.newUtil.call(this, shape, runtime);
        };
        EShapeActionRuntimeMiscHtmlElement.prototype.newElementCreator = function (shape, runtime) {
            var elementCreator = this.elementCreator;
            if (elementCreator) {
                return function (container) {
                    return elementCreator(shape, Date.now(), EShapeActionEnvironment, container);
                };
            }
            return undefined;
        };
        return EShapeActionRuntimeMiscHtmlElement;
    }(EShapeActionRuntimeMiscHtmlElementBase));

    /*
     * Copyright (C) 2021 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var UtilInput = /** @class */ (function (_super) {
        __extends(UtilInput, _super);
        function UtilInput(target, operation, theme, options) {
            var _a, _b, _c, _d, _e, _f;
            var _this = _super.call(this, target, operation, theme, options) || this;
            _this._operation = operation;
            _this._onInputKeyDownBound = function (e) {
                _this.onInputKeyDown(e);
            };
            _this._onInputChangeBound = function () {
                _this.onInputChange();
            };
            _this._onInputInputBound = function (e) {
                _this.onInputInput(e);
            };
            _this._description = (_a = options === null || options === void 0 ? void 0 : options.description) !== null && _a !== void 0 ? _a : "";
            var editing = options === null || options === void 0 ? void 0 : options.editing;
            _this._editingFormatter =
                (_d = (_b = editing === null || editing === void 0 ? void 0 : editing.formatter) !== null && _b !== void 0 ? _b : (_c = options === null || options === void 0 ? void 0 : options.text) === null || _c === void 0 ? void 0 : _c.formatter) !== null && _d !== void 0 ? _d : theme.getEditingFormatter();
            _this._editingUnformatter = (_e = editing === null || editing === void 0 ? void 0 : editing.unformatter) !== null && _e !== void 0 ? _e : theme.getEditingUnformatter();
            _this._editingValidator = (_f = editing === null || editing === void 0 ? void 0 : editing.validator) !== null && _f !== void 0 ? _f : theme.getEditingValidator();
            return _this;
        }
        UtilInput.prototype.onEnd = function () {
            _super.prototype.onEnd.call(this);
            this.onInputChange();
        };
        UtilInput.prototype.onElementAttached = function (element, before, after) {
            element.value = this.fromValue(this._operation.getValue());
            element.addEventListener("change", this._onInputChangeBound);
            element.addEventListener("input", this._onInputInputBound);
            _super.prototype.onElementAttached.call(this, element, before, after);
        };
        UtilInput.prototype.onElementDetached = function (element, before, after) {
            _super.prototype.onElementDetached.call(this, element, before, after);
            element.removeEventListener("change", this._onInputChangeBound);
            element.removeEventListener("input", this._onInputInputBound);
        };
        UtilInput.prototype.onInputKeyDown = function (e) {
            if (UtilKeyboardEvent.isOkKey(e)) {
                this.end();
                this._operation.onEnter();
            }
            else if (UtilKeyboardEvent.isCancelKey(e)) {
                this.cancel();
            }
        };
        UtilInput.prototype.toElementFocused = function (element) {
            _super.prototype.toElementFocused.call(this, element);
            element.scrollTop = 0;
            element.scrollLeft = 0;
        };
        UtilInput.prototype.onInputChange = function () {
            if (this.isShown()) {
                var element = this.element;
                if (element != null) {
                    var operation = this._operation;
                    var newValue = this.toValue(element.value);
                    var oldValue = operation.getValue();
                    if (oldValue !== newValue) {
                        operation.onValueChange(newValue, oldValue);
                    }
                }
            }
        };
        UtilInput.prototype.toValue = function (valueAsString) {
            return this._editingUnformatter(valueAsString, this);
        };
        UtilInput.prototype.fromValue = function (value) {
            if (value !== undefined) {
                return this._editingFormatter(value, this);
            }
            return "";
        };
        UtilInput.prototype.onInputInput = function (e) {
            var target = e.target;
            if (target instanceof HTMLInputElement || target instanceof HTMLTextAreaElement) {
                this._operation.onValueInput(this.toValue(target.value));
            }
        };
        UtilInput.prototype.validate = function () {
            var value = this._operation.getValue();
            if (value !== undefined) {
                var result = this._editingValidator(value, this);
                if (this._editingValidationResult !== result) {
                    this._editingValidationResult = result;
                    var state = this._target.state;
                    state.isInvalid = result != null;
                    if (state.isHovered) {
                        this._operation.applyTitle();
                    }
                }
                return result;
            }
            return null;
        };
        UtilInput.prototype.applyTitle = function () {
            var editingValidationResult = this._editingValidationResult;
            if (isString(editingValidationResult)) {
                var layer = DApplications.getLayer(this._target);
                if (layer) {
                    layer.view.title = editingValidationResult;
                }
                return true;
            }
            return false;
        };
        return UtilInput;
    }(UtilHtmlElement));

    /*
     * Copyright (C) 2021 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var UtilInputInput = /** @class */ (function (_super) {
        __extends(UtilInputInput, _super);
        function UtilInputInput() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        UtilInputInput.prototype.onElementAttached = function (element, before, after) {
            element.addEventListener("keydown", this._onInputKeyDownBound);
            _super.prototype.onElementAttached.call(this, element, before, after);
        };
        UtilInputInput.prototype.onElementDetached = function (element, before, after) {
            element.removeEventListener("keydown", this._onInputKeyDownBound);
            _super.prototype.onElementDetached.call(this, element, before, after);
        };
        return UtilInputInput;
    }(UtilInput));

    /*
     * Copyright (C) 2021 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var UtilInputNumber = /** @class */ (function (_super) {
        __extends(UtilInputNumber, _super);
        function UtilInputNumber(target, operation, theme, options) {
            var _a, _b, _c;
            var _this = _super.call(this, target, operation, theme, options) || this;
            _this._step = (_a = options === null || options === void 0 ? void 0 : options.step) !== null && _a !== void 0 ? _a : theme.getStep();
            _this._min = (_b = options === null || options === void 0 ? void 0 : options.min) !== null && _b !== void 0 ? _b : theme.getMin();
            _this._max = (_c = options === null || options === void 0 ? void 0 : options.max) !== null && _c !== void 0 ? _c : theme.getMax();
            return _this;
        }
        Object.defineProperty(UtilInputNumber.prototype, "step", {
            get: function () {
                return this._step;
            },
            set: function (step) {
                if (this._step !== step) {
                    this._step = step;
                    this.onStepChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UtilInputNumber.prototype, "min", {
            get: function () {
                return this._min;
            },
            set: function (min) {
                if (this._min !== min) {
                    this._min = min;
                    this.onMinChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UtilInputNumber.prototype, "max", {
            get: function () {
                return this._max;
            },
            set: function (max) {
                if (this._max !== max) {
                    this._max = max;
                    this.onMaxChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        UtilInputNumber.prototype.toValue = function (valueAsString) {
            var result = _super.prototype.toValue.call(this, valueAsString);
            if (result === result /* NaN Check */) {
                var min = this._min;
                if (min != null && result < min) {
                    return min;
                }
                var max = this._max;
                if (max != null && max < result) {
                    return max;
                }
                return result;
            }
            return 0;
        };
        UtilInputNumber.prototype.fromValue = function (value) {
            if (value !== undefined) {
                return this._editingFormatter(value, this);
            }
            return "0";
        };
        UtilInputNumber.prototype.onStepChange = function () {
            if (this.isShown()) {
                var element = this.element;
                if (element) {
                    this.updateStep(element);
                }
            }
        };
        UtilInputNumber.prototype.onMinChange = function () {
            if (this.isShown()) {
                var element = this.element;
                if (element) {
                    this.updateMin(element);
                }
            }
        };
        UtilInputNumber.prototype.onMaxChange = function () {
            if (this.isShown()) {
                var element = this.element;
                if (element) {
                    this.updateMax(element);
                }
            }
        };
        UtilInputNumber.prototype.updateStep = function (input) {
            var step = this.step;
            if (step != null) {
                input.step = "".concat(step);
            }
            else {
                input.step = "any";
            }
        };
        UtilInputNumber.prototype.updateMin = function (input) {
            var min = this.min;
            if (min != null) {
                input.min = "".concat(min);
            }
            else {
                input.removeAttribute("min");
            }
        };
        UtilInputNumber.prototype.updateMax = function (input) {
            var max = this.max;
            if (max != null) {
                input.max = "".concat(max);
            }
            else {
                input.removeAttribute("max");
            }
        };
        UtilInputNumber.prototype.onElementAttached = function (element, before, after) {
            element.type = "number";
            _super.prototype.onElementAttached.call(this, element, before, after);
            this.updateStep(element);
            this.updateMin(element);
            this.updateMax(element);
        };
        return UtilInputNumber;
    }(UtilInputInput));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueOnInputAction = {
        EMIT_EVENT: 0,
        WRITE_BOTH: 1,
        WRITE_LOCAL: 2,
        WRITE_REMOTE: 3
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueOnInputActions = /** @class */ (function () {
        function EShapeActionValueOnInputActions() {
        }
        EShapeActionValueOnInputActions.execute = function (shape, action, target, value, time) {
            switch (action) {
                case EShapeActionValueOnInputAction.EMIT_EVENT:
                    shape.emit(target, shape, value);
                    EShapeActions.emit(shape, target, value, time);
                    break;
                case EShapeActionValueOnInputAction.WRITE_LOCAL:
                    EShapeActions.writeLocal(shape, target, value, time);
                    break;
                case EShapeActionValueOnInputAction.WRITE_REMOTE:
                    EShapeActions.writeRemote(shape, target, value);
                    break;
                case EShapeActionValueOnInputAction.WRITE_BOTH:
                    EShapeActions.writeLocal(shape, target, value, time);
                    EShapeActions.writeRemote(shape, target, value);
                    break;
            }
        };
        return EShapeActionValueOnInputActions;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeMiscInput = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeMiscInput, _super);
        function EShapeActionRuntimeMiscInput(value) {
            var _this = _super.call(this, value) || this;
            _this.target = EShapeActionExpressions.ofStringOrNull(value.target);
            _this.onInputAction = value.onInputAction;
            return _this;
        }
        EShapeActionRuntimeMiscInput.prototype.newOperation = function (shape, runtime) {
            var _this = this;
            return {
                getElementRect: function (resolution, work, result) {
                    return _this.getElementRect(shape, runtime, resolution, work, result);
                },
                getElementMatrix: function () {
                    return _this.getElementMatrix(shape, runtime);
                },
                getClipperRect: function (resolution, work, result) {
                    return _this.getClipperToRect(shape, runtime, resolution, work, result);
                },
                getClipperExRects: function (result) {
                    _this.getClipperExRects(shape, result);
                },
                getPadding: function () {
                    return _this.getPadding(shape, runtime);
                },
                containsPoint: function (point) {
                    return _this.containsPoint(shape, runtime, point);
                },
                onStart: function () {
                    shape.text.enable = false;
                },
                onCancel: function () {
                    shape.text.enable = true;
                },
                onEnd: function () {
                    // DO NOTHING
                },
                getValue: function () {
                    return _this.getUtil(shape, runtime).toValue(shape.text.value);
                },
                onValueInput: function (newValue) {
                    // DO NOTHING
                },
                onValueChange: function (newValue, oldValue) {
                    _this.onValueChange(shape, runtime, newValue, oldValue);
                },
                onEnter: function () {
                    // DO NOTHING
                },
                applyTitle: function () {
                    // DO NOTHING
                }
            };
        };
        EShapeActionRuntimeMiscInput.prototype.newElementCreator = function (shape, runtime) {
            return undefined;
        };
        EShapeActionRuntimeMiscInput.prototype.getPadding = function (shape, runtime) {
            return shape.text.padding;
        };
        EShapeActionRuntimeMiscInput.prototype.onValueChange = function (shape, runtime, newValue, oldValue) {
            shape.text.value = this.getUtil(shape, runtime).fromValue(newValue);
            var now = Date.now();
            var target = this.target(shape, now, EShapeActionEnvironment);
            if (target != null) {
                EShapeActionValueOnInputActions.execute(shape, this.onInputAction, target, newValue, now);
            }
        };
        return EShapeActionRuntimeMiscInput;
    }(EShapeActionRuntimeMiscHtmlElementBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeMiscInputInput = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeMiscInputInput, _super);
        function EShapeActionRuntimeMiscInputInput() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return EShapeActionRuntimeMiscInputInput;
    }(EShapeActionRuntimeMiscInput));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeMiscInputNumber = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeMiscInputNumber, _super);
        function EShapeActionRuntimeMiscInputNumber() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return EShapeActionRuntimeMiscInputNumber;
    }(EShapeActionRuntimeMiscInputInput));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeMiscInputInteger = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeMiscInputInteger, _super);
        function EShapeActionRuntimeMiscInputInteger() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        EShapeActionRuntimeMiscInputInteger.prototype.newUtil = function (shape, runtime) {
            return new UtilInputNumber(shape, this.newOperation(shape, runtime), DThemes.getInstance().get("DInputInteger"), this.newUtilOptions(shape, runtime));
        };
        return EShapeActionRuntimeMiscInputInteger;
    }(EShapeActionRuntimeMiscInputNumber));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeMiscInputReal = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeMiscInputReal, _super);
        function EShapeActionRuntimeMiscInputReal() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        EShapeActionRuntimeMiscInputReal.prototype.newUtil = function (shape, runtime) {
            return new UtilInputNumber(shape, this.newOperation(shape, runtime), DThemes.getInstance().get("DInputReal"), this.newUtilOptions(shape, runtime));
        };
        return EShapeActionRuntimeMiscInputReal;
    }(EShapeActionRuntimeMiscInputNumber));

    /*
     * Copyright (C) 2021 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var UtilInputText = /** @class */ (function (_super) {
        __extends(UtilInputText, _super);
        function UtilInputText() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        UtilInputText.prototype.onElementAttached = function (element, before, after) {
            element.type = "text";
            _super.prototype.onElementAttached.call(this, element, before, after);
        };
        return UtilInputText;
    }(UtilInputInput));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeMiscInputText = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeMiscInputText, _super);
        function EShapeActionRuntimeMiscInputText() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        EShapeActionRuntimeMiscInputText.prototype.newUtil = function (shape, runtime) {
            return new UtilInputText(shape, this.newOperation(shape, runtime), DThemes.getInstance().get("DInputText"), this.newUtilOptions(shape, runtime));
        };
        return EShapeActionRuntimeMiscInputText;
    }(EShapeActionRuntimeMiscInputInput));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeMiscWrite = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeMiscWrite, _super);
        function EShapeActionRuntimeMiscWrite(value) {
            var _this = _super.call(this, value, EShapeRuntimeReset.NONE) || this;
            _this.target = EShapeActionExpressions.ofStringOrNull(value.target);
            _this.value = EShapeActionExpressions.ofUnknown(value.value);
            return _this;
        }
        EShapeActionRuntimeMiscWrite.prototype.execute = function (shape, runtime, time) {
            if (this.condition(shape, time, EShapeActionEnvironment)) {
                var target = this.target(shape, time, EShapeActionEnvironment);
                if (target != null) {
                    this.write(shape, target, this.value(shape, time, EShapeActionEnvironment), time);
                }
            }
        };
        return EShapeActionRuntimeMiscWrite;
    }(EShapeActionRuntimeConditional));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeMiscWriteBoth = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeMiscWriteBoth, _super);
        function EShapeActionRuntimeMiscWriteBoth() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        EShapeActionRuntimeMiscWriteBoth.prototype.write = function (shape, target, value, time) {
            EShapeActions.writeLocal(shape, target, value, time);
            EShapeActions.writeRemote(shape, target, value);
        };
        return EShapeActionRuntimeMiscWriteBoth;
    }(EShapeActionRuntimeMiscWrite));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeMiscWriteLocal = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeMiscWriteLocal, _super);
        function EShapeActionRuntimeMiscWriteLocal() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        EShapeActionRuntimeMiscWriteLocal.prototype.write = function (shape, target, value, time) {
            EShapeActions.writeLocal(shape, target, value, time);
        };
        return EShapeActionRuntimeMiscWriteLocal;
    }(EShapeActionRuntimeMiscWrite));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeMiscWriteRemote = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeMiscWriteRemote, _super);
        function EShapeActionRuntimeMiscWriteRemote() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        EShapeActionRuntimeMiscWriteRemote.prototype.write = function (shape, target, value, time) {
            EShapeActions.writeRemote(shape, target, value);
        };
        return EShapeActionRuntimeMiscWriteRemote;
    }(EShapeActionRuntimeMiscWrite));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueMisc = /** @class */ (function (_super) {
        __extends(EShapeActionValueMisc, _super);
        function EShapeActionValueMisc(subtype, condition, target, onInputAction, value) {
            var _this = _super.call(this, EShapeActionValueType.MISC, condition, subtype) || this;
            _this.target = target;
            _this.onInputAction = onInputAction;
            _this.value = value;
            return _this;
        }
        EShapeActionValueMisc.prototype.toRuntime = function () {
            switch (this.subtype) {
                case EShapeActionValueMiscType.INPUT_TEXT:
                    return new EShapeActionRuntimeMiscInputText(this);
                case EShapeActionValueMiscType.INPUT_INTEGER:
                    return new EShapeActionRuntimeMiscInputInteger(this);
                case EShapeActionValueMiscType.INPUT_REAL:
                    return new EShapeActionRuntimeMiscInputReal(this);
                case EShapeActionValueMiscType.EMIT_EVENT:
                    return new EShapeActionRuntimeMiscEmitEvent(this);
                case EShapeActionValueMiscType.WRITE_BOTH:
                    return new EShapeActionRuntimeMiscWriteBoth(this);
                case EShapeActionValueMiscType.WRITE_LOCAL:
                    return new EShapeActionRuntimeMiscWriteLocal(this);
                case EShapeActionValueMiscType.WRITE_REMOTE:
                    return new EShapeActionRuntimeMiscWriteRemote(this);
                case EShapeActionValueMiscType.HTML_ELEMENT:
                case EShapeActionValueMiscType.HTML_ELEMENT_WITHOUT_POINTER_EVENTS:
                    return new EShapeActionRuntimeMiscHtmlElement(this);
            }
        };
        EShapeActionValueMisc.prototype.serialize = function (manager) {
            var conditionId = manager.addResource(this.condition);
            var targetId = manager.addResource(this.target);
            var valueId = manager.addResource(this.value);
            return manager.addResource("[".concat(this.type, ",").concat(conditionId, ",").concat(this.subtype, ",").concat(targetId, ",").concat(this.onInputAction, ",").concat(valueId, "]"));
        };
        EShapeActionValueMisc.deserialize = function (serialized, manager) {
            var resources = manager.resources;
            var condition = EShapeActionValues.toResource(1, serialized, resources);
            var target = EShapeActionValues.toResource(3, serialized, resources);
            var value = EShapeActionValues.toResource(5, serialized, resources);
            return new EShapeActionValueMisc(serialized[2], condition, target, serialized[4], value);
        };
        return EShapeActionValueMisc;
    }(EShapeActionValueSubtyped));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeMiscExecute = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeMiscExecute, _super);
        function EShapeActionRuntimeMiscExecute(value) {
            var _this = _super.call(this, value, EShapeRuntimeReset.NONE) || this;
            _this.target = EShapeActionExpressions.ofUnknown(value.target);
            return _this;
        }
        EShapeActionRuntimeMiscExecute.prototype.execute = function (shape, runtime, time) {
            if (this.condition(shape, time, EShapeActionEnvironment)) {
                this.target(shape, time, EShapeActionEnvironment);
            }
        };
        return EShapeActionRuntimeMiscExecute;
    }(EShapeActionRuntimeConditional));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueMiscExecute = /** @class */ (function (_super) {
        __extends(EShapeActionValueMiscExecute, _super);
        function EShapeActionValueMiscExecute(condition, target) {
            var _this = _super.call(this, EShapeActionValueType.MISC, condition, EShapeActionValueMiscType.EXECUTE) || this;
            _this.target = target;
            return _this;
        }
        EShapeActionValueMiscExecute.prototype.toRuntime = function () {
            return new EShapeActionRuntimeMiscExecute(this);
        };
        EShapeActionValueMiscExecute.prototype.serialize = function (manager) {
            var conditionId = manager.addResource(this.condition);
            var targetId = manager.addResource(this.target);
            return manager.addResource("[".concat(this.type, ",").concat(conditionId, ",").concat(this.subtype, ",").concat(targetId, "]"));
        };
        EShapeActionValueMiscExecute.deserialize = function (serialized, manager) {
            var resources = manager.resources;
            var condition = EShapeActionValues.toResource(1, serialized, resources);
            var target = EShapeActionValues.toResource(3, serialized, resources);
            return new EShapeActionValueMiscExecute(condition, target);
        };
        return EShapeActionValueMiscExecute;
    }(EShapeActionValueSubtyped));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionMiscExtensions = /** @class */ (function () {
        function EShapeActionMiscExtensions() {
        }
        EShapeActionMiscExtensions.add = function (extension) {
            var _a, _b;
            ((_a = this._typeToDatum) !== null && _a !== void 0 ? _a : (this._typeToDatum = new Map())).set(extension.type, extension);
            ((_b = this._data) !== null && _b !== void 0 ? _b : (this._data = [])).push(extension);
        };
        EShapeActionMiscExtensions.get = function (type) {
            var typeToDatum = this._typeToDatum;
            if (typeToDatum != null) {
                return typeToDatum.get(type);
            }
        };
        EShapeActionMiscExtensions.each = function (iteratee) {
            var data = this._data;
            if (data != null) {
                for (var i = 0, imax = data.length; i < imax; ++i) {
                    iteratee(data[i]);
                }
            }
        };
        return EShapeActionMiscExtensions;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeMiscExtension = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeMiscExtension, _super);
        function EShapeActionRuntimeMiscExtension(value) {
            var _this = _super.call(this, value, EShapeRuntimeReset.NONE) || this;
            _this.argument = EShapeActionExpressions.ofUnknown(value.argument);
            _this.extension = EShapeActionMiscExtensions.get(value.subtype);
            return _this;
        }
        EShapeActionRuntimeMiscExtension.prototype.execute = function (shape, runtime, time) {
            var extension = this.extension;
            if (extension != null && this.condition(shape, time, EShapeActionEnvironment)) {
                var diagram = EShapeActions.toDiagram(shape);
                if (diagram != null) {
                    extension.executor(this.argument(shape, time, EShapeActionEnvironment), shape, diagram, EShapeActionEnvironment);
                }
            }
        };
        return EShapeActionRuntimeMiscExtension;
    }(EShapeActionRuntimeConditional));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueMiscExtension = /** @class */ (function (_super) {
        __extends(EShapeActionValueMiscExtension, _super);
        function EShapeActionValueMiscExtension(subtype, condition, argument) {
            var _this = _super.call(this, EShapeActionValueType.MISC, condition, subtype) || this;
            _this.argument = argument;
            return _this;
        }
        EShapeActionValueMiscExtension.prototype.toRuntime = function () {
            return new EShapeActionRuntimeMiscExtension(this);
        };
        EShapeActionValueMiscExtension.prototype.serialize = function (manager) {
            var conditionId = manager.addResource(this.condition);
            var argumentId = manager.addResource(this.argument);
            return manager.addResource("[".concat(this.type, ",").concat(conditionId, ",").concat(this.subtype, ",").concat(argumentId, "]"));
        };
        EShapeActionValueMiscExtension.deserialize = function (serialized, manager) {
            var resources = manager.resources;
            var condition = EShapeActionValues.toResource(1, serialized, resources);
            var argument = EShapeActionValues.toResource(3, serialized, resources);
            return new EShapeActionValueMiscExtension(serialized[2], condition, argument);
        };
        return EShapeActionValueMiscExtension;
    }(EShapeActionValueSubtyped));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeOpen = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeOpen, _super);
        function EShapeActionRuntimeOpen(value, subtype) {
            var _this = _super.call(this, value, EShapeRuntimeReset.NONE) || this;
            _this.subtype = subtype;
            _this.target = EShapeActionExpressions.ofUnknown(value.target);
            _this.inNewWindow = value.inNewWindow;
            return _this;
        }
        EShapeActionRuntimeOpen.prototype.execute = function (shape, runtime, time) {
            if (this.condition(shape, time, EShapeActionEnvironment)) {
                var target = this.target(shape, time, EShapeActionEnvironment);
                if (target != null) {
                    EShapeActions.open(shape, this.subtype, target, this.inNewWindow, EShapeActionEnvironment);
                }
            }
        };
        return EShapeActionRuntimeOpen;
    }(EShapeActionRuntimeConditional));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueOpenType = {
        /** @deprecated in favor of {@link DIAGRAM} */
        DIAGRAM_LEGACY: 0,
        /** @deprecated in favor of {@link PAGE} */
        PAGE_LEGACY: 1,
        /** @deprecated in favor of {@link PAGE} */
        PAGE_INPLACE_LEGACY: 2,
        /** @deprecated in favor of {@link DIALOG} */
        DIALOG_TEXT: 3,
        /** @deprecated in favor of {@link DIALOG} */
        DIALOG_INTEGER: 4,
        /** @deprecated in favor of {@link DIALOG} */
        DIALOG_REAL: 5,
        /** @deprecated in favor of {@link DIALOG} */
        DIALOG_BOOLEAN: 6,
        /** @deprecated in favor of {@link DIALOG} */
        DIALOG_DATE: 7,
        /** @deprecated in favor of {@link DIALOG} */
        DIALOG_TIME: 8,
        /** @deprecated in favor of {@link DIALOG} */
        DIALOG_DATETIME: 9,
        DIAGRAM: 10,
        PAGE: 11,
        DIALOG: 12,
        EXTENSION: DDiagramBaseControllerOpenType.EXTENSION
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueOpen = /** @class */ (function (_super) {
        __extends(EShapeActionValueOpen, _super);
        function EShapeActionValueOpen(subtype, condition, target, inNewWindow) {
            var _this = _super.call(this, EShapeActionValueType.OPEN, condition, subtype) || this;
            _this.target = target;
            _this.inNewWindow = inNewWindow;
            return _this;
        }
        EShapeActionValueOpen.prototype.isEquals = function (value) {
            return (_super.prototype.isEquals.call(this, value) &&
                value instanceof EShapeActionValueOpen &&
                this.target === value.target &&
                this.inNewWindow === value.inNewWindow);
        };
        EShapeActionValueOpen.prototype.toRuntime = function () {
            switch (this.subtype) {
                case EShapeActionValueOpenType.DIAGRAM:
                    return new EShapeActionRuntimeOpen(this, DDiagramBaseControllerOpenType.DIAGRAM);
                case EShapeActionValueOpenType.PAGE:
                    return new EShapeActionRuntimeOpen(this, DDiagramBaseControllerOpenType.PAGE);
            }
        };
        EShapeActionValueOpen.prototype.serialize = function (manager) {
            var conditionId = manager.addResource(this.condition);
            var targetId = manager.addResource(this.target);
            var inNewWindow = this.inNewWindow ? 1 : 0;
            return manager.addResource("[".concat(this.type, ",").concat(conditionId, ",").concat(this.subtype, ",").concat(targetId, ",").concat(inNewWindow, "]"));
        };
        EShapeActionValueOpen.deserialize = function (serialized, manager) {
            var condition = EShapeActionValues.toResource(1, serialized, manager.resources);
            var target = EShapeActionValues.toResource(3, serialized, manager.resources);
            return new EShapeActionValueOpen(this.toSubType(serialized), condition, target, this.inNewWindow(serialized));
        };
        EShapeActionValueOpen.toSubType = function (serialized) {
            switch (serialized[2]) {
                case EShapeActionValueOpenType.DIAGRAM_LEGACY:
                    return EShapeActionValueOpenType.DIAGRAM;
                case EShapeActionValueOpenType.PAGE_LEGACY:
                    return EShapeActionValueOpenType.PAGE;
                case EShapeActionValueOpenType.PAGE_INPLACE_LEGACY:
                    return EShapeActionValueOpenType.PAGE;
                case EShapeActionValueOpenType.DIAGRAM:
                    return EShapeActionValueOpenType.DIAGRAM;
                case EShapeActionValueOpenType.PAGE:
                    return EShapeActionValueOpenType.PAGE;
            }
            return EShapeActionValueOpenType.DIAGRAM;
        };
        EShapeActionValueOpen.inNewWindow = function (serialized) {
            switch (serialized[2]) {
                case EShapeActionValueOpenType.DIAGRAM_LEGACY:
                    return false;
                case EShapeActionValueOpenType.PAGE_LEGACY:
                    return true;
                case EShapeActionValueOpenType.PAGE_INPLACE_LEGACY:
                    return false;
                case EShapeActionValueOpenType.DIAGRAM:
                case EShapeActionValueOpenType.PAGE:
                    return !!serialized[4];
            }
            return false;
        };
        return EShapeActionValueOpen;
    }(EShapeActionValueSubtyped));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var UtilAttachAlign = {
        TOP: 0,
        TOP_LEFT: 1,
        TOP_CENTER: 2,
        TOP_RIGHT: 3,
        LEFT: 4,
        LEFT_TOP: 5,
        LEFT_MIDDLE: 6,
        LEFT_BOTTOM: 7,
        RIGHT: 8,
        RIGHT_TOP: 9,
        RIGHT_MIDDLE: 10,
        RIGHT_BOTTOM: 11,
        BOTTOM: 12,
        BOTTOM_LEFT: 13,
        BOTTOM_CENTER: 14,
        BOTTOM_RIGHT: 15,
        OVER: 16,
        NONE: 17
    };
    var UtilAttach = /** @class */ (function () {
        function UtilAttach() {
        }
        UtilAttach.attach = function (target, bounds, offsetX, offsetY, clippingWidth, clippingHeight, align) {
            if (align === UtilAttachAlign.NONE) {
                return;
            }
            var width = target.width;
            var height = target.height;
            var x = 0;
            switch (align) {
                case UtilAttachAlign.LEFT:
                case UtilAttachAlign.LEFT_TOP:
                case UtilAttachAlign.LEFT_MIDDLE:
                case UtilAttachAlign.LEFT_BOTTOM:
                    x = bounds.left - width - offsetX;
                    if (x < offsetX) {
                        x = bounds.right + offsetX;
                        if (clippingWidth - offsetX < x + width) {
                            x = offsetX;
                        }
                    }
                    break;
                case UtilAttachAlign.RIGHT:
                case UtilAttachAlign.RIGHT_TOP:
                case UtilAttachAlign.RIGHT_MIDDLE:
                case UtilAttachAlign.RIGHT_BOTTOM:
                    x = bounds.right + offsetX;
                    if (clippingWidth - offsetX < x + width) {
                        x = bounds.left - width - offsetX;
                        if (x < offsetX) {
                            x = clippingWidth - width - offsetX;
                        }
                    }
                    break;
                case UtilAttachAlign.TOP:
                case UtilAttachAlign.TOP_LEFT:
                case UtilAttachAlign.BOTTOM:
                case UtilAttachAlign.BOTTOM_LEFT:
                    x = this.adjust(bounds.left, width, offsetX, clippingWidth);
                    break;
                case UtilAttachAlign.TOP_RIGHT:
                case UtilAttachAlign.BOTTOM_RIGHT:
                    x = this.adjust(bounds.right - width, width, offsetX, clippingWidth);
                    break;
                case UtilAttachAlign.TOP_CENTER:
                case UtilAttachAlign.BOTTOM_CENTER:
                case UtilAttachAlign.OVER:
                    x = this.adjust((bounds.left + bounds.right - width) * 0.5, width, offsetX, clippingWidth);
                    break;
            }
            var y = 0;
            switch (align) {
                case UtilAttachAlign.LEFT:
                case UtilAttachAlign.LEFT_TOP:
                case UtilAttachAlign.RIGHT:
                case UtilAttachAlign.RIGHT_TOP:
                    y = this.adjust(bounds.top, height, offsetY, clippingHeight);
                    break;
                case UtilAttachAlign.LEFT_MIDDLE:
                case UtilAttachAlign.RIGHT_MIDDLE:
                case UtilAttachAlign.OVER:
                    y = this.adjust((bounds.top + bounds.bottom - height) * 0.5, height, offsetY, clippingHeight);
                    break;
                case UtilAttachAlign.LEFT_BOTTOM:
                case UtilAttachAlign.RIGHT_BOTTOM:
                    y = this.adjust(bounds.bottom, height, offsetY, clippingHeight);
                    break;
                case UtilAttachAlign.TOP:
                case UtilAttachAlign.TOP_LEFT:
                case UtilAttachAlign.TOP_RIGHT:
                case UtilAttachAlign.TOP_CENTER:
                    y = bounds.top - height - offsetY;
                    if (y < offsetY) {
                        y = bounds.bottom + offsetY;
                        if (clippingHeight < y + height) {
                            y = offsetY;
                        }
                    }
                    break;
                case UtilAttachAlign.BOTTOM:
                case UtilAttachAlign.BOTTOM_LEFT:
                case UtilAttachAlign.BOTTOM_RIGHT:
                case UtilAttachAlign.BOTTOM_CENTER:
                    y = bounds.bottom + offsetY;
                    if (clippingHeight - offsetY < y + height) {
                        y = bounds.top - height - offsetY;
                        if (y < offsetY) {
                            y = clippingHeight - height - offsetY;
                        }
                    }
                    break;
            }
            target.position.set(x, y);
        };
        UtilAttach.adjust = function (position, size, offset, clippingSize) {
            if (position < offset) {
                if (clippingSize - offset < position + size) {
                    return (clippingSize - size) * 0.5;
                }
                else {
                    return offset;
                }
            }
            else if (clippingSize - offset < position + size) {
                if (clippingSize < size) {
                    return (clippingSize - size) * 0.5;
                }
                else {
                    return clippingSize - size - offset;
                }
            }
            return position;
        };
        return UtilAttach;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogCloseOn = {
        NONE: 0,
        ESC: 1,
        CLICK_OUTSIDE: 2
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogGestureMode = {
        DIRTY: 0,
        CLEAN: 1
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogGestureImpl = /** @class */ (function () {
        function DDialogGestureImpl(parent, options) {
            var _a;
            this._parent = parent;
            this._options = options;
            if (options.enable) {
                this._util = this.newUtil();
            }
            this._mode = toEnum((_a = options.mode) !== null && _a !== void 0 ? _a : DDialogGestureMode.DIRTY, DDialogGestureMode);
            this._isEnabled = true;
            this._isDirty = false;
        }
        Object.defineProperty(DDialogGestureImpl.prototype, "parent", {
            get: function () {
                return this._parent;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDialogGestureImpl.prototype, "mode", {
            get: function () {
                return this._mode;
            },
            set: function (mode) {
                this._mode = mode;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDialogGestureImpl.prototype, "constraint", {
            get: function () {
                var _a, _b;
                var result = this._constraint;
                if (result == null) {
                    result = (_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.constraint) !== null && _b !== void 0 ? _b : this.newConstraint();
                    this._constraint = result;
                }
                return result;
            },
            set: function (constraint) {
                this._constraint = constraint;
            },
            enumerable: false,
            configurable: true
        });
        DDialogGestureImpl.prototype.newConstraint = function () {
            var _this = this;
            return function (target, layer, x, y) {
                _this.toConstrained(target, layer, x, y);
            };
        };
        DDialogGestureImpl.prototype.isDirty = function () {
            return this._isDirty;
        };
        DDialogGestureImpl.prototype.isClean = function () {
            return !this._isDirty;
        };
        DDialogGestureImpl.prototype.toClean = function () {
            if (this._isDirty) {
                this._isDirty = false;
            }
        };
        DDialogGestureImpl.prototype.newUtil = function () {
            var _this = this;
            var p = new pixi_js.Point();
            var parent = this._parent;
            var position = parent.position;
            return new UtilGesture({
                bind: parent,
                checker: {
                    start: function (e) {
                        // Are children clicked?
                        if (e.target !== parent) {
                            return false;
                        }
                        // Is clicked outside?
                        p.copyFrom(e.data.global);
                        parent.toLocal(p, undefined, p, true);
                        var x = p.x;
                        var y = p.y;
                        if (x < 0 || y < 0 || parent.width < x || parent.height < y) {
                            return false;
                        }
                        // Ok
                        return true;
                    }
                },
                on: {
                    start: function () {
                        p.copyFrom(position);
                    },
                    move: function (target, dx, dy) {
                        p.set(p.x + dx, p.y + dy);
                        if (!_this._isDirty) {
                            _this._isDirty = true;
                            parent.setX(position.x);
                            parent.setY(position.y);
                        }
                        var layer = parent.layer;
                        if (layer != null) {
                            _this.constraint(parent, layer, p.x, p.y);
                        }
                    }
                }
            });
        };
        DDialogGestureImpl.prototype.toConstrained = function (target, layer, x, y) {
            var _a;
            var position = target.position;
            if (layer) {
                var bounds = target.getBounds(false, ((_a = DDialogGestureImpl.WORK_BOUNDS) !== null && _a !== void 0 ? _a : (DDialogGestureImpl.WORK_BOUNDS = new pixi_js.Rectangle())));
                var obx = bounds.x + x - position.x;
                var oby = bounds.y + y - position.y;
                var nbx = Math.min(Math.max(0, obx), layer.width - bounds.width);
                var nby = Math.min(Math.max(0, oby), layer.height - bounds.height);
                position.set(x + nbx - obx, y + nby - oby);
            }
            else {
                position.set(x, y);
            }
        };
        return DDialogGestureImpl;
    }());

    /*
     * Copyright (C) 2021 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * {@link DDialog} mode options.
     */
    var DDialogMode = {
        MODAL: 0,
        MODELESS: 1,
        MENU: 2
    };

    /*
     * Copyright (C) 2021 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogState = {
        MODAL: "MODAL",
        MODELESS: "MODELESS",
        MENU: "MENU"
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var UtilClickOutside = /** @class */ (function () {
        function UtilClickOutside() {
        }
        UtilClickOutside.apply = function (target, onClick) {
            var _this = this;
            target.on(UtilPointerEvent.down, function (e) {
                if (e.target === target) {
                    var point = _this.point;
                    point.copyFrom(e.data.global);
                    target.toLocal(point, undefined, point, true);
                    var x = point.x;
                    var y = point.y;
                    if (x < 0 || y < 0 || target.width < x || target.height < y) {
                        // If dialogs / menus are being rendered on the overlay layer, closing them before
                        // the default pointerdown event handler causes the base layer to lose its focus.
                        // Therefore, onClick needed to be delayed.
                        setTimeout(function () {
                            onClick(e);
                        }, 0);
                    }
                }
            });
        };
        UtilClickOutside.point = new pixi_js.Point();
        return UtilClickOutside;
    }());

    var UtilOverlay = /** @class */ (function () {
        function UtilOverlay(options) {
            this._layer = null;
            this._application = (options === null || options === void 0 ? void 0 : options.parent) == null ? DApplications.last() : null;
        }
        Object.defineProperty(UtilOverlay.prototype, "picked", {
            get: function () {
                return this._layer;
            },
            enumerable: false,
            configurable: true
        });
        UtilOverlay.prototype.pick = function (owner, opener) {
            var layer = this._layer;
            if (layer == null) {
                layer = DApplications.getLayerOverlay(owner);
                if (layer == null && opener != null) {
                    layer = DApplications.getLayerOverlay(opener);
                }
                if (layer == null) {
                    var application = this._application;
                    if (application) {
                        layer = application.getLayerOverlay();
                    }
                    else {
                        layer = DApplications.last().getLayerOverlay();
                    }
                }
                this._layer = layer;
            }
            return layer;
        };
        return UtilOverlay;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A dialog class.
     *
     * If multiple application instances are there, better to set the constructor
     * option `parent` to an `application.stage` so that the dialog picks a right
     * application. `DDialog` searches applications in a following order:
     *
     * * To begin, `DDialog` tries to find applications which it belongs to.
     * * If `DDialog` can't find applications, then `DDialog` tries to find applications which openers belong to.
     * * If openers are not given, `DDialog` assumes the last created application at the very moment `DDialog` is instantiated is the one it belongs to.
     */
    var DDialog = /** @class */ (function (_super) {
        __extends(DDialog, _super);
        function DDialog() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DDialog.prototype.init = function (options) {
            var _this = this;
            var _a, _b, _c;
            _super.prototype.init.call(this, options);
            this._onPrerenderBound = function () {
                _this.onPrerender();
            };
            this._layer = null;
            // Mode
            var theme = this.theme;
            var mode = toEnum((_a = options === null || options === void 0 ? void 0 : options.mode) !== null && _a !== void 0 ? _a : theme.getMode(), DDialogMode);
            this._mode = mode;
            // Always On Top
            this._alwaysOnTop = (_b = options === null || options === void 0 ? void 0 : options.alwaysOnTop) !== null && _b !== void 0 ? _b : theme.isAlwaysOnTop();
            // Sticky
            this._sticky = (_c = options === null || options === void 0 ? void 0 : options.sticky) !== null && _c !== void 0 ? _c : theme.isSticky(mode);
            // Close On
            var closeOn = this.toCloseOn(mode, theme, options);
            this._closeOn = closeOn;
            // Align
            this._align = this.toAlign(mode, theme, options);
            // Overlay
            this._overlay = new UtilOverlay();
            // Gesture
            this._gesture = new DDialogGestureImpl(this, this.toGestureOptions(mode, theme, options));
            // Visibility
            this.visible = false;
            // State
            switch (mode) {
                case DDialogMode.MODAL:
                    this.state.addAll(DBaseState.FOCUS_ROOT, DDialogState.MODAL);
                    break;
                case DDialogMode.MODELESS:
                    this.state.add(DDialogState.MODELESS);
                    break;
                case DDialogMode.MENU:
                    this.state.addAll(DBaseState.FOCUS_ROOT, DDialogState.MENU);
                    break;
            }
            // Outside-click handling
            if (closeOn & DDialogCloseOn.CLICK_OUTSIDE) {
                UtilClickOutside.apply(this, function () {
                    _this.onCloseOn();
                });
            }
        };
        DDialog.prototype.toCloseOn = function (mode, theme, options) {
            var closeOn = options === null || options === void 0 ? void 0 : options.closeOn;
            if (closeOn == null) {
                return theme.closeOn(mode);
            }
            else if (isArray(closeOn)) {
                var result = DDialogCloseOn.NONE;
                for (var i = 0, imax = closeOn.length; i < imax; ++i) {
                    result |= DDialogCloseOn[closeOn[i]];
                }
                return result;
            }
            else if (isString(closeOn)) {
                return DDialogCloseOn[closeOn];
            }
            return closeOn;
        };
        DDialog.prototype.toAlign = function (mode, theme, options) {
            var align = options === null || options === void 0 ? void 0 : options.align;
            if (align === null) {
                return null;
            }
            else if (align === undefined) {
                return theme.getAlign(mode);
            }
            else {
                return toEnum(align, UtilAttachAlign);
            }
        };
        Object.defineProperty(DDialog.prototype, "mode", {
            get: function () {
                return this._mode;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDialog.prototype, "align", {
            get: function () {
                return this._align;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDialog.prototype, "algin", {
            set: function (align) {
                this._align = align;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDialog.prototype, "alwaysOnTop", {
            get: function () {
                return this._alwaysOnTop;
            },
            set: function (alwaysOnTop) {
                this._alwaysOnTop = alwaysOnTop;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDialog.prototype, "gesture", {
            get: function () {
                return this._gesture;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDialog.prototype, "layer", {
            get: function () {
                return this._layer;
            },
            enumerable: false,
            configurable: true
        });
        DDialog.prototype.toGestureOptions = function (mode, theme, options) {
            var gesture = options === null || options === void 0 ? void 0 : options.gesture;
            if (gesture === true) {
                return {
                    enable: true,
                    mode: theme.getGestureMode(mode)
                };
            }
            else if (gesture === false) {
                return {
                    enable: false,
                    mode: theme.getGestureMode(mode)
                };
            }
            else if (gesture != null) {
                if (gesture.enable === undefined) {
                    gesture.enable = theme.isGestureEnabled(mode);
                }
                if (gesture.mode === undefined) {
                    gesture.mode = theme.getGestureMode(mode);
                }
                return gesture;
            }
            return {
                enable: theme.isGestureEnabled(mode),
                mode: theme.getGestureMode(mode)
            };
        };
        DDialog.prototype.onParentResize = function (parentWidth, parentHeight, parentPadding) {
            if (this.isOpened()) {
                var layer = this._layer;
                if (layer != null) {
                    var gesture = this._gesture;
                    if (gesture.isDirty()) {
                        var position = this.position;
                        gesture.constraint(this, layer, position.x, position.y);
                    }
                }
            }
            _super.prototype.onParentResize.call(this, parentWidth, parentHeight, parentPadding);
        };
        DDialog.prototype.getAnimation = function () {
            var _this = this;
            var _a, _b;
            var result = this._animation;
            if (result === undefined) {
                result = (_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.animation) !== null && _b !== void 0 ? _b : this.theme.newAnimation(this._mode);
                if (result) {
                    result.target = this;
                    result.on("end", function (isReverse) {
                        _this.onAnimationEnd(isReverse);
                    });
                }
                this._animation = result;
            }
            return result;
        };
        DDialog.prototype.onAnimationEnd = function (isReverse) {
            if (isReverse) {
                if (this._mode === DDialogMode.MODELESS) {
                    this.hide();
                }
                else {
                    var parent_1 = this.parent;
                    if (parent_1) {
                        parent_1.removeChild(this);
                    }
                }
            }
            else {
                var layer = DApplications.getLayer(this);
                if (layer) {
                    var focusController = layer.getFocusController();
                    this._focused = focusController.get();
                    focusController.focus(this.findFirstFocusable(focusController) || this);
                }
            }
        };
        DDialog.prototype.findFirstFocusable = function (focusController) {
            return focusController.find(this, false, true, true);
        };
        /**
         * Opens a dialog.
         *
         * @param opener An opener of a dialog.
         * The dialog position is determined based on a position and a size of the opener.
         * If the opener is undefined, the dialog is placed at the center of the screen.
         *
         * @returns a value of this dialog
         */
        DDialog.prototype.open = function (opener) {
            var _this = this;
            var result = this._promise;
            if (result == null) {
                result = new Promise(function (resolve, reject) {
                    _this._resolve = resolve;
                    _this._reject = reject;
                });
                this._promise = result;
                this._opener = opener;
                // Attach to a layer
                var layer = null;
                switch (this._mode) {
                    case DDialogMode.MODAL:
                    case DDialogMode.MENU:
                        layer = this._overlay.pick(this, opener);
                        layer.stage.addChild(this);
                        break;
                    case DDialogMode.MODELESS:
                        layer = DApplications.getLayer(this);
                        this.show();
                        break;
                }
                this._layer = layer;
                // Position & size
                var gesture = this._gesture;
                if (gesture.mode === DDialogGestureMode.CLEAN) {
                    gesture.toClean();
                }
                if (layer != null) {
                    if (gesture.isClean()) {
                        var renderer = layer.renderer;
                        var onPrerenderBound = this._onPrerenderBound;
                        if (this._sticky) {
                            renderer.on("prerender", onPrerenderBound);
                        }
                        else {
                            renderer.once("prerender", onPrerenderBound);
                        }
                    }
                    else {
                        var position = this.position;
                        gesture.constraint(this, layer, position.x, position.y);
                    }
                }
                // Bring To Front
                this.bringToFront();
                // Done
                this.onOpen();
            }
            return result;
        };
        DDialog.prototype.onChildFocus = function (focused) {
            _super.prototype.onChildFocus.call(this, focused);
            this.bringToFront();
        };
        DDialog.prototype.onFocus = function () {
            _super.prototype.onFocus.call(this);
            this.bringToFront();
        };
        DDialog.prototype.bringToFront = function () {
            var parent = this.parent;
            if (parent == null) {
                return;
            }
            var children = parent.children;
            var childrenLength = children.length;
            var index = childrenLength - 1;
            for (; 0 <= index; --index) {
                if (children[index] === this) {
                    break;
                }
            }
            if (index < 0) {
                return;
            }
            for (var i = index + 1; i < childrenLength; ++i) {
                children[i - 1] = children[i];
            }
            children[childrenLength - 1] = this;
            children.sort(function (a, b) {
                return ((a instanceof DDialog ? (a._alwaysOnTop ? 2 : 1) : 0) -
                    (b instanceof DDialog ? (b._alwaysOnTop ? 2 : 1) : 0));
            });
        };
        DDialog.prototype.onPrerender = function () {
            var _a;
            var layer = this._layer;
            if (layer == null) {
                return;
            }
            var align = this._align;
            if (align === UtilAttachAlign.NONE) {
                return;
            }
            var opener = this._opener;
            if (align != null && opener != null) {
                var mode = this._mode;
                var bounds = opener.getBounds(false, ((_a = DDialog.WORK_BOUNDS) !== null && _a !== void 0 ? _a : (DDialog.WORK_BOUNDS = new pixi_js.Rectangle())));
                var theme = this.theme;
                UtilAttach.attach(this, bounds, theme.getOffsetX(mode), theme.getOffsetY(mode), layer.width, layer.height, align);
            }
            else {
                this.position.set((layer.width - this.width) * 0.5, (layer.height - this.height) * 0.5);
            }
        };
        DDialog.prototype.onOpen = function () {
            this.emit("open", this);
            // Animation
            var animation = this.getAnimation();
            if (animation) {
                animation.start();
            }
            else if (this._mode === DDialogMode.MENU) {
                this.visible = true;
                this.onAnimationEnd(false);
            }
        };
        DDialog.prototype.isOpened = function () {
            return this._promise != null;
        };
        DDialog.prototype.close = function () {
            this.doReject();
        };
        DDialog.prototype.doResolve = function (value) {
            var resolve = this._resolve;
            if (resolve) {
                this._promise = undefined;
                this._resolve = undefined;
                this._reject = undefined;
                this.onClose();
                resolve(value);
            }
        };
        DDialog.prototype.doReject = function (reason) {
            var reject = this._reject;
            if (reject) {
                this._promise = undefined;
                this._resolve = undefined;
                this._reject = undefined;
                this.onClose();
                reject(reason);
            }
        };
        DDialog.prototype.onClose = function () {
            // Focus
            var layer = this._layer;
            var focused = this._focused;
            if (focused != null) {
                this._focused = null;
                if (layer) {
                    var focusedLayer = DApplications.getLayer(focused);
                    if (focusedLayer != null && layer !== focusedLayer) {
                        focusedLayer.view.focus();
                    }
                    layer.getFocusController().focus(focused);
                }
                else {
                    this.blur(true);
                }
            }
            else {
                this.blur(true);
            }
            // Remove the prerender event handler and forget the layer
            if (layer) {
                layer.renderer.off("prerender", this._onPrerenderBound);
                this._layer = null;
            }
            // Forget the opener
            this._opener = null;
            // Animation
            var animation = this.getAnimation();
            if (animation) {
                animation.start(true);
            }
            else {
                this.visible = false;
                this.onAnimationEnd(true);
            }
            // Always On Top
            if (this._alwaysOnTop) {
                var parent_2 = this.parent;
                if (parent_2 != null) {
                    parent_2.off("childAdded", this._onParentChildAddedBound);
                }
            }
            this.emit("close", this);
        };
        DDialog.prototype.onKeyDown = function (e) {
            if (this._closeOn & DDialogCloseOn.ESC) {
                if (UtilKeyboardEvent.isCancelKey(e)) {
                    this.onCloseOn();
                }
            }
            return _super.prototype.onKeyDown.call(this, e);
        };
        DDialog.prototype.onCloseOn = function () {
            this.close();
        };
        DDialog.prototype.containsGlobalPoint = function (point) {
            switch (this._mode) {
                case DDialogMode.MODAL:
                case DDialogMode.MENU:
                    return true;
                case DDialogMode.MODELESS:
                    return _super.prototype.containsGlobalPoint.call(this, point);
            }
        };
        DDialog.prototype.getType = function () {
            return "DDialog";
        };
        return DDialog;
    }(DBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DLayoutDirection = {
        VERTICAL: 0,
        HORIZONTAL: 1
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DLayoutSpace = /** @class */ (function (_super) {
        __extends(DLayoutSpace, _super);
        function DLayoutSpace(options) {
            var _this = _super.call(this, options) || this;
            _this.visible = false;
            return _this;
        }
        DLayoutSpace.prototype.getType = function () {
            return "DLayoutSpace";
        };
        return DLayoutSpace;
    }(DBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var isVisible = function (child) {
        return child instanceof DBase && (child.visible || child instanceof DLayoutSpace);
    };
    var toMultiplicity = function (theme, options) {
        if (options) {
            var row = options.row;
            if (row != null) {
                return row;
            }
            var column = options.column;
            if (column != null) {
                return column;
            }
        }
        return theme.getMultiplicity();
    };
    var toMargin = function (theme, options) {
        var _a, _b;
        var margin = options === null || options === void 0 ? void 0 : options.margin;
        if (margin != null) {
            if (isNumber(margin)) {
                return {
                    horizontal: margin,
                    vertical: margin
                };
            }
            else {
                var themeMargin = theme.getMargin();
                return {
                    horizontal: (_a = margin.horizontal) !== null && _a !== void 0 ? _a : themeMargin,
                    vertical: (_b = margin.vertical) !== null && _b !== void 0 ? _b : themeMargin
                };
            }
        }
        else {
            var themeMargin = theme.getMargin();
            return {
                horizontal: themeMargin,
                vertical: themeMargin
            };
        }
    };
    var toDirection = function (theme, options) {
        var direction = options === null || options === void 0 ? void 0 : options.direction;
        if (direction != null) {
            if (isString(direction)) {
                return DLayoutDirection[direction];
            }
            else {
                return direction;
            }
        }
        return theme.getDirection();
    };
    var toCornerAdjust = function (theme, options) {
        var corner = options === null || options === void 0 ? void 0 : options.corner;
        if (corner != null && !isNumber(corner)) {
            var adjust = corner.adjust;
            if (adjust != null) {
                return adjust;
            }
        }
        return theme.getCornerAdjust();
    };
    var toReverse = function (theme, options) {
        var _a;
        return (_a = options === null || options === void 0 ? void 0 : options.reverse) !== null && _a !== void 0 ? _a : theme.getReverse();
    };
    var DLayout = /** @class */ (function (_super) {
        __extends(DLayout, _super);
        function DLayout() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DLayout.prototype.init = function (options) {
            _super.prototype.init.call(this, options);
            var theme = this.theme;
            this._margin = toMargin(theme, options);
            this._direction = toDirection(theme, options);
            this._cornerAdjust = toCornerAdjust(theme, options);
            this._multiplicity = toMultiplicity(theme, options);
            this._reverse = toReverse(theme, options);
        };
        Object.defineProperty(DLayout.prototype, "margin", {
            get: function () {
                return this._margin;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DLayout.prototype, "multiplicity", {
            get: function () {
                return this._multiplicity;
            },
            enumerable: false,
            configurable: true
        });
        DLayout.prototype.getWeightTotal = function () {
            var children = this.children;
            var result = 0;
            var multiplicity = this._multiplicity;
            var reverse = this._reverse;
            for (var i = 0, imax = children.length; i < imax;) {
                var weight = -1;
                var j = 0;
                for (; j < multiplicity && i + j < imax; ++j) {
                    var child = children[reverse ? imax - 1 - (i + j) : i + j];
                    if (isVisible(child)) {
                        var clearType = child.getClearType();
                        if (j !== 0 && clearType & DLayoutClearType.BEFORE) {
                            break;
                        }
                        else {
                            weight = Math.max(weight, child.weight);
                            if (clearType && DLayoutClearType.AFTER) {
                                j += 1;
                                break;
                            }
                        }
                    }
                    else {
                        i += 1;
                        j -= 1;
                    }
                }
                i += j;
                if (0 <= weight) {
                    result += weight;
                }
            }
            return result;
        };
        DLayout.prototype.getSpaceLeft = function (baseSize, margin) {
            var children = this.children;
            var multiplicity = this._multiplicity;
            var reverse = this._reverse;
            if (this._direction === DLayoutDirection.VERTICAL) {
                var result = baseSize;
                var marginNext = 0;
                for (var i = 0, imax = children.length; i < imax;) {
                    var height = 0;
                    var weight = -1;
                    var j = 0;
                    for (; j < multiplicity && i + j < imax; ++j) {
                        var child = children[reverse ? imax - 1 - (i + j) : i + j];
                        if (isVisible(child)) {
                            var clearType = child.getClearType();
                            if (j !== 0 && clearType & DLayoutClearType.BEFORE) {
                                break;
                            }
                            else {
                                weight = Math.max(weight, child.weight);
                                if (weight < 0) {
                                    height = Math.max(height, child.height + marginNext);
                                }
                                else {
                                    height = marginNext;
                                }
                                if (clearType & DLayoutClearType.AFTER) {
                                    j += 1;
                                    break;
                                }
                            }
                        }
                        else {
                            i += 1;
                            j -= 1;
                        }
                    }
                    i += j;
                    result -= height;
                    marginNext = margin;
                }
                return Math.max(0, result);
            }
            else {
                var result = baseSize;
                var marginNext = 0;
                for (var i = 0, imax = children.length; i < imax;) {
                    var width = 0;
                    var weight = -1;
                    var j = 0;
                    for (; j < multiplicity && i + j < imax; ++j) {
                        var child = children[reverse ? imax - 1 - (i + j) : i + j];
                        if (isVisible(child)) {
                            var clearType = child.getClearType();
                            if (j !== 0 && clearType & DLayoutClearType.BEFORE) {
                                break;
                            }
                            else {
                                weight = Math.max(weight, child.weight);
                                if (weight < 0) {
                                    width = Math.max(width, child.width + marginNext);
                                }
                                else {
                                    width = marginNext;
                                }
                                if (clearType & DLayoutClearType.AFTER) {
                                    j += 1;
                                    break;
                                }
                            }
                        }
                        else {
                            i += 1;
                            j -= 1;
                        }
                    }
                    i += j;
                    result -= width;
                    marginNext = margin;
                }
                return Math.max(0, result);
            }
        };
        DLayout.prototype.calcSpaceLeft = function (isOn, size, padding, margin) {
            return isOn ? 0 : this.getSpaceLeft(size - padding, margin);
        };
        DLayout.prototype.onRefit = function () {
            var children = this.children;
            var padding = this._padding;
            var paddingTop = padding.getTop();
            var paddingBottom = padding.getBottom();
            var paddingLeft = padding.getLeft();
            var paddingRight = padding.getRight();
            var margin = this._margin;
            var marginVertical = margin.vertical;
            var marginHorizontal = margin.horizontal;
            var weightTotal = this.getWeightTotal();
            var multiplicity = this._multiplicity;
            var reverse = this._reverse;
            var auto = this._auto;
            var cornerAdjustWork = null;
            if (this._cornerAdjust) {
                var requiredSize = 4 + (children.length << 1);
                if (DLayout.CORNER_ADJUST_WORK == null ||
                    DLayout.CORNER_ADJUST_WORK.length < requiredSize) {
                    DLayout.CORNER_ADJUST_WORK = new Float32Array(requiredSize);
                }
                cornerAdjustWork = DLayout.CORNER_ADJUST_WORK;
                cornerAdjustWork[0] = -2;
                cornerAdjustWork[1] = -2;
                cornerAdjustWork[requiredSize - 2] = -3;
                cornerAdjustWork[requiredSize - 1] = -3;
            }
            if (this._direction === DLayoutDirection.VERTICAL) {
                var irow = 0;
                var y = paddingTop - marginVertical;
                if (0 < weightTotal) {
                    var weightTotalInverse = 1 / weightTotal;
                    var spaceLeft = this.calcSpaceLeft(auto.height.isOn, this.height, paddingTop + paddingBottom, marginVertical);
                    for (var i = 0, imax = children.length; i < imax;) {
                        var x = paddingLeft - marginHorizontal;
                        var height = 0;
                        var j = 0;
                        for (; j < multiplicity && i + j < imax; ++j) {
                            var child = children[reverse ? imax - 1 - (i + j) : i + j];
                            if (isVisible(child)) {
                                var clearType = child.getClearType();
                                if (j !== 0 && clearType & DLayoutClearType.BEFORE) {
                                    break;
                                }
                                else {
                                    child.position.set(marginHorizontal + x, marginVertical + y);
                                    var weight = child.weight;
                                    if (0 <= weight) {
                                        child.height = spaceLeft * (weight * weightTotalInverse);
                                    }
                                    x += marginHorizontal + child.width;
                                    height = Math.max(height, child.height);
                                    if (clearType & DLayoutClearType.AFTER) {
                                        if (cornerAdjustWork != null) {
                                            var k = (i + j + 1) << 1;
                                            cornerAdjustWork[k + 0] = j;
                                            cornerAdjustWork[k + 1] = irow;
                                        }
                                        j += 1;
                                        break;
                                    }
                                    else {
                                        if (cornerAdjustWork != null) {
                                            var k = (i + j + 1) << 1;
                                            cornerAdjustWork[k + 0] = j;
                                            cornerAdjustWork[k + 1] = irow;
                                        }
                                    }
                                }
                            }
                            else {
                                if (cornerAdjustWork != null) {
                                    var k = (i + j + 1) << 1;
                                    cornerAdjustWork[k + 0] = j - 1;
                                    cornerAdjustWork[k + 1] = irow;
                                }
                                i += 1;
                                j -= 1;
                            }
                        }
                        y += marginVertical + height;
                        i += j;
                        irow += 1;
                    }
                    if (cornerAdjustWork != null) {
                        for (var i = 0, imax = children.length; i < imax; ++i) {
                            var child = children[reverse ? imax - 1 - i : i];
                            if (isVisible(child)) {
                                var i1 = 2 + (i << 1);
                                var icolumn1 = cornerAdjustWork[i1 + 0];
                                var irow1 = cornerAdjustWork[i1 + 1];
                                var clearType = child.getClearType();
                                var icolumn0 = -2;
                                if (!(clearType & DLayoutClearType.BEFORE)) {
                                    var i0 = this.findRowIndexPrevious(i1, irow1, cornerAdjustWork);
                                    if (!this.hasClearTypeAfter(children, i0)) {
                                        icolumn0 = cornerAdjustWork[i0];
                                    }
                                }
                                var icolumn2 = -2;
                                if (!(clearType & DLayoutClearType.AFTER)) {
                                    var i2 = this.findRowIndexNext(i1, irow1, cornerAdjustWork);
                                    if (!this.hasClearTypeBefore(children, i2)) {
                                        icolumn2 = cornerAdjustWork[i2];
                                    }
                                }
                                var ncolumn = this.countColumn(i1, irow1, cornerAdjustWork);
                                child.corner.mask = this.toCornerMaskColumn(icolumn0, icolumn1, icolumn2, ncolumn);
                            }
                        }
                    }
                }
                else {
                    for (var i = 0, imax = children.length; i < imax;) {
                        var x = paddingLeft - marginHorizontal;
                        var height = 0;
                        var j = 0;
                        for (; j < multiplicity && i + j < imax; ++j) {
                            var child = children[reverse ? imax - 1 - (i + j) : i + j];
                            if (isVisible(child)) {
                                var clearType = child.getClearType();
                                if (j !== 0 && clearType & DLayoutClearType.BEFORE) {
                                    break;
                                }
                                else {
                                    child.position.set(marginHorizontal + x, marginVertical + y);
                                    var weight = child.weight;
                                    if (0 <= weight) {
                                        child.height = 0;
                                    }
                                    x += marginHorizontal + child.width;
                                    height = Math.max(height, child.height);
                                    if (clearType & DLayoutClearType.AFTER) {
                                        if (cornerAdjustWork != null) {
                                            var k = (i + j + 1) << 1;
                                            cornerAdjustWork[k + 0] = j;
                                            cornerAdjustWork[k + 1] = irow;
                                        }
                                        j += 1;
                                        break;
                                    }
                                    else {
                                        if (cornerAdjustWork != null) {
                                            var k = (i + j + 1) << 1;
                                            cornerAdjustWork[k + 0] = j;
                                            cornerAdjustWork[k + 1] = irow;
                                        }
                                    }
                                }
                            }
                            else {
                                if (cornerAdjustWork != null) {
                                    var k = (i + j + 1) << 1;
                                    cornerAdjustWork[k + 0] = j - 1;
                                    cornerAdjustWork[k + 1] = irow;
                                }
                                i += 1;
                                j -= 1;
                            }
                        }
                        y += marginVertical + height;
                        i += j;
                        irow += 1;
                    }
                    if (cornerAdjustWork != null) {
                        for (var i = 0, imax = children.length; i < imax; ++i) {
                            var child = children[reverse ? imax - 1 - i : i];
                            if (isVisible(child)) {
                                var i1 = 2 + (i << 1);
                                var icolumn1 = cornerAdjustWork[i1 + 0];
                                var irow1 = cornerAdjustWork[i1 + 1];
                                var clearType = child.getClearType();
                                var icolumn0 = -2;
                                if (!(clearType & DLayoutClearType.BEFORE)) {
                                    var i0 = this.findRowIndexPrevious(i1, irow1, cornerAdjustWork);
                                    if (!this.hasClearTypeAfter(children, i0)) {
                                        icolumn0 = cornerAdjustWork[i0];
                                    }
                                }
                                var icolumn2 = -2;
                                if (!(clearType & DLayoutClearType.AFTER)) {
                                    var i2 = this.findRowIndexNext(i1, irow1, cornerAdjustWork);
                                    if (!this.hasClearTypeBefore(children, i2)) {
                                        icolumn2 = cornerAdjustWork[i2];
                                    }
                                }
                                var ncolumn = this.countColumn(i1, irow1, cornerAdjustWork);
                                child.corner.mask = this.toCornerMaskColumn(icolumn0, icolumn1, icolumn2, ncolumn);
                            }
                        }
                    }
                }
            }
            else {
                var icolumn = 0;
                var x = paddingLeft - marginHorizontal;
                if (0 < weightTotal) {
                    var weightTotalInverse = 1 / weightTotal;
                    var spaceLeft = this.calcSpaceLeft(auto.width.isOn, this.width, paddingLeft + paddingRight, marginHorizontal);
                    for (var i = 0, imax = children.length; i < imax;) {
                        var y = paddingTop - marginVertical;
                        var width = 0;
                        var j = 0;
                        for (; j < multiplicity && i + j < imax; ++j) {
                            var child = children[reverse ? imax - 1 - (i + j) : i + j];
                            if (isVisible(child)) {
                                var clearType = child.getClearType();
                                if (j !== 0 && clearType & DLayoutClearType.BEFORE) {
                                    break;
                                }
                                else {
                                    child.position.set(marginHorizontal + x, marginVertical + y);
                                    var weight = child.weight;
                                    if (0 <= weight) {
                                        child.width = spaceLeft * (weight * weightTotalInverse);
                                    }
                                    width = Math.max(width, child.width);
                                    y += marginVertical + child.height;
                                    if (clearType & DLayoutClearType.AFTER) {
                                        if (cornerAdjustWork != null) {
                                            var k = (i + j + 1) << 1;
                                            cornerAdjustWork[k + 0] = icolumn;
                                            cornerAdjustWork[k + 1] = j;
                                        }
                                        j += 1;
                                        break;
                                    }
                                    else {
                                        if (cornerAdjustWork != null) {
                                            var k = (i + j + 1) << 1;
                                            cornerAdjustWork[k + 0] = icolumn;
                                            cornerAdjustWork[k + 1] = j;
                                        }
                                    }
                                }
                            }
                            else {
                                if (cornerAdjustWork != null) {
                                    var k = (i + j + 1) << 1;
                                    cornerAdjustWork[k + 0] = icolumn;
                                    cornerAdjustWork[k + 1] = j - 1;
                                }
                                i += 1;
                                j -= 1;
                            }
                        }
                        x += marginHorizontal + width;
                        i += j;
                        icolumn += 1;
                    }
                    if (cornerAdjustWork != null) {
                        for (var i = 0, imax = children.length; i < imax; ++i) {
                            var child = children[reverse ? imax - 1 - i : i];
                            if (isVisible(child)) {
                                var i1 = 2 + (i << 1);
                                var icolumn1 = cornerAdjustWork[i1 + 0];
                                var irow1 = cornerAdjustWork[i1 + 1];
                                var clearType = child.getClearType();
                                var irow0 = -2;
                                if (!(clearType & DLayoutClearType.BEFORE)) {
                                    var i0 = this.findColumnIndexPrevious(i1, icolumn1, cornerAdjustWork);
                                    if (!this.hasClearTypeAfter(children, i0)) {
                                        irow0 = cornerAdjustWork[i0 + 1];
                                    }
                                }
                                var irow2 = -2;
                                if (!(clearType & DLayoutClearType.AFTER)) {
                                    var i2 = this.findColumnIndexNext(i1, icolumn1, cornerAdjustWork);
                                    if (!this.hasClearTypeBefore(children, i2)) {
                                        irow2 = cornerAdjustWork[i2 + 1];
                                    }
                                }
                                var nrow = this.countRow(i1, icolumn1, cornerAdjustWork);
                                child.corner.mask = this.toCornerMaskRow(irow0, irow1, irow2, nrow);
                            }
                        }
                    }
                }
                else {
                    for (var i = 0, imax = children.length; i < imax;) {
                        var y = paddingTop - marginVertical;
                        var width = 0;
                        var j = 0;
                        for (; j < multiplicity && i + j < imax; ++j) {
                            var child = children[reverse ? imax - 1 - (i + j) : i + j];
                            if (isVisible(child)) {
                                var clearType = child.getClearType();
                                if (j !== 0 && clearType & DLayoutClearType.BEFORE) {
                                    break;
                                }
                                else {
                                    child.position.set(marginHorizontal + x, marginVertical + y);
                                    var weight = child.weight;
                                    if (0 <= weight) {
                                        child.width = 0;
                                    }
                                    width = Math.max(width, child.width);
                                    y += marginVertical + child.height;
                                    if (clearType & DLayoutClearType.AFTER) {
                                        if (cornerAdjustWork != null) {
                                            var k = (i + j + 1) << 1;
                                            cornerAdjustWork[k + 0] = icolumn;
                                            cornerAdjustWork[k + 1] = j;
                                        }
                                        j += 1;
                                        break;
                                    }
                                    else {
                                        if (cornerAdjustWork != null) {
                                            var k = (i + j + 1) << 1;
                                            cornerAdjustWork[k + 0] = icolumn;
                                            cornerAdjustWork[k + 1] = j;
                                        }
                                    }
                                }
                            }
                            else {
                                if (cornerAdjustWork != null) {
                                    var k = (i + j + 1) << 1;
                                    cornerAdjustWork[k + 0] = icolumn;
                                    cornerAdjustWork[k + 1] = j - 1;
                                }
                                i += 1;
                                j -= 1;
                            }
                        }
                        x += marginHorizontal + width;
                        i += j;
                        icolumn += 1;
                    }
                    if (cornerAdjustWork != null) {
                        for (var i = 0, imax = children.length; i < imax; ++i) {
                            var child = children[reverse ? imax - 1 - i : i];
                            if (isVisible(child)) {
                                var i1 = 2 + (i << 1);
                                var icolumn1 = cornerAdjustWork[i1 + 0];
                                var irow1 = cornerAdjustWork[i1 + 1];
                                var clearType = child.getClearType();
                                var irow0 = -2;
                                if (!(clearType & DLayoutClearType.BEFORE)) {
                                    var i0 = this.findColumnIndexPrevious(i1, icolumn1, cornerAdjustWork);
                                    if (!this.hasClearTypeAfter(children, i0)) {
                                        irow0 = cornerAdjustWork[i0 + 1];
                                    }
                                }
                                var irow2 = -2;
                                if (!(clearType & DLayoutClearType.AFTER)) {
                                    var i2 = this.findColumnIndexNext(i1, icolumn1, cornerAdjustWork);
                                    if (!this.hasClearTypeBefore(children, i2)) {
                                        irow2 = cornerAdjustWork[i2 + 1];
                                    }
                                }
                                var nrow = this.countRow(i1, icolumn1, cornerAdjustWork);
                                child.corner.mask = this.toCornerMaskRow(irow0, irow1, irow2, nrow);
                            }
                        }
                    }
                }
            }
            _super.prototype.onRefit.call(this);
        };
        DLayout.prototype.hasClearTypeBefore = function (children, index) {
            return this.hasClearType(children, index, DLayoutClearType.BEFORE);
        };
        DLayout.prototype.hasClearTypeAfter = function (children, index) {
            return this.hasClearType(children, index, DLayoutClearType.AFTER);
        };
        DLayout.prototype.hasClearType = function (children, index, clearType) {
            if (2 <= index) {
                var i = (index - 2) >> 1;
                if (0 <= i && i < children.length) {
                    var child = children[i];
                    if (child instanceof DBase) {
                        return !!(child.getClearType() & clearType);
                    }
                }
            }
            return false;
        };
        DLayout.prototype.findColumnIndexPrevious = function (istart, icolumn, cornerAdjustWork) {
            for (var i = istart - 2; 0 <= i; i -= 2) {
                if (cornerAdjustWork[i] !== icolumn) {
                    return i;
                }
            }
            return 0;
        };
        DLayout.prototype.findColumnIndexNext = function (istart, icolumn, cornerAdjustWork) {
            for (var i = istart + 2, imax = cornerAdjustWork.length; i < imax; i += 2) {
                var icolumn2 = cornerAdjustWork[i];
                if (icolumn2 !== icolumn) {
                    for (var j = i + 2; j < imax; j += 2) {
                        if (cornerAdjustWork[j] !== icolumn2) {
                            return j - 2;
                        }
                    }
                    return i;
                }
            }
            return cornerAdjustWork.length - 2;
        };
        DLayout.prototype.countRow = function (istart, icolumn, cornerAdjustWork) {
            for (var i = istart + 2, imax = cornerAdjustWork.length; i < imax; i += 2) {
                var icolumn2 = cornerAdjustWork[i];
                if (icolumn2 !== icolumn) {
                    return cornerAdjustWork[i - 2 + 1] + 1;
                }
            }
            return 0;
        };
        DLayout.prototype.findRowIndexPrevious = function (istart, irow, cornerAdjustWork) {
            for (var i = istart - 2; 0 <= i; i -= 2) {
                if (cornerAdjustWork[i + 1] !== irow) {
                    return i;
                }
            }
            return 0;
        };
        DLayout.prototype.findRowIndexNext = function (istart, irow, cornerAdjustWork) {
            for (var i = istart + 2, imax = cornerAdjustWork.length; i < imax; i += 2) {
                var irow2 = cornerAdjustWork[i + 1];
                if (irow2 !== irow) {
                    for (var j = i + 2; j < imax; j += 2) {
                        if (cornerAdjustWork[j + 1] !== irow2) {
                            return j - 2;
                        }
                    }
                    return i;
                }
            }
            return cornerAdjustWork.length - 2;
        };
        DLayout.prototype.countColumn = function (istart, irow, cornerAdjustWork) {
            for (var i = istart + 2, imax = cornerAdjustWork.length; i < imax; i += 2) {
                var irow2 = cornerAdjustWork[i + 1];
                if (irow2 !== irow) {
                    return cornerAdjustWork[i - 2 + 0] + 1;
                }
            }
            return 0;
        };
        DLayout.prototype.toCornerMaskColumn = function (i0, i1, i2, n) {
            var result = DCornerMask.NONE;
            if (i0 + 1 < i1 && i1 === 0) {
                result |= DCornerMask.TOP_LEFT;
            }
            if (i2 + 1 < i1 && i1 === 0) {
                result |= DCornerMask.BOTTOM_LEFT;
            }
            if (i0 < i1 && i1 + 1 === n) {
                result |= DCornerMask.TOP_RIGHT;
            }
            if (i2 < i1 && i1 + 1 === n) {
                result |= DCornerMask.BOTTOM_RIGHT;
            }
            return DCornerMask.ALL & ~result;
        };
        DLayout.prototype.toCornerMaskRow = function (i0, i1, i2, n) {
            var result = DCornerMask.NONE;
            if (i0 + 1 < i1 && i1 === 0) {
                result |= DCornerMask.TOP_LEFT;
            }
            if (i2 + 1 < i1 && i1 === 0) {
                result |= DCornerMask.TOP_RIGHT;
            }
            if (i0 < i1 && i1 + 1 === n) {
                result |= DCornerMask.BOTTOM_LEFT;
            }
            if (i2 < i1 && i1 + 1 === n) {
                result |= DCornerMask.BOTTOM_RIGHT;
            }
            return DCornerMask.ALL & ~result;
        };
        DLayout.prototype.addSpace = function (options) {
            return this.addChild(new DLayoutSpace(options));
        };
        DLayout.prototype.getType = function () {
            return "DLayout";
        };
        DLayout.CORNER_ADJUST_WORK = null;
        return DLayout;
    }(DBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DLayoutVertical = /** @class */ (function (_super) {
        __extends(DLayoutVertical, _super);
        function DLayoutVertical() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DLayoutVertical.prototype.getType = function () {
            return "DLayoutVertical";
        };
        return DLayoutVertical;
    }(DLayout));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogLayeredContent = /** @class */ (function (_super) {
        __extends(DDialogLayeredContent, _super);
        function DDialogLayeredContent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DDialogLayeredContent.prototype.getType = function () {
            return "DDialogLayeredContent";
        };
        return DDialogLayeredContent;
    }(DLayoutVertical));

    /*
     * Copyright (C) 2021 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * {@link DButtonBase} option when to activate a button.
     */
    var DButtonBaseWhen = {
        /** Activates when clicked */
        CLICKED: 0,
        /** Activates when double clicked */
        DOUBLE_CLICKED: 1
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DAlignWith = {
        TEXT: 0,
        PADDING: 1,
        BORDER: 2
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DAlignHorizontal = {
        LEFT: 0,
        CENTER: 1,
        RIGHT: 2
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DAlignVertical = {
        TOP: 0,
        MIDDLE: 1,
        BOTTOM: 2
    };

    var DImagePieceLayouterPart = /** @class */ (function () {
        function DImagePieceLayouterPart() {
            this._pieces = [];
            this._bounds = [];
            this._size = 0;
            this._margin = 0;
        }
        DImagePieceLayouterPart.prototype.clear = function () {
            this._pieces.length = 0;
            this._bounds.length = 0;
            this._size = 0;
            this._margin = 0;
            this._text = undefined;
        };
        DImagePieceLayouterPart.prototype.set = function (text) {
            this._text = text;
        };
        Object.defineProperty(DImagePieceLayouterPart.prototype, "size", {
            get: function () {
                return this._size - (this._text === null ? this._margin : 0);
            },
            enumerable: false,
            configurable: true
        });
        return DImagePieceLayouterPart;
    }());

    var DImagePieceLayouterPartBottom = /** @class */ (function (_super) {
        __extends(DImagePieceLayouterPartBottom, _super);
        function DImagePieceLayouterPartBottom() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DImagePieceLayouterPartBottom.prototype.add = function (image, bound, margin) {
            this._pieces.push(image);
            this._bounds.push(bound);
            this._size += margin + bound.height;
            this._margin = margin;
        };
        DImagePieceLayouterPartBottom.prototype.execute = function (pbottom, height) {
            var pieces = this._pieces;
            var bounds = this._bounds;
            var y = height - pbottom;
            if (this._text !== undefined) {
                var margin = 0;
                for (var i = 0, imax = pieces.length; i < imax; ++i) {
                    var piece = pieces[i];
                    var bound = bounds[i];
                    var object = piece.object;
                    y -= margin + bound.height;
                    object.y = y - bound.y;
                    margin = piece.margin.horizontal;
                }
            }
            else {
                for (var i = 0, imax = pieces.length; i < imax; ++i) {
                    var piece = pieces[i];
                    var bound = bounds[i];
                    var object = piece.object;
                    y -= piece.margin.horizontal + bound.height;
                    object.y = y - bound.y;
                }
            }
        };
        return DImagePieceLayouterPartBottom;
    }(DImagePieceLayouterPart));

    var DImagePieceLayouterPartCenter = /** @class */ (function (_super) {
        __extends(DImagePieceLayouterPartCenter, _super);
        function DImagePieceLayouterPartCenter() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DImagePieceLayouterPartCenter.prototype.add = function (image, bound, margin) {
            this._pieces.push(image);
            this._bounds.push(bound);
            this._size = Math.max(this.size, bound.width);
        };
        DImagePieceLayouterPartCenter.prototype.execute = function (pleft, pright, width) {
            var c = pleft + (width - pleft - pright) * 0.5;
            var pieces = this._pieces;
            var bounds = this._bounds;
            for (var i = 0, imax = pieces.length; i < imax; ++i) {
                var piece = pieces[i];
                var bound = bounds[i];
                var object = piece.object;
                object.x = c - bound.x - bound.width * 0.5;
            }
        };
        return DImagePieceLayouterPartCenter;
    }(DImagePieceLayouterPart));

    var DImagePieceLayouterPartLeft = /** @class */ (function (_super) {
        __extends(DImagePieceLayouterPartLeft, _super);
        function DImagePieceLayouterPartLeft() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DImagePieceLayouterPartLeft.prototype.add = function (image, bound, margin) {
            this._pieces.push(image);
            this._bounds.push(bound);
            this._size += margin + bound.width;
            this._margin = margin;
        };
        DImagePieceLayouterPartLeft.prototype.execute = function (pleft) {
            var pieces = this._pieces;
            var bounds = this._bounds;
            var x = pleft;
            if (this._text !== undefined) {
                for (var i = 0, imax = pieces.length; i < imax; ++i) {
                    var piece = pieces[i];
                    var bound = bounds[i];
                    var object = piece.object;
                    object.x = x - bound.x;
                    x += bound.width + piece.margin.horizontal;
                }
            }
            else {
                for (var i = 0, imax = pieces.length; i < imax; ++i) {
                    var piece = pieces[i];
                    var bound = bounds[i];
                    var object = piece.object;
                    x += piece.margin.horizontal;
                    object.x = x - bound.x;
                    x += bound.width;
                }
            }
        };
        return DImagePieceLayouterPartLeft;
    }(DImagePieceLayouterPart));

    var DImagePieceLayouterPartMiddle = /** @class */ (function (_super) {
        __extends(DImagePieceLayouterPartMiddle, _super);
        function DImagePieceLayouterPartMiddle() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DImagePieceLayouterPartMiddle.prototype.add = function (image, bound, margin) {
            this._pieces.push(image);
            this._bounds.push(bound);
            this._size = Math.max(this.size, bound.height);
        };
        DImagePieceLayouterPartMiddle.prototype.execute = function (ptop, pbottom, height) {
            var c = ptop + (height - ptop - pbottom) * 0.5;
            var pieces = this._pieces;
            var bounds = this._bounds;
            for (var i = 0, imax = pieces.length; i < imax; ++i) {
                var piece = pieces[i];
                var bound = bounds[i];
                var object = piece.object;
                object.y = c - bound.y - bound.height * 0.5;
            }
        };
        return DImagePieceLayouterPartMiddle;
    }(DImagePieceLayouterPart));

    var DImagePieceLayouterPartRight = /** @class */ (function (_super) {
        __extends(DImagePieceLayouterPartRight, _super);
        function DImagePieceLayouterPartRight() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DImagePieceLayouterPartRight.prototype.add = function (image, bound, margin) {
            this._pieces.push(image);
            this._bounds.push(bound);
            this._size += margin + bound.width;
            this._margin = margin;
        };
        DImagePieceLayouterPartRight.prototype.execute = function (pright, width) {
            var pieces = this._pieces;
            var bounds = this._bounds;
            var x = width - pright;
            if (this._text !== undefined) {
                var margin = 0;
                for (var i = 0, imax = pieces.length; i < imax; ++i) {
                    var piece = pieces[i];
                    var bound = bounds[i];
                    var object = piece.object;
                    x -= margin + bound.width;
                    object.x = x - bound.x;
                    margin = piece.margin.horizontal;
                }
            }
            else {
                for (var i = 0, imax = pieces.length; i < imax; ++i) {
                    var piece = pieces[i];
                    var bound = bounds[i];
                    var object = piece.object;
                    x -= piece.margin.horizontal + bound.width;
                    object.x = x - bound.x;
                }
            }
        };
        return DImagePieceLayouterPartRight;
    }(DImagePieceLayouterPart));

    var DImagePieceLayouterPartTop = /** @class */ (function (_super) {
        __extends(DImagePieceLayouterPartTop, _super);
        function DImagePieceLayouterPartTop() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DImagePieceLayouterPartTop.prototype.add = function (image, bound, margin) {
            this._pieces.push(image);
            this._bounds.push(bound);
            this._size += margin + bound.height;
            this._margin = margin;
        };
        DImagePieceLayouterPartTop.prototype.execute = function (ptop) {
            var pieces = this._pieces;
            var bounds = this._bounds;
            var y = ptop;
            if (this._text !== undefined) {
                var margin = 0;
                for (var i = 0, imax = pieces.length; i < imax; ++i) {
                    var piece = pieces[i];
                    var bound = bounds[i];
                    var object = piece.object;
                    object.y = margin + y - bound.y;
                    y += bound.height;
                    margin = piece.margin.vertical;
                }
            }
            else {
                for (var i = 0, imax = pieces.length; i < imax; ++i) {
                    var piece = pieces[i];
                    var bound = bounds[i];
                    var object = piece.object;
                    y += piece.margin.vertical;
                    object.y = y - bound.y;
                    y += bound.height;
                }
            }
        };
        return DImagePieceLayouterPartTop;
    }(DImagePieceLayouterPart));

    var DImagePieceLayouterPartContainer = /** @class */ (function () {
        function DImagePieceLayouterPartContainer() {
            this.left = new DImagePieceLayouterPartLeft();
            this.center = new DImagePieceLayouterPartCenter();
            this.right = new DImagePieceLayouterPartRight();
            this.top = new DImagePieceLayouterPartTop();
            this.middle = new DImagePieceLayouterPartMiddle();
            this.bottom = new DImagePieceLayouterPartBottom();
        }
        DImagePieceLayouterPartContainer.prototype.clear = function () {
            this.left.clear();
            this.center.clear();
            this.right.clear();
            this.top.clear();
            this.middle.clear();
            this.bottom.clear();
            this.text = undefined;
        };
        DImagePieceLayouterPartContainer.prototype.add = function (image) {
            var object = image.object;
            if (object != null) {
                var bound = object.getLocalBounds();
                var margin = image.margin;
                var align = image.align;
                switch (align.horizontal) {
                    case DAlignHorizontal.LEFT:
                        this.left.add(image, bound, margin.horizontal);
                        break;
                    case DAlignHorizontal.CENTER:
                        this.center.add(image, bound, margin.horizontal);
                        break;
                    case DAlignHorizontal.RIGHT:
                        this.right.add(image, bound, margin.horizontal);
                        break;
                }
                switch (align.vertical) {
                    case DAlignVertical.TOP:
                        this.top.add(image, bound, margin.vertical);
                        break;
                    case DAlignVertical.MIDDLE:
                        this.middle.add(image, bound, margin.vertical);
                        break;
                    case DAlignVertical.BOTTOM:
                        this.bottom.add(image, bound, margin.vertical);
                        break;
                }
            }
        };
        DImagePieceLayouterPartContainer.prototype.set = function (text) {
            this.left.set(text);
            this.center.set(text);
            this.right.set(text);
            this.top.set(text);
            this.middle.set(text);
            this.bottom.set(text);
            this.text = text;
        };
        Object.defineProperty(DImagePieceLayouterPartContainer.prototype, "width", {
            get: function () {
                var text = this.text;
                var left = this.left;
                var leftSize = left.size;
                var center = this.center;
                var centerSize = center.size;
                var right = this.right;
                var rightSize = right.size;
                if (text !== undefined) {
                    if (text !== null) {
                        return Math.max(leftSize + text.width + rightSize, centerSize);
                    }
                    else {
                        return Math.max(leftSize + rightSize, centerSize);
                    }
                }
                else {
                    return Math.max(leftSize, rightSize, centerSize);
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DImagePieceLayouterPartContainer.prototype, "height", {
            get: function () {
                var text = this.text;
                var top = this.top;
                var topSize = top.size;
                var middle = this.middle;
                var middleSize = middle.size;
                var bottom = this.bottom;
                var bottomSize = bottom.size;
                if (text !== undefined) {
                    if (text !== null) {
                        return Math.max(topSize + text.height + bottomSize, middleSize);
                    }
                    else {
                        return Math.max(topSize + bottomSize, middleSize);
                    }
                }
                else {
                    return Math.max(topSize, bottomSize, middleSize);
                }
            },
            enumerable: false,
            configurable: true
        });
        DImagePieceLayouterPartContainer.prototype.execute = function (pleft, ptop, pright, pbottom, textAlign, width, height) {
            var left = this.left;
            var center = this.center;
            var right = this.right;
            var top = this.top;
            var middle = this.middle;
            var bottom = this.bottom;
            var text = this.text;
            if (text !== undefined) {
                var leftSize = left.size;
                var rightSize = right.size;
                var topSize = top.size;
                var bottomSize = bottom.size;
                var textX = 0;
                var textWidth = 0;
                var textHeight = 0;
                if (text != null) {
                    text.setClippingDelta(leftSize + rightSize, topSize + bottomSize);
                    textWidth = text.width;
                    textHeight = text.height;
                }
                switch (textAlign.horizontal) {
                    case DAlignHorizontal.LEFT:
                        textX = pleft + leftSize;
                        break;
                    case DAlignHorizontal.CENTER:
                        textX =
                            pleft +
                                (width - pleft - pright - (leftSize + textWidth + rightSize)) * 0.5 +
                                leftSize;
                        break;
                    case DAlignHorizontal.RIGHT:
                        textX = width - pright - rightSize - textWidth;
                        break;
                }
                var textY = 0;
                switch (textAlign.vertical) {
                    case DAlignVertical.TOP:
                        textY = ptop + topSize;
                        break;
                    case DAlignVertical.MIDDLE:
                        textY =
                            ptop +
                                (height - ptop - pbottom - (topSize + textHeight + bottomSize)) * 0.5 +
                                topSize;
                        break;
                    case DAlignVertical.BOTTOM:
                        textY = height - pbottom - bottomSize - textHeight;
                        break;
                }
                if (text != null) {
                    text.position.set(textX, textY);
                }
                left.execute(textX - leftSize);
                center.execute(0, 0, textX * 2 + textWidth);
                right.execute(0, textX + textWidth + rightSize);
                top.execute(textY - topSize);
                middle.execute(0, 0, textY * 2 + textHeight);
                bottom.execute(0, textY + textHeight + bottomSize);
            }
            else {
                left.execute(pleft);
                center.execute(pleft, pright, width);
                right.execute(pright, width);
                top.execute(ptop);
                middle.execute(ptop, pbottom, height);
                bottom.execute(pbottom, height);
            }
        };
        return DImagePieceLayouterPartContainer;
    }());

    var DImagePieceLayouter = /** @class */ (function () {
        function DImagePieceLayouter() {
            this.text = new DImagePieceLayouterPartContainer();
            this.padding = new DImagePieceLayouterPartContainer();
            this.border = new DImagePieceLayouterPartContainer();
        }
        DImagePieceLayouter.prototype.clear = function () {
            this.text.clear();
            this.padding.clear();
            this.border.clear();
        };
        DImagePieceLayouter.prototype.add = function (image) {
            var object = image.object;
            if (object) {
                switch (image.align.with) {
                    case DAlignWith.TEXT:
                        this.text.add(image);
                        break;
                    case DAlignWith.PADDING:
                        this.padding.add(image);
                        break;
                    case DAlignWith.BORDER:
                        this.border.add(image);
                        break;
                }
            }
        };
        DImagePieceLayouter.prototype.set = function (text) {
            this.text.set(text);
        };
        DImagePieceLayouter.prototype.execute = function (padding, textAlign, width, height) {
            var pleft = padding.getLeft();
            var ptop = padding.getTop();
            var pright = padding.getRight();
            var pbottom = padding.getBottom();
            if (width == null) {
                width = pleft + this.width + pright;
            }
            if (height == null) {
                height = ptop + this.height + pbottom;
            }
            this.border.execute(0, 0, 0, 0, textAlign, width, height);
            this.padding.execute(pleft, ptop, pright, pbottom, textAlign, width, height);
            this.text.execute(pleft, ptop, pright, pbottom, textAlign, width, height);
        };
        Object.defineProperty(DImagePieceLayouter.prototype, "width", {
            get: function () {
                return Math.max(this.border.width, this.padding.width, this.text.width);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DImagePieceLayouter.prototype, "height", {
            get: function () {
                return Math.max(this.border.height, this.padding.height, this.text.height);
            },
            enumerable: false,
            configurable: true
        });
        return DImagePieceLayouter;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DBaseOverflowMaskSimple = /** @class */ (function (_super) {
        __extends(DBaseOverflowMaskSimple, _super);
        function DBaseOverflowMaskSimple(parent) {
            var _this = _super.call(this) || this;
            _this.parent = parent;
            _this._isInitialized = false;
            _this._width = _this.width;
            _this._height = _this.height;
            return _this;
        }
        DBaseOverflowMaskSimple.prototype.render = function (renderer) {
            this.updateTransform();
            _super.prototype.render.call(this, renderer);
        };
        DBaseOverflowMaskSimple.prototype.onReflow = function (base, width, height) {
            if (this._isInitialized && this._width === width && this._height === height) {
                return;
            }
            this._isInitialized = true;
            this._width = width;
            this._height = height;
            this.clear();
            this.beginFill(0xffffff, 1);
            this.drawRect(0, 0, width, height);
            this.endFill();
        };
        return DBaseOverflowMaskSimple;
    }(pixi_js.Graphics));

    var DDynamicTextMeasureResultCharacter = /** @class */ (function () {
        function DDynamicTextMeasureResultCharacter(x, y, character, wrappable) {
            this.x = x;
            this.y = y;
            this.character = character;
            this.wrappable = wrappable;
        }
        DDynamicTextMeasureResultCharacter.prototype.set = function (x, y, character, isWrappable) {
            this.x = x;
            this.y = y;
            this.character = character;
            this.wrappable = isWrappable;
        };
        return DDynamicTextMeasureResultCharacter;
    }());

    var DDynamicTextMeasureResult = /** @class */ (function () {
        function DDynamicTextMeasureResult() {
            this.count = 0;
            this.countPerLine = 0;
            this.width = 0;
            this.height = 0;
            this.characters = [];
            this.scale = 1;
            this.scaled = false;
            this.clipped = false;
            this.x = 0;
            this.y = 0;
        }
        DDynamicTextMeasureResult.prototype.start = function (lineHeight, fontHeight) {
            this.count = 0;
            this.countPerLine = 0;
            this.width = 0;
            this.height = 0;
            this.scale = 1;
            this.scaled = false;
            this.clipped = false;
            this.x = 0;
            this.y = 0.5 * (lineHeight - fontHeight);
        };
        DDynamicTextMeasureResult.prototype.isPushable = function (width, character) {
            var x = this.x + character.advance;
            if (width < x) {
                if (character.type & DynamicFontAtlasCharacterType.SPACE) {
                    return true;
                }
                else {
                    return false;
                }
            }
            return true;
        };
        DDynamicTextMeasureResult.prototype.isPushableAtNewLine = function (height, lineHeight, fontHeight) {
            return this.y + 1.5 * lineHeight + 0.5 * fontHeight <= height;
        };
        DDynamicTextMeasureResult.prototype.push = function (character, isWrappable) {
            var x = this.x;
            this.x += character.advance;
            var y = this.y;
            var count = this.count;
            var characters = this.characters;
            if (count < characters.length) {
                characters[count].set(x, y, character, isWrappable);
            }
            else {
                characters.push(new DDynamicTextMeasureResultCharacter(x, y, character, isWrappable));
            }
            this.count += 1;
            this.countPerLine += 1;
        };
        DDynamicTextMeasureResult.prototype.newLine = function (lineHeight) {
            this.width = Math.max(this.width, this.x);
            this.x = 0;
            this.y += lineHeight;
            this.countPerLine = 0;
        };
        DDynamicTextMeasureResult.prototype.wordWrap = function (lineHeight) {
            var countPerLine = this.countPerLine;
            var characters = this.characters;
            if (0 < countPerLine) {
                var count = this.count;
                for (var i = count - 1, imin = count - countPerLine; imin < i; --i) {
                    var character = characters[i];
                    if (character.wrappable) {
                        var x = character.character.advance;
                        var y = character.y + lineHeight;
                        character.x = 0;
                        character.y = y;
                        for (var j = i + 1; j < count; ++j) {
                            character = characters[j];
                            character.x = x;
                            character.y = y;
                            x += character.character.advance;
                        }
                        this.x = x;
                        this.y = y;
                        this.countPerLine = count - i;
                        return true;
                    }
                }
                var last = characters[count - 1];
                last.x = 0;
                last.y = last.y + lineHeight;
                this.x = last.character.advance;
                this.y = last.y;
                this.countPerLine = 1;
                return false;
            }
            return false;
        };
        DDynamicTextMeasureResult.prototype.pop = function () {
            var countPerLine = this.countPerLine;
            var characters = this.characters;
            if (0 < countPerLine) {
                var character = characters[this.count - 1];
                this.x -= character.character.advance;
                this.count -= 1;
                this.countPerLine -= 1;
                return true;
            }
            return false;
        };
        DDynamicTextMeasureResult.prototype.fit = function (width, height) {
            var w = this.width;
            var h = this.height;
            if (1e-4 < w && width < w) {
                if (1e-4 < h && height < h) {
                    this.scale = Math.min(width / w, height / h);
                    this.scaled = true;
                }
                else {
                    this.scale = width / w;
                    this.scaled = true;
                }
            }
            else if (1e-4 < h && height < h) {
                this.scale = height / h;
                this.scaled = true;
            }
        };
        DDynamicTextMeasureResult.prototype.end = function (lineHeight, fontHeight) {
            this.newLine(lineHeight);
            this.y -= 0.5 * (lineHeight - fontHeight);
            this.height = this.y;
        };
        return DDynamicTextMeasureResult;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var UtilCharacterIterator = /** @class */ (function () {
        function UtilCharacterIterator() {
            this.target = "";
            this.position = 0;
        }
        UtilCharacterIterator.prototype.init = function (target) {
            this.target = target;
            this.position = 0;
        };
        UtilCharacterIterator.prototype.hasNext = function () {
            return this.position < this.target.length;
        };
        UtilCharacterIterator.prototype.findNextBreak = function (target, istart) {
            var iend = target.length;
            for (var i = istart; i < iend; ++i) {
                var code = target.charCodeAt(i);
                if (!this.isLowSurrogate(code) && !this.isVariationSelector(code)) {
                    return i;
                }
            }
            return iend;
        };
        UtilCharacterIterator.prototype.isHighSurrogate = function (code) {
            return 0xd800 <= code && code <= 0xdbff;
        };
        UtilCharacterIterator.prototype.isLowSurrogate = function (code) {
            return 0xdc00 <= code && code <= 0xdfff;
        };
        UtilCharacterIterator.prototype.isVariationSelector = function (code) {
            return 0xfe00 <= code && code <= 0xfe0f;
        };
        UtilCharacterIterator.prototype.next = function () {
            var target = this.target;
            var position = this.position;
            var nextBreak = this.findNextBreak(target, position + 1);
            var result = target.substring(position, nextBreak);
            this.position = nextBreak;
            return result;
        };
        /**
         * Closes this iterator.
         *
         * @returns true if closed.
         */
        UtilCharacterIterator.prototype.close = function () {
            var length = this.target.length;
            if (this.position < length) {
                this.position = length;
                return true;
            }
            return false;
        };
        UtilCharacterIterator.from = function (target) {
            if (UtilCharacterIterator._instance == null) {
                UtilCharacterIterator._instance = new UtilCharacterIterator();
            }
            var instance = UtilCharacterIterator._instance;
            instance.init(target);
            return instance;
        };
        UtilCharacterIterator._instance = null;
        return UtilCharacterIterator;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDynamicTextStyleWordWrap = {
        NONE: 0,
        NORMAL: 1,
        BREAK_ALL: 2
    };

    var DDynamicTextMeasure = /** @class */ (function () {
        function DDynamicTextMeasure() {
        }
        DDynamicTextMeasure.measure = function (text, atlas, modifier) {
            var result = DDynamicTextMeasure.RESULT || new DDynamicTextMeasureResult();
            DDynamicTextMeasure.RESULT = result;
            if (atlas != null) {
                var itr = UtilCharacterIterator.from(text);
                var fh = atlas.font.height;
                var lh = modifier.lineHeight;
                var cf = modifier.fitting;
                var cc = !cf && modifier.clipping;
                var cw = modifier.width;
                var ch = modifier.height;
                var cp = !cf && modifier.wordWrap;
                result.start(lh, fh);
                switch (cp) {
                    case DDynamicTextStyleWordWrap.BREAK_ALL:
                        if (cc) {
                            this.measure1(itr, cw, ch, fh, lh, atlas, result);
                        }
                        else {
                            this.measure2(itr, cw, lh, atlas, result);
                        }
                        break;
                    case DDynamicTextStyleWordWrap.NORMAL:
                        var lb = this.newLineBreaker(text);
                        if (lb) {
                            if (cc) {
                                this.measure1a(lb, itr, cw, ch, fh, lh, atlas, result);
                            }
                            else {
                                this.measure2a(lb, itr, cw, lh, atlas, result);
                            }
                        }
                        else {
                            if (cc) {
                                this.measure1b(itr, cw, ch, fh, lh, atlas, result);
                            }
                            else {
                                this.measure2b(itr, cw, lh, atlas, result);
                            }
                        }
                        break;
                    default:
                        if (cc) {
                            this.measure3(itr, cw, ch, fh, lh, atlas, result);
                        }
                        else {
                            this.measure4(itr, lh, atlas, result);
                        }
                        break;
                }
                result.end(lh, fh);
                if (cf) {
                    result.fit(cw, ch);
                }
            }
            else {
                result.start(0, 0);
                result.end(0, 0);
            }
            return result;
        };
        DDynamicTextMeasure.measure1a = function (lineBreaker, iterator, clippingWidth, clippingHeight, fontHeight, lineHeight, atlas, result) {
            var lineBreak = lineBreaker.next();
            while (iterator.hasNext()) {
                var characterPosition = iterator.position;
                var character = iterator.next();
                if (character === Character.NEW_LINE) {
                    if (result.isPushableAtNewLine(clippingHeight, lineHeight, fontHeight)) {
                        result.newLine(lineHeight);
                    }
                    else {
                        this.measure5(iterator, clippingWidth, lineHeight, atlas, result, true);
                    }
                }
                else {
                    var a = atlas.get(character);
                    if (a == null)
                        continue;
                    lineBreak = this.advance(characterPosition, lineBreak, lineBreaker);
                    var isWrappable = this.isWrappable1(characterPosition, lineBreak);
                    if (result.isPushable(clippingWidth, a)) {
                        result.push(a, isWrappable);
                    }
                    else {
                        if (result.isPushableAtNewLine(clippingHeight, lineHeight, fontHeight)) {
                            result.push(a, isWrappable);
                            result.wordWrap(lineHeight);
                        }
                        else {
                            this.measure5(iterator, clippingWidth, lineHeight, atlas, result, true);
                        }
                    }
                }
            }
        };
        DDynamicTextMeasure.measure1b = function (iterator, clippingWidth, clippingHeight, fontHeight, lineHeight, atlas, result) {
            while (iterator.hasNext()) {
                var character = iterator.next();
                if (character === Character.NEW_LINE) {
                    if (result.isPushableAtNewLine(clippingHeight, lineHeight, fontHeight)) {
                        result.newLine(lineHeight);
                    }
                    else {
                        this.measure5(iterator, clippingWidth, lineHeight, atlas, result, true);
                    }
                }
                else {
                    var a = atlas.get(character);
                    if (a == null)
                        continue;
                    var isWrappable = this.isWrappable2(result, a);
                    if (result.isPushable(clippingWidth, a)) {
                        result.push(a, isWrappable);
                    }
                    else {
                        if (result.isPushableAtNewLine(clippingHeight, lineHeight, fontHeight)) {
                            result.push(a, isWrappable);
                            result.wordWrap(lineHeight);
                        }
                        else {
                            this.measure5(iterator, clippingWidth, lineHeight, atlas, result, true);
                        }
                    }
                }
            }
        };
        DDynamicTextMeasure.measure1 = function (iterator, clippingWidth, clippingHeight, fontHeight, lineHeight, atlas, result) {
            while (iterator.hasNext()) {
                var character = iterator.next();
                if (character === Character.NEW_LINE) {
                    if (result.isPushableAtNewLine(clippingHeight, lineHeight, fontHeight)) {
                        result.newLine(lineHeight);
                    }
                    else {
                        this.measure5(iterator, clippingWidth, lineHeight, atlas, result, true);
                    }
                }
                else {
                    var a = atlas.get(character);
                    if (a == null)
                        continue;
                    if (result.isPushable(clippingWidth, a)) {
                        result.push(a, true);
                    }
                    else {
                        if (result.isPushableAtNewLine(clippingHeight, lineHeight, fontHeight)) {
                            result.newLine(lineHeight);
                            result.push(a, true);
                        }
                        else {
                            this.measure5(iterator, clippingWidth, lineHeight, atlas, result, true);
                        }
                    }
                }
            }
        };
        DDynamicTextMeasure.measure2a = function (lineBreaker, iterator, clippingWidth, lineHeight, atlas, result) {
            var lineBreak = lineBreaker.next();
            while (iterator.hasNext()) {
                var characterPosition = iterator.position;
                var character = iterator.next();
                if (character === Character.NEW_LINE) {
                    result.newLine(lineHeight);
                }
                else {
                    var a = atlas.get(character);
                    if (a == null)
                        continue;
                    lineBreak = this.advance(characterPosition, lineBreak, lineBreaker);
                    var isWrappable = this.isWrappable1(characterPosition, lineBreak);
                    if (result.isPushable(clippingWidth, a)) {
                        result.push(a, isWrappable);
                    }
                    else {
                        result.push(a, isWrappable);
                        result.wordWrap(lineHeight);
                    }
                }
            }
        };
        DDynamicTextMeasure.measure2b = function (iterator, clippingWidth, lineHeight, atlas, result) {
            while (iterator.hasNext()) {
                var character = iterator.next();
                if (character === Character.NEW_LINE) {
                    result.newLine(lineHeight);
                }
                else {
                    var a = atlas.get(character);
                    if (a == null)
                        continue;
                    var isWrappable = this.isWrappable2(result, a);
                    if (result.isPushable(clippingWidth, a)) {
                        result.push(a, isWrappable);
                    }
                    else {
                        result.push(a, isWrappable);
                        result.wordWrap(lineHeight);
                    }
                }
            }
        };
        DDynamicTextMeasure.measure2 = function (iterator, clippingWidth, lineHeight, atlas, result) {
            while (iterator.hasNext()) {
                var character = iterator.next();
                if (character === Character.NEW_LINE) {
                    result.newLine(lineHeight);
                }
                else {
                    var a = atlas.get(character);
                    if (a == null)
                        continue;
                    if (result.isPushable(clippingWidth, a)) {
                        result.push(a, false);
                    }
                    else {
                        result.newLine(lineHeight);
                        result.push(a, false);
                    }
                }
            }
        };
        DDynamicTextMeasure.measure3 = function (iterator, clippingWidth, clippingHeight, fontHeight, lineHeight, atlas, result) {
            while (iterator.hasNext()) {
                var character = iterator.next();
                if (character === Character.NEW_LINE) {
                    if (result.isPushableAtNewLine(clippingHeight, lineHeight, fontHeight)) {
                        result.newLine(lineHeight);
                    }
                    else {
                        this.measure5(iterator, clippingWidth, lineHeight, atlas, result, true);
                    }
                }
                else {
                    var a = atlas.get(character);
                    if (a == null)
                        continue;
                    if (result.isPushable(clippingWidth, a)) {
                        result.push(a, false);
                    }
                    else {
                        this.measure5(iterator, clippingWidth, lineHeight, atlas, result, false);
                    }
                }
            }
        };
        DDynamicTextMeasure.measure4 = function (iterator, lineHeight, atlas, result) {
            while (iterator.hasNext()) {
                var character = iterator.next();
                if (character === Character.NEW_LINE) {
                    result.newLine(lineHeight);
                }
                else {
                    var a = atlas.get(character);
                    if (a == null)
                        continue;
                    result.push(a, false);
                }
            }
        };
        DDynamicTextMeasure.measure5 = function (iterator, clippingWidth, lineHeight, atlas, result, close) {
            result.clipped = true;
            var dots = atlas.get(Character.DOTS);
            if (dots != null) {
                while (!result.isPushable(clippingWidth, dots)) {
                    if (!result.pop()) {
                        break;
                    }
                }
                if (result.isPushable(clippingWidth, dots)) {
                    result.push(dots, false);
                }
            }
            if (close) {
                iterator.close();
            }
            else {
                while (iterator.hasNext()) {
                    if (iterator.next() === Character.NEW_LINE) {
                        result.newLine(lineHeight);
                        break;
                    }
                }
            }
        };
        DDynamicTextMeasure.isWrappable2 = function (result, character) {
            if (result.countPerLine <= 0) {
                return false;
            }
            var last = result.characters[result.count - 1];
            var lastType = last.character.type;
            var type = character.type;
            if (lastType & DynamicFontAtlasCharacterType.SPACE) {
                if (type & DynamicFontAtlasCharacterType.SPACE) {
                    return false;
                }
                else {
                    if (lastType & DynamicFontAtlasCharacterType.NON_BREAKING) {
                        return false;
                    }
                    else {
                        return true;
                    }
                }
            }
            else {
                if (type & DynamicFontAtlasCharacterType.SPACE) {
                    return false;
                }
                else {
                    if (lastType & DynamicFontAtlasCharacterType.NON_BREAKING) {
                        if (type & DynamicFontAtlasCharacterType.NON_BREAKING) {
                            return false;
                        }
                        else {
                            return true;
                        }
                    }
                    else {
                        return true;
                    }
                }
            }
        };
        DDynamicTextMeasure.advance = function (position, lineBreak, lineBreaker) {
            if (lineBreak.done) {
                return lineBreak;
            }
            if (position <= lineBreak.value.end) {
                return lineBreak;
            }
            lineBreak = lineBreaker.next();
            return lineBreak;
        };
        DDynamicTextMeasure.isWrappable1 = function (position, lineBreak) {
            if (lineBreak.done) {
                return false;
            }
            var value = lineBreak.value;
            return value.start === position || value.end === position;
        };
        DDynamicTextMeasure.newLineBreaker = function (target) {
            if ("css-line-break" in window) {
                var cssLineBreak = window["css-line-break"];
                return cssLineBreak.LineBreaker(target, {
                    lineBreak: "strict",
                    wordBreak: "normal"
                });
            }
            return null;
        };
        DDynamicTextMeasure.RESULT = null;
        return DDynamicTextMeasure;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDynamicTextGeometry = /** @class */ (function (_super) {
        __extends(DDynamicTextGeometry, _super);
        function DDynamicTextGeometry() {
            var _a, _b, _c;
            var _this = _super.call(this, ((_a = DDynamicTextGeometry.VERTICES) !== null && _a !== void 0 ? _a : (DDynamicTextGeometry.VERTICES = new Float32Array(0))), ((_b = DDynamicTextGeometry.UVS) !== null && _b !== void 0 ? _b : (DDynamicTextGeometry.UVS = new Float32Array(0))), ((_c = DDynamicTextGeometry.INDICES) !== null && _c !== void 0 ? _c : (DDynamicTextGeometry.INDICES = new Uint16Array(0)))) || this;
            _this.width = 0;
            _this.height = 0;
            _this.scale = 1;
            _this.scaled = false;
            _this.clipped = false;
            _this.vertexBuffer = _this.getBuffer("aVertexPosition");
            _this.vertices = DDynamicTextGeometry.VERTICES;
            _this.uvBuffer = _this.getBuffer("aTextureCoord");
            _this.uvs = DDynamicTextGeometry.UVS;
            _this.indexBuffer = _this.getIndex();
            _this.indices = DDynamicTextGeometry.INDICES;
            _this.nchars = 0;
            return _this;
        }
        DDynamicTextGeometry.prototype.update = function (text, atlas, modifier) {
            var result = DDynamicTextMeasure.measure(text, atlas, modifier);
            var resultCount = result.count;
            var nchars = ((resultCount >> 3) + (resultCount & 0x7 ? 1 : 0)) << 3;
            if (this.nchars < nchars) {
                this.nchars = nchars;
                var nvertex = nchars << 3;
                this.vertices = new Float32Array(nvertex);
                this.uvs = new Float32Array(nvertex);
                this.vertexBuffer.data = this.vertices;
                this.uvBuffer.data = this.uvs;
                var nindex = (nchars << 2) + (nchars << 1);
                this.indices = new Uint16Array(nindex);
                this.indexBuffer.data = this.indices;
                this.initIndices(this.indices);
                this.indexBuffer.update();
            }
            else {
                nchars = this.nchars;
            }
            if (nchars <= 0) {
                return;
            }
            var vertices = this.vertices;
            var uvs = this.uvs;
            if (atlas != null) {
                var characters = result.characters;
                var scale = result.scale;
                var fw = 1 / atlas.width;
                var fh = 1 / atlas.height;
                for (var i = 0; i < resultCount; ++i) {
                    var character = characters[i];
                    var cx = character.x;
                    var cy = character.y;
                    var cc = character.character;
                    this.fill(vertices, uvs, i, cx, cy, scale, cc, fw, fh);
                }
                for (var i = resultCount; i < nchars; ++i) {
                    this.fillBlank(vertices, uvs, i);
                }
                this.width = result.width * scale;
                this.height = result.height * scale;
                this.scale = scale;
                this.scaled = result.scaled;
                this.clipped = result.clipped;
            }
            else {
                for (var i = 0; i < nchars; ++i) {
                    this.fillBlank(vertices, uvs, i);
                }
                this.width = 0;
                this.height = 0;
                this.scale = 1;
                this.scaled = false;
                this.clipped = false;
            }
            this.vertexBuffer.update();
            this.uvBuffer.update();
        };
        DDynamicTextGeometry.prototype.fill = function (vertices, uvs, index, x, y, scale, character, fw, fh) {
            var cx = character.x;
            var cy = character.y;
            var cw = character.width;
            var ch = character.height;
            var cox = character.origin.x;
            var x0 = (x + (cx - cox)) * scale;
            var y0 = y * scale;
            var x1 = x0 + cw * scale;
            var y1 = y0 + ch * scale;
            var iv = index << 3;
            vertices[iv + 0] = x0;
            vertices[iv + 1] = y0;
            vertices[iv + 2] = x1;
            vertices[iv + 3] = y0;
            vertices[iv + 4] = x1;
            vertices[iv + 5] = y1;
            vertices[iv + 6] = x0;
            vertices[iv + 7] = y1;
            var u0 = cx * fw;
            var v0 = cy * fh;
            var u1 = (cx + cw) * fw;
            var v1 = (cy + ch) * fh;
            uvs[iv + 0] = u0;
            uvs[iv + 1] = v0;
            uvs[iv + 2] = u1;
            uvs[iv + 3] = v0;
            uvs[iv + 4] = u1;
            uvs[iv + 5] = v1;
            uvs[iv + 6] = u0;
            uvs[iv + 7] = v1;
        };
        DDynamicTextGeometry.prototype.fillBlank = function (vertices, uvs, index) {
            var iv = index << 3;
            vertices[iv + 0] = 0;
            vertices[iv + 1] = 0;
            vertices[iv + 2] = 0;
            vertices[iv + 3] = 0;
            vertices[iv + 4] = 0;
            vertices[iv + 5] = 0;
            vertices[iv + 6] = 0;
            vertices[iv + 7] = 0;
            uvs[iv + 0] = 0;
            uvs[iv + 1] = 0;
            uvs[iv + 2] = 0;
            uvs[iv + 3] = 0;
            uvs[iv + 4] = 0;
            uvs[iv + 5] = 0;
            uvs[iv + 6] = 0;
            uvs[iv + 7] = 0;
        };
        DDynamicTextGeometry.prototype.initIndices = function (indices) {
            for (var iv = 0, ivmax = this.nchars << 2, ii = 0; iv < ivmax; iv += 4, ii += 6) {
                indices[ii] = iv;
                indices[ii + 1] = iv + 1;
                indices[ii + 2] = iv + 3;
                indices[ii + 3] = iv + 1;
                indices[ii + 4] = iv + 2;
                indices[ii + 5] = iv + 3;
            }
        };
        return DDynamicTextGeometry;
    }(pixi_js.MeshGeometry));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDynamicText = /** @class */ (function (_super) {
        __extends(DDynamicText, _super);
        function DDynamicText(style) {
            var _this = _super.call(this, new DDynamicTextGeometry(), new pixi_js.MeshMaterial(pixi_js.Texture.EMPTY)) || this;
            _this._style = style;
            style.on("change", function () {
                _this.onStyleChange();
            });
            _this._text = "";
            _this._textApproved = "";
            _this._isDirty = true;
            _this._isGeometryDirty = true;
            _this._atlas = null;
            _this._atlasRevisionUpdated = 0;
            _this._width = 0;
            _this._height = 0;
            _this._modifier = {
                clipping: false,
                fitting: false,
                wordWrap: DDynamicTextStyleWordWrap.NONE,
                width: 0,
                height: 0,
                lineHeight: 0,
                delta: {
                    width: 0,
                    height: 0
                }
            };
            return _this;
        }
        DDynamicText.prototype.onStyleChange = function () {
            this._isDirty = true;
            this._isGeometryDirty = true;
            this._atlas = null;
            this.update_();
        };
        DDynamicText.prototype.update_ = function () {
            var layer = DApplications.getLayer(this);
            if (layer) {
                if (this._isDirty) {
                    this._isDirty = false;
                    var text = this._text;
                    var textApproved = this._textApproved;
                    this._textApproved = text;
                    var style = this._style;
                    var fontId = style.fontId;
                    var fontIdApproved = style.fontIdApproved;
                    var fontIdFontSize = style.fontIdFontSize;
                    var fill = style.fill;
                    var fillApproved = style.fillApproved;
                    style.approve();
                    var atlases = layer.getDynamicFontAtlases();
                    if (text !== textApproved || fontId !== fontIdApproved || fill !== fillApproved) {
                        atlases.add(fontId, fontIdFontSize, fill, text);
                        atlases.remove(fontIdApproved, fillApproved, textApproved);
                    }
                }
            }
        };
        Object.defineProperty(DDynamicText.prototype, "text", {
            get: function () {
                return this._text;
            },
            set: function (text) {
                if (this._text !== text) {
                    this._text = text;
                    if (!this._style.unfit()) {
                        this._isDirty = true;
                        this._isGeometryDirty = true;
                        this.update_();
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDynamicText.prototype, "width", {
            // @ts-ignore
            get: function () {
                this.update();
                return Math.abs(this.scale.x) * this.geometry.width;
            },
            set: function (width) {
                this.update();
                var geometryWidth = this.geometry.width;
                if (+1e-4 < geometryWidth) {
                    var newScale = width / geometryWidth;
                    this.scale.x = 0 <= this.scale.x ? +newScale : -newScale;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDynamicText.prototype, "height", {
            // @ts-ignore
            get: function () {
                this.update();
                return Math.abs(this.scale.y) * this.geometry.height;
            },
            set: function (height) {
                this.update();
                var geometryHeight = this.geometry.height;
                if (+1e-4 < geometryHeight) {
                    var newScale = height / geometryHeight;
                    this.scale.y = 0 <= this.scale.y ? +newScale : -newScale;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDynamicText.prototype, "clipped", {
            get: function () {
                return this.geometry.clipped;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDynamicText.prototype, "style", {
            get: function () {
                return this._style;
            },
            enumerable: false,
            configurable: true
        });
        DDynamicText.prototype.update = function () {
            var _this = this;
            this.update_();
            var style = this._style;
            var atlas = this._atlas;
            if (atlas == null) {
                var layer = DApplications.getLayer(this);
                if (layer) {
                    atlas = layer.getDynamicFontAtlases().get(style.fontId, style.fill);
                    if (atlas != null) {
                        this._atlasRevisionUpdated = atlas.getRevisionUpdate();
                        this._atlas = atlas;
                        this.texture = atlas.texture;
                        this._isGeometryDirty = true;
                    }
                }
            }
            else {
                var revisionUpdate = atlas.getRevisionUpdate();
                if (revisionUpdate !== this._atlasRevisionUpdated) {
                    this._atlasRevisionUpdated = revisionUpdate;
                    this._isGeometryDirty = true;
                }
            }
            var modifier = this._modifier;
            if (this.updateClipping(style, modifier)) {
                this._isGeometryDirty = true;
            }
            if (this._isGeometryDirty) {
                this._isGeometryDirty = false;
                var geometry = this.geometry;
                geometry.update(this._text, atlas, modifier);
                if (modifier.fitting && !style.isFontFitted && geometry.scaled) {
                    var oldScale = geometry.scale;
                    var oldFontSize = style.fontSize;
                    var newFontId = style.toFontId(Math.ceil(oldFontSize * oldScale * 1000) / 1000);
                    var newFontSize = UtilFont.toSize(newFontId);
                    var newScale = newFontSize / oldFontSize;
                    var newLineHeight = style.lineHeight * newScale;
                    if (style.fit(newFontSize, newLineHeight)) {
                        setTimeout(function () {
                            DApplications.update(_this);
                        }, 0);
                    }
                }
            }
        };
        DDynamicText.prototype.updateClipping = function (style, modifier) {
            var isChanged = false;
            var styleClipping = style.clipping;
            if (modifier.clipping !== styleClipping) {
                modifier.clipping = styleClipping;
                isChanged = true;
            }
            var styleFitting = style.fitting;
            if (modifier.fitting !== styleFitting) {
                modifier.fitting = styleFitting;
                isChanged = true;
            }
            var styleWordWrap = style.wordWrap;
            if (modifier.wordWrap !== styleWordWrap) {
                modifier.wordWrap = styleWordWrap;
                isChanged = true;
            }
            var styleLineHeight = styleFitting ? style.lineHeightFitted : style.lineHeight;
            if (modifier.lineHeight !== styleLineHeight) {
                modifier.lineHeight = styleLineHeight;
                isChanged = true;
            }
            if (styleClipping || styleFitting || styleWordWrap) {
                var parent_1 = this.parent;
                if (parent_1 instanceof DBase) {
                    var padding = parent_1.padding;
                    var width = parent_1.width - padding.getLeft() - padding.getRight() - modifier.delta.width;
                    if (modifier.width !== width) {
                        modifier.width = width;
                        isChanged = true;
                    }
                    var height = parent_1.height - padding.getTop() - padding.getBottom() - modifier.delta.height;
                    if (modifier.height !== height) {
                        modifier.height = height;
                        isChanged = true;
                    }
                }
            }
            return isChanged;
        };
        DDynamicText.prototype.setClippingDelta = function (width, height) {
            var delta = this._modifier.delta;
            delta.width = width;
            delta.height = height;
        };
        DDynamicText.prototype._calculateBounds = function () {
            this.update();
            var geometry = this.geometry;
            this._bounds.addFrame(this.transform, 0, 0, geometry.width, geometry.height);
        };
        DDynamicText.prototype._render = function (renderer) {
            this.update();
            _super.prototype._render.call(this, renderer);
        };
        return DDynamicText;
    }(pixi_js.Mesh));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDynamicTextStyle = /** @class */ (function (_super) {
        __extends(DDynamicTextStyle, _super);
        function DDynamicTextStyle(parent, theme, options) {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j;
            var _this = _super.call(this) || this;
            _this._id = 0;
            _this._idApproved = -1;
            if (options) {
                _this._fontFamily = (_a = options.fontFamily) !== null && _a !== void 0 ? _a : theme.getFontFamilly();
                _this._fontSize = (_b = options.fontSize) !== null && _b !== void 0 ? _b : theme.getFontSize();
                _this._fontStyle = (_c = options.fontStyle) !== null && _c !== void 0 ? _c : theme.getFontStyle();
                _this._fontVariant = (_d = options.fontVariant) !== null && _d !== void 0 ? _d : theme.getFontVariant();
                _this._fontWeight = (_e = options.fontWeight) !== null && _e !== void 0 ? _e : theme.getFontWeight();
                _this._clipping = (_f = options.clipping) !== null && _f !== void 0 ? _f : theme.getTextStyleClipping();
                _this._fitting = (_g = options.fitting) !== null && _g !== void 0 ? _g : theme.getTextStyleFitting();
                _this._wordWrap = toEnum((_h = options.wordWrap) !== null && _h !== void 0 ? _h : theme.getTextStyleWordWrap(), DDynamicTextStyleWordWrap);
                _this._lineHeight = (_j = options.lineHeight) !== null && _j !== void 0 ? _j : theme.getLineHeight();
            }
            else {
                _this._fontFamily = theme.getFontFamilly();
                _this._fontSize = theme.getFontSize();
                _this._fontStyle = theme.getFontStyle();
                _this._fontVariant = theme.getFontVariant();
                _this._fontWeight = theme.getFontWeight();
                _this._clipping = theme.getTextStyleClipping();
                _this._fitting = theme.getTextStyleFitting();
                _this._wordWrap = theme.getTextStyleWordWrap();
                _this._lineHeight = theme.getLineHeight();
            }
            _this._fill = theme.getColor(parent.state);
            _this._fontSizeFitted = _this._fontSize;
            _this._lineHeightFitted = _this._lineHeight;
            _this._isFontFitted = false;
            _this._fontIdFontSize = _this._fontSize;
            _this._fontIdId = -1;
            _this._fontId = "";
            _this._fontIdApproved = "";
            _this._fillApproved = 0x000000;
            return _this;
        }
        Object.defineProperty(DDynamicTextStyle.prototype, "id", {
            get: function () {
                return this._id;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDynamicTextStyle.prototype, "idApproved", {
            get: function () {
                return this._idApproved;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDynamicTextStyle.prototype, "fontId", {
            get: function () {
                this.update();
                return this._fontId;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDynamicTextStyle.prototype, "fontIdFontSize", {
            get: function () {
                this.update();
                return this._fontSizeFitted;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDynamicTextStyle.prototype, "fontIdApproved", {
            get: function () {
                return this._fontIdApproved;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDynamicTextStyle.prototype, "fill", {
            get: function () {
                return this._fill;
            },
            set: function (fill) {
                if (this._fill !== fill) {
                    this._fill = fill;
                    this.onChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        DDynamicTextStyle.prototype.onChange = function () {
            this._id += 1;
            this.emit("change", this);
        };
        Object.defineProperty(DDynamicTextStyle.prototype, "fillApproved", {
            get: function () {
                return this._fillApproved;
            },
            enumerable: false,
            configurable: true
        });
        DDynamicTextStyle.prototype.approve = function () {
            this.update();
            this._idApproved = this._id;
            this._fontIdApproved = this._fontId;
            this._fillApproved = this._fill;
        };
        Object.defineProperty(DDynamicTextStyle.prototype, "fontFamily", {
            get: function () {
                return this._fontFamily;
            },
            set: function (fontFamily) {
                if (this._fontFamily !== fontFamily) {
                    this._fontFamily = fontFamily;
                    this.onChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDynamicTextStyle.prototype, "fontSize", {
            get: function () {
                return this._fontSize;
            },
            set: function (fontSize) {
                if (this._fontSize !== fontSize) {
                    this._fontSize = fontSize;
                    this._fontSizeFitted = fontSize;
                    this._lineHeightFitted = this._lineHeight;
                    this._isFontFitted = false;
                    this.onChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDynamicTextStyle.prototype, "fontSizeFitted", {
            get: function () {
                return this._fontSizeFitted;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDynamicTextStyle.prototype, "isFontFitted", {
            get: function () {
                return this._isFontFitted;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDynamicTextStyle.prototype, "fontStyle", {
            get: function () {
                return this._fontStyle;
            },
            set: function (fontStyle) {
                if (this._fontStyle !== fontStyle) {
                    this._fontStyle = fontStyle;
                    this.onChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDynamicTextStyle.prototype, "fontVariant", {
            get: function () {
                return this._fontVariant;
            },
            set: function (fontVariant) {
                if (this._fontVariant !== fontVariant) {
                    this._fontVariant = fontVariant;
                    this.onChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDynamicTextStyle.prototype, "fontWeight", {
            get: function () {
                return this._fontWeight;
            },
            set: function (fontWeight) {
                if (this._fontWeight !== fontWeight) {
                    this._fontWeight = fontWeight;
                    this.onChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        DDynamicTextStyle.prototype.update = function () {
            if (this._fontIdId !== this._id) {
                this._fontIdId = this._id;
                var fontIdFontSize = this._fitting ? this._fontSizeFitted : this._fontSize;
                this._fontIdFontSize = fontIdFontSize;
                this._fontId = this.toFontId(fontIdFontSize);
            }
        };
        DDynamicTextStyle.prototype.toFontId = function (fontSize) {
            return "".concat(this._fontStyle, " ").concat(this._fontVariant, " ").concat(this._fontWeight, " ").concat(fontSize, "px ").concat(this._fontFamily);
        };
        Object.defineProperty(DDynamicTextStyle.prototype, "clipping", {
            get: function () {
                return this._clipping;
            },
            set: function (clipping) {
                if (this._clipping !== clipping) {
                    this._clipping = clipping;
                    this.onChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDynamicTextStyle.prototype, "fitting", {
            get: function () {
                return this._fitting;
            },
            set: function (fitting) {
                if (this._fitting !== fitting) {
                    this._fitting = fitting;
                    this.onChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDynamicTextStyle.prototype, "wordWrap", {
            get: function () {
                return this._wordWrap;
            },
            set: function (wordWrap) {
                if (this._wordWrap !== wordWrap) {
                    this._wordWrap = wordWrap;
                    this.onChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDynamicTextStyle.prototype, "lineHeight", {
            get: function () {
                return this._lineHeight;
            },
            set: function (lineHeight) {
                if (this._lineHeight !== lineHeight) {
                    this._lineHeight = lineHeight;
                    this._fontSizeFitted = this._fontSize;
                    this._lineHeightFitted = lineHeight;
                    this._isFontFitted = false;
                    this.onChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDynamicTextStyle.prototype, "lineHeightFitted", {
            get: function () {
                return this._lineHeightFitted;
            },
            set: function (lineHeightFitted) {
                if (this._lineHeightFitted !== lineHeightFitted) {
                    this._lineHeightFitted = lineHeightFitted;
                    this.onChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        DDynamicTextStyle.prototype.fit = function (fontSize, lineHeight) {
            var isChanged = false;
            if (fontSize < this._fontSizeFitted) {
                this._fontSizeFitted = fontSize;
                isChanged = true;
            }
            if (this._lineHeightFitted !== lineHeight) {
                this._lineHeightFitted = lineHeight;
                isChanged = true;
            }
            if (this._isFontFitted !== true) {
                this._isFontFitted = true;
                isChanged = true;
            }
            if (isChanged) {
                this.onChange();
            }
            return isChanged;
        };
        DDynamicTextStyle.prototype.unfit = function () {
            var isChanged = false;
            if (this._isFontFitted !== false) {
                this._isFontFitted = false;
                isChanged = true;
            }
            if (this._fontSizeFitted !== this._fontSize) {
                this._fontSizeFitted = this._fontSize;
                isChanged = true;
            }
            if (this._lineHeightFitted !== this._lineHeight) {
                this._lineHeightFitted = this._lineHeight;
                isChanged = true;
            }
            if (isChanged) {
                this.onChange();
            }
            return isChanged;
        };
        return DDynamicTextStyle;
    }(pixi_js.utils.EventEmitter));

    var DTextPieceAlignImpl = /** @class */ (function () {
        function DTextPieceAlignImpl(parent, theme, options) {
            var _a, _b;
            this._parent = parent;
            this._vertical = toEnum((_a = options === null || options === void 0 ? void 0 : options.vertical) !== null && _a !== void 0 ? _a : theme.getTextAlignVertical(), DAlignVertical);
            this._horizontal = toEnum((_b = options === null || options === void 0 ? void 0 : options.horizontal) !== null && _b !== void 0 ? _b : theme.getTextAlignHorizontal(), DAlignHorizontal);
        }
        Object.defineProperty(DTextPieceAlignImpl.prototype, "vertical", {
            get: function () {
                return this._vertical;
            },
            set: function (vertical) {
                vertical = toEnum(vertical, DAlignVertical);
                if (this._vertical !== vertical) {
                    this._vertical = vertical;
                    this.onChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTextPieceAlignImpl.prototype, "horizontal", {
            get: function () {
                return this._horizontal;
            },
            set: function (horizontal) {
                horizontal = toEnum(horizontal, DAlignHorizontal);
                if (this._horizontal !== horizontal) {
                    this._horizontal = horizontal;
                    this.onChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        DTextPieceAlignImpl.prototype.set = function (vertical, horizontal) {
            var isChanged = false;
            if (vertical != null) {
                vertical = toEnum(vertical, DAlignVertical);
                if (this._vertical !== vertical) {
                    this._vertical = vertical;
                    isChanged = true;
                }
            }
            if (horizontal != null) {
                horizontal = toEnum(horizontal, DAlignHorizontal);
                if (this._horizontal !== horizontal) {
                    this._horizontal = horizontal;
                    isChanged = true;
                }
            }
            if (isChanged) {
                this.onChange();
            }
            return this;
        };
        DTextPieceAlignImpl.prototype.onChange = function () {
            var parent = this._parent;
            parent.toDirty();
            DApplications.update(parent);
        };
        return DTextPieceAlignImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTextPieceStyleImpl = /** @class */ (function () {
        function DTextPieceStyleImpl(parent, style) {
            this._parent = parent;
            this._style = style;
        }
        Object.defineProperty(DTextPieceStyleImpl.prototype, "fontFamily", {
            get: function () {
                return this._style.fontFamily;
            },
            set: function (fontFamily) {
                var style = this._style;
                if (style.fontFamily !== fontFamily) {
                    style.fontFamily = fontFamily;
                    this.onChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTextPieceStyleImpl.prototype, "fontSize", {
            get: function () {
                return this._style.fontSize;
            },
            set: function (fontSize) {
                var style = this._style;
                if (style.fontSize !== fontSize) {
                    style.fontSize = fontSize;
                    this.onChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTextPieceStyleImpl.prototype, "fontStyle", {
            get: function () {
                return this._style.fontStyle;
            },
            set: function (fontStyle) {
                var style = this._style;
                if (style.fontStyle !== fontStyle) {
                    style.fontStyle = fontStyle;
                    this.onChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTextPieceStyleImpl.prototype, "fontVariant", {
            get: function () {
                return this._style.fontVariant;
            },
            set: function (fontVariant) {
                var style = this._style;
                if (style.fontVariant !== fontVariant) {
                    style.fontVariant = fontVariant;
                    this.onChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTextPieceStyleImpl.prototype, "fontWeight", {
            get: function () {
                return this._style.fontWeight;
            },
            set: function (fontWeight) {
                var style = this._style;
                if (style.fontWeight !== fontWeight) {
                    style.fontWeight = fontWeight;
                    this.onChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTextPieceStyleImpl.prototype, "clipping", {
            get: function () {
                return this._style.clipping;
            },
            set: function (clipping) {
                var style = this._style;
                if (style.clipping !== clipping) {
                    style.clipping = clipping;
                    this.onChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTextPieceStyleImpl.prototype, "fitting", {
            get: function () {
                return this._style.fitting;
            },
            set: function (fitting) {
                var style = this._style;
                if (style.fitting !== fitting) {
                    style.fitting = fitting;
                    this.onChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTextPieceStyleImpl.prototype, "wordWrap", {
            get: function () {
                return this._style.wordWrap;
            },
            set: function (wordWrap) {
                wordWrap = toEnum(wordWrap, DDynamicTextStyleWordWrap);
                var style = this._style;
                if (style.wordWrap !== wordWrap) {
                    style.wordWrap = wordWrap;
                    this.onChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTextPieceStyleImpl.prototype, "lineHeight", {
            get: function () {
                return this._style.lineHeight;
            },
            set: function (lineHeight) {
                var style = this._style;
                if (style.lineHeight !== lineHeight) {
                    style.lineHeight = lineHeight;
                    this.onChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        DTextPieceStyleImpl.prototype.onChange = function () {
            DApplications.update(this._parent);
        };
        return DTextPieceStyleImpl;
    }());

    var DTextPieceImpl = /** @class */ (function (_super) {
        __extends(DTextPieceImpl, _super);
        function DTextPieceImpl(parent, theme, options) {
            var _a, _b;
            var _this = _super.call(this) || this;
            _this._parent = parent;
            _this._theme = theme;
            _this._value = (_a = options === null || options === void 0 ? void 0 : options.value) !== null && _a !== void 0 ? _a : theme.newTextValue();
            _this._computed = _this.newComputed();
            _this._color = options === null || options === void 0 ? void 0 : options.color;
            _this._alpha = options === null || options === void 0 ? void 0 : options.alpha;
            var dstyle = new DDynamicTextStyle(parent, theme, options === null || options === void 0 ? void 0 : options.style);
            _this._dstyle = dstyle;
            _this._style = new DTextPieceStyleImpl(parent, dstyle);
            _this._align = new DTextPieceAlignImpl(parent, theme, options === null || options === void 0 ? void 0 : options.align);
            _this._formatter = (_b = options === null || options === void 0 ? void 0 : options.formatter) !== null && _b !== void 0 ? _b : theme.getTextFormatter();
            _this._isVisible = true;
            _this.onComputedChange();
            if (_this.updateObject()) {
                parent.toDirty();
                DApplications.update(parent);
            }
            return _this;
        }
        Object.defineProperty(DTextPieceImpl.prototype, "value", {
            get: function () {
                return this._value;
            },
            set: function (value) {
                if (this._value !== value) {
                    this._value = value;
                    this.onValueChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        DTextPieceImpl.prototype.getValue = function () {
            return this._value;
        };
        DTextPieceImpl.prototype.setValue = function (value, forcibly) {
            if (forcibly || this._value !== value) {
                this._value = value;
                this.onValueChange(forcibly);
            }
        };
        DTextPieceImpl.prototype.onValueChange = function (forcibly) {
            var newComputed = this.newComputed();
            if (forcibly || this._computed !== newComputed) {
                this._computed = newComputed;
                this.onComputedChange();
                if (this.updateObject()) {
                    var parent_1 = this._parent;
                    parent_1.toDirty();
                    DApplications.update(parent_1);
                }
            }
        };
        DTextPieceImpl.prototype.compute = function (forcibly) {
            this.onValueChange(forcibly);
        };
        Object.defineProperty(DTextPieceImpl.prototype, "computed", {
            get: function () {
                return this._computed;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTextPieceImpl.prototype, "formatter", {
            get: function () {
                return this._formatter;
            },
            set: function (formatter) {
                if (this._formatter !== formatter) {
                    this._formatter = formatter;
                    this.onValueChange(true);
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTextPieceImpl.prototype, "color", {
            get: function () {
                return this._color;
            },
            set: function (color) {
                if (this._color !== color) {
                    this._color = color;
                    this.onColorChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTextPieceImpl.prototype, "alpha", {
            get: function () {
                return this._alpha;
            },
            set: function (alpha) {
                if (this._alpha !== alpha) {
                    this._alpha = alpha;
                    this.onColorChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        DTextPieceImpl.prototype.onColorChange = function () {
            var object = this._object;
            if (object != null) {
                var parent_2 = this._parent;
                var state = parent_2.state;
                var color = this.newColor(state);
                var alpha = this.newAlpha(state);
                var style = object.style;
                if (style.fill !== color || object.alpha !== alpha) {
                    style.fill = color;
                    object.alpha = alpha;
                    DApplications.update(parent_2);
                }
            }
        };
        Object.defineProperty(DTextPieceImpl.prototype, "align", {
            get: function () {
                return this._align;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTextPieceImpl.prototype, "style", {
            get: function () {
                return this._style;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTextPieceImpl.prototype, "object", {
            get: function () {
                return this._object;
            },
            enumerable: false,
            configurable: true
        });
        DTextPieceImpl.prototype.update = function (layouter) {
            // Compute a value
            var newComputed = this.newComputed();
            if (this._computed !== newComputed) {
                this._computed = newComputed;
                this.onComputedChange();
                this.updateObject();
            }
            var object = this._object;
            if (object != null) {
                // Update the color
                var state = this._parent.state;
                object.style.fill = this.newColor(state);
                object.alpha = this.newAlpha(state);
                // Layout
                layouter.set(object);
            }
            else {
                // Layout
                layouter.set(null);
            }
        };
        DTextPieceImpl.prototype.updateObject = function () {
            var computed = this._computed;
            if (computed !== undefined) {
                var formatted = this._formatter(computed, this._parent);
                var object = this._object;
                if (object == null) {
                    if (0 < formatted.length) {
                        var newObject = this.newObject();
                        newObject.visible = this._isVisible;
                        this._object = newObject;
                        var parent_3 = this._parent;
                        parent_3.addChild(newObject);
                        var overflowMask = parent_3.getOverflowMask();
                        if (overflowMask) {
                            newObject.mask = overflowMask;
                        }
                        newObject.text = formatted;
                        return true;
                    }
                }
                else if (object.text !== formatted) {
                    object.text = formatted;
                    return true;
                }
            }
            else {
                var object = this._object;
                if (object != null && object.text !== "") {
                    object.text = "";
                    return true;
                }
            }
            return false;
        };
        DTextPieceImpl.prototype.newComputed = function () {
            var value = this._value;
            if (value !== undefined) {
                if (isFunction(value)) {
                    var result = value(this._parent.state);
                    if (result !== undefined) {
                        return result;
                    }
                }
                else {
                    return value;
                }
            }
            return this._theme.getTextValue(this._parent.state);
        };
        DTextPieceImpl.prototype.newColor = function (state) {
            var color = this._color;
            if (color !== undefined) {
                if (isFunction(color)) {
                    var result = color(state);
                    if (result !== undefined) {
                        return result;
                    }
                }
                else {
                    return color;
                }
            }
            return this._theme.getColor(state);
        };
        DTextPieceImpl.prototype.newAlpha = function (state) {
            var alpha = this._alpha;
            if (alpha !== undefined) {
                if (isFunction(alpha)) {
                    var result = alpha(state);
                    if (result !== undefined) {
                        return result;
                    }
                }
                else {
                    return alpha;
                }
            }
            return this._theme.getAlpha(state);
        };
        DTextPieceImpl.prototype.newObject = function () {
            return new DDynamicText(this._dstyle);
        };
        Object.defineProperty(DTextPieceImpl.prototype, "visible", {
            get: function () {
                var object = this._object;
                if (object != null) {
                    return object.visible;
                }
                return this._isVisible;
            },
            set: function (visible) {
                var object = this._object;
                if (object != null) {
                    object.visible = visible;
                }
                this._isVisible = visible;
            },
            enumerable: false,
            configurable: true
        });
        DTextPieceImpl.prototype.show = function () {
            this.visible = true;
            return this;
        };
        DTextPieceImpl.prototype.hide = function () {
            this.visible = false;
            return this;
        };
        DTextPieceImpl.prototype.isShown = function () {
            return this.visible;
        };
        DTextPieceImpl.prototype.onComputedChange = function () {
            this.emit("change", this);
        };
        DTextPieceImpl.prototype.destroy = function () {
            var object = this._object;
            if (object) {
                this._object = undefined;
                object.destroy();
            }
            return this;
        };
        return DTextPieceImpl;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A base class for UI classes with a text support.
     * See {@link DTextBaseEvents} for event defaults.
     */
    var DTextBase = /** @class */ (function (_super) {
        __extends(DTextBase, _super);
        function DTextBase() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DTextBase.prototype.init = function (options) {
            _super.prototype.init.call(this, options);
            this.getText();
        };
        DTextBase.prototype.getOverflowMask = function () {
            var result = this._overflowMask;
            if (result === undefined) {
                result = this.newOverflowMask();
                this._overflowMask = result;
            }
            return null;
        };
        DTextBase.prototype.newOverflowMask = function () {
            var _a, _b;
            if ((_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.mask) !== null && _b !== void 0 ? _b : this.theme.isOverflowMaskEnabled()) {
                var result = new DBaseOverflowMaskSimple(this);
                this._reflowable.add(result);
                this.toDirty();
                return result;
            }
            else {
                return null;
            }
        };
        Object.defineProperty(DTextBase.prototype, "text", {
            get: function () {
                var _a;
                return ((_a = this._text) !== null && _a !== void 0 ? _a : (this._text = this.newText()));
            },
            set: function (text) {
                this.text.value = text;
            },
            enumerable: false,
            configurable: true
        });
        DTextBase.prototype.getText = function () {
            var _a;
            return ((_a = this._text) !== null && _a !== void 0 ? _a : (this._text = this.newText()));
        };
        DTextBase.prototype.newText = function () {
            var _a;
            return new DTextPieceImpl(this, this.theme, (_a = this._options) === null || _a === void 0 ? void 0 : _a.text);
        };
        DTextBase.prototype.onReflow = function () {
            _super.prototype.onReflow.call(this);
            this.onReflowTextAndImage();
        };
        DTextBase.prototype.getLayouter = function () {
            var _a;
            return ((_a = DTextBase.LAYOUTER) !== null && _a !== void 0 ? _a : (DTextBase.LAYOUTER = new DImagePieceLayouter()));
        };
        DTextBase.prototype.onReflowTextAndImage = function () {
            var layouter = this.getLayouter();
            var text = this.getText();
            text.update(layouter);
            var auto = this._auto;
            layouter.execute(this._padding, text.align, auto.width.isOn ? null : this.width, auto.height.isOn ? null : this.height);
            layouter.clear();
        };
        DTextBase.prototype.isRefitable = function (target) {
            if (_super.prototype.isRefitable.call(this, target)) {
                return true;
            }
            if (target != null) {
                var text = this._text;
                if (text != null && target === text.object) {
                    return true;
                }
            }
            return false;
        };
        DTextBase.prototype.applyTitle = function () {
            var object = this.text.object;
            if (this._title.length <= 0 && object != null && object.clipped) {
                var layer = DApplications.getLayer(this);
                if (layer) {
                    layer.view.title = object.text;
                }
            }
            else {
                _super.prototype.applyTitle.call(this);
            }
        };
        DTextBase.prototype.getType = function () {
            return "DTextBase";
        };
        DTextBase.prototype.destroy = function () {
            // Text
            var text = this._text;
            if (text) {
                text.destroy();
            }
            // Overflow mask
            var overflowMask = this._overflowMask;
            if (overflowMask) {
                this._overflowMask = null;
                overflowMask.destroy();
            }
            _super.prototype.destroy.call(this);
        };
        return DTextBase;
    }(DBase));

    var DImageBaseThemeWrapperOther = /** @class */ (function () {
        function DImageBaseThemeWrapperOther(theme) {
            this._theme = theme;
        }
        DImageBaseThemeWrapperOther.prototype.getImageAlignHorizontal = function () {
            return this._theme.getImageAlignHorizontal();
        };
        DImageBaseThemeWrapperOther.prototype.getImageAlignVertical = function () {
            return this._theme.getImageAlignVertical();
        };
        DImageBaseThemeWrapperOther.prototype.getImageAlignWith = function () {
            return this._theme.getImageAlignWith();
        };
        DImageBaseThemeWrapperOther.prototype.getImageMarginHorizontal = function () {
            return this._theme.getImageMarginHorizontal();
        };
        DImageBaseThemeWrapperOther.prototype.getImageMarginVertial = function () {
            return this._theme.getImageMarginVertial();
        };
        DImageBaseThemeWrapperOther.prototype.getImageTintColor = function (state) {
            return this._theme.getImageTintColor(state);
        };
        DImageBaseThemeWrapperOther.prototype.getImageTintAlpha = function (state) {
            return this._theme.getImageTintAlpha(state);
        };
        DImageBaseThemeWrapperOther.prototype.getImageRotation = function (state) {
            return this._theme.getImageRotation(state);
        };
        DImageBaseThemeWrapperOther.prototype.getImageSource = function (state) {
            return null;
        };
        return DImageBaseThemeWrapperOther;
    }());

    var DImageBaseThemeWrapperSecondary = /** @class */ (function () {
        function DImageBaseThemeWrapperSecondary(theme) {
            this._theme = theme;
        }
        DImageBaseThemeWrapperSecondary.prototype.getImageAlignHorizontal = function () {
            return this._theme.getSecondaryImageAlignHorizontal();
        };
        DImageBaseThemeWrapperSecondary.prototype.getImageAlignVertical = function () {
            return this._theme.getSecondaryImageAlignVertical();
        };
        DImageBaseThemeWrapperSecondary.prototype.getImageAlignWith = function () {
            return this._theme.getSecondaryImageAlignWith();
        };
        DImageBaseThemeWrapperSecondary.prototype.getImageMarginHorizontal = function () {
            return this._theme.getSecondaryImageMarginHorizontal();
        };
        DImageBaseThemeWrapperSecondary.prototype.getImageMarginVertial = function () {
            return this._theme.getSecondaryImageMarginVertial();
        };
        DImageBaseThemeWrapperSecondary.prototype.getImageTintColor = function (state) {
            return this._theme.getSecondaryImageTintColor(state);
        };
        DImageBaseThemeWrapperSecondary.prototype.getImageTintAlpha = function (state) {
            return this._theme.getSecondaryImageTintAlpha(state);
        };
        DImageBaseThemeWrapperSecondary.prototype.getImageRotation = function (state) {
            return this._theme.getSecondaryImageRotation(state);
        };
        DImageBaseThemeWrapperSecondary.prototype.getImageSource = function (state) {
            var _a, _b, _c;
            return (_c = (_b = (_a = this._theme).getSecondaryImageSource) === null || _b === void 0 ? void 0 : _b.call(_a, state)) !== null && _c !== void 0 ? _c : null;
        };
        return DImageBaseThemeWrapperSecondary;
    }());

    var DImageBaseThemeWrapperTertiary = /** @class */ (function () {
        function DImageBaseThemeWrapperTertiary(theme) {
            this._theme = theme;
        }
        DImageBaseThemeWrapperTertiary.prototype.getImageAlignHorizontal = function () {
            return this._theme.getTertiaryImageAlignHorizontal();
        };
        DImageBaseThemeWrapperTertiary.prototype.getImageAlignVertical = function () {
            return this._theme.getTertiaryImageAlignVertical();
        };
        DImageBaseThemeWrapperTertiary.prototype.getImageAlignWith = function () {
            return this._theme.getTertiaryImageAlignWith();
        };
        DImageBaseThemeWrapperTertiary.prototype.getImageMarginHorizontal = function () {
            return this._theme.getTertiaryImageMarginHorizontal();
        };
        DImageBaseThemeWrapperTertiary.prototype.getImageMarginVertial = function () {
            return this._theme.getTertiaryImageMarginVertial();
        };
        DImageBaseThemeWrapperTertiary.prototype.getImageTintColor = function (state) {
            return this._theme.getTertiaryImageTintColor(state);
        };
        DImageBaseThemeWrapperTertiary.prototype.getImageTintAlpha = function (state) {
            return this._theme.getTertiaryImageTintAlpha(state);
        };
        DImageBaseThemeWrapperTertiary.prototype.getImageRotation = function (state) {
            return this._theme.getTertiaryImageRotation(state);
        };
        DImageBaseThemeWrapperTertiary.prototype.getImageSource = function (state) {
            var _a, _b, _c;
            return (_c = (_b = (_a = this._theme).getTertiaryImageSource) === null || _b === void 0 ? void 0 : _b.call(_a, state)) !== null && _c !== void 0 ? _c : null;
        };
        return DImageBaseThemeWrapperTertiary;
    }());

    var DImagePieceTintImpl = /** @class */ (function () {
        function DImagePieceTintImpl(parent, theme, options) {
            this._parent = parent;
            if (options != null) {
                this._color = options.color;
                this._alpha = options.alpha;
            }
            this._theme = theme;
        }
        Object.defineProperty(DImagePieceTintImpl.prototype, "color", {
            get: function () {
                return this._color;
            },
            set: function (color) {
                if (this._color !== color) {
                    this._color = color;
                    this.onChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        DImagePieceTintImpl.prototype.getColor = function (state) {
            var color = this._color;
            if (color !== undefined) {
                if (isFunction(color)) {
                    var result = color(state);
                    if (result !== undefined) {
                        return result;
                    }
                }
                else {
                    return color;
                }
            }
            return this._theme.getImageTintColor(state);
        };
        Object.defineProperty(DImagePieceTintImpl.prototype, "alpha", {
            get: function () {
                return this._alpha;
            },
            set: function (alpha) {
                if (this._alpha !== alpha) {
                    this._alpha = alpha;
                    this.onChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        DImagePieceTintImpl.prototype.getAlpha = function (state) {
            var alpha = this._alpha;
            if (alpha !== undefined) {
                if (isFunction(alpha)) {
                    var result = alpha(state);
                    if (result !== undefined) {
                        return result;
                    }
                }
                else {
                    return alpha;
                }
            }
            return this._theme.getImageTintAlpha(state);
        };
        DImagePieceTintImpl.prototype.set = function (color, alpha) {
            var isChanged = false;
            if (color != null && this._color !== color) {
                this._color = color;
                isChanged = true;
            }
            if (alpha != null && this._alpha !== alpha) {
                this._alpha = alpha;
                isChanged = true;
            }
            if (isChanged) {
                this.onChange();
            }
            return this;
        };
        DImagePieceTintImpl.prototype.onChange = function () {
            this._parent.updateTint();
            DApplications.update(this._parent);
        };
        return DImagePieceTintImpl;
    }());

    var DImagePieceMarginImpl = /** @class */ (function () {
        function DImagePieceMarginImpl(parent, theme, options) {
            var _a, _b;
            this._parent = parent;
            this._vertical = (_a = options === null || options === void 0 ? void 0 : options.vertical) !== null && _a !== void 0 ? _a : theme.getImageMarginVertial();
            this._horizontal = (_b = options === null || options === void 0 ? void 0 : options.horizontal) !== null && _b !== void 0 ? _b : theme.getImageMarginHorizontal();
        }
        Object.defineProperty(DImagePieceMarginImpl.prototype, "vertical", {
            get: function () {
                return this._vertical;
            },
            set: function (vertical) {
                if (this._vertical !== vertical) {
                    this._vertical = vertical;
                    this.onChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DImagePieceMarginImpl.prototype, "horizontal", {
            get: function () {
                return this._horizontal;
            },
            set: function (horizontal) {
                if (this._horizontal !== horizontal) {
                    this._horizontal = horizontal;
                    this.onChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        DImagePieceMarginImpl.prototype.set = function (vertical, horizontal) {
            var isChanged = false;
            if (vertical != null && this._vertical !== vertical) {
                this._vertical = vertical;
                isChanged = true;
            }
            if (horizontal != null && this._horizontal !== horizontal) {
                this._horizontal = horizontal;
                isChanged = true;
            }
            if (isChanged) {
                this.onChange();
            }
            return this;
        };
        DImagePieceMarginImpl.prototype.onChange = function () {
            this._parent.onUpdate();
        };
        return DImagePieceMarginImpl;
    }());

    var DImagePieceAlignImpl = /** @class */ (function () {
        function DImagePieceAlignImpl(parent, theme, options) {
            var _a, _b, _c;
            this._parent = parent;
            this._with = toEnum((_a = options === null || options === void 0 ? void 0 : options.with) !== null && _a !== void 0 ? _a : theme.getImageAlignWith(), DAlignWith);
            this._vertical = toEnum((_b = options === null || options === void 0 ? void 0 : options.vertical) !== null && _b !== void 0 ? _b : theme.getImageAlignVertical(), DAlignVertical);
            this._horizontal = toEnum((_c = options === null || options === void 0 ? void 0 : options.horizontal) !== null && _c !== void 0 ? _c : theme.getImageAlignHorizontal(), DAlignHorizontal);
        }
        Object.defineProperty(DImagePieceAlignImpl.prototype, "with", {
            get: function () {
                return this._with;
            },
            set: function (w) {
                w = toEnum(w, DAlignWith);
                if (this._with !== w) {
                    this._with = w;
                    this.onChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DImagePieceAlignImpl.prototype, "vertical", {
            get: function () {
                return this._vertical;
            },
            set: function (vertical) {
                vertical = toEnum(vertical, DAlignVertical);
                if (this._vertical !== vertical) {
                    this._vertical = vertical;
                    this.onChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DImagePieceAlignImpl.prototype, "horizontal", {
            get: function () {
                return this._horizontal;
            },
            set: function (horizontal) {
                horizontal = toEnum(horizontal, DAlignHorizontal);
                if (this._horizontal !== horizontal) {
                    this._horizontal = horizontal;
                    this.onChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        DImagePieceAlignImpl.prototype.set = function (w, vertical, horizontal) {
            var isChanged = false;
            if (w != null) {
                w = toEnum(w, DAlignWith);
                if (this._with !== w) {
                    this._with = w;
                    isChanged = true;
                }
            }
            if (vertical != null) {
                vertical = toEnum(vertical, DAlignVertical);
                if (this._vertical !== vertical) {
                    this._vertical = vertical;
                    isChanged = true;
                }
            }
            if (horizontal != null) {
                horizontal = toEnum(horizontal, DAlignHorizontal);
                if (this._horizontal !== horizontal) {
                    this._horizontal = horizontal;
                    isChanged = true;
                }
            }
            if (isChanged) {
                this.onChange();
            }
            return this;
        };
        DImagePieceAlignImpl.prototype.onChange = function () {
            this._parent.onUpdate();
        };
        return DImagePieceAlignImpl;
    }());

    var DImagePieceImpl = /** @class */ (function () {
        function DImagePieceImpl(parent, theme, options) {
            var _this = this;
            this._parent = parent;
            this._theme = theme;
            this._object = null;
            this._align = new DImagePieceAlignImpl(this, theme, options === null || options === void 0 ? void 0 : options.align);
            this._margin = new DImagePieceMarginImpl(this, theme, options === null || options === void 0 ? void 0 : options.margin);
            this._tint = new DImagePieceTintImpl(this, theme, options === null || options === void 0 ? void 0 : options.tint);
            this._rotation = options === null || options === void 0 ? void 0 : options.rotation;
            this._source = options === null || options === void 0 ? void 0 : options.source;
            this._computed = null;
            this._onUpdateBound = function () {
                _this.onUpdate();
            };
        }
        Object.defineProperty(DImagePieceImpl.prototype, "object", {
            get: function () {
                return this._object;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DImagePieceImpl.prototype, "align", {
            get: function () {
                return this._align;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DImagePieceImpl.prototype, "margin", {
            get: function () {
                return this._margin;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DImagePieceImpl.prototype, "tint", {
            get: function () {
                return this._tint;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DImagePieceImpl.prototype, "source", {
            get: function () {
                return this._source;
            },
            set: function (source) {
                if (this._source !== source) {
                    this._source = source;
                    if (this.updateSource()) {
                        this.onUpdate();
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DImagePieceImpl.prototype, "rotation", {
            get: function () {
                return this._rotation;
            },
            set: function (rotation) {
                if (this._rotation !== rotation) {
                    this._rotation = rotation;
                    if (this.updateRotation()) {
                        DApplications.update(this._parent);
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        DImagePieceImpl.prototype.computeSource = function () {
            var source = this._source;
            if (source !== undefined) {
                if (isFunction(source)) {
                    var result = source(this._parent.state);
                    if (result !== undefined) {
                        return result;
                    }
                }
                else {
                    return source;
                }
            }
            return this._theme.getImageSource(this._parent.state);
        };
        DImagePieceImpl.prototype.onStateChange = function (newState, oldState) {
            this.updateTint();
            this.updateRotation();
        };
        DImagePieceImpl.prototype.isTintAware = function (target) {
            return target != null && "tint" in target;
        };
        /**
         * Updates the tint.
         *
         * @returns True if the tint is changed.
         */
        DImagePieceImpl.prototype.updateTint = function () {
            var object = this._object;
            if (object) {
                if (this.isTintAware(object)) {
                    var state = this._parent.state;
                    var color = this._tint.getColor(state);
                    if (color != null) {
                        var result = false;
                        if (object.tint !== color) {
                            object.tint = color;
                            result = true;
                        }
                        var alpha = this._tint.getAlpha(state);
                        if (object.alpha !== alpha) {
                            object.alpha = alpha;
                            result = true;
                        }
                        if (!object.visible) {
                            object.visible = true;
                            result = true;
                        }
                        return result;
                    }
                    else if (object.visible) {
                        object.visible = false;
                        return true;
                    }
                }
            }
            return false;
        };
        DImagePieceImpl.prototype.toRotation = function (theme, state) {
            var rotation = this._rotation;
            if (rotation != null) {
                if (isFunction(rotation)) {
                    var result = rotation(state);
                    if (result !== undefined) {
                        return result;
                    }
                }
                else {
                    return rotation;
                }
            }
            return theme.getImageRotation(state);
        };
        DImagePieceImpl.prototype.updateRotation = function () {
            var object = this._object;
            if (object) {
                var theme = this._theme;
                var state = this._parent.state;
                var rotation = this.toRotation(theme, state);
                if (rotation != null) {
                    var transform = object.transform;
                    if (transform.rotation !== rotation) {
                        transform.rotation = rotation;
                        return true;
                    }
                }
            }
            return false;
        };
        /**
         * Updates the computed source.
         *
         * @returns True if the computed source is changed
         */
        DImagePieceImpl.prototype.updateSource = function () {
            var newComputed = this.computeSource();
            var oldComputed = this._computed;
            if (newComputed !== oldComputed) {
                this._computed = newComputed;
                var parent_1 = this._parent;
                var oldObject = this._object;
                var onUpdateBound = this._onUpdateBound;
                if (newComputed instanceof pixi_js.Texture) {
                    if (oldComputed instanceof pixi_js.Texture) {
                        oldComputed.off("update", onUpdateBound);
                        if (oldObject instanceof pixi_js.Sprite) {
                            oldObject.texture = newComputed;
                            newComputed.on("update", onUpdateBound);
                        }
                    }
                    else {
                        if (oldObject != null) {
                            parent_1.removeChild(oldObject);
                        }
                        var newObject = new pixi_js.Sprite(newComputed);
                        newObject.anchor.set(0.5, 0.5);
                        var overflowMask = parent_1.getOverflowMask();
                        if (overflowMask) {
                            newObject.mask = overflowMask;
                        }
                        newComputed.on("update", onUpdateBound);
                        parent_1.addChild(newObject);
                        this._object = newObject;
                    }
                }
                else {
                    if (oldComputed instanceof pixi_js.Texture) {
                        oldComputed.off("update", onUpdateBound);
                        if (oldObject != null) {
                            parent_1.removeChild(oldObject);
                            oldObject.destroy();
                        }
                    }
                    else if (oldObject != null) {
                        parent_1.removeChild(oldObject);
                    }
                    if (newComputed != null) {
                        var overflowMask = parent_1.getOverflowMask();
                        if (overflowMask) {
                            newComputed.mask = overflowMask;
                        }
                        parent_1.addChild(newComputed);
                    }
                    this._object = newComputed;
                }
                return true;
            }
            return false;
        };
        DImagePieceImpl.prototype.isRefitable = function (target) {
            return target != null && target === this._object;
        };
        DImagePieceImpl.prototype.destroy = function () {
            this.source = null;
        };
        DImagePieceImpl.prototype.onUpdate = function () {
            this._parent.toDirty();
            DApplications.update(this._parent);
        };
        return DImagePieceImpl;
    }());

    var DImagePieceContainerImpl = /** @class */ (function () {
        function DImagePieceContainerImpl(parent, theme, options) {
            this._parent = parent;
            this._theme = theme;
            var pieces = [];
            this._pieces = pieces;
            if (options != null) {
                var images = options.images;
                if (images != null) {
                    pieces.push(this.newImage(theme, 0 < images.length ? images[0] : undefined));
                    if (theme.getSecondaryImageSource != null || 1 < images.length) {
                        pieces.push(this.newImage(new DImageBaseThemeWrapperSecondary(theme), images[1]));
                    }
                    if (theme.getTertiaryImageSource != null || 2 < images.length) {
                        pieces.push(this.newImage(new DImageBaseThemeWrapperTertiary(theme), images[2]));
                    }
                    if (3 < images.length) {
                        var other = new DImageBaseThemeWrapperOther(theme);
                        for (var i = 3, imax = images.length; i < imax; ++i) {
                            pieces.push(this.newImage(other, images[i]));
                        }
                    }
                }
                else {
                    pieces.push(this.newImage(theme, options.image));
                    if (theme.getSecondaryImageSource != null) {
                        pieces.push(this.newImage(new DImageBaseThemeWrapperSecondary(theme)));
                    }
                    if (theme.getTertiaryImageSource != null) {
                        pieces.push(this.newImage(new DImageBaseThemeWrapperTertiary(theme)));
                    }
                }
            }
            else {
                pieces.push(this.newImage(theme));
                if (theme.getSecondaryImageSource != null) {
                    pieces.push(this.newImage(new DImageBaseThemeWrapperSecondary(theme)));
                }
                if (theme.getTertiaryImageSource != null) {
                    pieces.push(this.newImage(new DImageBaseThemeWrapperTertiary(theme)));
                }
            }
        }
        DImagePieceContainerImpl.prototype.newImage = function (theme, options) {
            return new DImagePieceImpl(this._parent, theme, options);
        };
        DImagePieceContainerImpl.prototype.onStateChange = function (newState, oldState) {
            var pieces = this._pieces;
            for (var i = 0, imax = pieces.length; i < imax; ++i) {
                pieces[i].onStateChange(newState, oldState);
            }
        };
        DImagePieceContainerImpl.prototype.isRefitable = function (target) {
            var pieces = this._pieces;
            for (var i = 0, imax = pieces.length; i < imax; ++i) {
                if (pieces[i].isRefitable(target)) {
                    return true;
                }
            }
            return false;
        };
        DImagePieceContainerImpl.prototype.update = function (layouter) {
            var pieces = this._pieces;
            for (var i = 0, imax = pieces.length; i < imax; ++i) {
                var piece = pieces[i];
                piece.updateSource();
                piece.updateTint();
                piece.updateRotation();
                layouter.add(piece);
            }
        };
        Object.defineProperty(DImagePieceContainerImpl.prototype, "object", {
            get: function () {
                return this._pieces[0].object;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DImagePieceContainerImpl.prototype, "align", {
            get: function () {
                return this._pieces[0].align;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DImagePieceContainerImpl.prototype, "margin", {
            get: function () {
                return this._pieces[0].margin;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DImagePieceContainerImpl.prototype, "tint", {
            get: function () {
                return this._pieces[0].tint;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DImagePieceContainerImpl.prototype, "source", {
            get: function () {
                return this._pieces[0].source;
            },
            set: function (source) {
                this._pieces[0].source = source;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DImagePieceContainerImpl.prototype, "rotation", {
            get: function () {
                return this._pieces[0].rotation;
            },
            set: function (rotation) {
                this._pieces[0].rotation = rotation;
            },
            enumerable: false,
            configurable: true
        });
        DImagePieceContainerImpl.prototype.add = function (options) {
            var result = this.newImage(this._theme, options);
            this._pieces.push(result);
            return result;
        };
        DImagePieceContainerImpl.prototype.get = function (index) {
            var pieces = this._pieces;
            if (0 <= index && index < pieces.length) {
                return pieces[index];
            }
            return null;
        };
        DImagePieceContainerImpl.prototype.remove = function (index) {
            var pieces = this._pieces;
            if (0 <= index && index < pieces.length) {
                pieces[index].destroy();
                return true;
            }
            return false;
        };
        DImagePieceContainerImpl.prototype.size = function () {
            return this._pieces.length;
        };
        DImagePieceContainerImpl.prototype.destroy = function () {
            var pieces = this._pieces;
            for (var i = 0, imax = pieces.length; i < imax; ++i) {
                pieces[i].destroy();
            }
        };
        return DImagePieceContainerImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A base class for UI classes with an image support.
     * See {@link DImageBaseEvents} for event details.
     */
    var DImageBase = /** @class */ (function (_super) {
        __extends(DImageBase, _super);
        function DImageBase() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DImageBase.prototype.init = function (options) {
            this.getImage();
            _super.prototype.init.call(this, options);
        };
        Object.defineProperty(DImageBase.prototype, "image", {
            get: function () {
                var _a;
                return ((_a = this._image) !== null && _a !== void 0 ? _a : (this._image = this.newImage()));
            },
            set: function (imageSource) {
                var image = this.image.get(0);
                if (image != null) {
                    image.source = imageSource;
                }
            },
            enumerable: false,
            configurable: true
        });
        DImageBase.prototype.getImage = function () {
            var _a;
            return ((_a = this._image) !== null && _a !== void 0 ? _a : (this._image = this.newImage()));
        };
        DImageBase.prototype.newImage = function () {
            return new DImagePieceContainerImpl(this, this.theme, this.options);
        };
        DImageBase.prototype.onStateChange = function (newState, oldState) {
            _super.prototype.onStateChange.call(this, newState, oldState);
            this.getImage().onStateChange(newState, oldState);
        };
        DImageBase.prototype.onReflowTextAndImage = function () {
            var layouter = this.getLayouter();
            this.getImage().update(layouter);
            var text = this.getText();
            text.update(layouter);
            var auto = this._auto;
            layouter.execute(this._padding, text.align, auto.width.isOn ? null : this.width, auto.height.isOn ? null : this.height);
            layouter.clear();
        };
        DImageBase.prototype.isRefitable = function (target) {
            if (_super.prototype.isRefitable.call(this, target)) {
                return true;
            }
            if (this.getImage().isRefitable(target)) {
                return true;
            }
            return false;
        };
        DImageBase.prototype.getType = function () {
            return "DImageBase";
        };
        DImageBase.prototype.destroy = function () {
            var image = this._image;
            if (image != null) {
                image.destroy();
            }
            _super.prototype.destroy.call(this);
        };
        return DImageBase;
    }(DTextBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A base class for button classes.
     * See {@link DButtonBaseEvents} for event details.
     */
    var DButtonBase = /** @class */ (function (_super) {
        __extends(DButtonBase, _super);
        function DButtonBase() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DButtonBase.prototype.init = function (options) {
            var _this = this;
            var _a, _b;
            _super.prototype.init.call(this, options);
            var theme = this.theme;
            this._isToggle = (_a = options === null || options === void 0 ? void 0 : options.toggle) !== null && _a !== void 0 ? _a : theme.isToggle();
            this._when = toEnum((_b = options === null || options === void 0 ? void 0 : options.when) !== null && _b !== void 0 ? _b : theme.getWhen(), DButtonBaseWhen);
            // Event handlers
            this.on(UtilPointerEvent.tap, function (e) {
                _this.onClick(e);
            });
            this.initOnPress();
            // Group
            var group = options === null || options === void 0 ? void 0 : options.group;
            if (group) {
                group.add(this);
            }
        };
        DButtonBase.prototype.onShortcut = function (e) {
            if (this.state.isActionable) {
                this.activate(e);
            }
            _super.prototype.onShortcut.call(this, e);
        };
        Object.defineProperty(DButtonBase.prototype, "isToggle", {
            get: function () {
                return !!this._isToggle;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DButtonBase.prototype, "isGrouped", {
            get: function () {
                return !!this._isGrouped;
            },
            set: function (isGrouped) {
                this._isGrouped = isGrouped;
            },
            enumerable: false,
            configurable: true
        });
        DButtonBase.prototype.initOnPress = function () {
            var _this = this;
            var interactionManager = null;
            var onUp = function () {
                _this.state.isPressed = false;
                if (interactionManager != null) {
                    interactionManager.off(UtilPointerEvent.up, onUp);
                    interactionManager.off(UtilPointerEvent.upoutside, onUp);
                    interactionManager.off(UtilPointerEvent.cancel, onUp);
                    interactionManager = null;
                }
            };
            this.on(UtilPointerEvent.down, function () {
                if (_this.state.isActionable) {
                    _this.state.isPressed = true;
                    var layer = DApplications.getLayer(_this);
                    if (layer) {
                        interactionManager = layer.renderer.plugins.interaction;
                        if (interactionManager != null) {
                            interactionManager.on(UtilPointerEvent.up, onUp);
                            interactionManager.on(UtilPointerEvent.upoutside, onUp);
                            interactionManager.on(UtilPointerEvent.cancel, onUp);
                        }
                    }
                }
            });
        };
        DButtonBase.prototype.getType = function () {
            return "DButton";
        };
        DButtonBase.prototype.onClick = function (e) {
            if (this._when === DButtonBaseWhen.CLICKED && this.state.isActionable) {
                this.activate(e);
            }
        };
        DButtonBase.prototype.onDblClick = function (e, interactionManager) {
            if (this._when === DButtonBaseWhen.DOUBLE_CLICKED && this.state.isActionable) {
                this.activate(e);
            }
            return _super.prototype.onDblClick.call(this, e, interactionManager);
        };
        DButtonBase.prototype.activate = function (e) {
            if (this._isToggle) {
                if (this._isGrouped) {
                    if (!this.state.isActive) {
                        this.onToggleStart(e);
                        this.onToggleEnd(e);
                    }
                }
                else {
                    this.onToggleStart(e);
                    this.onToggleEnd(e);
                }
            }
            else {
                this.onActivate(e);
            }
        };
        DButtonBase.prototype.onActivate = function (e) {
            this.emit("active", this);
        };
        DButtonBase.prototype.onInactivate = function (e) {
            this.emit("inactive", this);
        };
        DButtonBase.prototype.toggle = function () {
            if (this.state.isActionable) {
                if (this._isToggle) {
                    this.onToggleStart();
                    this.onToggleEnd();
                }
            }
        };
        DButtonBase.prototype.onToggleStart = function (e) {
            this.state.isActive = !this.state.isActive;
        };
        DButtonBase.prototype.onToggleEnd = function (e) {
            if (this.state.isActive) {
                this.onActivate(e);
            }
            else {
                this.onInactivate(e);
            }
        };
        DButtonBase.prototype.onActivateKeyDown = function (e) {
            if (this.state.isActionable) {
                if (this._isToggle) {
                    this.onToggleStart(e);
                }
                else {
                    this.state.isPressed = true;
                }
            }
        };
        DButtonBase.prototype.onActivateKeyUp = function (e) {
            if (this.state.isActionable) {
                if (this._isToggle) {
                    this.onToggleEnd(e);
                }
                else {
                    if (this.state.isPressed) {
                        this.onActivate(e);
                    }
                    this.state.isPressed = false;
                }
            }
        };
        DButtonBase.prototype.onKeyDown = function (e) {
            if (UtilKeyboardEvent.isActivateKey(e)) {
                this.onActivateKeyDown(e);
            }
            return _super.prototype.onKeyDown.call(this, e);
        };
        DButtonBase.prototype.onKeyUp = function (e) {
            if (UtilKeyboardEvent.isActivateKey(e)) {
                this.onActivateKeyUp(e);
            }
            return _super.prototype.onKeyUp.call(this, e);
        };
        DButtonBase.prototype.onStateChange = function (newState, oldState) {
            _super.prototype.onStateChange.call(this, newState, oldState);
            if (newState.isPressed) {
                if (!oldState.isPressed) {
                    this.onPress();
                }
            }
            else if (oldState.isPressed) {
                this.onUnpress();
            }
        };
        DButtonBase.prototype.onPress = function () {
            this.emit("press", this);
        };
        DButtonBase.prototype.onUnpress = function () {
            this.emit("unpress", this);
        };
        DButtonBase.prototype.destroy = function () {
            var _a, _b;
            (_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.group) === null || _b === void 0 ? void 0 : _b.remove(this);
            _super.prototype.destroy.call(this);
        };
        return DButtonBase;
    }(DImageBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A button class.
     */
    var DButton = /** @class */ (function (_super) {
        __extends(DButton, _super);
        function DButton() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DButton.prototype.getType = function () {
            return "DButton";
        };
        return DButton;
    }(DButtonBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DButtonPrimary = /** @class */ (function (_super) {
        __extends(DButtonPrimary, _super);
        function DButtonPrimary() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DButtonPrimary.prototype.getType = function () {
            return "DButtonPrimary";
        };
        return DButtonPrimary;
    }(DButton));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DLayoutHorizontal = /** @class */ (function (_super) {
        __extends(DLayoutHorizontal, _super);
        function DLayoutHorizontal() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DLayoutHorizontal.prototype.getType = function () {
            return "DLayoutHorizontal";
        };
        return DLayoutHorizontal;
    }(DLayout));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogLayeredFooter = /** @class */ (function (_super) {
        __extends(DDialogLayeredFooter, _super);
        function DDialogLayeredFooter(parent, options) {
            var _this = _super.call(this, options) || this;
            _this._parent = parent;
            return _this;
        }
        DDialogLayeredFooter.prototype.init = function (options) {
            _super.prototype.init.call(this, options);
            var children = this.newChildren();
            if (0 < children.length) {
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    var child = children[i];
                    if (child != null) {
                        this.addChild(child);
                    }
                }
            }
        };
        DDialogLayeredFooter.prototype.newChildren = function () {
            return [this.buttonSpaceLeft, this.buttonCancel, this.buttonOk, this.buttonSpaceRight];
        };
        Object.defineProperty(DDialogLayeredFooter.prototype, "buttonSpaceLeft", {
            get: function () {
                var result = this._buttonSpaceLeft;
                if (result === undefined) {
                    result = this.newButtonSpaceLeft();
                    this._buttonSpaceLeft = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DDialogLayeredFooter.prototype.newButtonSpaceLeft = function () {
            var _a, _b, _c, _d;
            if ((_d = (_c = (_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.button) === null || _b === void 0 ? void 0 : _b.space) === null || _c === void 0 ? void 0 : _c.left) !== null && _d !== void 0 ? _d : this.theme.isButtonSpaceLeftEnabled()) {
                return new DLayoutSpace({
                    weight: 1
                });
            }
            return null;
        };
        Object.defineProperty(DDialogLayeredFooter.prototype, "buttonSpaceRight", {
            get: function () {
                var result = this._buttonSpaceRight;
                if (result === undefined) {
                    result = this.newButtonSpaceRight();
                    this._buttonSpaceRight = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DDialogLayeredFooter.prototype.newButtonSpaceRight = function () {
            var _a, _b, _c, _d;
            if ((_d = (_c = (_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.button) === null || _b === void 0 ? void 0 : _b.space) === null || _c === void 0 ? void 0 : _c.right) !== null && _d !== void 0 ? _d : this.theme.isButtonSpaceRightEnabled()) {
                return new DLayoutSpace({
                    weight: 1
                });
            }
            return null;
        };
        Object.defineProperty(DDialogLayeredFooter.prototype, "buttonCancel", {
            get: function () {
                var result = this._buttonCancel;
                if (result === undefined) {
                    result = this.newButtonCancel();
                    this._buttonCancel = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DDialogLayeredFooter.prototype.newButtonCancel = function () {
            var _this = this;
            var _a, _b;
            var cancel = (_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.button) === null || _b === void 0 ? void 0 : _b.cancel;
            if (cancel === undefined) {
                cancel = this.theme.getButtonCancel();
            }
            if (cancel != null) {
                return new DButtonPrimary({
                    text: {
                        value: cancel
                    },
                    on: {
                        active: function () {
                            _this._parent.cancel();
                        }
                    }
                });
            }
            return null;
        };
        Object.defineProperty(DDialogLayeredFooter.prototype, "buttonOk", {
            get: function () {
                var result = this._buttonOk;
                if (result === undefined) {
                    result = this.newButtonOk();
                    this._buttonOk = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DDialogLayeredFooter.prototype.newButtonOk = function () {
            var _this = this;
            var _a, _b;
            var ok = (_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.button) === null || _b === void 0 ? void 0 : _b.ok;
            if (ok === undefined) {
                ok = this.theme.getButtonOk();
            }
            if (ok != null) {
                if (this.buttonCancel != null) {
                    return new DButton({
                        text: {
                            value: ok
                        },
                        on: {
                            active: function () {
                                _this._parent.ok();
                            }
                        }
                    });
                }
                else {
                    return new DButtonPrimary({
                        text: {
                            value: ok
                        },
                        on: {
                            active: function () {
                                _this._parent.ok();
                            }
                        }
                    });
                }
            }
            return null;
        };
        DDialogLayeredFooter.prototype.getType = function () {
            return "DDialogLayeredFooter";
        };
        return DDialogLayeredFooter;
    }(DLayoutHorizontal));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DButtonAmbient = /** @class */ (function (_super) {
        __extends(DButtonAmbient, _super);
        function DButtonAmbient() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DButtonAmbient.prototype.getType = function () {
            return "DButtonAmbient";
        };
        return DButtonAmbient;
    }(DButton));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogLayeredHeaderButtonClose = /** @class */ (function (_super) {
        __extends(DDialogLayeredHeaderButtonClose, _super);
        function DDialogLayeredHeaderButtonClose() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DDialogLayeredHeaderButtonClose.prototype.getType = function () {
            return "DDialogLayeredHeaderButtonClose";
        };
        return DDialogLayeredHeaderButtonClose;
    }(DButtonAmbient));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogLayeredHeaderSeparator = /** @class */ (function (_super) {
        __extends(DDialogLayeredHeaderSeparator, _super);
        function DDialogLayeredHeaderSeparator() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DDialogLayeredHeaderSeparator.prototype.getType = function () {
            return "DDialogLayeredHeaderSeparator";
        };
        return DDialogLayeredHeaderSeparator;
    }(DImageBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogLayeredHeader = /** @class */ (function (_super) {
        __extends(DDialogLayeredHeader, _super);
        function DDialogLayeredHeader(parent, options) {
            var _this = _super.call(this, options) || this;
            _this._parent = parent;
            var separator = _this.separator;
            if (separator) {
                _this.addChild(separator);
            }
            var buttonClose = _this.buttonClose;
            if (buttonClose) {
                _this.addChild(buttonClose);
                buttonClose.on("active", function () {
                    _this._parent.cancel();
                });
            }
            return _this;
        }
        Object.defineProperty(DDialogLayeredHeader.prototype, "buttonClose", {
            get: function () {
                var result = this._buttonClose;
                if (result === undefined) {
                    result = this.newButtonClose();
                    this._buttonClose = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DDialogLayeredHeader.prototype.newButtonClose = function () {
            var _a, _b;
            if (((_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.button) === null || _b === void 0 ? void 0 : _b.close) !== false) {
                return new DDialogLayeredHeaderButtonClose();
            }
            return null;
        };
        Object.defineProperty(DDialogLayeredHeader.prototype, "separator", {
            get: function () {
                var result = this._separator;
                if (result === undefined) {
                    result = this.newSeparator();
                    this._separator = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DDialogLayeredHeader.prototype.newSeparator = function () {
            var _a;
            if (((_a = this._options) === null || _a === void 0 ? void 0 : _a.separator) !== false) {
                return new DDialogLayeredHeaderSeparator();
            }
            return null;
        };
        DDialogLayeredHeader.prototype.getType = function () {
            return "DDialogLayeredHeader";
        };
        return DDialogLayeredHeader;
    }(DImageBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A dialog with a header, a content and a footer.
     */
    var DDialogLayered = /** @class */ (function (_super) {
        __extends(DDialogLayered, _super);
        function DDialogLayered() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DDialogLayered.prototype.init = function (options) {
            _super.prototype.init.call(this, options);
            this.addChild(this.layout);
        };
        Object.defineProperty(DDialogLayered.prototype, "layout", {
            get: function () {
                var result = this._layout;
                if (result == null) {
                    result = this.newLayout();
                    this._layout = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DDialogLayered.prototype.newLayout = function () {
            return new DLayoutVertical(this.toLayoutOptions(this.theme, this._options));
        };
        DDialogLayered.prototype.toLayoutOptions = function (theme, options) {
            var _a, _b;
            var result = (_b = (_a = options === null || options === void 0 ? void 0 : options.layout) !== null && _a !== void 0 ? _a : theme.getLayout()) !== null && _b !== void 0 ? _b : this.newLayoutOptions(theme, options);
            if (result.children === undefined) {
                result.children = this.newLayoutChildren(theme, options);
            }
            return result;
        };
        DDialogLayered.prototype.newLayoutOptions = function (theme, options) {
            return {
                width: "padding",
                height: "auto",
                margin: 0
            };
        };
        DDialogLayered.prototype.newLayoutChildren = function (theme, options) {
            return [this.header, this.content, this.footer];
        };
        Object.defineProperty(DDialogLayered.prototype, "header", {
            get: function () {
                var result = this._header;
                if (result === undefined) {
                    result = this.newHeader();
                    this._header = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DDialogLayered.prototype.newHeader = function () {
            var options = this.toHeaderOptions(this.theme, this._options);
            if (options !== null) {
                return new DDialogLayeredHeader(this, options);
            }
            return null;
        };
        DDialogLayered.prototype.toHeaderOptions = function (theme, options) {
            if (options) {
                var result = options.header;
                if (result !== undefined) {
                    return result;
                }
            }
            return theme.getHeader();
        };
        Object.defineProperty(DDialogLayered.prototype, "content", {
            get: function () {
                var result = this._content;
                if (result == null) {
                    result = this.newContent();
                    this._content = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DDialogLayered.prototype.newContent = function () {
            return new DDialogLayeredContent(this.toContentOptions(this.theme, this._options));
        };
        DDialogLayered.prototype.toContentOptions = function (theme, options) {
            var _a, _b;
            var result = (_b = (_a = options === null || options === void 0 ? void 0 : options.content) !== null && _a !== void 0 ? _a : theme.getContent()) !== null && _b !== void 0 ? _b : {};
            if (result.children === undefined) {
                result.children = this.newContentChildren(theme, options);
            }
            return result;
        };
        DDialogLayered.prototype.newContentChildren = function (theme, options) {
            return [];
        };
        Object.defineProperty(DDialogLayered.prototype, "footer", {
            get: function () {
                var result = this._footer;
                if (result === undefined) {
                    result = this.newFooter();
                    this._footer = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DDialogLayered.prototype.newFooter = function () {
            var options = this.toFooterOptions(this.theme, this._options);
            if (options !== null) {
                return new DDialogLayeredFooter(this, options);
            }
            return null;
        };
        DDialogLayered.prototype.toFooterOptions = function (theme, options) {
            if (options) {
                var result = options.footer;
                if (result !== undefined) {
                    return result;
                }
            }
            return theme.getFooter();
        };
        DDialogLayered.prototype.findFirstFocusable = function (focusController) {
            return focusController.find(this.content, false, true, true);
        };
        DDialogLayered.prototype.ok = function () {
            this.onOk(this.getResolvedValue());
        };
        DDialogLayered.prototype.onOk = function (value) {
            this.doResolve(value);
            this.emit("ok", value, this);
        };
        DDialogLayered.prototype.cancel = function () {
            this.onCancel(this.getRejectReason());
        };
        DDialogLayered.prototype.onCancel = function (reason) {
            this.doReject(reason);
            this.emit("cancel", reason, this);
        };
        DDialogLayered.prototype.getRejectReason = function () {
            return undefined;
        };
        DDialogLayered.prototype.getType = function () {
            return "DDialogLayered";
        };
        return DDialogLayered;
    }(DDialog));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogInput = /** @class */ (function (_super) {
        __extends(DDialogInput, _super);
        function DDialogInput() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DDialogInput.prototype.newContentChildren = function (theme, options) {
            var result = _super.prototype.newContentChildren.call(this, theme, options);
            result.push(this.inputLayout);
            return result;
        };
        DDialogInput.prototype.toInputMargin = function (theme, options) {
            var _a, _b;
            return (_b = (_a = options === null || options === void 0 ? void 0 : options.input) === null || _a === void 0 ? void 0 : _a.margin) !== null && _b !== void 0 ? _b : theme.getInputMargin();
        };
        Object.defineProperty(DDialogInput.prototype, "inputLayout", {
            get: function () {
                var result = this._inputLayout;
                if (result == null) {
                    result = this.newInputLayout();
                    this._inputLayout = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DDialogInput.prototype.newInputLayout = function () {
            var margin = this.toInputMargin(this.theme, this._options);
            return new DLayoutHorizontal({
                width: "padding",
                height: "auto",
                margin: 0,
                children: [
                    new DLayoutSpace({ width: margin }),
                    this.input,
                    new DLayoutSpace({ width: margin })
                ]
            });
        };
        Object.defineProperty(DDialogInput.prototype, "input", {
            get: function () {
                var result = this._input;
                if (result == null) {
                    var options = this._options;
                    result = this.newInput(options === null || options === void 0 ? void 0 : options.input);
                    this._input = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDialogInput.prototype, "value", {
            get: function () {
                return this.input.value;
            },
            set: function (value) {
                this.input.value = value;
            },
            enumerable: false,
            configurable: true
        });
        DDialogInput.prototype.getResolvedValue = function () {
            return this.input.value;
        };
        DDialogInput.prototype.getType = function () {
            return "DDialogInput";
        };
        return DDialogInput;
    }(DDialogLayered));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DButtonGroup = /** @class */ (function (_super) {
        __extends(DButtonGroup, _super);
        function DButtonGroup(options) {
            var _this = _super.call(this) || this;
            _this._buttons = [];
            _this._active = null;
            _this._onActiveBound = function (button) {
                _this.active = button;
            };
            // Events
            var on = options === null || options === void 0 ? void 0 : options.on;
            if (on != null) {
                for (var name_1 in on) {
                    var handler = on[name_1];
                    if (handler) {
                        _this.on(name_1, handler);
                    }
                }
            }
            // Done
            _this.emit("init", _this);
            return _this;
        }
        DButtonGroup.prototype.add = function (button) {
            var buttons = this._buttons;
            var index = buttons.indexOf(button);
            if (index < 0) {
                this._buttons.push(button);
                button.isGrouped = true;
                var isEnabled = this._isEnabled;
                if (isEnabled != null) {
                    button.state.isEnabled = isEnabled;
                }
                button.on("active", this._onActiveBound);
                if (button.state.isActive) {
                    this.active = button;
                }
            }
        };
        Object.defineProperty(DButtonGroup.prototype, "active", {
            get: function () {
                return this._active;
            },
            set: function (newActive) {
                if ((newActive == null || newActive.isToggle) && this._active !== newActive) {
                    var oldActive = this._active;
                    this._active = newActive;
                    var buttons = this._buttons;
                    for (var i = 0, imax = buttons.length; i < imax; ++i) {
                        var button = buttons[i];
                        if (button !== newActive && button.isToggle && button.state.isActive) {
                            button.toggle();
                        }
                    }
                    this.emit("active", newActive, oldActive, this);
                }
            },
            enumerable: false,
            configurable: true
        });
        DButtonGroup.prototype.remove = function (button) {
            var buttons = this._buttons;
            var index = buttons.indexOf(button);
            if (0 <= index) {
                buttons.splice(index, 1);
                button.isGrouped = false;
                button.off("active", this._onActiveBound);
                if (this._active === button) {
                    this.active = null;
                }
            }
        };
        DButtonGroup.prototype.contains = function (button) {
            var buttons = this._buttons;
            var index = buttons.indexOf(button);
            return 0 <= index;
        };
        DButtonGroup.prototype.clear = function () {
            var buttons = this._buttons;
            for (var i = 0, imax = buttons.length; i < imax; ++i) {
                buttons[i].isGrouped = false;
            }
            buttons.length = 0;
            this.active = null;
        };
        DButtonGroup.prototype.size = function () {
            return this._buttons.length;
        };
        DButtonGroup.prototype.each = function (iteratee) {
            var buttons = this._buttons;
            for (var i = 0, imax = buttons.length; i < imax; ++i) {
                var button = buttons[i];
                if (iteratee(button) === false) {
                    break;
                }
            }
        };
        DButtonGroup.prototype.disable = function () {
            var buttons = this._buttons;
            for (var i = 0, imax = buttons.length; i < imax; ++i) {
                buttons[i].state.isDisabled = true;
            }
            this._isEnabled = false;
        };
        DButtonGroup.prototype.enable = function () {
            var buttons = this._buttons;
            for (var i = 0, imax = buttons.length; i < imax; ++i) {
                buttons[i].state.isDisabled = false;
            }
            this._isEnabled = true;
        };
        DButtonGroup.prototype.destroy = function () {
            this.clear();
        };
        return DButtonGroup;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2021 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DInputBooleanButtonOff = /** @class */ (function (_super) {
        __extends(DInputBooleanButtonOff, _super);
        function DInputBooleanButtonOff() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DInputBooleanButtonOff.prototype.getType = function () {
            return "DInputBooleanButtonOff";
        };
        return DInputBooleanButtonOff;
    }(DButton));

    /*
     * Copyright (C) 2021 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DInputBooleanButtonOn = /** @class */ (function (_super) {
        __extends(DInputBooleanButtonOn, _super);
        function DInputBooleanButtonOn() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DInputBooleanButtonOn.prototype.getType = function () {
            return "DInputBooleanButtonOn";
        };
        return DInputBooleanButtonOn;
    }(DButton));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DInputBoolean = /** @class */ (function (_super) {
        __extends(DInputBoolean, _super);
        function DInputBoolean(options) {
            var _this = _super.call(this, options) || this;
            _this._lockCount = 0;
            _this.addChild(_this.getButtonOff());
            _this.addChild(_this.getButtonOn());
            var value = options === null || options === void 0 ? void 0 : options.value;
            if (value != null) {
                _this.value = value;
            }
            _this.getButtonGroup().on("active", function () {
                if (_this._lockCount <= 0) {
                    var newValue = _this.value;
                    _this.emit("change", newValue, !newValue, _this);
                }
            });
            return _this;
        }
        DInputBoolean.prototype.getButtonGroup = function () {
            var result = this._buttonGroup;
            if (result == null) {
                result = this.newButtonGroup();
                this._buttonGroup = result;
            }
            return result;
        };
        DInputBoolean.prototype.newButtonGroup = function () {
            return new DButtonGroup();
        };
        DInputBoolean.prototype.getButtonOn = function () {
            var result = this._buttonOn;
            if (result == null) {
                result = this.newButtonOn();
                this._buttonOn = result;
            }
            return result;
        };
        DInputBoolean.prototype.newButtonOn = function () {
            return new DInputBooleanButtonOn({
                weight: 1,
                group: this.getButtonGroup()
            });
        };
        DInputBoolean.prototype.getButtonOff = function () {
            var result = this._buttonOff;
            if (result == null) {
                result = this.newButtonOff();
                this._buttonOff = result;
            }
            return result;
        };
        DInputBoolean.prototype.newButtonOff = function () {
            return new DInputBooleanButtonOff({
                weight: 1,
                group: this.getButtonGroup(),
                state: DBaseState.ACTIVE
            });
        };
        Object.defineProperty(DInputBoolean.prototype, "value", {
            get: function () {
                return this.getButtonOn().state.isActive;
            },
            set: function (value) {
                if (this.value !== value) {
                    this._lockCount += 1;
                    try {
                        if (value) {
                            this.getButtonOn().activate();
                        }
                        else {
                            this.getButtonOff().activate();
                        }
                    }
                    catch (e) {
                        // DO NOTHING
                    }
                    this._lockCount -= 1;
                }
            },
            enumerable: false,
            configurable: true
        });
        DInputBoolean.prototype.getType = function () {
            return "DInputBoolean";
        };
        return DInputBoolean;
    }(DLayoutHorizontal));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogInputBoolean = /** @class */ (function (_super) {
        __extends(DDialogInputBoolean, _super);
        function DDialogInputBoolean() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DDialogInputBoolean.prototype.newInput = function (options) {
            return new DInputBoolean(this.toInputOptions(options));
        };
        DDialogInputBoolean.prototype.toInputOptions = function (options) {
            if (options) {
                if (options.weight === undefined) {
                    options.weight = 1;
                }
                return options;
            }
            return {
                weight: 1
            };
        };
        DDialogInputBoolean.prototype.getType = function () {
            return "DDialogInputBoolean";
        };
        return DDialogInputBoolean;
    }(DDialogInput));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeOpenDialog = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeOpenDialog, _super);
        function EShapeActionRuntimeOpenDialog(value) {
            var _this = _super.call(this, value, EShapeRuntimeReset.NONE) || this;
            _this.target = EShapeActionExpressions.ofStringOrNull(value.target);
            _this.onInputAction = value.onInputAction;
            _this.isOpened = false;
            _this.step = EShapeActionExpressions.ofNumberOrNull(value.step);
            _this.min = EShapeActionExpressions.ofNumberOrNull(value.min);
            _this.max = EShapeActionExpressions.ofNumberOrNull(value.max);
            return _this;
        }
        EShapeActionRuntimeOpenDialog.prototype.execute = function (shape, runtime, time) {
            var _this = this;
            if (!this.isOpened) {
                if (this.condition(shape, time, EShapeActionEnvironment)) {
                    var target_1 = this.target(shape, time, EShapeActionEnvironment);
                    if (target_1 != null) {
                        var initial_1 = this.initial(shape, time, EShapeActionEnvironment);
                        var step_1 = this.step(shape, time, EShapeActionEnvironment);
                        var min_1 = this.min(shape, time, EShapeActionEnvironment);
                        var max_1 = this.max(shape, time, EShapeActionEnvironment);
                        this.isOpened = true;
                        setTimeout(function () {
                            _this.open(shape, target_1, initial_1, step_1, min_1, max_1).then(function (value) {
                                _this.isOpened = false;
                                EShapeActionValueOnInputActions.execute(shape, _this.onInputAction, target_1, value, time);
                            }, function () {
                                _this.isOpened = false;
                            });
                        }, 0);
                    }
                }
            }
        };
        return EShapeActionRuntimeOpenDialog;
    }(EShapeActionRuntimeConditional));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeOpenDialogBoolean = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeOpenDialogBoolean, _super);
        function EShapeActionRuntimeOpenDialogBoolean(value) {
            var _this = _super.call(this, value) || this;
            _this.initial = EShapeActionExpressions.ofBooleanOrFalse(value.initial);
            return _this;
        }
        EShapeActionRuntimeOpenDialogBoolean.prototype.open = function (shape, target, initial, step, min, max) {
            var dialog = EShapeActionRuntimeOpenDialogBoolean.DIALOG;
            if (dialog == null) {
                dialog = new DDialogInputBoolean({
                    header: {
                        text: {
                            value: target
                        },
                        button: {
                            close: false
                        }
                    }
                });
                EShapeActionRuntimeOpenDialogBoolean.DIALOG = dialog;
            }
            else {
                var header = dialog.header;
                if (header) {
                    header.text = target;
                }
            }
            dialog.value = initial;
            return dialog.open(shape);
        };
        return EShapeActionRuntimeOpenDialogBoolean;
    }(EShapeActionRuntimeOpenDialog));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DHtmlElement = /** @class */ (function (_super) {
        __extends(DHtmlElement, _super);
        function DHtmlElement() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DHtmlElement.prototype.getUtil = function () {
            var result = this._util;
            if (result == null) {
                result = this.newUtil();
                this._util = result;
            }
            return result;
        };
        DHtmlElement.prototype.newUtil = function () {
            return new UtilHtmlElement(this, this.newOperation(), this.theme, this._options);
        };
        DHtmlElement.prototype.newOperation = function () {
            var _this = this;
            return {
                getElementRect: function (resolution, work, result) {
                    return _this.getElementRect(resolution, work, result);
                },
                getElementMatrix: function () {
                    return null;
                },
                getClipperRect: function (resolution, work, result) {
                    return _this.getClipperRect(resolution, work, result);
                },
                getPadding: function () {
                    return _this.padding;
                },
                containsPoint: function (point) {
                    return _this.containsPoint(point);
                },
                onStart: function () {
                    // DO NOTHING
                },
                onCancel: function () {
                    // DO NOTHING
                },
                onEnd: function () {
                    // DO NOTHING
                }
            };
        };
        Object.defineProperty(DHtmlElement.prototype, "element", {
            get: function () {
                return this.getUtil().element;
            },
            enumerable: false,
            configurable: true
        });
        DHtmlElement.prototype.onDownThis = function (e) {
            var util = this.getUtil();
            util.onDowning(e);
            _super.prototype.onDownThis.call(this, e);
            util.onDown(e);
        };
        DHtmlElement.prototype.onDblClick = function (e, interactionManager) {
            this.getUtil().onDblClick(e, interactionManager);
            return _super.prototype.onDblClick.call(this, e, interactionManager);
        };
        DHtmlElement.prototype.onFocus = function () {
            _super.prototype.onFocus.call(this);
            this.getUtil().onFocus();
        };
        DHtmlElement.prototype.onBlur = function () {
            _super.prototype.onBlur.call(this);
            this.getUtil().onBlur();
        };
        DHtmlElement.prototype.start = function () {
            this.getUtil().start();
        };
        DHtmlElement.prototype.render = function (renderer) {
            this.getUtil().onRender(renderer);
            _super.prototype.render.call(this, renderer);
        };
        /**
         * Please note that this method does not update transforms.
         *
         * @param resolution
         */
        DHtmlElement.prototype.getElementRect = function (resolution, point, result) {
            point.set(0, 0);
            this.toGlobal(point, point, false);
            result.x = point.x;
            result.y = point.y;
            point.set(this.width, this.height);
            this.toGlobal(point, point, true);
            result.width = point.x - result.x;
            result.height = point.y - result.y;
            return result;
        };
        DHtmlElement.prototype.getClipperRect = function (resolution, point, result) {
            return UtilHtmlElement.getClipperRect(this.parent, this, resolution, point, result);
        };
        DHtmlElement.prototype.cancel = function () {
            this.getUtil().cancel();
        };
        DHtmlElement.prototype.end = function () {
            this.getUtil().end();
        };
        DHtmlElement.prototype.select = function () {
            this.getUtil().select();
            return this;
        };
        DHtmlElement.prototype.onActivateKeyDown = function (e) {
            if (this.state.isActionable) {
                this.state.isPressed = true;
            }
        };
        DHtmlElement.prototype.onActivateKeyUp = function (e) {
            if (this.state.isActionable) {
                if (this.state.isPressed) {
                    this.start();
                }
                this.state.isPressed = false;
            }
        };
        DHtmlElement.prototype.onKeyDown = function (e) {
            if (UtilKeyboardEvent.isActivateKey(e)) {
                this.onActivateKeyDown(e);
            }
            return _super.prototype.onKeyDown.call(this, e);
        };
        DHtmlElement.prototype.onKeyUp = function (e) {
            if (UtilKeyboardEvent.isActivateKey(e)) {
                this.onActivateKeyUp(e);
            }
            return _super.prototype.onKeyUp.call(this, e);
        };
        DHtmlElement.prototype.getType = function () {
            return "DHtmlElement";
        };
        return DHtmlElement;
    }(DImageBase));

    /*
     * Copyright (C) 2021 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DInput = /** @class */ (function (_super) {
        __extends(DInput, _super);
        function DInput() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DInput.prototype.newOperation = function () {
            var _this = this;
            return {
                getElementRect: function (resolution, work, result) {
                    return _this.getElementRect(resolution, work, result);
                },
                getElementMatrix: function () {
                    return null;
                },
                getClipperRect: function (resolution, work, result) {
                    return _this.getClipperRect(resolution, work, result);
                },
                getPadding: function () {
                    return _this.padding;
                },
                containsPoint: function (point) {
                    return _this.containsPoint(point);
                },
                onStart: function () {
                    _this.text.hide();
                },
                onCancel: function () {
                    _this.text.show();
                },
                onEnd: function () {
                    // DO NOTHING
                },
                getValue: function () {
                    return _this.text.computed;
                },
                onValueInput: function (newValue) {
                    _this.onValueInput(newValue);
                },
                onValueChange: function (newValue, oldValue) {
                    _this.text = newValue;
                    _this.onValueChange(newValue, oldValue);
                },
                onEnter: function () {
                    _this.onEnter();
                },
                applyTitle: function () {
                    _this.applyTitle();
                }
            };
        };
        Object.defineProperty(DInput.prototype, "value", {
            get: function () {
                return this.text.computed;
            },
            set: function (value) {
                this.text = value;
            },
            enumerable: false,
            configurable: true
        });
        DInput.prototype.newText = function () {
            var _this = this;
            var result = _super.prototype.newText.call(this);
            result.on("change", function () {
                _this.validate();
            });
            return result;
        };
        DInput.prototype.onValueChange = function (newValue, oldValue) {
            this.emit("change", newValue, oldValue, this);
        };
        DInput.prototype.onValueInput = function (newValue) {
            this.emit("input", newValue, this);
        };
        DInput.prototype.onEnter = function () {
            this.emit("enter", this);
        };
        DInput.prototype.validate = function () {
            return this.getUtil().validate();
        };
        DInput.prototype.applyTitle = function () {
            if (!this.getUtil().applyTitle()) {
                _super.prototype.applyTitle.call(this);
            }
        };
        DInput.prototype.getType = function () {
            return "DInput";
        };
        return DInput;
    }(DHtmlElement));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DInputInput = /** @class */ (function (_super) {
        __extends(DInputInput, _super);
        function DInputInput() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DInputInput.prototype.getType = function () {
            return "DInputInput";
        };
        return DInputInput;
    }(DInput));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DInputNumber = /** @class */ (function (_super) {
        __extends(DInputNumber, _super);
        function DInputNumber() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DInputNumber.prototype.newUtil = function () {
            return new UtilInputNumber(this, this.newOperation(), this.theme, this._options);
        };
        Object.defineProperty(DInputNumber.prototype, "step", {
            get: function () {
                return this.getUtil().step;
            },
            set: function (step) {
                this.getUtil().step = step;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DInputNumber.prototype, "min", {
            get: function () {
                return this.getUtil().min;
            },
            set: function (min) {
                this.getUtil().min = min;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DInputNumber.prototype, "max", {
            get: function () {
                return this.getUtil().max;
            },
            set: function (max) {
                this.getUtil().max = max;
            },
            enumerable: false,
            configurable: true
        });
        return DInputNumber;
    }(DInputInput));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DInputInteger = /** @class */ (function (_super) {
        __extends(DInputInteger, _super);
        function DInputInteger() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DInputInteger.prototype.getType = function () {
            return "DInputInteger";
        };
        return DInputInteger;
    }(DInputNumber));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogInputInteger = /** @class */ (function (_super) {
        __extends(DDialogInputInteger, _super);
        function DDialogInputInteger() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DDialogInputInteger.prototype.newInput = function (options) {
            var _this = this;
            var result = new DInputInteger(this.toInputOptions(options));
            result.on("enter", function () {
                _this.ok();
            });
            return result;
        };
        DDialogInputInteger.prototype.toInputOptions = function (options) {
            if (options) {
                if (options.weight === undefined) {
                    options.weight = 1;
                }
                return options;
            }
            return {
                weight: 1
            };
        };
        DDialogInputInteger.prototype.getType = function () {
            return "DDialogInputInteger";
        };
        return DDialogInputInteger;
    }(DDialogInput));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeOpenDialogInteger = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeOpenDialogInteger, _super);
        function EShapeActionRuntimeOpenDialogInteger(value) {
            var _this = _super.call(this, value) || this;
            _this.initial = EShapeActionExpressions.ofNumber(value.initial);
            return _this;
        }
        EShapeActionRuntimeOpenDialogInteger.prototype.open = function (shape, target, initial, step, min, max) {
            var dialog = EShapeActionRuntimeOpenDialogInteger.DIALOG;
            if (dialog == null) {
                dialog = new DDialogInputInteger({
                    header: {
                        text: {
                            value: target
                        },
                        button: {
                            close: false
                        }
                    },
                    input: {
                        step: step,
                        min: min,
                        max: max,
                        text: {
                            value: initial
                        }
                    }
                });
                EShapeActionRuntimeOpenDialogInteger.DIALOG = dialog;
            }
            else {
                var header = dialog.header;
                if (header) {
                    header.text = target;
                }
                var input = dialog.input;
                input.step = step;
                input.min = min;
                input.max = max;
                dialog.value = initial;
            }
            return dialog.open(shape);
        };
        return EShapeActionRuntimeOpenDialogInteger;
    }(EShapeActionRuntimeOpenDialog));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DInputReal = /** @class */ (function (_super) {
        __extends(DInputReal, _super);
        function DInputReal() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DInputReal.prototype.getType = function () {
            return "DInputReal";
        };
        return DInputReal;
    }(DInputNumber));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogInputReal = /** @class */ (function (_super) {
        __extends(DDialogInputReal, _super);
        function DDialogInputReal() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DDialogInputReal.prototype.newInput = function (options) {
            var _this = this;
            var result = new DInputReal(this.toInputOptions(options));
            result.on("enter", function () {
                _this.ok();
            });
            return result;
        };
        DDialogInputReal.prototype.toInputOptions = function (options) {
            if (options) {
                if (options.weight === undefined) {
                    options.weight = 1;
                }
                return options;
            }
            return {
                weight: 1
            };
        };
        DDialogInputReal.prototype.getType = function () {
            return "DDialogInputReal";
        };
        return DDialogInputReal;
    }(DDialogInput));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeOpenDialogReal = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeOpenDialogReal, _super);
        function EShapeActionRuntimeOpenDialogReal(value) {
            var _this = _super.call(this, value) || this;
            _this.initial = EShapeActionExpressions.ofNumber(value.initial);
            return _this;
        }
        EShapeActionRuntimeOpenDialogReal.prototype.open = function (shape, target, initial, step, min, max) {
            var dialog = EShapeActionRuntimeOpenDialogReal.DIALOG;
            if (dialog == null) {
                dialog = new DDialogInputReal({
                    header: {
                        text: {
                            value: target
                        },
                        button: {
                            close: false
                        }
                    },
                    input: {
                        step: step,
                        min: min,
                        max: max,
                        text: {
                            value: initial
                        }
                    }
                });
                EShapeActionRuntimeOpenDialogReal.DIALOG = dialog;
            }
            else {
                var header = dialog.header;
                if (header) {
                    header.text = target;
                }
                var input = dialog.input;
                input.step = step;
                input.min = min;
                input.max = max;
                dialog.value = initial;
            }
            return dialog.open(shape);
        };
        return EShapeActionRuntimeOpenDialogReal;
    }(EShapeActionRuntimeOpenDialog));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DInputText = /** @class */ (function (_super) {
        __extends(DInputText, _super);
        function DInputText() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DInputText.prototype.newUtil = function () {
            return new UtilInputText(this, this.newOperation(), this.theme, this._options);
        };
        DInputText.prototype.getType = function () {
            return "DInputText";
        };
        return DInputText;
    }(DInputInput));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogInputText = /** @class */ (function (_super) {
        __extends(DDialogInputText, _super);
        function DDialogInputText() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DDialogInputText.prototype.newInput = function (options) {
            var _this = this;
            var result = new DInputText(this.toInputOptions(options));
            result.on("enter", function () {
                _this.ok();
            });
            return result;
        };
        DDialogInputText.prototype.toInputOptions = function (options) {
            if (options) {
                if (options.weight === undefined) {
                    options.weight = 1;
                }
                return options;
            }
            return {
                weight: 1
            };
        };
        DDialogInputText.prototype.getType = function () {
            return "DDialogInputText";
        };
        return DDialogInputText;
    }(DDialogInput));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeOpenDialogText = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeOpenDialogText, _super);
        function EShapeActionRuntimeOpenDialogText(value) {
            var _this = _super.call(this, value) || this;
            _this.initial = EShapeActionExpressions.ofString(value.initial);
            return _this;
        }
        EShapeActionRuntimeOpenDialogText.prototype.open = function (shape, target, initial, step, min, max) {
            var dialog = EShapeActionRuntimeOpenDialogText.DIALOG;
            if (dialog == null) {
                dialog = new DDialogInputText({
                    header: {
                        text: {
                            value: target
                        },
                        button: {
                            close: false
                        }
                    }
                });
                EShapeActionRuntimeOpenDialogText.DIALOG = dialog;
            }
            else {
                var header = dialog.header;
                if (header) {
                    header.text = target;
                }
            }
            dialog.value = initial;
            return dialog.open(shape);
        };
        return EShapeActionRuntimeOpenDialogText;
    }(EShapeActionRuntimeOpenDialog));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogFittedContent = /** @class */ (function (_super) {
        __extends(DDialogFittedContent, _super);
        function DDialogFittedContent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DDialogFittedContent.prototype.getType = function () {
            return "DDialogFittedContent";
        };
        return DDialogFittedContent;
    }(DDialogLayeredContent));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A dialog with a header, a content and a footer.
     * Unlike {@link DDialogLayered}, the width is determined by the content width.
     */
    var DDialogFitted = /** @class */ (function (_super) {
        __extends(DDialogFitted, _super);
        function DDialogFitted() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DDialogFitted.prototype.newLayoutOptions = function (theme, options) {
            return {
                width: "auto",
                height: "auto",
                margin: 0
            };
        };
        DDialogFitted.prototype.newContent = function () {
            return new DDialogFittedContent(this.toContentOptions(this.theme, this._options));
        };
        DDialogFitted.prototype.getType = function () {
            return "DDialogFitted";
        };
        return DDialogFitted;
    }(DDialogLayered));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPickerDatetimeButtonBack = /** @class */ (function (_super) {
        __extends(DPickerDatetimeButtonBack, _super);
        function DPickerDatetimeButtonBack() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DPickerDatetimeButtonBack.prototype.getType = function () {
            return "DPickerDatetimeButtonBack";
        };
        return DPickerDatetimeButtonBack;
    }(DButtonAmbient));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPickerDatetimeButtonDate = /** @class */ (function (_super) {
        __extends(DPickerDatetimeButtonDate, _super);
        function DPickerDatetimeButtonDate() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DPickerDatetimeButtonDate.prototype.getType = function () {
            return "DPickerDatetimeButtonDate";
        };
        return DPickerDatetimeButtonDate;
    }(DButtonAmbient));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPickerDatetimeButtonNext = /** @class */ (function (_super) {
        __extends(DPickerDatetimeButtonNext, _super);
        function DPickerDatetimeButtonNext() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DPickerDatetimeButtonNext.prototype.getType = function () {
            return "DPickerDatetimeButtonNext";
        };
        return DPickerDatetimeButtonNext;
    }(DButtonAmbient));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DText = /** @class */ (function (_super) {
        __extends(DText, _super);
        function DText() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DText.prototype.getType = function () {
            return "DText";
        };
        return DText;
    }(DTextBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPickerDatetimeLabel = /** @class */ (function (_super) {
        __extends(DPickerDatetimeLabel, _super);
        function DPickerDatetimeLabel() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DPickerDatetimeLabel.prototype.getType = function () {
            return "DPickerDatetimeLabel";
        };
        return DPickerDatetimeLabel;
    }(DText));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPickerDatetimeLabelDate = /** @class */ (function (_super) {
        __extends(DPickerDatetimeLabelDate, _super);
        function DPickerDatetimeLabelDate() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DPickerDatetimeLabelDate.prototype.getType = function () {
            return "DPickerDatetimeLabelDate";
        };
        return DPickerDatetimeLabelDate;
    }(DText));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPickerDatetimeSpace = /** @class */ (function (_super) {
        __extends(DPickerDatetimeSpace, _super);
        function DPickerDatetimeSpace(options) {
            var _this = _super.call(this, options) || this;
            _this.renderable = false;
            return _this;
        }
        DPickerDatetimeSpace.prototype.getType = function () {
            return "DPickerDatetimeSpace";
        };
        return DPickerDatetimeSpace;
    }(DBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DATE = 1;
    var HOURS = 2;
    var MINUTES = 4;
    var SECONDS = 8;
    var DPickerDatetimeMask = {
        NONE: 0,
        DATE: DATE,
        HOURS: HOURS,
        MINUTES: MINUTES,
        SECONDS: SECONDS,
        TIME: HOURS | MINUTES | SECONDS,
        ALL: DATE | HOURS | MINUTES | SECONDS
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPickerDatetimeMasks = /** @class */ (function () {
        function DPickerDatetimeMasks() {
        }
        DPickerDatetimeMasks.from = function (themeOrThemeName, options) {
            var mask = options === null || options === void 0 ? void 0 : options.mask;
            if (mask == null) {
                if (isString(themeOrThemeName)) {
                    var theme = DThemes.getInstance().get(themeOrThemeName);
                    if (theme != null) {
                        return theme.getMask();
                    }
                }
                else if (themeOrThemeName != null) {
                    return themeOrThemeName.getMask();
                }
                return DPickerDatetimeMask.NONE;
            }
            else if (isString(mask)) {
                return DPickerDatetimeMask[mask];
            }
            else if (isNumber(mask)) {
                return mask;
            }
            var result = DPickerDatetimeMask.NONE;
            for (var i = 0, imax = mask.length; i < imax; ++i) {
                result |= DPickerDatetimeMask[mask[i]];
            }
            return result;
        };
        return DPickerDatetimeMasks;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPickerTimeBound = /** @class */ (function () {
        function DPickerTimeBound(options, onChange) {
            var _a, _b;
            this._date = (_a = options === null || options === void 0 ? void 0 : options.date) !== null && _a !== void 0 ? _a : null;
            this._inclusive = (_b = options === null || options === void 0 ? void 0 : options.inclusive) !== null && _b !== void 0 ? _b : false;
            this._onChange = onChange;
        }
        Object.defineProperty(DPickerTimeBound.prototype, "date", {
            get: function () {
                return this._date;
            },
            set: function (date) {
                if (this._date !== date) {
                    this._date = date;
                    this._onChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DPickerTimeBound.prototype, "inclusive", {
            get: function () {
                return this._inclusive;
            },
            set: function (inclusive) {
                if (this._inclusive !== inclusive) {
                    this._inclusive = inclusive;
                    this._onChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        return DPickerTimeBound;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPickerTimeBoundHours = /** @class */ (function () {
        function DPickerTimeBoundHours(parent) {
            this._parent = parent;
        }
        DPickerTimeBoundHours.prototype.min = function (date) {
            var parent = this._parent;
            var lower = parent.lower;
            var lowerDate = lower.date;
            var constant = parent.constant;
            if (lowerDate != null) {
                var mask = parent.mask;
                if (mask & DPickerDatetimeMask.DATE) {
                    if (lowerDate.getFullYear() < date.getFullYear()) {
                        return constant.hour.min;
                    }
                    if (lowerDate.getMonth() < date.getMonth()) {
                        return constant.hour.min;
                    }
                    if (lowerDate.getDate() < date.getDate()) {
                        return constant.hour.min;
                    }
                }
                var lowerDateHours = lowerDate.getHours();
                if (lower.inclusive) {
                    return lowerDateHours;
                }
                else {
                    if (mask & DPickerDatetimeMask.SECONDS) {
                        if (lowerDate.getSeconds() < constant.second.max) {
                            return lowerDateHours;
                        }
                    }
                    if (mask & DPickerDatetimeMask.MINUTES) {
                        if (lowerDate.getMinutes() < constant.minute.max) {
                            return lowerDateHours;
                        }
                    }
                    return lowerDateHours + 1;
                }
            }
            return constant.hour.min;
        };
        DPickerTimeBoundHours.prototype.max = function (date) {
            var parent = this._parent;
            var upper = parent.upper;
            var upperDate = upper.date;
            var constant = parent.constant;
            if (upperDate != null) {
                var mask = parent.mask;
                if (mask & DPickerDatetimeMask.DATE) {
                    if (date.getFullYear() < upperDate.getFullYear()) {
                        return constant.hour.max;
                    }
                    if (date.getMonth() < upperDate.getMonth()) {
                        return constant.hour.max;
                    }
                    if (date.getDate() < upperDate.getDate()) {
                        return constant.hour.max;
                    }
                }
                var upperDateHours = upperDate.getHours();
                if (upper.inclusive) {
                    return upperDateHours;
                }
                else {
                    if (mask & DPickerDatetimeMask.SECONDS) {
                        if (constant.second.min < upperDate.getSeconds()) {
                            return upperDateHours;
                        }
                    }
                    if (mask & DPickerDatetimeMask.MINUTES) {
                        if (constant.minute.min < upperDate.getMinutes()) {
                            return upperDateHours;
                        }
                    }
                    return upperDateHours - 1;
                }
            }
            return constant.hour.max;
        };
        return DPickerTimeBoundHours;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPickerTimeBoundMinutes = /** @class */ (function () {
        function DPickerTimeBoundMinutes(parent) {
            this._parent = parent;
        }
        DPickerTimeBoundMinutes.prototype.min = function (date) {
            var parent = this._parent;
            var lower = parent.lower;
            var lowerDate = lower.date;
            var constant = parent.constant;
            if (lowerDate != null) {
                var mask = parent.mask;
                if (mask & DPickerDatetimeMask.DATE) {
                    if (lowerDate.getFullYear() < date.getFullYear()) {
                        return constant.minute.min;
                    }
                    if (lowerDate.getMonth() < date.getMonth()) {
                        return constant.minute.min;
                    }
                    if (lowerDate.getDate() < date.getDate()) {
                        return constant.minute.min;
                    }
                }
                if (mask & DPickerDatetimeMask.HOURS) {
                    if (lowerDate.getHours() < date.getHours()) {
                        return constant.minute.min;
                    }
                }
                var lowerDateMinutes = lowerDate.getMinutes();
                if (lower.inclusive) {
                    return lowerDateMinutes;
                }
                else {
                    if (mask & DPickerDatetimeMask.SECONDS) {
                        if (lowerDate.getSeconds() < constant.second.max) {
                            return lowerDateMinutes;
                        }
                    }
                    return lowerDateMinutes + 1;
                }
            }
            return constant.minute.min;
        };
        DPickerTimeBoundMinutes.prototype.max = function (date) {
            var parent = this._parent;
            var upper = parent.upper;
            var upperDate = upper.date;
            var constant = parent.constant;
            if (upperDate != null) {
                var mask = parent.mask;
                if (mask & DPickerDatetimeMask.DATE) {
                    if (date.getFullYear() < upperDate.getFullYear()) {
                        return constant.minute.max;
                    }
                    if (date.getMonth() < upperDate.getMonth()) {
                        return constant.minute.max;
                    }
                    if (date.getDate() < upperDate.getDate()) {
                        return constant.minute.max;
                    }
                }
                if (mask & DPickerDatetimeMask.HOURS) {
                    if (date.getHours() < upperDate.getHours()) {
                        return constant.minute.max;
                    }
                }
                var upperDateMinutes = upperDate.getMinutes();
                if (upper.inclusive) {
                    return upperDateMinutes;
                }
                else {
                    if (mask & DPickerDatetimeMask.SECONDS) {
                        if (constant.second.min < upperDate.getSeconds()) {
                            return upperDateMinutes;
                        }
                    }
                    return upperDateMinutes - 1;
                }
            }
            return constant.minute.max;
        };
        return DPickerTimeBoundMinutes;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPickerTimeBoundSeconds = /** @class */ (function () {
        function DPickerTimeBoundSeconds(parent) {
            this._parent = parent;
        }
        DPickerTimeBoundSeconds.prototype.min = function (date) {
            var parent = this._parent;
            var lower = parent.lower;
            var lowerDate = lower.date;
            var constant = parent.constant;
            if (lowerDate != null) {
                var mask = parent.mask;
                if (mask & DPickerDatetimeMask.DATE) {
                    if (lowerDate.getFullYear() < date.getFullYear()) {
                        return constant.second.min;
                    }
                    if (lowerDate.getMonth() < date.getMonth()) {
                        return constant.second.min;
                    }
                    if (lowerDate.getDate() < date.getDate()) {
                        return constant.second.min;
                    }
                }
                if (mask & DPickerDatetimeMask.HOURS) {
                    if (lowerDate.getHours() < date.getHours()) {
                        return constant.second.min;
                    }
                }
                if (mask & DPickerDatetimeMask.MINUTES) {
                    if (lowerDate.getMinutes() < date.getMinutes()) {
                        return constant.second.min;
                    }
                }
                return lowerDate.getSeconds() + (lower.inclusive ? 0 : 1);
            }
            return constant.second.min;
        };
        DPickerTimeBoundSeconds.prototype.max = function (date) {
            var parent = this._parent;
            var upper = parent.upper;
            var upperDate = upper.date;
            var constant = parent.constant;
            if (upperDate != null) {
                var mask = parent.mask;
                if (mask & DPickerDatetimeMask.DATE) {
                    if (date.getFullYear() < upperDate.getFullYear()) {
                        return constant.second.max;
                    }
                    if (date.getMonth() < upperDate.getMonth()) {
                        return constant.second.max;
                    }
                    if (date.getDate() < upperDate.getDate()) {
                        return constant.second.max;
                    }
                }
                if (mask & DPickerDatetimeMask.HOURS) {
                    if (date.getHours() < upperDate.getHours()) {
                        return constant.second.max;
                    }
                }
                if (mask & DPickerDatetimeMask.MINUTES) {
                    if (date.getMinutes() < upperDate.getMinutes()) {
                        return constant.second.max;
                    }
                }
                return upperDate.getSeconds() - (upper.inclusive ? 0 : 1);
            }
            return constant.second.max;
        };
        return DPickerTimeBoundSeconds;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPickerTimeBounds = /** @class */ (function () {
        function DPickerTimeBounds(options, onChange) {
            this.constant = this.newConstant();
            this.lower = new DPickerTimeBound(options && options.lower, onChange);
            this.upper = new DPickerTimeBound(options && options.upper, onChange);
            this.mask = DPickerDatetimeMask.ALL;
            this.hours = new DPickerTimeBoundHours(this);
            this.minutes = new DPickerTimeBoundMinutes(this);
            this.seconds = new DPickerTimeBoundSeconds(this);
        }
        DPickerTimeBounds.prototype.newConstant = function () {
            return {
                second: {
                    min: 0,
                    max: 59
                },
                minute: {
                    min: 0,
                    max: 59
                },
                hour: {
                    min: 0,
                    max: 23
                }
            };
        };
        DPickerTimeBounds.prototype.adjust = function (date) {
            var result = this.test(date);
            if (result < 0) {
                var lower = this.lower;
                var lowerDate = lower.date;
                if (lowerDate) {
                    date.setTime(lowerDate.getTime());
                    if (!lower.inclusive) {
                        var mask = this.mask;
                        if (mask & DPickerDatetimeMask.SECONDS) {
                            date.setSeconds(lowerDate.getSeconds() + 1);
                        }
                        else if (mask & DPickerDatetimeMask.MINUTES) {
                            date.setMinutes(lowerDate.getMinutes() + 1);
                        }
                        else if (mask & DPickerDatetimeMask.HOURS) {
                            date.setHours(lowerDate.getHours() + 1);
                        }
                        else if (mask & DPickerDatetimeMask.DATE) {
                            date.setDate(lowerDate.getDate() + 1);
                        }
                    }
                    return true;
                }
            }
            else if (0 < result) {
                var upper = this.upper;
                var upperDate = upper.date;
                if (upperDate) {
                    date.setTime(upperDate.getTime());
                    if (!upper.inclusive) {
                        var mask = this.mask;
                        if (mask & DPickerDatetimeMask.SECONDS) {
                            date.setSeconds(upperDate.getSeconds() - 1);
                        }
                        else if (mask & DPickerDatetimeMask.MINUTES) {
                            date.setMinutes(upperDate.getMinutes() - 1);
                        }
                        else if (mask & DPickerDatetimeMask.HOURS) {
                            date.setHours(upperDate.getHours() - 1);
                        }
                        else if (mask & DPickerDatetimeMask.DATE) {
                            date.setDate(upperDate.getDate() - 1);
                        }
                    }
                    return true;
                }
            }
            return false;
        };
        DPickerTimeBounds.prototype.compare = function (a, b) {
            var mask = this.mask;
            if (mask & DPickerDatetimeMask.DATE) {
                var ay = a.getFullYear();
                var by = b.getFullYear();
                if (ay !== by) {
                    return ay < by ? -1 : +1;
                }
                var am = a.getMonth();
                var bm = b.getMonth();
                if (am !== bm) {
                    return am < bm ? -1 : +1;
                }
                var ad = a.getDate();
                var bd = b.getDate();
                if (ad !== bd) {
                    return ad < bd ? -1 : +1;
                }
            }
            if (mask & DPickerDatetimeMask.HOURS) {
                var ah = a.getHours();
                var bh = b.getHours();
                if (ah !== bh) {
                    return ah < bh ? -1 : +1;
                }
            }
            if (mask & DPickerDatetimeMask.MINUTES) {
                var am = a.getMinutes();
                var bm = b.getMinutes();
                if (am !== bm) {
                    return am < bm ? -1 : +1;
                }
            }
            if (mask & DPickerDatetimeMask.SECONDS) {
                var ad = a.getSeconds();
                var bd = b.getSeconds();
                if (ad !== bd) {
                    return ad < bd ? -1 : +1;
                }
            }
            return 0;
        };
        DPickerTimeBounds.prototype.test = function (date) {
            // Lower bound
            var lower = this.lower;
            var lowerDate = lower.date;
            if (lowerDate != null) {
                var result = this.compare(lowerDate, date);
                if (lower.inclusive) {
                    return result <= 0 ? 0 : -1;
                }
                else {
                    return result < 0 ? 0 : -1;
                }
            }
            // Upper bound
            var upper = this.upper;
            var upperDate = upper.date;
            if (upperDate != null) {
                var result = this.compare(date, upperDate);
                if (upper.inclusive) {
                    return result <= 0 ? 0 : +1;
                }
                else {
                    return result < 0 ? 0 : +1;
                }
            }
            return 0;
        };
        DPickerTimeBounds.prototype.contains = function (date) {
            return this.test(date) === 0;
        };
        return DPickerTimeBounds;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var toBoundOptions = function (options, defaultDate, defaultInclusive) {
        if (options) {
            var date = options.date;
            var inclusive = options.inclusive;
            return {
                date: date !== undefined ? date : defaultDate,
                inclusive: inclusive !== undefined ? inclusive : defaultInclusive
            };
        }
        return {
            date: defaultDate,
            inclusive: defaultInclusive
        };
    };
    var toBoundsOptions = function (theme, options) {
        if (options) {
            return {
                lower: toBoundOptions(options.lower, theme.getLowerBound(), theme.isLowerBoundInclusive()),
                upper: toBoundOptions(options.upper, theme.getUpperBound(), theme.isUpperBoundInclusive())
            };
        }
        return {
            lower: {
                date: theme.getLowerBound(),
                inclusive: theme.isLowerBoundInclusive()
            },
            upper: {
                date: theme.getUpperBound(),
                inclusive: theme.isUpperBoundInclusive()
            }
        };
    };
    var DPickerTime = /** @class */ (function (_super) {
        __extends(DPickerTime, _super);
        function DPickerTime(options) {
            var _this = _super.call(this, options) || this;
            _this.onNewChange();
            return _this;
        }
        DPickerTime.prototype.init = function (options) {
            var _this = this;
            var _a;
            _super.prototype.init.call(this, options);
            var theme = this.theme;
            this._dateCurrent = new Date();
            var dateCurrentTime = this._dateCurrent.getTime();
            this._dateNew = new Date(dateCurrentTime);
            this._dateBounds = new DPickerTimeBounds(toBoundsOptions(theme, options === null || options === void 0 ? void 0 : options.bounds), function () {
                _this.onNewChange();
            });
            var margin = (_a = options === null || options === void 0 ? void 0 : options.margin) !== null && _a !== void 0 ? _a : theme.getMargin();
            new DLayoutVertical({
                parent: this,
                x: "padding",
                y: "padding",
                width: "auto",
                height: "auto",
                margin: margin,
                children: this.newChildren(theme, options, margin)
            });
        };
        Object.defineProperty(DPickerTime.prototype, "current", {
            get: function () {
                return this._dateCurrent;
            },
            set: function (dateCurrent) {
                if (this._dateCurrent.getTime() !== dateCurrent.getTime()) {
                    this._dateCurrent = dateCurrent;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DPickerTime.prototype, "new", {
            get: function () {
                return this._dateNew;
            },
            set: function (dateNew) {
                if (this._dateNew.getTime() !== dateNew.getTime()) {
                    this._dateNew = dateNew;
                    this.onNewChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DPickerTime.prototype, "bounds", {
            get: function () {
                return this._dateBounds;
            },
            enumerable: false,
            configurable: true
        });
        DPickerTime.prototype.hasHours = function () {
            return this._inputHours != null;
        };
        DPickerTime.prototype.hasMinutes = function () {
            return this._inputMinutes != null;
        };
        DPickerTime.prototype.hasSeconds = function () {
            return this._inputSeconds != null;
        };
        DPickerTime.prototype.reset = function () {
            var currentTime = this._dateCurrent.getTime();
            this._dateNew.setTime(currentTime);
            this.onReset();
        };
        DPickerTime.prototype.onReset = function () {
            this.onNewChange();
        };
        DPickerTime.prototype.onNewChange = function () {
            var dateNew = this._dateNew;
            var dateBounds = this._dateBounds;
            dateBounds.adjust(this._dateNew);
            var inputHours = this._inputHours;
            if (inputHours) {
                var hours = dateBounds.hours;
                inputHours.value = dateNew.getHours();
                inputHours.min = hours.min(dateNew);
                inputHours.max = hours.max(dateNew);
            }
            var inputMinutes = this._inputMinutes;
            if (inputMinutes) {
                var minutes = dateBounds.minutes;
                inputMinutes.value = dateNew.getMinutes();
                inputMinutes.min = minutes.min(dateNew);
                inputMinutes.max = minutes.max(dateNew);
            }
            var inputSeconds = this._inputSeconds;
            if (inputSeconds) {
                var seconds = dateBounds.seconds;
                inputSeconds.value = dateNew.getSeconds();
                inputSeconds.min = seconds.min(dateNew);
                inputSeconds.max = seconds.max(dateNew);
            }
        };
        DPickerTime.prototype.newChildren = function (theme, options, margin) {
            var mask = DPickerDatetimeMasks.from(theme, options);
            this._dateBounds.mask = mask;
            this._inputHours =
                mask & DPickerDatetimeMask.HOURS ? this.newInputHours(theme, options) : null;
            this._inputMinutes =
                mask & DPickerDatetimeMask.MINUTES ? this.newInputMinutes(theme, options) : null;
            this._inputSeconds =
                mask & DPickerDatetimeMask.SECONDS ? this.newInputSeconds(theme, options) : null;
            return [
                this.newTimeLayout(this._inputHours, this._inputMinutes, this._inputSeconds, margin)
            ];
        };
        DPickerTime.prototype.newTimeLayout = function (hours, minutes, seconds, margin) {
            var children = this.newTimeLayoutChildren(hours, minutes, seconds);
            if (0 < children.length) {
                return new DLayoutHorizontal({
                    width: this.getTimeLayoutWidth(),
                    height: this.getTimeLayoutHeight(),
                    margin: margin,
                    children: children
                });
            }
            return null;
        };
        DPickerTime.prototype.getTimeLayoutWidth = function () {
            return "auto";
        };
        DPickerTime.prototype.getTimeLayoutHeight = function () {
            return "auto";
        };
        DPickerTime.prototype.newTimeLayoutChildren = function (hours, minutes, seconds) {
            var result = [];
            if (hours != null) {
                result.push(hours);
            }
            if (minutes != null) {
                if (0 < result.length) {
                    result.push(this.newMinuteSeparator());
                }
                result.push(minutes);
            }
            if (seconds != null) {
                if (0 < result.length) {
                    result.push(this.newSecondSeparator());
                }
                result.push(seconds);
            }
            return result;
        };
        DPickerTime.prototype.newMinuteSeparator = function () {
            return new DText({
                width: "auto",
                text: {
                    value: this.getMinuteSeparator()
                }
            });
        };
        DPickerTime.prototype.getMinuteSeparator = function () {
            return ":";
        };
        DPickerTime.prototype.newSecondSeparator = function () {
            return new DText({
                width: "auto",
                text: {
                    value: this.getSecondSeparator()
                }
            });
        };
        DPickerTime.prototype.getSecondSeparator = function () {
            return ":";
        };
        DPickerTime.prototype.adjustInputOptions = function (theme, options, max) {
            if (options.step == null) {
                options.step = 1;
            }
            if (options.min == null) {
                options.min = 0;
            }
            if (options.max == null) {
                options.max = max;
            }
            return options;
        };
        DPickerTime.prototype.newInputHours = function (theme, options) {
            var _this = this;
            var _a;
            var inputOptions = (_a = options === null || options === void 0 ? void 0 : options.hours) !== null && _a !== void 0 ? _a : theme.getHoursOptions();
            var max = this._dateBounds.constant.hour.max;
            var input = new DInputInteger(this.adjustInputOptions(theme, inputOptions, max));
            input.on("change", function (value) {
                _this.onHoursChange(value);
            });
            return input;
        };
        DPickerTime.prototype.onHoursChange = function (value) {
            var dateNew = this._dateNew;
            dateNew.setHours(value);
            this.onNewChange();
        };
        DPickerTime.prototype.newInputMinutes = function (theme, options) {
            var _this = this;
            var inputOptions = (options === null || options === void 0 ? void 0 : options.minutes) || theme.getMinutesOptions();
            var max = this._dateBounds.constant.minute.max;
            var input = new DInputInteger(this.adjustInputOptions(theme, inputOptions, max));
            input.on("change", function (value) {
                _this.onMinutesChange(value);
            });
            return input;
        };
        DPickerTime.prototype.onMinutesChange = function (value) {
            var dateNew = this._dateNew;
            dateNew.setMinutes(value);
            this.onNewChange();
        };
        DPickerTime.prototype.newInputSeconds = function (theme, options) {
            var _this = this;
            var inputOptions = (options === null || options === void 0 ? void 0 : options.seconds) || theme.getSecondsOptions();
            var max = this._dateBounds.constant.second.max;
            var input = new DInputInteger(this.adjustInputOptions(theme, inputOptions, max));
            input.on("change", function (value) {
                _this.onSecondsChange(value);
            });
            return input;
        };
        DPickerTime.prototype.onSecondsChange = function (value) {
            this._dateNew.setSeconds(value);
        };
        DPickerTime.prototype.getType = function () {
            return "DPickerTime";
        };
        return DPickerTime;
    }(DBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPickerDatetime = /** @class */ (function (_super) {
        __extends(DPickerDatetime, _super);
        function DPickerDatetime() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DPickerDatetime.prototype.init = function (options) {
            _super.prototype.init.call(this, options);
            this._datePage = new Date(this._dateCurrent.getTime());
        };
        DPickerDatetime.prototype.newChildren = function (theme, options, margin) {
            var _a, _b;
            this._dateButtons = this.newDateButtons(theme, options);
            this._dateDecorator = (_b = (_a = options === null || options === void 0 ? void 0 : options.date) === null || _a === void 0 ? void 0 : _a.decorator) !== null && _b !== void 0 ? _b : theme.getDateDecorator();
            this._label = this.newLabel(theme, options);
            var result = _super.prototype.newChildren.call(this, theme, options, margin);
            result.unshift(new DLayoutHorizontal({
                width: "100%",
                height: "auto",
                children: [
                    this.newBackButton(theme, options),
                    this._label,
                    this.newNextButton(theme, options)
                ]
            }), new DLayoutHorizontal({
                width: "auto",
                height: "auto",
                margin: margin,
                children: this.newDateLabels(theme, options)
            }), new DLayoutVertical({
                width: "auto",
                height: "auto",
                margin: margin,
                column: 7,
                children: this._dateButtons
            }));
            return result;
        };
        Object.defineProperty(DPickerDatetime.prototype, "page", {
            get: function () {
                return this._datePage;
            },
            set: function (datePage) {
                if (this._datePage.getTime() !== datePage.getTime()) {
                    this._datePage = datePage;
                    this.onPageChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        DPickerDatetime.prototype.onReset = function () {
            this._datePage.setTime(this._dateCurrent.getTime());
            _super.prototype.onReset.call(this);
        };
        DPickerDatetime.prototype.next = function () {
            var work = this._datePage;
            work.setFullYear(work.getFullYear(), work.getMonth() + 1, 1);
            work.setHours(0, 0, 0, 0);
            this.onPageChange();
        };
        DPickerDatetime.prototype.back = function () {
            var work = this._datePage;
            work.setFullYear(work.getFullYear(), work.getMonth() - 1, 1);
            work.setHours(0, 0, 0, 0);
            this.onPageChange();
        };
        DPickerDatetime.prototype.onNewChange = function () {
            this._dateBounds.adjust(this._datePage);
            _super.prototype.onNewChange.call(this);
            this.onPageChange();
        };
        DPickerDatetime.prototype.onPageChange = function () {
            var buttons = this._dateButtons;
            var bounds = this._dateBounds;
            var datePage = this._datePage;
            var dateNew = this._dateNew;
            var tmp = new Date(datePage.getTime());
            tmp.setDate(1);
            tmp.setHours(0, 0, 0, 0);
            // Spaces
            var theme = this.theme;
            var spaceCount = (tmp.getDay() - theme.getDayStart() + 7) % 7;
            for (var i = 0; i < spaceCount; ++i) {
                buttons[i].show();
            }
            for (var i = spaceCount; i < 7; ++i) {
                buttons[i].hide();
            }
            // Date buttons
            var dateDecorator = this._dateDecorator;
            tmp.setFullYear(tmp.getFullYear(), tmp.getMonth() + 1, 0);
            var dateCount = tmp.getDate();
            var dateNewDate = dateNew.getFullYear() === tmp.getFullYear() && dateNew.getMonth() === tmp.getMonth()
                ? dateNew.getDate()
                : 0;
            for (var i = 0; i < dateCount; ++i) {
                tmp.setDate(i + 1);
                var button = buttons[i + 7];
                button.state.isActive = dateNewDate === i + 1;
                button.state.isDisabled = !bounds.contains(tmp);
                button.show();
                dateDecorator(tmp, button);
            }
            for (var i = dateCount; i < 31; ++i) {
                var button = buttons[i + 7];
                button.state.isActive = false;
                button.hide();
            }
            // Label
            tmp.setTime(datePage.getTime());
            this._label.text = tmp;
        };
        DPickerDatetime.prototype.adjustInputOptions = function (theme, options, max) {
            if (options.weight == null) {
                options.weight = 1;
            }
            return _super.prototype.adjustInputOptions.call(this, theme, options, max);
        };
        DPickerDatetime.prototype.getTimeLayoutWidth = function () {
            return "100%";
        };
        DPickerDatetime.prototype.toLabelOptions = function (theme, options) {
            var result = (options && options.label) || {};
            if (result.weight === undefined) {
                result.weight = 1;
            }
            if (result.padding === undefined) {
                result.padding = 0;
            }
            var labelText = (result.text = result.text || {});
            var labelTextAlign = (labelText.align = labelText.align || {});
            if (labelTextAlign.horizontal === undefined) {
                labelTextAlign.horizontal = "CENTER";
            }
            if (labelText.formatter === undefined) {
                labelText.formatter = theme.getLabelFormatter();
            }
            return result;
        };
        DPickerDatetime.prototype.newLabel = function (theme, options) {
            return new DPickerDatetimeLabel(this.toLabelOptions(theme, options));
        };
        DPickerDatetime.prototype.newBackButton = function (theme, options) {
            var _this = this;
            var buttonOptions = options === null || options === void 0 ? void 0 : options.back;
            if (buttonOptions === undefined) {
                buttonOptions = theme.getBackButtonOptions();
            }
            if (buttonOptions != null) {
                var button = new DPickerDatetimeButtonBack(buttonOptions);
                button.on("active", function () {
                    _this.back();
                });
                return button;
            }
            return null;
        };
        DPickerDatetime.prototype.newNextButton = function (theme, options) {
            var _this = this;
            var buttonOptions = options === null || options === void 0 ? void 0 : options.next;
            if (buttonOptions === undefined) {
                buttonOptions = theme.getNextButtonOptions();
            }
            if (buttonOptions != null) {
                var button = new DPickerDatetimeButtonNext(buttonOptions);
                button.on("active", function () {
                    _this.next();
                });
                return button;
            }
            return null;
        };
        DPickerDatetime.prototype.newDateLabels = function (theme, options) {
            var dateLabels = theme.getDayLabels();
            var dayStart = theme.getDayStart();
            var result = [];
            for (var i = 0; i < 7; ++i) {
                var label = dateLabels[(dayStart + i) % 7];
                result.push(this.newDateLabel(theme, options, label));
            }
            return result;
        };
        DPickerDatetime.prototype.newDateLabel = function (theme, options, label) {
            return new DPickerDatetimeLabelDate({
                text: {
                    value: label
                }
            });
        };
        DPickerDatetime.prototype.newDateButtons = function (theme, options) {
            var result = [];
            for (var i = 0; i < 7; ++i) {
                result.push(this.newSpace(theme, options));
            }
            for (var i = 1; i <= 31; ++i) {
                result.push(this.newDateButton(theme, options, i));
            }
            return result;
        };
        DPickerDatetime.prototype.newSpace = function (theme, options) {
            return new DPickerDatetimeSpace();
        };
        DPickerDatetime.prototype.newDateButton = function (theme, options, date) {
            var _this = this;
            return new DPickerDatetimeButtonDate({
                text: {
                    value: String(date)
                },
                on: {
                    active: function () {
                        _this.onDateButtonClicked(date);
                    }
                }
            });
        };
        DPickerDatetime.prototype.onDateButtonClicked = function (date) {
            var dateNew = this._dateNew;
            if (dateNew.getDate() !== date) {
                var datePage = this._datePage;
                dateNew.setFullYear(datePage.getFullYear());
                dateNew.setMonth(datePage.getMonth());
                dateNew.setDate(date);
                this.onNewChange();
            }
        };
        DPickerDatetime.prototype.getType = function () {
            return "DPickerDatetime";
        };
        return DPickerDatetime;
    }(DPickerTime));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogDatetime = /** @class */ (function (_super) {
        __extends(DDialogDatetime, _super);
        function DDialogDatetime() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DDialogDatetime.prototype.newContentChildren = function (theme, options) {
            var result = _super.prototype.newContentChildren.call(this, theme, options);
            result.push(this.picker);
            return result;
        };
        Object.defineProperty(DDialogDatetime.prototype, "current", {
            get: function () {
                return this.picker.current;
            },
            set: function (dateCurrent) {
                this.picker.current = dateCurrent;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDialogDatetime.prototype, "new", {
            get: function () {
                return this.picker.new;
            },
            set: function (value) {
                this.picker.new = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDialogDatetime.prototype, "page", {
            get: function () {
                return this.picker.new;
            },
            set: function (page) {
                this.picker.page = page;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDialogDatetime.prototype, "picker", {
            get: function () {
                var _a;
                var result = this._picker;
                if (result == null) {
                    result = new DPickerDatetime((_a = this._options) === null || _a === void 0 ? void 0 : _a.picker);
                    this._picker = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DDialogDatetime.prototype.getResolvedValue = function () {
            return this.picker.new;
        };
        DDialogDatetime.prototype.getType = function () {
            return "DDialogDatetime";
        };
        return DDialogDatetime;
    }(DDialogFitted));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeOpenDialogDatetime = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeOpenDialogDatetime, _super);
        function EShapeActionRuntimeOpenDialogDatetime(value) {
            var _this = _super.call(this, value) || this;
            _this.initial = EShapeActionExpressions.ofUnknown(value.initial);
            return _this;
        }
        EShapeActionRuntimeOpenDialogDatetime.prototype.open = function (shape, target, initial, step, min, max) {
            var dialog = EShapeActionRuntimeOpenDialogDatetime.DIALOG;
            if (dialog == null) {
                dialog = new DDialogDatetime();
                EShapeActionRuntimeOpenDialogDatetime.DIALOG = dialog;
            }
            dialog.new = dialog.current = this.toDate(initial);
            return dialog.open(shape).then(function (value) {
                return value.toISOString();
            });
        };
        EShapeActionRuntimeOpenDialogDatetime.prototype.toDate = function (value) {
            if (isString(value) || isNumber(value)) {
                return new Date(value);
            }
            else if (value instanceof Date) {
                return value;
            }
            else {
                return new Date();
            }
        };
        return EShapeActionRuntimeOpenDialogDatetime;
    }(EShapeActionRuntimeOpenDialog));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogTime = /** @class */ (function (_super) {
        __extends(DDialogTime, _super);
        function DDialogTime() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DDialogTime.prototype.newContentChildren = function (theme, options) {
            var result = _super.prototype.newContentChildren.call(this, theme, options);
            result.push(this.picker);
            return result;
        };
        Object.defineProperty(DDialogTime.prototype, "current", {
            get: function () {
                return this.picker.current;
            },
            set: function (dateCurrent) {
                this.picker.current = dateCurrent;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDialogTime.prototype, "new", {
            get: function () {
                return this.picker.new;
            },
            set: function (dateNew) {
                this.picker.new = dateNew;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDialogTime.prototype, "picker", {
            get: function () {
                var _a;
                var result = this._picker;
                if (result == null) {
                    result = new DPickerTime((_a = this._options) === null || _a === void 0 ? void 0 : _a.picker);
                    this._picker = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DDialogTime.prototype.getResolvedValue = function () {
            return this.picker.new;
        };
        DDialogTime.prototype.getType = function () {
            return "DDialogTime";
        };
        return DDialogTime;
    }(DDialogFitted));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var isNaN$1 = function (target) {
        return target !== target;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeOpenDialogTime = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeOpenDialogTime, _super);
        function EShapeActionRuntimeOpenDialogTime(value) {
            var _this = _super.call(this, value) || this;
            _this.initial = EShapeActionExpressions.ofUnknown(value.initial);
            return _this;
        }
        EShapeActionRuntimeOpenDialogTime.prototype.open = function (shape, target, initial, step, min, max) {
            var _this = this;
            var dialog = EShapeActionRuntimeOpenDialogTime.DIALOG;
            if (dialog == null) {
                dialog = new DDialogTime();
                EShapeActionRuntimeOpenDialogTime.DIALOG = dialog;
            }
            dialog.new = dialog.current = this.toDate(initial);
            return dialog.open(shape).then(function (value) {
                return _this.getFormatter().format(value.getTime(), 0);
            });
        };
        EShapeActionRuntimeOpenDialogTime.prototype.toDate = function (value) {
            if (isNumber(value)) {
                return new Date(value);
            }
            else if (isString(value)) {
                var result = new Date();
                var pattern = this.getPattern();
                var matched = pattern.exec(value);
                if (matched != null) {
                    var hours = this.toHours(matched[1]);
                    if (hours != null) {
                        result.setHours(hours);
                    }
                    var minutes = this.toMinutes(matched[2]);
                    if (minutes != null) {
                        result.setMinutes(minutes);
                    }
                    var seconds = this.toSeconds(matched[3]);
                    if (seconds != null) {
                        result.setSeconds(seconds);
                    }
                    var milliseconds = this.toMilliseconds(matched[4]);
                    if (milliseconds != null) {
                        result.setMilliseconds(milliseconds);
                    }
                }
                return result;
            }
            else if (value instanceof Date) {
                return value;
            }
            else {
                return new Date();
            }
        };
        EShapeActionRuntimeOpenDialogTime.prototype.toHours = function (value) {
            return this.toNumber(value, 0, 23);
        };
        EShapeActionRuntimeOpenDialogTime.prototype.toMinutes = function (value) {
            return this.toNumber(value, 0, 59);
        };
        EShapeActionRuntimeOpenDialogTime.prototype.toSeconds = function (value) {
            return this.toNumber(value, 0, 59);
        };
        EShapeActionRuntimeOpenDialogTime.prototype.toMilliseconds = function (value) {
            var result = this.toNumber(value, 0, 999);
            if (result != null) {
                var length_1 = value.length;
                if (length_1 === 1) {
                    return result * 100;
                }
                else if (length_1 === 2) {
                    return result * 10;
                }
                else {
                    return result;
                }
            }
            return result;
        };
        EShapeActionRuntimeOpenDialogTime.prototype.toNumber = function (value, min, max) {
            if (value != null) {
                var num = +value;
                if (!isNaN$1(num)) {
                    return Math.min(max, Math.max(min, num));
                }
            }
            return null;
        };
        EShapeActionRuntimeOpenDialogTime.prototype.getPattern = function () {
            var result = EShapeActionRuntimeOpenDialogTime.PATTERN;
            if (result == null) {
                result = this.newPattern();
                EShapeActionRuntimeOpenDialogTime.PATTERN = result;
            }
            return result;
        };
        EShapeActionRuntimeOpenDialogTime.prototype.newPattern = function () {
            return /^\s*(?:(\d+)(?::(\d+)(?::(\d+))?)?)?(?:\.(\d+))?\s*$/;
        };
        EShapeActionRuntimeOpenDialogTime.prototype.getFormatter = function () {
            var result = EShapeActionRuntimeOpenDialogTime.FORMATTER;
            if (result == null) {
                result = this.newFormatter();
                EShapeActionRuntimeOpenDialogTime.FORMATTER = result;
            }
            return result;
        };
        EShapeActionRuntimeOpenDialogTime.prototype.newFormatter = function () {
            return NumberFormatters.create("%Hm");
        };
        return EShapeActionRuntimeOpenDialogTime;
    }(EShapeActionRuntimeOpenDialog));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPickerDate = /** @class */ (function (_super) {
        __extends(DPickerDate, _super);
        function DPickerDate() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DPickerDate.prototype.getType = function () {
            return "DPickerDate";
        };
        return DPickerDate;
    }(DPickerDatetime));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogDate = /** @class */ (function (_super) {
        __extends(DDialogDate, _super);
        function DDialogDate() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DDialogDate.prototype.newContentChildren = function (theme, options) {
            var result = _super.prototype.newContentChildren.call(this, theme, options);
            result.push(this.picker);
            return result;
        };
        Object.defineProperty(DDialogDate.prototype, "current", {
            get: function () {
                return this.picker.current;
            },
            set: function (dateCurrent) {
                this.picker.current = dateCurrent;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDialogDate.prototype, "new", {
            get: function () {
                return this.picker.new;
            },
            set: function (value) {
                this.picker.new = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDialogDate.prototype, "page", {
            get: function () {
                return this.picker.new;
            },
            set: function (page) {
                this.picker.page = page;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDialogDate.prototype, "picker", {
            get: function () {
                var _a;
                var result = this._picker;
                if (result == null) {
                    result = new DPickerDate((_a = this._options) === null || _a === void 0 ? void 0 : _a.picker);
                    this._picker = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DDialogDate.prototype.getResolvedValue = function () {
            return this.picker.new;
        };
        DDialogDate.prototype.getType = function () {
            return "DDialogDate";
        };
        return DDialogDate;
    }(DDialogFitted));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeOpenDialogDate = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeOpenDialogDate, _super);
        function EShapeActionRuntimeOpenDialogDate(value) {
            var _this = _super.call(this, value) || this;
            _this.initial = EShapeActionExpressions.ofUnknown(value.initial);
            return _this;
        }
        EShapeActionRuntimeOpenDialogDate.prototype.open = function (shape, target, initial, step, min, max) {
            var _this = this;
            var dialog = EShapeActionRuntimeOpenDialogDate.DIALOG;
            if (dialog == null) {
                dialog = new DDialogDate();
                EShapeActionRuntimeOpenDialogDate.DIALOG = dialog;
            }
            dialog.new = dialog.current = this.toDate(initial);
            return dialog.open(shape).then(function (value) {
                return _this.getFormatter().format(value.getTime(), 0);
            });
        };
        EShapeActionRuntimeOpenDialogDate.prototype.toDate = function (value) {
            if (isString(value) || isNumber(value)) {
                return new Date(value);
            }
            else if (value instanceof Date) {
                return value;
            }
            else {
                return new Date();
            }
        };
        EShapeActionRuntimeOpenDialogDate.prototype.getFormatter = function () {
            var result = EShapeActionRuntimeOpenDialogDate.FORMATTER;
            if (result == null) {
                result = this.newFormatter();
                EShapeActionRuntimeOpenDialogDate.FORMATTER = result;
            }
            return result;
        };
        EShapeActionRuntimeOpenDialogDate.prototype.newFormatter = function () {
            return NumberFormatters.create("%Y-%M-%D");
        };
        return EShapeActionRuntimeOpenDialogDate;
    }(EShapeActionRuntimeOpenDialog));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueOpenDialogType = {
        TEXT: 0,
        INTEGER: 1,
        REAL: 2,
        BOOLEAN: 3,
        DATE: 4,
        TIME: 5,
        DATETIME: 6,
        EXTENSION: 1000
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueOpenDialog = /** @class */ (function (_super) {
        __extends(EShapeActionValueOpenDialog, _super);
        function EShapeActionValueOpenDialog(condition, target, onInputAction, initial, step, min, max, dialogType) {
            var _this = _super.call(this, EShapeActionValueType.OPEN, condition, EShapeActionValueOpenType.DIALOG) || this;
            _this.target = target;
            _this.onInputAction = onInputAction;
            _this.initial = initial;
            _this.step = step;
            _this.min = min;
            _this.max = max;
            _this.dialogType = dialogType;
            return _this;
        }
        EShapeActionValueOpenDialog.prototype.isEquals = function (value) {
            return (_super.prototype.isEquals.call(this, value) &&
                value instanceof EShapeActionValueOpenDialog &&
                this.target === value.target &&
                this.dialogType === value.dialogType &&
                this.onInputAction === value.onInputAction &&
                this.initial === value.initial &&
                this.step === value.step &&
                this.min === value.min &&
                this.max === value.max);
        };
        EShapeActionValueOpenDialog.prototype.toRuntime = function () {
            switch (this.dialogType) {
                case EShapeActionValueOpenDialogType.TEXT:
                    return new EShapeActionRuntimeOpenDialogText(this);
                case EShapeActionValueOpenDialogType.INTEGER:
                    return new EShapeActionRuntimeOpenDialogInteger(this);
                case EShapeActionValueOpenDialogType.REAL:
                    return new EShapeActionRuntimeOpenDialogReal(this);
                case EShapeActionValueOpenDialogType.BOOLEAN:
                    return new EShapeActionRuntimeOpenDialogBoolean(this);
                case EShapeActionValueOpenDialogType.DATE:
                    return new EShapeActionRuntimeOpenDialogDate(this);
                case EShapeActionValueOpenDialogType.TIME:
                    return new EShapeActionRuntimeOpenDialogTime(this);
                case EShapeActionValueOpenDialogType.DATETIME:
                    return new EShapeActionRuntimeOpenDialogDatetime(this);
            }
        };
        EShapeActionValueOpenDialog.prototype.serialize = function (manager) {
            var conditionId = manager.addResource(this.condition);
            var targetId = manager.addResource(this.target);
            var initialId = manager.addResource(this.initial);
            var stepId = manager.addResource(this.step);
            var minId = manager.addResource(this.min);
            var maxId = manager.addResource(this.max);
            return manager.addResource("[".concat(this.type, ",").concat(conditionId, ",").concat(this.subtype, ",").concat(targetId, ",").concat(this.onInputAction, ",").concat(initialId, ",").concat(this.dialogType, ",").concat(stepId, ",").concat(minId, ",").concat(maxId, "]"));
        };
        EShapeActionValueOpenDialog.deserialize = function (serialized, manager) {
            var resources = manager.resources;
            var condition = EShapeActionValues.toResource(1, serialized, resources);
            var target = EShapeActionValues.toResource(3, serialized, resources);
            var initial = EShapeActionValues.toResource(5, serialized, resources);
            var step = EShapeActionValues.toResource(7, serialized, resources);
            var min = EShapeActionValues.toResource(8, serialized, resources);
            var max = EShapeActionValues.toResource(9, serialized, resources);
            return new EShapeActionValueOpenDialog(condition, target, serialized[4], initial, step, min, max, this.toDialogType(serialized));
        };
        EShapeActionValueOpenDialog.toDialogType = function (serialized) {
            if (serialized[2] === EShapeActionValueOpenType.DIALOG) {
                return serialized[6];
            }
            else {
                switch (serialized[2]) {
                    case EShapeActionValueOpenType.DIALOG_TEXT:
                        return EShapeActionValueOpenDialogType.TEXT;
                    case EShapeActionValueOpenType.DIALOG_INTEGER:
                        return EShapeActionValueOpenDialogType.INTEGER;
                    case EShapeActionValueOpenType.DIALOG_REAL:
                        return EShapeActionValueOpenDialogType.REAL;
                    case EShapeActionValueOpenType.DIALOG_BOOLEAN:
                        return EShapeActionValueOpenDialogType.BOOLEAN;
                    case EShapeActionValueOpenType.DIALOG_DATE:
                        return EShapeActionValueOpenDialogType.DATE;
                    case EShapeActionValueOpenType.DIALOG_TIME:
                        return EShapeActionValueOpenDialogType.TIME;
                    case EShapeActionValueOpenType.DIALOG_DATETIME:
                        return EShapeActionValueOpenDialogType.DATETIME;
                }
            }
        };
        return EShapeActionValueOpenDialog;
    }(EShapeActionValueSubtyped));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionOpenDialogExtensions = /** @class */ (function () {
        function EShapeActionOpenDialogExtensions() {
        }
        EShapeActionOpenDialogExtensions.add = function (extension) {
            var _a, _b;
            ((_a = this._typeToDatum) !== null && _a !== void 0 ? _a : (this._typeToDatum = new Map())).set(extension.type, extension);
            ((_b = this._data) !== null && _b !== void 0 ? _b : (this._data = [])).push(extension);
        };
        EShapeActionOpenDialogExtensions.get = function (type) {
            var typeToDatum = this._typeToDatum;
            if (typeToDatum != null) {
                return typeToDatum.get(type);
            }
        };
        EShapeActionOpenDialogExtensions.each = function (iteratee) {
            var data = this._data;
            if (data != null) {
                for (var i = 0, imax = data.length; i < imax; ++i) {
                    iteratee(data[i]);
                }
            }
        };
        return EShapeActionOpenDialogExtensions;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeOpenDialogExtension = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeOpenDialogExtension, _super);
        function EShapeActionRuntimeOpenDialogExtension(value) {
            var _this = _super.call(this, value, EShapeRuntimeReset.NONE) || this;
            _this.target = EShapeActionExpressions.ofStringOrNull(value.target);
            _this.argument = EShapeActionExpressions.ofUnknown(value.argument);
            var extension = EShapeActionOpenDialogExtensions.get(value.dialogType);
            if (extension) {
                _this.opener = extension.opener;
            }
            return _this;
        }
        EShapeActionRuntimeOpenDialogExtension.prototype.execute = function (shape, runtime, time) {
            var opener = this.opener;
            if (opener) {
                if (this.condition(shape, time, EShapeActionEnvironment)) {
                    var target_1 = this.target(shape, time, EShapeActionEnvironment);
                    if (target_1 != null) {
                        var diagram_1 = EShapeActions.toDiagram(shape);
                        if (diagram_1 != null) {
                            var argument_1 = this.argument(shape, time, EShapeActionEnvironment);
                            setTimeout(function () {
                                opener(target_1, argument_1, shape, diagram_1, EShapeActionEnvironment);
                            }, 0);
                        }
                    }
                }
            }
        };
        return EShapeActionRuntimeOpenDialogExtension;
    }(EShapeActionRuntimeConditional));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueOpenDialogExtension = /** @class */ (function (_super) {
        __extends(EShapeActionValueOpenDialogExtension, _super);
        function EShapeActionValueOpenDialogExtension(condition, target, argument, dialogType) {
            var _this = _super.call(this, EShapeActionValueType.OPEN, condition, EShapeActionValueOpenType.DIALOG) || this;
            _this.target = target;
            _this.argument = argument;
            _this.dialogType = dialogType;
            return _this;
        }
        EShapeActionValueOpenDialogExtension.prototype.isEquals = function (value) {
            return (_super.prototype.isEquals.call(this, value) &&
                value instanceof EShapeActionValueOpenDialogExtension &&
                this.target === value.target &&
                this.argument === value.argument &&
                this.dialogType === value.dialogType);
        };
        EShapeActionValueOpenDialogExtension.prototype.toRuntime = function () {
            return new EShapeActionRuntimeOpenDialogExtension(this);
        };
        EShapeActionValueOpenDialogExtension.prototype.serialize = function (manager) {
            var conditionId = manager.addResource(this.condition);
            var targetId = manager.addResource(this.target);
            var argumentId = manager.addResource(this.argument);
            return manager.addResource("[".concat(this.type, ",").concat(conditionId, ",").concat(this.subtype, ",").concat(targetId, ",0,-1,").concat(this.dialogType, ",").concat(argumentId, "]"));
        };
        EShapeActionValueOpenDialogExtension.deserialize = function (serialized, manager) {
            var condition = EShapeActionValues.toResource(1, serialized, manager.resources);
            var target = EShapeActionValues.toResource(3, serialized, manager.resources);
            var argument = EShapeActionValues.toResource(7, serialized, manager.resources);
            return new EShapeActionValueOpenDialogExtension(condition, target, argument, serialized[6]);
        };
        return EShapeActionValueOpenDialogExtension;
    }(EShapeActionValueSubtyped));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionOpenExtensions = /** @class */ (function () {
        function EShapeActionOpenExtensions() {
        }
        EShapeActionOpenExtensions.add = function (extension) {
            var _a, _b;
            ((_a = this._typeToDatum) !== null && _a !== void 0 ? _a : (this._typeToDatum = new Map())).set(extension.type, extension);
            ((_b = this._data) !== null && _b !== void 0 ? _b : (this._data = [])).push(extension);
            EShapeActionOpenOpeners[extension.type] = extension.opener;
        };
        EShapeActionOpenExtensions.get = function (type) {
            var typeToDatum = this._typeToDatum;
            if (typeToDatum != null) {
                return typeToDatum.get(type);
            }
        };
        EShapeActionOpenExtensions.each = function (iteratee) {
            var data = this._data;
            if (data != null) {
                for (var i = 0, imax = data.length; i < imax; ++i) {
                    iteratee(data[i]);
                }
            }
        };
        return EShapeActionOpenExtensions;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueOpenExtension = /** @class */ (function (_super) {
        __extends(EShapeActionValueOpenExtension, _super);
        function EShapeActionValueOpenExtension(subtype, condition, target, inNewWindow) {
            var _this = _super.call(this, EShapeActionValueType.OPEN, condition, subtype) || this;
            _this.target = target;
            _this.inNewWindow = inNewWindow;
            return _this;
        }
        EShapeActionValueOpenExtension.prototype.isEquals = function (value) {
            return (_super.prototype.isEquals.call(this, value) &&
                value instanceof EShapeActionValueOpenExtension &&
                this.target === value.target &&
                this.inNewWindow === value.inNewWindow);
        };
        EShapeActionValueOpenExtension.prototype.toRuntime = function () {
            return new EShapeActionRuntimeOpen(this, this.subtype);
        };
        EShapeActionValueOpenExtension.prototype.toLabel = function () {
            var typeLabel = this.getTheme().toTypeLabel(this.type);
            var datum = EShapeActionOpenExtensions.get(this.subtype);
            return "".concat(typeLabel, ": ").concat(datum != null ? datum.label : "Unknown");
        };
        EShapeActionValueOpenExtension.prototype.serialize = function (manager) {
            var conditionId = manager.addResource(this.condition);
            var targetId = manager.addResource(this.target);
            var inNewWindow = this.inNewWindow ? 1 : 0;
            return manager.addResource("[".concat(this.type, ",").concat(conditionId, ",").concat(this.subtype, ",").concat(targetId, ",").concat(inNewWindow, "]"));
        };
        EShapeActionValueOpenExtension.deserialize = function (serialized, manager) {
            var condition = EShapeActionValues.toResource(1, serialized, manager.resources);
            var target = EShapeActionValues.toResource(3, serialized, manager.resources);
            return new EShapeActionValueOpenExtension(serialized[2], condition, target, !!serialized[4]);
        };
        return EShapeActionValueOpenExtension;
    }(EShapeActionValueSubtyped));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueShowHideType = {
        /** @deprecated in favor of {@link SHAPE} */
        SHAPE_SHOW: 0,
        /** @deprecated in favor of {@link SHAPE} */
        SHAPE_HIDE: 1,
        SHAPE: 2,
        LAYER: 3
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * @deprecated in favor of {@link EShapeActionRuntimeShowHideShape}.
     */
    var EShapeActionRuntimeShowHide = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeShowHide, _super);
        function EShapeActionRuntimeShowHide(value) {
            var _this = _super.call(this, value, EShapeRuntimeReset.VISIBILITY) || this;
            _this.visibility = value.subtype === EShapeActionValueShowHideType.SHAPE_SHOW;
            return _this;
        }
        EShapeActionRuntimeShowHide.prototype.execute = function (shape, runtime, time) {
            if (this.condition(shape, time, EShapeActionEnvironment)) {
                shape.visible = this.visibility;
                runtime.written |= this.reset;
            }
        };
        return EShapeActionRuntimeShowHide;
    }(EShapeActionRuntimeConditional));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * @deprecated in favor of {@link EShapeActionValueShowHideShape}.
     */
    var EShapeActionValueShowHide = /** @class */ (function (_super) {
        __extends(EShapeActionValueShowHide, _super);
        function EShapeActionValueShowHide(subtype, condition) {
            return _super.call(this, EShapeActionValueType.SHOW_HIDE, condition, subtype) || this;
        }
        EShapeActionValueShowHide.prototype.toRuntime = function () {
            return new EShapeActionRuntimeShowHide(this);
        };
        EShapeActionValueShowHide.prototype.serialize = function (manager) {
            var conditionId = manager.addResource(this.condition);
            return manager.addResource("[".concat(this.type, ",").concat(conditionId, ",").concat(this.subtype, "]"));
        };
        EShapeActionValueShowHide.deserialize = function (serialized, manager) {
            var condition = EShapeActionValues.toResource(1, serialized, manager.resources);
            return new EShapeActionValueShowHide(serialized[2], condition);
        };
        return EShapeActionValueShowHide;
    }(EShapeActionValueSubtyped));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeShowHideLayer = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeShowHideLayer, _super);
        function EShapeActionRuntimeShowHideLayer(value) {
            var _this = _super.call(this, value, EShapeRuntimeReset.NONE) || this;
            _this._data = new Map();
            _this._layers = value.layers;
            _this._bringToFront = value.bringToFront;
            return _this;
        }
        EShapeActionRuntimeShowHideLayer.prototype.initialize = function (shape, runtime) {
            _super.prototype.initialize.call(this, shape, runtime);
            var data = this._data.get(shape);
            if (data == null) {
                data = this.newData(shape);
                if (data != null) {
                    this._data.set(shape, data);
                }
            }
        };
        EShapeActionRuntimeShowHideLayer.prototype.execute = function (shape, runtime, time) {
            var data = this._data.get(shape);
            if (data) {
                var newCondition = this.condition(shape, time, EShapeActionEnvironment);
                if (data.condition !== newCondition) {
                    data.condition = newCondition;
                    var layers = data.layers;
                    if (newCondition) {
                        if (data.bringToFront) {
                            DDiagramLayers.bringAllToFront(layers);
                            DDiagramLayers.showAll(layers);
                        }
                        else {
                            DDiagramLayers.showAll(layers);
                        }
                    }
                    else {
                        DDiagramLayers.hideAll(layers);
                    }
                }
            }
        };
        EShapeActionRuntimeShowHideLayer.prototype.newData = function (shape) {
            var layers = DDiagramLayers.toLayers(shape, this._layers);
            if (0 < layers.length) {
                return {
                    layers: layers,
                    bringToFront: this._bringToFront,
                    condition: null
                };
            }
        };
        return EShapeActionRuntimeShowHideLayer;
    }(EShapeActionRuntimeConditional));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueShowHideLayer = /** @class */ (function (_super) {
        __extends(EShapeActionValueShowHideLayer, _super);
        function EShapeActionValueShowHideLayer(condition, layers, bringToFront) {
            var _this = _super.call(this, EShapeActionValueType.SHOW_HIDE, condition, EShapeActionValueShowHideType.LAYER) || this;
            _this.layers = layers;
            _this.bringToFront = bringToFront;
            return _this;
        }
        EShapeActionValueShowHideLayer.prototype.toRuntime = function () {
            return new EShapeActionRuntimeShowHideLayer(this);
        };
        EShapeActionValueShowHideLayer.prototype.serialize = function (manager) {
            var conditionId = manager.addResource(this.condition);
            var layersId = this.serializeLayers(manager);
            var bringToFrontId = this.bringToFront ? 1 : 0;
            return manager.addResource("[".concat(this.type, ",").concat(conditionId, ",").concat(this.subtype, ",").concat(layersId, ",").concat(bringToFrontId, "]"));
        };
        EShapeActionValueShowHideLayer.prototype.serializeLayers = function (manager) {
            var layers = this.layers;
            var result = "[";
            var delimiter = "";
            for (var i = 0, imax = layers.length; i < imax; ++i) {
                result += delimiter + layers[i];
                delimiter = ",";
            }
            result += "]";
            return manager.addResource(result);
        };
        EShapeActionValueShowHideLayer.deserialize = function (serialized, manager) {
            var condition = EShapeActionValues.toResource(1, serialized, manager.resources);
            var layers = this.deserializeLayers(serialized[3], manager);
            var bringToFront = !!serialized[4];
            return new EShapeActionValueShowHideLayer(condition, layers, bringToFront);
        };
        EShapeActionValueShowHideLayer.deserializeLayers = function (target, manager) {
            var resources = manager.resources;
            var resourcesLength = resources.length;
            if (0 <= target && target < resourcesLength) {
                return JSON.parse(resources[target]);
            }
            return [];
        };
        return EShapeActionValueShowHideLayer;
    }(EShapeActionValueSubtyped));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeShowHideShape = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeShowHideShape, _super);
        function EShapeActionRuntimeShowHideShape(value) {
            return _super.call(this, value, EShapeRuntimeReset.VISIBILITY) || this;
        }
        EShapeActionRuntimeShowHideShape.prototype.initialize = function (shape, runtime) {
            _super.prototype.initialize.call(this, shape, runtime);
        };
        EShapeActionRuntimeShowHideShape.prototype.execute = function (shape, runtime, time) {
            shape.visible = this.condition(shape, time, EShapeActionEnvironment);
            runtime.written |= this.reset;
        };
        return EShapeActionRuntimeShowHideShape;
    }(EShapeActionRuntimeConditional));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueShowHideShape = /** @class */ (function (_super) {
        __extends(EShapeActionValueShowHideShape, _super);
        function EShapeActionValueShowHideShape(condition) {
            return _super.call(this, EShapeActionValueType.SHOW_HIDE, condition, EShapeActionValueShowHideType.SHAPE) || this;
        }
        EShapeActionValueShowHideShape.prototype.toRuntime = function () {
            return new EShapeActionRuntimeShowHideShape(this);
        };
        EShapeActionValueShowHideShape.prototype.serialize = function (manager) {
            var conditionId = manager.addResource(this.condition);
            return manager.addResource("[".concat(this.type, ",").concat(conditionId, ",").concat(this.subtype, "]"));
        };
        EShapeActionValueShowHideShape.deserialize = function (serialized, manager) {
            var condition = EShapeActionValues.toResource(1, serialized, manager.resources);
            return new EShapeActionValueShowHideShape(condition);
        };
        return EShapeActionValueShowHideShape;
    }(EShapeActionValueSubtyped));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeTransformMove = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeTransformMove, _super);
        function EShapeActionRuntimeTransformMove(value, reset) {
            var _this = _super.call(this, value, reset) || this;
            _this.amount = EShapeActionExpressions.ofNumber(value.amount);
            return _this;
        }
        return EShapeActionRuntimeTransformMove;
    }(EShapeActionRuntimeConditional));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeTransformMoveAbsoluteX = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeTransformMoveAbsoluteX, _super);
        function EShapeActionRuntimeTransformMoveAbsoluteX(value) {
            return _super.call(this, value, EShapeRuntimeReset.POSITION_X) || this;
        }
        EShapeActionRuntimeTransformMoveAbsoluteX.prototype.execute = function (shape, runtime, time) {
            if (this.condition(shape, time, EShapeActionEnvironment)) {
                var amount = this.amount(shape, time, EShapeActionEnvironment);
                shape.transform.position.x = amount;
                runtime.written |= this.reset;
            }
        };
        return EShapeActionRuntimeTransformMoveAbsoluteX;
    }(EShapeActionRuntimeTransformMove));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeTransformMoveAbsoluteY = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeTransformMoveAbsoluteY, _super);
        function EShapeActionRuntimeTransformMoveAbsoluteY(value) {
            return _super.call(this, value, EShapeRuntimeReset.POSITION_Y) || this;
        }
        EShapeActionRuntimeTransformMoveAbsoluteY.prototype.execute = function (shape, runtime, time) {
            if (this.condition(shape, time, EShapeActionEnvironment)) {
                var amount = this.amount(shape, time, EShapeActionEnvironment);
                shape.transform.position.y = amount;
                runtime.written |= this.reset;
            }
        };
        return EShapeActionRuntimeTransformMoveAbsoluteY;
    }(EShapeActionRuntimeTransformMove));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeTransformMoveForwardOrBackward = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeTransformMoveForwardOrBackward, _super);
        function EShapeActionRuntimeTransformMoveForwardOrBackward(value) {
            return _super.call(this, value, EShapeRuntimeReset.POSITION) || this;
        }
        EShapeActionRuntimeTransformMoveForwardOrBackward.prototype.execute = function (shape, runtime, time) {
            if (this.condition(shape, time, EShapeActionEnvironment)) {
                var amount = this.amount(shape, time, EShapeActionEnvironment);
                var transform = shape.transform;
                var position = transform.position;
                var writtenPositionX = !!(runtime.written & EShapeRuntimeReset.POSITION_X);
                var writtenPositionY = !!(runtime.written & EShapeRuntimeReset.POSITION_Y);
                var oldPositionX = writtenPositionX ? position.x : runtime.x;
                var oldPositionY = writtenPositionY ? position.y : runtime.y;
                shape.updateTransform();
                var localTransform = transform.localTransform;
                position.set(oldPositionX - localTransform.c * amount, oldPositionY - localTransform.d * amount);
                runtime.written |= this.reset;
            }
        };
        return EShapeActionRuntimeTransformMoveForwardOrBackward;
    }(EShapeActionRuntimeTransformMove));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeTransformMoveLeftOrRight = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeTransformMoveLeftOrRight, _super);
        function EShapeActionRuntimeTransformMoveLeftOrRight(value) {
            return _super.call(this, value, EShapeRuntimeReset.POSITION) || this;
        }
        EShapeActionRuntimeTransformMoveLeftOrRight.prototype.execute = function (shape, runtime, time) {
            if (this.condition(shape, time, EShapeActionEnvironment)) {
                var amount = this.amount(shape, time, EShapeActionEnvironment);
                var transform = shape.transform;
                var position = transform.position;
                var writtenPositionX = !!(runtime.written & EShapeRuntimeReset.POSITION_X);
                var writtenPositionY = !!(runtime.written & EShapeRuntimeReset.POSITION_Y);
                var oldPositionX = writtenPositionX ? position.x : runtime.x;
                var oldPositionY = writtenPositionY ? position.y : runtime.y;
                shape.updateTransform();
                var localTransform = transform.localTransform;
                position.set(oldPositionX + localTransform.a * amount, oldPositionY + localTransform.b * amount);
                runtime.written |= this.reset;
            }
        };
        return EShapeActionRuntimeTransformMoveLeftOrRight;
    }(EShapeActionRuntimeTransformMove));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeTransformMoveRelativeX = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeTransformMoveRelativeX, _super);
        function EShapeActionRuntimeTransformMoveRelativeX(value) {
            return _super.call(this, value, EShapeRuntimeReset.POSITION_X) || this;
        }
        EShapeActionRuntimeTransformMoveRelativeX.prototype.execute = function (shape, runtime, time) {
            if (this.condition(shape, time, EShapeActionEnvironment)) {
                var amount = this.amount(shape, time, EShapeActionEnvironment);
                var writtenPositionX = !!(runtime.written & EShapeRuntimeReset.POSITION_X);
                var position = shape.transform.position;
                var oldPositionX = writtenPositionX ? position.x : runtime.x;
                position.x = oldPositionX + amount;
                runtime.written |= this.reset;
            }
        };
        return EShapeActionRuntimeTransformMoveRelativeX;
    }(EShapeActionRuntimeTransformMove));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeTransformMoveRelativeY = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeTransformMoveRelativeY, _super);
        function EShapeActionRuntimeTransformMoveRelativeY(action) {
            return _super.call(this, action, EShapeRuntimeReset.POSITION_Y) || this;
        }
        EShapeActionRuntimeTransformMoveRelativeY.prototype.execute = function (shape, runtime, time) {
            if (this.condition(shape, time, EShapeActionEnvironment)) {
                var amount = this.amount(shape, time, EShapeActionEnvironment);
                var writtenPositionY = !!(runtime.written & EShapeRuntimeReset.POSITION_Y);
                var position = shape.transform.position;
                var oldPositionY = writtenPositionY ? position.y : runtime.y;
                position.y = oldPositionY + amount;
                runtime.written |= this.reset;
            }
        };
        return EShapeActionRuntimeTransformMoveRelativeY;
    }(EShapeActionRuntimeTransformMove));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueOpetyped = /** @class */ (function (_super) {
        __extends(EShapeActionValueOpetyped, _super);
        function EShapeActionValueOpetyped(type, condition, subtype, opetype) {
            var _this = _super.call(this, type, condition, subtype) || this;
            _this.opetype = opetype;
            return _this;
        }
        EShapeActionValueOpetyped.prototype.isEquals = function (value) {
            return (_super.prototype.isEquals.call(this, value) &&
                value instanceof EShapeActionValueOpetyped &&
                this.opetype === value.opetype);
        };
        return EShapeActionValueOpetyped;
    }(EShapeActionValueSubtyped));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueTransformMoveType = {
        RELATIVE_X: 0,
        RELATIVE_Y: 1,
        ABSOLUTE_X: 2,
        ABSOLUTE_Y: 3,
        FORWARD_OR_BACKWARD: 4,
        LEFT_OR_RIGHT: 5
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueTransformType = {
        RESIZE: 0,
        MOVE: 1,
        ROTATE: 2
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueTransformMove = /** @class */ (function (_super) {
        __extends(EShapeActionValueTransformMove, _super);
        function EShapeActionValueTransformMove(opetype, condition, amount) {
            var _this = _super.call(this, EShapeActionValueType.TRANSFORM, condition, EShapeActionValueTransformType.MOVE, opetype) || this;
            _this.amount = amount;
            return _this;
        }
        EShapeActionValueTransformMove.prototype.isEquals = function (value) {
            return (_super.prototype.isEquals.call(this, value) &&
                value instanceof EShapeActionValueTransformMove &&
                this.amount === value.amount);
        };
        EShapeActionValueTransformMove.prototype.toRuntime = function () {
            switch (this.opetype) {
                case EShapeActionValueTransformMoveType.ABSOLUTE_X:
                    return new EShapeActionRuntimeTransformMoveAbsoluteX(this);
                case EShapeActionValueTransformMoveType.ABSOLUTE_Y:
                    return new EShapeActionRuntimeTransformMoveAbsoluteY(this);
                case EShapeActionValueTransformMoveType.FORWARD_OR_BACKWARD:
                    return new EShapeActionRuntimeTransformMoveForwardOrBackward(this);
                case EShapeActionValueTransformMoveType.LEFT_OR_RIGHT:
                    return new EShapeActionRuntimeTransformMoveLeftOrRight(this);
                case EShapeActionValueTransformMoveType.RELATIVE_X:
                    return new EShapeActionRuntimeTransformMoveRelativeX(this);
                case EShapeActionValueTransformMoveType.RELATIVE_Y:
                    return new EShapeActionRuntimeTransformMoveRelativeY(this);
            }
        };
        EShapeActionValueTransformMove.prototype.serialize = function (manager) {
            var conditionId = manager.addResource(this.condition);
            var amountId = manager.addResource(this.amount);
            return manager.addResource("[".concat(this.type, ",").concat(conditionId, ",").concat(this.subtype, ",").concat(this.opetype, ",").concat(amountId, "]"));
        };
        EShapeActionValueTransformMove.deserialize = function (serialized, manager) {
            var condition = EShapeActionValues.toResource(1, serialized, manager.resources);
            var amount = EShapeActionValues.toResource(4, serialized, manager.resources);
            return new EShapeActionValueTransformMove(serialized[3], condition, amount);
        };
        return EShapeActionValueTransformMove;
    }(EShapeActionValueOpetyped));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueTransformResizeType = {
        RELATIVE_SIZE: 0,
        RELATIVE_HEIGHT: 1,
        RELATIVE_WIDTH: 2,
        ABSOLUTE_SIZE: 3,
        ABSOLUTE_HEIGHT: 4,
        ABSOLUTE_WIDTH: 5
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeTransformResize = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeTransformResize, _super);
        function EShapeActionRuntimeTransformResize(value, reset) {
            var _this = _super.call(this, value, reset) || this;
            switch (value.opetype) {
                case EShapeActionValueTransformResizeType.RELATIVE_SIZE:
                    _this.size = EShapeActionExpressions.ofNumberOrOne(value.amount);
                    break;
                case EShapeActionValueTransformResizeType.ABSOLUTE_SIZE:
                    _this.size = EShapeActionExpressions.ofNumberOrOneHundred(value.amount);
                    break;
                case EShapeActionValueTransformResizeType.RELATIVE_HEIGHT:
                    _this.size = EShapeActionExpressions.ofNumberOrOne(value.amount);
                    break;
                case EShapeActionValueTransformResizeType.ABSOLUTE_HEIGHT:
                    _this.size = EShapeActionExpressions.ofNumberOrOneHundred(value.amount);
                    break;
                case EShapeActionValueTransformResizeType.RELATIVE_WIDTH:
                    _this.size = EShapeActionExpressions.ofNumberOrOne(value.amount);
                    break;
                case EShapeActionValueTransformResizeType.ABSOLUTE_WIDTH:
                    _this.size = EShapeActionExpressions.ofNumberOrOneHundred(value.amount);
                    break;
                default:
                    _this.size = EShapeActionExpressions.ONE;
            }
            return _this;
        }
        EShapeActionRuntimeTransformResize.prototype.adjustPosition = function (shape, runtime, dsx, dsy, originX, originY) {
            var dx = (-0.5 + originX) * dsx;
            var dy = (-0.5 + originY) * dsy;
            shape.updateTransform();
            var transform = shape.transform;
            var position = transform.position;
            var localTransform = transform.localTransform;
            var writtenPositionX = !!(runtime.written & EShapeRuntimeReset.POSITION_X);
            var writtenPositionY = !!(runtime.written & EShapeRuntimeReset.POSITION_Y);
            var oldPositionX = writtenPositionX ? position.x : runtime.x;
            var oldPositionY = writtenPositionY ? position.y : runtime.y;
            runtime.written |= EShapeRuntimeReset.POSITION;
            position.set(oldPositionX + dx * localTransform.a + dy * localTransform.c, oldPositionY + dx * localTransform.b + dy * localTransform.d);
        };
        return EShapeActionRuntimeTransformResize;
    }(EShapeActionRuntimeConditional));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeTransformResizeHeightAbsolute = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeTransformResizeHeightAbsolute, _super);
        function EShapeActionRuntimeTransformResizeHeightAbsolute(value) {
            var _this = _super.call(this, value, EShapeRuntimeReset.HEIGHT | EShapeRuntimeReset.POSITION) || this;
            _this.origin = value.originY;
            return _this;
        }
        EShapeActionRuntimeTransformResizeHeightAbsolute.prototype.execute = function (shape, runtime, time) {
            if (this.condition(shape, time, EShapeActionEnvironment)) {
                var sizeAbsolute = this.size(shape, time, EShapeActionEnvironment);
                var size = shape.size;
                var writtenHeight = !!(runtime.written & EShapeRuntimeReset.HEIGHT);
                var oldSizeY = writtenHeight ? size.y : runtime.sizeY;
                size.y = toSizeNormalized(sizeAbsolute);
                runtime.written |= EShapeRuntimeReset.HEIGHT;
                this.adjustPosition(shape, runtime, 0, oldSizeY - size.y, 0.5, this.origin);
            }
        };
        return EShapeActionRuntimeTransformResizeHeightAbsolute;
    }(EShapeActionRuntimeTransformResize));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeTransformResizeHeightRelative = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeTransformResizeHeightRelative, _super);
        function EShapeActionRuntimeTransformResizeHeightRelative(value) {
            var _this = _super.call(this, value, EShapeRuntimeReset.HEIGHT | EShapeRuntimeReset.POSITION) || this;
            _this.origin = value.originY;
            return _this;
        }
        EShapeActionRuntimeTransformResizeHeightRelative.prototype.execute = function (shape, runtime, time) {
            if (this.condition(shape, time, EShapeActionEnvironment)) {
                var sizeRelative = this.size(shape, time, EShapeActionEnvironment);
                var size = shape.size;
                var writtenHeight = !!(runtime.written & EShapeRuntimeReset.HEIGHT);
                var oldSizeY = writtenHeight ? size.y : runtime.sizeY;
                size.y = toSizeNormalized(oldSizeY * sizeRelative);
                runtime.written |= EShapeRuntimeReset.HEIGHT;
                this.adjustPosition(shape, runtime, 0, oldSizeY - size.y, 0.5, this.origin);
            }
        };
        return EShapeActionRuntimeTransformResizeHeightRelative;
    }(EShapeActionRuntimeTransformResize));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeTransformResizeSizeAbsolute = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeTransformResizeSizeAbsolute, _super);
        function EShapeActionRuntimeTransformResizeSizeAbsolute(value) {
            var _this = _super.call(this, value, EShapeRuntimeReset.SIZE | EShapeRuntimeReset.POSITION) || this;
            _this.originX = value.originX;
            _this.originY = value.originY;
            return _this;
        }
        EShapeActionRuntimeTransformResizeSizeAbsolute.prototype.execute = function (shape, runtime, time) {
            if (this.condition(shape, time, EShapeActionEnvironment)) {
                var sizeAbsolute = toSizeNormalized(this.size(shape, time, EShapeActionEnvironment));
                var size = shape.size;
                var writtenWidth = !!(runtime.written & EShapeRuntimeReset.WIDTH);
                var writtenHeight = !!(runtime.written & EShapeRuntimeReset.HEIGHT);
                var oldSizeX = writtenWidth ? size.x : runtime.sizeX;
                var oldSizeY = writtenHeight ? size.y : runtime.sizeY;
                size.set(sizeAbsolute, sizeAbsolute);
                runtime.written |= EShapeRuntimeReset.SIZE;
                this.adjustPosition(shape, runtime, oldSizeX - size.x, oldSizeY - size.y, this.originX, this.originY);
            }
        };
        return EShapeActionRuntimeTransformResizeSizeAbsolute;
    }(EShapeActionRuntimeTransformResize));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeTransformResizeSizeRelative = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeTransformResizeSizeRelative, _super);
        function EShapeActionRuntimeTransformResizeSizeRelative(value) {
            var _this = _super.call(this, value, EShapeRuntimeReset.SIZE | EShapeRuntimeReset.POSITION) || this;
            _this.originX = value.originX;
            _this.originY = value.originY;
            return _this;
        }
        EShapeActionRuntimeTransformResizeSizeRelative.prototype.execute = function (shape, runtime, time) {
            if (this.condition(shape, time, EShapeActionEnvironment)) {
                var sizeRelative = this.size(shape, time, EShapeActionEnvironment);
                var size = shape.size;
                var writtenWidth = !!(runtime.written & EShapeRuntimeReset.WIDTH);
                var writtenHeight = !!(runtime.written & EShapeRuntimeReset.HEIGHT);
                var oldSizeX = writtenWidth ? size.x : runtime.sizeX;
                var oldSizeY = writtenHeight ? size.y : runtime.sizeY;
                size.set(toSizeNormalized(oldSizeX * sizeRelative), toSizeNormalized(oldSizeY * sizeRelative));
                runtime.written |= EShapeRuntimeReset.SIZE;
                this.adjustPosition(shape, runtime, oldSizeX - size.x, oldSizeY - size.y, this.originX, this.originY);
            }
        };
        return EShapeActionRuntimeTransformResizeSizeRelative;
    }(EShapeActionRuntimeTransformResize));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeTransformResizeWidthAbsolute = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeTransformResizeWidthAbsolute, _super);
        function EShapeActionRuntimeTransformResizeWidthAbsolute(value) {
            var _this = _super.call(this, value, EShapeRuntimeReset.WIDTH | EShapeRuntimeReset.POSITION) || this;
            _this.origin = value.originX;
            return _this;
        }
        EShapeActionRuntimeTransformResizeWidthAbsolute.prototype.execute = function (shape, runtime, time) {
            if (this.condition(shape, time, EShapeActionEnvironment)) {
                var sizeAbsolute = this.size(shape, time, EShapeActionEnvironment);
                var size = shape.size;
                var writtenWidth = !!(runtime.written & EShapeRuntimeReset.WIDTH);
                var oldSizeX = writtenWidth ? size.x : runtime.sizeX;
                size.x = toSizeNormalized(sizeAbsolute);
                runtime.written |= EShapeRuntimeReset.WIDTH;
                this.adjustPosition(shape, runtime, oldSizeX - size.x, 0, this.origin, 0.5);
            }
        };
        return EShapeActionRuntimeTransformResizeWidthAbsolute;
    }(EShapeActionRuntimeTransformResize));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeTransformResizeWidthRelative = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeTransformResizeWidthRelative, _super);
        function EShapeActionRuntimeTransformResizeWidthRelative(value) {
            var _this = _super.call(this, value, EShapeRuntimeReset.WIDTH | EShapeRuntimeReset.POSITION) || this;
            _this.origin = value.originX;
            return _this;
        }
        EShapeActionRuntimeTransformResizeWidthRelative.prototype.execute = function (shape, runtime, time) {
            if (this.condition(shape, time, EShapeActionEnvironment)) {
                var sizeRelative = this.size(shape, time, EShapeActionEnvironment);
                var size = shape.size;
                var writtenWidth = !!(runtime.written & EShapeRuntimeReset.WIDTH);
                var oldSizeX = writtenWidth ? size.x : runtime.sizeX;
                size.x = toSizeNormalized(oldSizeX * sizeRelative);
                runtime.written |= EShapeRuntimeReset.WIDTH;
                this.adjustPosition(shape, runtime, oldSizeX - size.x, 0, this.origin, 0.5);
            }
        };
        return EShapeActionRuntimeTransformResizeWidthRelative;
    }(EShapeActionRuntimeTransformResize));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueTransformResize = /** @class */ (function (_super) {
        __extends(EShapeActionValueTransformResize, _super);
        function EShapeActionValueTransformResize(opetype, condition, originX, originY, amount) {
            var _this = _super.call(this, EShapeActionValueType.TRANSFORM, condition, EShapeActionValueTransformType.RESIZE, opetype) || this;
            _this.originX = originX;
            _this.originY = originY;
            _this.amount = amount;
            return _this;
        }
        EShapeActionValueTransformResize.prototype.isEquals = function (value) {
            return (_super.prototype.isEquals.call(this, value) &&
                value instanceof EShapeActionValueTransformResize &&
                this.originX === value.originX &&
                this.originY === value.originY &&
                this.amount === value.amount);
        };
        EShapeActionValueTransformResize.prototype.toRuntime = function () {
            switch (this.opetype) {
                case EShapeActionValueTransformResizeType.ABSOLUTE_HEIGHT:
                    return new EShapeActionRuntimeTransformResizeHeightAbsolute(this);
                case EShapeActionValueTransformResizeType.ABSOLUTE_WIDTH:
                    return new EShapeActionRuntimeTransformResizeWidthAbsolute(this);
                case EShapeActionValueTransformResizeType.ABSOLUTE_SIZE:
                    return new EShapeActionRuntimeTransformResizeSizeAbsolute(this);
                case EShapeActionValueTransformResizeType.RELATIVE_HEIGHT:
                    return new EShapeActionRuntimeTransformResizeHeightRelative(this);
                case EShapeActionValueTransformResizeType.RELATIVE_WIDTH:
                    return new EShapeActionRuntimeTransformResizeWidthRelative(this);
                case EShapeActionValueTransformResizeType.RELATIVE_SIZE:
                    return new EShapeActionRuntimeTransformResizeSizeRelative(this);
            }
        };
        EShapeActionValueTransformResize.prototype.serialize = function (manager) {
            var conditionId = manager.addResource(this.condition);
            var amountId = manager.addResource(this.amount);
            return manager.addResource("[".concat(this.type, ",").concat(conditionId, ",").concat(this.subtype, ",").concat(this.opetype, ",").concat(this.originX, ",").concat(this.originY, ",").concat(amountId, "]"));
        };
        EShapeActionValueTransformResize.deserialize = function (serialized, manager) {
            var condition = EShapeActionValues.toResource(1, serialized, manager.resources);
            var amount = EShapeActionValues.toResource(6, serialized, manager.resources);
            return new EShapeActionValueTransformResize(serialized[3], condition, serialized[4], serialized[5], amount);
        };
        return EShapeActionValueTransformResize;
    }(EShapeActionValueOpetyped));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeTransformRotate = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeTransformRotate, _super);
        function EShapeActionRuntimeTransformRotate(value, reset) {
            var _this = _super.call(this, value, reset) || this;
            _this.originX = value.originX;
            _this.originY = value.originY;
            _this.amount = EShapeActionExpressions.ofNumber("(".concat(value.amount, ") * (Math.PI / 180)"));
            return _this;
        }
        EShapeActionRuntimeTransformRotate.prototype.adjustPosition = function (shape, runtime, oldRotation, newRotation, originX, originY) {
            var writtenWidth = !!(runtime.written & EShapeRuntimeReset.WIDTH);
            var writtenHeight = !!(runtime.written & EShapeRuntimeReset.HEIGHT);
            var dx = (-0.5 + originX) * (writtenWidth ? shape.size.x : runtime.sizeX);
            var dy = (-0.5 + originY) * (writtenHeight ? shape.size.y : runtime.sizeY);
            var s = Math.sin(oldRotation) - Math.sin(newRotation);
            var c = Math.cos(oldRotation) - Math.cos(newRotation);
            var position = shape.transform.position;
            var writtenPositionX = !!(runtime.written & EShapeRuntimeReset.POSITION_X);
            var writtenPositionY = !!(runtime.written & EShapeRuntimeReset.POSITION_Y);
            var oldPositionX = writtenPositionX ? position.x : runtime.x;
            var oldPositionY = writtenPositionY ? position.y : runtime.y;
            runtime.written |= EShapeRuntimeReset.POSITION;
            position.set(oldPositionX + dx * c - dy * s, oldPositionY + dx * s + dy * c);
        };
        return EShapeActionRuntimeTransformRotate;
    }(EShapeActionRuntimeConditional));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeTransformRotateAbsolute = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeTransformRotateAbsolute, _super);
        function EShapeActionRuntimeTransformRotateAbsolute(value) {
            return _super.call(this, value, EShapeRuntimeReset.ROTATION | EShapeRuntimeReset.POSITION) || this;
        }
        EShapeActionRuntimeTransformRotateAbsolute.prototype.execute = function (shape, runtime, time) {
            if (this.condition(shape, time, EShapeActionEnvironment)) {
                var amount = this.amount(shape, time, EShapeActionEnvironment);
                var transform = shape.transform;
                var writtenRotation = !!(runtime.written & EShapeRuntimeReset.ROTATION);
                var oldRotation = writtenRotation ? transform.rotation : runtime.rotation;
                transform.rotation = amount;
                runtime.written |= EShapeRuntimeReset.ROTATION;
                this.adjustPosition(shape, runtime, oldRotation, amount, this.originX, this.originY);
            }
        };
        return EShapeActionRuntimeTransformRotateAbsolute;
    }(EShapeActionRuntimeTransformRotate));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeTransformRotateRelative = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeTransformRotateRelative, _super);
        function EShapeActionRuntimeTransformRotateRelative(value) {
            return _super.call(this, value, EShapeRuntimeReset.ROTATION | EShapeRuntimeReset.POSITION) || this;
        }
        EShapeActionRuntimeTransformRotateRelative.prototype.execute = function (shape, runtime, time) {
            if (this.condition(shape, time, EShapeActionEnvironment)) {
                var amount = this.amount(shape, time, EShapeActionEnvironment);
                var transform = shape.transform;
                var writtenRotation = !!(runtime.written & EShapeRuntimeReset.ROTATION);
                var oldRotation = writtenRotation ? transform.rotation : runtime.rotation;
                transform.rotation = oldRotation + amount;
                runtime.written |= EShapeRuntimeReset.ROTATION;
                this.adjustPosition(shape, runtime, oldRotation, transform.rotation, this.originX, this.originY);
            }
        };
        return EShapeActionRuntimeTransformRotateRelative;
    }(EShapeActionRuntimeTransformRotate));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueTransformRotateType = {
        RELATIVE: 0,
        ABSOLUTE: 1
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueTransformRotate = /** @class */ (function (_super) {
        __extends(EShapeActionValueTransformRotate, _super);
        function EShapeActionValueTransformRotate(opetype, condition, originX, originY, amount) {
            var _this = _super.call(this, EShapeActionValueType.TRANSFORM, condition, EShapeActionValueTransformType.ROTATE, opetype) || this;
            _this.originX = originX;
            _this.originY = originY;
            _this.amount = amount;
            return _this;
        }
        EShapeActionValueTransformRotate.prototype.isEquals = function (value) {
            return (_super.prototype.isEquals.call(this, value) &&
                value instanceof EShapeActionValueTransformRotate &&
                this.originX === value.originX &&
                this.originY === value.originY &&
                this.amount === value.amount);
        };
        EShapeActionValueTransformRotate.prototype.toRuntime = function () {
            switch (this.opetype) {
                case EShapeActionValueTransformRotateType.ABSOLUTE:
                    return new EShapeActionRuntimeTransformRotateAbsolute(this);
                case EShapeActionValueTransformRotateType.RELATIVE:
                    return new EShapeActionRuntimeTransformRotateRelative(this);
            }
        };
        EShapeActionValueTransformRotate.prototype.serialize = function (manager) {
            var conditionId = manager.addResource(this.condition);
            var amountId = manager.addResource(this.amount);
            return manager.addResource("[".concat(this.type, ",").concat(conditionId, ",").concat(this.subtype, ",").concat(this.opetype, ",").concat(this.originX, ",").concat(this.originY, ",").concat(amountId, "]"));
        };
        EShapeActionValueTransformRotate.deserialize = function (serialized, manager) {
            var condition = EShapeActionValues.toResource(1, serialized, manager.resources);
            var amount = EShapeActionValues.toResource(6, serialized, manager.resources);
            return new EShapeActionValueTransformRotate(serialized[3], condition, serialized[4], serialized[5], amount);
        };
        return EShapeActionValueTransformRotate;
    }(EShapeActionValueOpetyped));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var deserializeActionValue = function (serialized, manager) {
        switch (serialized[0]) {
            case EShapeActionValueType.SHOW_HIDE:
                switch (serialized[2]) {
                    case EShapeActionValueShowHideType.SHAPE_SHOW:
                    case EShapeActionValueShowHideType.SHAPE_HIDE:
                        return EShapeActionValueShowHide.deserialize(serialized, manager);
                    case EShapeActionValueShowHideType.SHAPE:
                        return EShapeActionValueShowHideShape.deserialize(serialized, manager);
                    case EShapeActionValueShowHideType.LAYER:
                        return EShapeActionValueShowHideLayer.deserialize(serialized, manager);
                }
                break;
            case EShapeActionValueType.BLINK:
                return EShapeActionValueBlink.deserialize(serialized, manager);
            case EShapeActionValueType.CHANGE_COLOR:
            case EShapeActionValueType.CHANGE_COLOR_LEGACY:
                switch (serialized[3]) {
                    case EShapeActionValueChangeColorTarget.COLOR_AND_ALPHA:
                    case EShapeActionValueChangeColorTarget.COLOR:
                    case EShapeActionValueChangeColorTarget.ALPHA:
                        return EShapeActionValueChangeColor.deserialize(serialized, manager);
                    case EShapeActionValueChangeColorTarget.CODE:
                        return EShapeActionValueChangeColorCode.deserialize(serialized, manager);
                    case EShapeActionValueChangeColorTarget.BRIGHTNESS:
                        return EShapeActionValueChangeColorBrightness.deserialize(serialized, manager);
                }
                break;
            case EShapeActionValueType.CHANGE_TEXT:
                return EShapeActionValueChangeText.deserialize(serialized, manager);
            case EShapeActionValueType.CHANGE_CURSOR:
                return EShapeActionValueChangeCursor.deserialize(serialized, manager);
            case EShapeActionValueType.EMIT_EVENT:
                return EShapeActionValueEmitEvent.deserialize(serialized, manager);
            case EShapeActionValueType.OPEN:
                switch (serialized[2]) {
                    case EShapeActionValueOpenType.DIALOG_TEXT:
                    case EShapeActionValueOpenType.DIALOG_INTEGER:
                    case EShapeActionValueOpenType.DIALOG_REAL:
                    case EShapeActionValueOpenType.DIALOG_BOOLEAN:
                    case EShapeActionValueOpenType.DIALOG_DATE:
                    case EShapeActionValueOpenType.DIALOG_TIME:
                    case EShapeActionValueOpenType.DIALOG_DATETIME:
                    case EShapeActionValueOpenType.DIALOG:
                        if (EShapeActionValueOpenDialogType.EXTENSION <= serialized[6]) {
                            return EShapeActionValueOpenDialogExtension.deserialize(serialized, manager);
                        }
                        return EShapeActionValueOpenDialog.deserialize(serialized, manager);
                    case EShapeActionValueOpenType.DIAGRAM_LEGACY:
                    case EShapeActionValueOpenType.PAGE_LEGACY:
                    case EShapeActionValueOpenType.PAGE_INPLACE_LEGACY:
                    case EShapeActionValueOpenType.DIAGRAM:
                    case EShapeActionValueOpenType.PAGE:
                        return EShapeActionValueOpen.deserialize(serialized, manager);
                    default:
                        if (EShapeActionValueOpenType.EXTENSION <= serialized[2]) {
                            return EShapeActionValueOpenExtension.deserialize(serialized, manager);
                        }
                        break;
                }
                break;
            case EShapeActionValueType.TRANSFORM:
                switch (serialized[2]) {
                    case EShapeActionValueTransformType.MOVE:
                        return EShapeActionValueTransformMove.deserialize(serialized, manager);
                    case EShapeActionValueTransformType.RESIZE:
                        return EShapeActionValueTransformResize.deserialize(serialized, manager);
                    case EShapeActionValueTransformType.ROTATE:
                        return EShapeActionValueTransformRotate.deserialize(serialized, manager);
                }
                break;
            case EShapeActionValueType.GESTURE:
                return EShapeActionValueGesture.deserialize(serialized, manager);
            case EShapeActionValueType.MISC:
                switch (serialized[2]) {
                    case EShapeActionValueMiscType.GESTURE:
                        return EShapeActionValueGesture.deserialize(serialized, manager);
                    case EShapeActionValueMiscType.SHOW_HIDE_LAYER:
                        return EShapeActionValueShowHideLayer.deserialize(serialized, manager);
                    case EShapeActionValueMiscType.GESTURE_LAYER:
                        return EShapeActionValueGesture.deserialize(serialized, manager);
                    case EShapeActionValueMiscType.EXECUTE:
                        return EShapeActionValueMiscExecute.deserialize(serialized, manager);
                    default:
                        if (EShapeActionValueMiscType.EXTENSION <= serialized[2]) {
                            return EShapeActionValueMiscExtension.deserialize(serialized, manager);
                        }
                        else {
                            return EShapeActionValueMisc.deserialize(serialized, manager);
                        }
                }
        }
        return null;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueDeserializers = {};

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var toSerialized = function (resource) {
        try {
            var parsed = JSON.parse(resource);
            if (isArray(parsed) && 2 <= parsed.length) {
                return parsed;
            }
            return null;
        }
        catch (e) {
            return null;
        }
    };
    var deserializeActionValues = function (indices, manager, result) {
        var action = result.action;
        var resources = manager.resources;
        for (var i = 0, imax = indices.length; i < imax; ++i) {
            var index = indices[i];
            var saved = manager.getAction(index);
            if (saved != null) {
                action.add(saved);
            }
            else {
                var resource = resources[index];
                if (resource != null) {
                    var serialized = toSerialized(resource);
                    if (serialized != null && 0 < serialized.length) {
                        var type = serialized[0];
                        var deserializer = EShapeActionValueType.EXTENSION <= type
                            ? EShapeActionValueDeserializers[type]
                            : deserializeActionValue;
                        if (deserializer != null) {
                            var deserialized = deserializer(serialized, manager);
                            if (deserialized != null) {
                                manager.setAction(index, deserialized);
                                action.add(deserialized);
                            }
                        }
                    }
                }
            }
        }
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var parse = function (target) {
        try {
            return JSON.parse(target);
        }
        catch (e) {
            return null;
        }
    };
    var toGradientLike = function (target) {
        var parsed = parse(target);
        if (parsed == null || parsed.length < 7) {
            return undefined;
        }
        else {
            var direction = parsed[0];
            var points = [];
            for (var i = 1, imax = parsed.length; i < imax; i += 3) {
                points.push({
                    color: parsed[i + 0],
                    alpha: parsed[i + 1],
                    position: parsed[i + 2]
                });
            }
            return {
                points: points,
                direction: direction
            };
        }
    };
    var deserializeGradient = function (index, manager, result) {
        var resources = manager.resources;
        if (0 <= index && index < resources.length) {
            var serialized = resources[index];
            if (isString(serialized)) {
                result.gradient = toGradientLike(serialized);
            }
        }
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var imageElementCache = {};
    var toImageElement = function (dataUrl) {
        var cachedImageElement = imageElementCache[dataUrl];
        if (cachedImageElement != null) {
            if ("url" in cachedImageElement) {
                return Promise.resolve(cachedImageElement);
            }
            else {
                return cachedImageElement;
            }
        }
        else {
            var result = new Promise(function (resolve, reject) {
                var imageElement = document.createElement("img");
                imageElement.onload = function () {
                    var resolved = {
                        url: dataUrl,
                        width: imageElement.width,
                        height: imageElement.height,
                        source: imageElement
                    };
                    imageElementCache[dataUrl] = resolved;
                    resolve(resolved);
                };
                imageElement.onabort = imageElement.onerror = function () {
                    reject();
                };
                imageElement.src = dataUrl;
            });
            imageElementCache[dataUrl] = result;
            return result;
        }
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var deserializeChildren = function (serializeds, manager, result) {
        if (0 < serializeds.length) {
            var deserializeds = [];
            for (var i = 0, imax = serializeds.length; i < imax; ++i) {
                deserializeds.push(deserialize(serializeds[i], manager));
            }
            return Promise.all(deserializeds).then(function (children) {
                result.children = children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    children[i].parent = result;
                }
                result.onChildTransformChange();
                result.toDirty();
                return result;
            });
        }
        return null;
    };
    var deserializeImage$1 = function (index, manager, result) {
        var resources = manager.resources;
        if (0 <= index && index < resources.length) {
            var imageSrc = resources[index];
            if (isString(imageSrc)) {
                return toImageElement(imageSrc).then(function (imageElement) {
                    result.image = imageElement;
                    return result;
                });
            }
        }
        return null;
    };
    var deserializeBase = function (item, manager, result) {
        var resources = manager.resources;
        result.id = resources[item[1]] || "";
        var transform = result.transform;
        transform.position.set(item[2], item[3]);
        transform.rotation = item[6];
        transform.skew.set(item[7], item[7]);
        transform.pivot.set(item[21], item[22]);
        result.size.set(toSizeNormalized(item[4]), toSizeNormalized(item[5]));
        result.fill.deserialize(item[8], manager);
        result.stroke.deserialize(item[9], manager);
        var item10 = item[10];
        result.cursor = 0 <= item10 ? resources[item10] : undefined;
        result.text.deserialize(item[11], manager);
        result.data.deserialize(item[12], manager);
        result.radius = item[13];
        result.corner = item[14];
        var item23 = item[23];
        result.interactive = !!(item23 & 1);
        var state = result.state;
        state.isFocusable = !(item23 & 2);
        state.isActive = !!(item23 & 4);
        var item24 = item[24];
        result.shortcut = 0 <= item24 ? resources[item24] : undefined;
        var item25 = item[25];
        result.title = 0 <= item25 ? resources[item25] : undefined;
        var item26 = item[26];
        result.uuid = item26 != null ? item26 : 0;
        var item27 = item[27];
        var item28 = item[28];
        var item29 = item[29];
        var hasItem27 = item27 != null && item27 !== EShapeCapability.NONE;
        var hasItem28 = item28 != null && item28 !== EShapeCapability.NONE;
        var hasItem29 = item29 != null && item29 !== EShapeCapability.NONE;
        if (hasItem27 || hasItem28 || hasItem29) {
            result.capability.set(item27, item28, item29);
        }
        var children = deserializeChildren(item[20], manager, result);
        deserializeActionValues(item[17], manager, result);
        deserializeGradient(item[19], manager, result);
        var image = deserializeImage$1(item[18], manager, result);
        if (children != null) {
            if (image != null) {
                return Promise.all([children, image]).then(function () {
                    return result;
                });
            }
            else {
                return children;
            }
        }
        else {
            if (image != null) {
                return image;
            }
            else {
                return result;
            }
        }
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var deserializeBar = function (item, manager, shape) {
        shape = shape || new EShapeBar();
        var result = deserializeBase(item, manager, shape);
        shape.points.deserialize(item[15], manager);
        var style = shape.points.style;
        var mask = EShapePointsStyle.NON_SCALING_MASK |
            EShapePointsStyle.DOTTED_MASK |
            EShapePointsStyle.DASHED_MASK;
        var deprecated = style & mask;
        if (deprecated) {
            shape.points.style &= ~mask;
            shape.stroke.style |= deprecated;
        }
        return result;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadShapeBar = function () {
        EShapeUploadeds[EShapeType.BAR] = createBarUploaded;
        EShapeDeserializers[EShapeType.BAR] = deserializeBar;
    };

    var RECTANGLE_ROUNDED_VERTEX_COUNT = 44;
    var RECTANGLE_ROUNDED_INDEX_COUNT = 24;
    var RECTANGLE_ROUNDED_WORLD_SIZE = [
        0, 0, 0, 0, 0
    ];
    var RECTANGLE_ROUNDED_WORK_POINT = new pixi_js.Point();
    var buildRectangleRoundedIndex = function (indices, voffset, ioffset) {
        // c0   c1        c4   c5
        //  |---|          |---|
        //  |   |          |   |
        //  |---|          |---|
        // c2   c3        c6   c7
        //
        // c8   c9       c12   c13
        //  |---|          |---|
        //  |   |          |   |
        //  |---|          |---|
        //c10   c11      c14   c15
        var ii = ioffset * 3 - 1;
        indices[++ii] = voffset + 0;
        indices[++ii] = voffset + 1;
        indices[++ii] = voffset + 2;
        indices[++ii] = voffset + 2;
        indices[++ii] = voffset + 1;
        indices[++ii] = voffset + 3;
        indices[++ii] = voffset + 4;
        indices[++ii] = voffset + 5;
        indices[++ii] = voffset + 6;
        indices[++ii] = voffset + 6;
        indices[++ii] = voffset + 5;
        indices[++ii] = voffset + 7;
        indices[++ii] = voffset + 8;
        indices[++ii] = voffset + 9;
        indices[++ii] = voffset + 10;
        indices[++ii] = voffset + 10;
        indices[++ii] = voffset + 9;
        indices[++ii] = voffset + 11;
        indices[++ii] = voffset + 12;
        indices[++ii] = voffset + 13;
        indices[++ii] = voffset + 14;
        indices[++ii] = voffset + 14;
        indices[++ii] = voffset + 13;
        indices[++ii] = voffset + 15;
        //     16  17  23  24
        //      |---|  |---|
        //      |   |  |   |
        // 18--19--20  25--26--27
        //  |       |  |       |
        //  |       |  |       |
        // 21------22  28------29
        indices[++ii] = voffset + 16;
        indices[++ii] = voffset + 17;
        indices[++ii] = voffset + 19;
        indices[++ii] = voffset + 19;
        indices[++ii] = voffset + 17;
        indices[++ii] = voffset + 20;
        indices[++ii] = voffset + 18;
        indices[++ii] = voffset + 20;
        indices[++ii] = voffset + 21;
        indices[++ii] = voffset + 21;
        indices[++ii] = voffset + 20;
        indices[++ii] = voffset + 22;
        indices[++ii] = voffset + 23;
        indices[++ii] = voffset + 24;
        indices[++ii] = voffset + 25;
        indices[++ii] = voffset + 25;
        indices[++ii] = voffset + 24;
        indices[++ii] = voffset + 26;
        indices[++ii] = voffset + 25;
        indices[++ii] = voffset + 27;
        indices[++ii] = voffset + 28;
        indices[++ii] = voffset + 28;
        indices[++ii] = voffset + 27;
        indices[++ii] = voffset + 29;
        // 30------31  37------38
        //  |       |  |       |
        //  |       |  |       |
        // 32--33--34  39--40--41
        //      |   |  |   |
        //      |---|  |---|
        //     35  36  42  43
        indices[++ii] = voffset + 30;
        indices[++ii] = voffset + 31;
        indices[++ii] = voffset + 32;
        indices[++ii] = voffset + 32;
        indices[++ii] = voffset + 31;
        indices[++ii] = voffset + 34;
        indices[++ii] = voffset + 33;
        indices[++ii] = voffset + 34;
        indices[++ii] = voffset + 35;
        indices[++ii] = voffset + 35;
        indices[++ii] = voffset + 34;
        indices[++ii] = voffset + 36;
        indices[++ii] = voffset + 37;
        indices[++ii] = voffset + 38;
        indices[++ii] = voffset + 39;
        indices[++ii] = voffset + 39;
        indices[++ii] = voffset + 38;
        indices[++ii] = voffset + 41;
        indices[++ii] = voffset + 39;
        indices[++ii] = voffset + 40;
        indices[++ii] = voffset + 42;
        indices[++ii] = voffset + 42;
        indices[++ii] = voffset + 40;
        indices[++ii] = voffset + 43;
    };
    var buildRectangleRoundedVertex = function (vertices, voffset, originX, originY, sizeX, sizeY, strokeAlign, strokeWidth, radius, internalTransform, worldSize) {
        // b0      b1      b2
        // |-------|-------|
        // |       |       |
        // b3------b4------b5
        // |       |       |
        // |-------|-------|
        // b6      b7      b8
        var s = strokeAlign * strokeWidth;
        var sx = sizeX * 0.5 + (0 <= sizeX ? +s : -s);
        var sy = sizeY * 0.5 + (0 <= sizeY ? +s : -s);
        var ax = Math.abs(sx);
        var ay = Math.abs(sy);
        var a = radius * Math.min(ax, ay);
        var rx = a / ax;
        var ry = a / ay;
        var work = RECTANGLE_ROUNDED_WORK_POINT;
        work.set(originX - sx, originY - sy);
        internalTransform.apply(work, work);
        var b0x = work.x;
        var b0y = work.y;
        work.set(originX, originY - sy);
        internalTransform.apply(work, work);
        var b1x = work.x;
        var b1y = work.y;
        work.set(originX - sx, originY);
        internalTransform.apply(work, work);
        var b3x = work.x;
        var b3y = work.y;
        var d01x = b1x - b0x;
        var d01y = b1y - b0y;
        var d03x = b3x - b0x;
        var d03y = b3y - b0y;
        var b2x = b1x + d01x;
        var b2y = b1y + d01y;
        var b4x = b3x + d01x;
        var b4y = b3y + d01y;
        var b5x = b2x + d03x;
        var b5y = b2y + d03y;
        var b6x = b3x + d03x;
        var b6y = b3y + d03y;
        var b7x = b6x + d01x;
        var b7y = b6y + d01y;
        var b8x = b7x + d01x;
        var b8y = b7y + d01y;
        var r01x = rx * d01x;
        var r01y = rx * d01y;
        var r03x = ry * d03x;
        var r03y = ry * d03y;
        // c0   c1        c4   c5
        //  |---|          |---|
        //  |   |          |   |
        //  |---|          |---|
        // c2   c3        c6   c7
        //
        // c8   c9       c12   c13
        //  |---|          |---|
        //  |   |          |   |
        //  |---|          |---|
        //c10   c11      c14   c15
        var c0x = b0x;
        var c0y = b0y;
        var c1x = c0x + r01x;
        var c1y = c0y + r01y;
        var c2x = c0x + r03x;
        var c2y = c0y + r03y;
        var c3x = c2x + r01x;
        var c3y = c2y + r01y;
        var iv = voffset * 2 - 1;
        vertices[++iv] = c0x;
        vertices[++iv] = c0y;
        vertices[++iv] = c1x;
        vertices[++iv] = c1y;
        vertices[++iv] = c2x;
        vertices[++iv] = c2y;
        vertices[++iv] = c3x;
        vertices[++iv] = c3y;
        var c5x = b2x;
        var c5y = b2y;
        var c4x = b2x - r01x;
        var c4y = b2y - r01y;
        var c6x = c4x + r03x;
        var c6y = c4y + r03y;
        var c7x = c6x + r01x;
        var c7y = c6y + r01y;
        vertices[++iv] = c4x;
        vertices[++iv] = c4y;
        vertices[++iv] = c5x;
        vertices[++iv] = c5y;
        vertices[++iv] = c6x;
        vertices[++iv] = c6y;
        vertices[++iv] = c7x;
        vertices[++iv] = c7y;
        var c10x = b6x;
        var c10y = b6y;
        var c8x = c10x - r03x;
        var c8y = c10y - r03y;
        var c11x = c10x + r01x;
        var c11y = c10y + r01y;
        var c9x = c8x + r01x;
        var c9y = c8y + r01y;
        vertices[++iv] = c8x;
        vertices[++iv] = c8y;
        vertices[++iv] = c9x;
        vertices[++iv] = c9y;
        vertices[++iv] = c10x;
        vertices[++iv] = c10y;
        vertices[++iv] = c11x;
        vertices[++iv] = c11y;
        var c15x = b8x;
        var c15y = b8y;
        var c14x = c15x - r01x;
        var c14y = c15y - r01y;
        var c13x = c15x - r03x;
        var c13y = c15y - r03y;
        var c12x = c13x - r01x;
        var c12y = c13y - r01y;
        vertices[++iv] = c12x;
        vertices[++iv] = c12y;
        vertices[++iv] = c13x;
        vertices[++iv] = c13y;
        vertices[++iv] = c14x;
        vertices[++iv] = c14y;
        vertices[++iv] = c15x;
        vertices[++iv] = c15y;
        //     16  17  23  24
        //      |---|  |---|
        //      |   |  |   |
        // 18--19--20  25--26--27
        //  |       |  |       |
        //  |       |  |       |
        // 21------22  28------29
        var c16x = c1x;
        var c16y = c1y;
        var c17x = b1x;
        var c17y = b1y;
        var c18x = c2x;
        var c18y = c2y;
        var c19x = c3x;
        var c19y = c3y;
        var c20x = c17x + r03x;
        var c20y = c17y + r03y;
        var c21x = b3x;
        var c21y = b3y;
        var c22x = b4x;
        var c22y = b4y;
        vertices[++iv] = c16x;
        vertices[++iv] = c16y;
        vertices[++iv] = c17x;
        vertices[++iv] = c17y;
        vertices[++iv] = c18x;
        vertices[++iv] = c18y;
        vertices[++iv] = c19x;
        vertices[++iv] = c19y;
        vertices[++iv] = c20x;
        vertices[++iv] = c20y;
        vertices[++iv] = c21x;
        vertices[++iv] = c21y;
        vertices[++iv] = c22x;
        vertices[++iv] = c22y;
        var c23x = c17x;
        var c23y = c17y;
        var c24x = c4x;
        var c24y = c4y;
        var c25x = c20x;
        var c25y = c20y;
        var c26x = c6x;
        var c26y = c6y;
        var c27x = c7x;
        var c27y = c7y;
        var c28x = c22x;
        var c28y = c22y;
        var c29x = b5x;
        var c29y = b5y;
        vertices[++iv] = c23x;
        vertices[++iv] = c23y;
        vertices[++iv] = c24x;
        vertices[++iv] = c24y;
        vertices[++iv] = c25x;
        vertices[++iv] = c25y;
        vertices[++iv] = c26x;
        vertices[++iv] = c26y;
        vertices[++iv] = c27x;
        vertices[++iv] = c27y;
        vertices[++iv] = c28x;
        vertices[++iv] = c28y;
        vertices[++iv] = c29x;
        vertices[++iv] = c29y;
        // 30------31  37------38
        //  |       |  |       |
        //  |       |  |       |
        // 32--33--34  39--40--41
        //      |   |  |   |
        //      |---|  |---|
        //     35  36  42  43
        var c30x = c21x;
        var c30y = c21y;
        var c31x = c22x;
        var c31y = c22y;
        var c32x = c8x;
        var c32y = c8y;
        var c33x = c9x;
        var c33y = c9y;
        var c34x = b7x - r03x;
        var c34y = b7y - r03y;
        var c35x = c11x;
        var c35y = c11y;
        var c36x = b7x;
        var c36y = b7y;
        vertices[++iv] = c30x;
        vertices[++iv] = c30y;
        vertices[++iv] = c31x;
        vertices[++iv] = c31y;
        vertices[++iv] = c32x;
        vertices[++iv] = c32y;
        vertices[++iv] = c33x;
        vertices[++iv] = c33y;
        vertices[++iv] = c34x;
        vertices[++iv] = c34y;
        vertices[++iv] = c35x;
        vertices[++iv] = c35y;
        vertices[++iv] = c36x;
        vertices[++iv] = c36y;
        var c37x = c31x;
        var c37y = c31y;
        var c38x = c29x;
        var c38y = c29y;
        var c39x = c34x;
        var c39y = c34y;
        var c40x = c12x;
        var c40y = c12y;
        var c41x = c13x;
        var c41y = c13y;
        var c42x = c36x;
        var c42y = c36y;
        var c43x = c14x;
        var c43y = c14y;
        vertices[++iv] = c37x;
        vertices[++iv] = c37y;
        vertices[++iv] = c38x;
        vertices[++iv] = c38y;
        vertices[++iv] = c39x;
        vertices[++iv] = c39y;
        vertices[++iv] = c40x;
        vertices[++iv] = c40y;
        vertices[++iv] = c41x;
        vertices[++iv] = c41y;
        vertices[++iv] = c42x;
        vertices[++iv] = c42y;
        vertices[++iv] = c43x;
        vertices[++iv] = c43y;
        // World size
        worldSize[0] = ax;
        worldSize[1] = ay;
        worldSize[2] = a;
        worldSize[3] = rx;
        worldSize[4] = ry;
    };
    var buildRectangleRoundedStep = function (steps, voffset, strokeWidth, strokeSide, strokeStyle, corner, worldSize) {
        var scaleInvariant = toScaleInvariant(strokeStyle);
        var ax = worldSize[0];
        var ay = worldSize[1];
        var a = worldSize[2];
        var wt = strokeSide & EShapeStrokeSide.TOP ? 1 : 0;
        var wr = strokeSide & EShapeStrokeSide.RIGHT ? 1 : 0;
        var wb = strokeSide & EShapeStrokeSide.BOTTOM ? 1 : 0;
        var wl = strokeSide & EShapeStrokeSide.LEFT ? 1 : 0;
        var elt0 = toPackedI4x64(0, scaleInvariant, wl, wt);
        var ert0 = toPackedI4x64(0, scaleInvariant, wr, wt);
        var elb0 = toPackedI4x64(0, scaleInvariant, wl, wb);
        var erb0 = toPackedI4x64(0, scaleInvariant, wr, wb);
        var elt1 = toPackedI4x64(1, scaleInvariant, wl, wt);
        var ert1 = toPackedI4x64(1, scaleInvariant, wr, wt);
        var elb1 = toPackedI4x64(1, scaleInvariant, wl, wb);
        var erb1 = toPackedI4x64(1, scaleInvariant, wr, wb);
        var rxi = 1 - worldSize[3];
        var ryi = 1 - worldSize[4];
        var c11 = toPackedF2x1024(1, 1);
        var c01 = toPackedF2x1024(0, 1);
        var c10 = toPackedF2x1024(1, 0);
        var c00 = toPackedF2x1024(0, 0);
        var cx1 = toPackedF2x1024(rxi, 1);
        var c1y = toPackedF2x1024(1, ryi);
        var cxy = toPackedF2x1024(rxi, ryi);
        var c0y = toPackedF2x1024(0, ryi);
        // c0   c1        c4   c5
        //  |---|          |---|
        //  |   |          |   |
        //  |---|          |---|
        // c2   c3        c6   c7
        //
        // c8   c9       c12   c13
        //  |---|          |---|
        //  |   |          |   |
        //  |---|          |---|
        //c10   c11      c14   c15
        var is = voffset * 6 - 1;
        if (corner & EShapeCorner.TOP_LEFT) {
            steps[++is] = strokeWidth;
            steps[++is] = elt1;
            steps[++is] = a;
            steps[++is] = a;
            steps[++is] = c11;
            steps[++is] = 0;
            steps[++is] = strokeWidth;
            steps[++is] = elt1;
            steps[++is] = a;
            steps[++is] = a;
            steps[++is] = c01;
            steps[++is] = 0;
            steps[++is] = strokeWidth;
            steps[++is] = elt1;
            steps[++is] = a;
            steps[++is] = a;
            steps[++is] = c10;
            steps[++is] = 0;
            steps[++is] = strokeWidth;
            steps[++is] = elt1;
            steps[++is] = a;
            steps[++is] = a;
            steps[++is] = c00;
            steps[++is] = 0;
        }
        else {
            steps[++is] = strokeWidth;
            steps[++is] = elt0;
            steps[++is] = ax;
            steps[++is] = ay;
            steps[++is] = c11;
            steps[++is] = 0;
            steps[++is] = strokeWidth;
            steps[++is] = elt0;
            steps[++is] = ax;
            steps[++is] = ay;
            steps[++is] = cx1;
            steps[++is] = 0;
            steps[++is] = strokeWidth;
            steps[++is] = elt0;
            steps[++is] = ax;
            steps[++is] = ay;
            steps[++is] = c1y;
            steps[++is] = 0;
            steps[++is] = strokeWidth;
            steps[++is] = elt0;
            steps[++is] = ax;
            steps[++is] = ay;
            steps[++is] = cxy;
            steps[++is] = 0;
        }
        if (corner & EShapeCorner.TOP_RIGHT) {
            steps[++is] = strokeWidth;
            steps[++is] = ert1;
            steps[++is] = a;
            steps[++is] = a;
            steps[++is] = c01;
            steps[++is] = 0;
            steps[++is] = strokeWidth;
            steps[++is] = ert1;
            steps[++is] = a;
            steps[++is] = a;
            steps[++is] = c11;
            steps[++is] = 0;
            steps[++is] = strokeWidth;
            steps[++is] = ert1;
            steps[++is] = a;
            steps[++is] = a;
            steps[++is] = c00;
            steps[++is] = 0;
            steps[++is] = strokeWidth;
            steps[++is] = ert1;
            steps[++is] = a;
            steps[++is] = a;
            steps[++is] = c10;
            steps[++is] = 0;
        }
        else {
            steps[++is] = strokeWidth;
            steps[++is] = ert0;
            steps[++is] = ax;
            steps[++is] = ay;
            steps[++is] = cx1;
            steps[++is] = 0;
            steps[++is] = strokeWidth;
            steps[++is] = ert0;
            steps[++is] = ax;
            steps[++is] = ay;
            steps[++is] = c11;
            steps[++is] = 0;
            steps[++is] = strokeWidth;
            steps[++is] = ert0;
            steps[++is] = ax;
            steps[++is] = ay;
            steps[++is] = cxy;
            steps[++is] = 0;
            steps[++is] = strokeWidth;
            steps[++is] = ert0;
            steps[++is] = ax;
            steps[++is] = ay;
            steps[++is] = c1y;
            steps[++is] = 0;
        }
        if (corner & EShapeCorner.BOTTOM_LEFT) {
            steps[++is] = strokeWidth;
            steps[++is] = elb1;
            steps[++is] = a;
            steps[++is] = a;
            steps[++is] = c10;
            steps[++is] = 0;
            steps[++is] = strokeWidth;
            steps[++is] = elb1;
            steps[++is] = a;
            steps[++is] = a;
            steps[++is] = c00;
            steps[++is] = 0;
            steps[++is] = strokeWidth;
            steps[++is] = elb1;
            steps[++is] = a;
            steps[++is] = a;
            steps[++is] = c11;
            steps[++is] = 0;
            steps[++is] = strokeWidth;
            steps[++is] = elb1;
            steps[++is] = a;
            steps[++is] = a;
            steps[++is] = c01;
            steps[++is] = 0;
        }
        else {
            steps[++is] = strokeWidth;
            steps[++is] = elb0;
            steps[++is] = ax;
            steps[++is] = ay;
            steps[++is] = c1y;
            steps[++is] = 0;
            steps[++is] = strokeWidth;
            steps[++is] = elb0;
            steps[++is] = ax;
            steps[++is] = ay;
            steps[++is] = cxy;
            steps[++is] = 0;
            steps[++is] = strokeWidth;
            steps[++is] = elb0;
            steps[++is] = ax;
            steps[++is] = ay;
            steps[++is] = c11;
            steps[++is] = 0;
            steps[++is] = strokeWidth;
            steps[++is] = elb0;
            steps[++is] = ax;
            steps[++is] = ay;
            steps[++is] = cx1;
            steps[++is] = 0;
        }
        if (corner & EShapeCorner.BOTTOM_RIGHT) {
            steps[++is] = strokeWidth;
            steps[++is] = erb1;
            steps[++is] = a;
            steps[++is] = a;
            steps[++is] = c00;
            steps[++is] = 0;
            steps[++is] = strokeWidth;
            steps[++is] = erb1;
            steps[++is] = a;
            steps[++is] = a;
            steps[++is] = c10;
            steps[++is] = 0;
            steps[++is] = strokeWidth;
            steps[++is] = erb1;
            steps[++is] = a;
            steps[++is] = a;
            steps[++is] = c01;
            steps[++is] = 0;
            steps[++is] = strokeWidth;
            steps[++is] = erb1;
            steps[++is] = a;
            steps[++is] = a;
            steps[++is] = c11;
            steps[++is] = 0;
        }
        else {
            steps[++is] = strokeWidth;
            steps[++is] = erb0;
            steps[++is] = ax;
            steps[++is] = ay;
            steps[++is] = cxy;
            steps[++is] = 0;
            steps[++is] = strokeWidth;
            steps[++is] = erb0;
            steps[++is] = ax;
            steps[++is] = ay;
            steps[++is] = c1y;
            steps[++is] = 0;
            steps[++is] = strokeWidth;
            steps[++is] = erb0;
            steps[++is] = ax;
            steps[++is] = ay;
            steps[++is] = cx1;
            steps[++is] = 0;
            steps[++is] = strokeWidth;
            steps[++is] = erb0;
            steps[++is] = ax;
            steps[++is] = ay;
            steps[++is] = c11;
            steps[++is] = 0;
        }
        //     16  17  23  24
        //      |---|  |---|
        //      |   |  |   |
        // 18--19--20  25--26--27
        //  |       |  |       |
        //  |       |  |       |
        // 21------22  28------29
        steps[++is] = strokeWidth;
        steps[++is] = elt0;
        steps[++is] = ax;
        steps[++is] = ay;
        steps[++is] = cx1;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = elt0;
        steps[++is] = ax;
        steps[++is] = ay;
        steps[++is] = c01;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = elt0;
        steps[++is] = ax;
        steps[++is] = ay;
        steps[++is] = c1y;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = elt0;
        steps[++is] = ax;
        steps[++is] = ay;
        steps[++is] = cxy;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = elt0;
        steps[++is] = ax;
        steps[++is] = ay;
        steps[++is] = c0y;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = elt0;
        steps[++is] = ax;
        steps[++is] = ay;
        steps[++is] = c10;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = elt0;
        steps[++is] = ax;
        steps[++is] = ay;
        steps[++is] = c00;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = ert0;
        steps[++is] = ax;
        steps[++is] = ay;
        steps[++is] = c01;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = ert0;
        steps[++is] = ax;
        steps[++is] = ay;
        steps[++is] = cx1;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = ert0;
        steps[++is] = ax;
        steps[++is] = ay;
        steps[++is] = c0y;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = ert0;
        steps[++is] = ax;
        steps[++is] = ay;
        steps[++is] = cxy;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = ert0;
        steps[++is] = ax;
        steps[++is] = ay;
        steps[++is] = c1y;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = ert0;
        steps[++is] = ax;
        steps[++is] = ay;
        steps[++is] = c00;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = ert0;
        steps[++is] = ax;
        steps[++is] = ay;
        steps[++is] = c10;
        steps[++is] = 0;
        // 30------31  37------38
        //  |       |  |       |
        //  |       |  |       |
        // 32--33--34  39--40--41
        //      |   |  |   |
        //      |---|  |---|
        //     35  36  42  43
        steps[++is] = strokeWidth;
        steps[++is] = elb0;
        steps[++is] = ax;
        steps[++is] = ay;
        steps[++is] = c10;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = elb0;
        steps[++is] = ax;
        steps[++is] = ay;
        steps[++is] = c00;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = elb0;
        steps[++is] = ax;
        steps[++is] = ay;
        steps[++is] = c1y;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = elb0;
        steps[++is] = ax;
        steps[++is] = ay;
        steps[++is] = cxy;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = elb0;
        steps[++is] = ax;
        steps[++is] = ay;
        steps[++is] = c0y;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = elb0;
        steps[++is] = ax;
        steps[++is] = ay;
        steps[++is] = cx1;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = elb0;
        steps[++is] = ax;
        steps[++is] = ay;
        steps[++is] = c01;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = erb0;
        steps[++is] = ax;
        steps[++is] = ay;
        steps[++is] = c00;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = erb0;
        steps[++is] = ax;
        steps[++is] = ay;
        steps[++is] = c10;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = erb0;
        steps[++is] = ax;
        steps[++is] = ay;
        steps[++is] = c0y;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = erb0;
        steps[++is] = ax;
        steps[++is] = ay;
        steps[++is] = cxy;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = erb0;
        steps[++is] = ax;
        steps[++is] = ay;
        steps[++is] = c1y;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = erb0;
        steps[++is] = ax;
        steps[++is] = ay;
        steps[++is] = c01;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = erb0;
        steps[++is] = ax;
        steps[++is] = ay;
        steps[++is] = cx1;
        steps[++is] = 0;
    };
    var buildRectangleRoundedUv = function (uvs, voffset, textureUvs, worldSize) {
        // b0      b1      b2
        // |-------|-------|
        // |       |       |
        // b3------b4------b5
        // |       |       |
        // |-------|-------|
        // b6      b7      b8
        var b0x = textureUvs.x0;
        var b0y = textureUvs.y0;
        var b2x = textureUvs.x1;
        var b2y = textureUvs.y1;
        var b8x = textureUvs.x2;
        var b8y = textureUvs.y2;
        var b6x = textureUvs.x3;
        var b6y = textureUvs.y3;
        var b1x = (b0x + b2x) * 0.5;
        var b1y = (b0y + b2y) * 0.5;
        var b3x = (b0x + b6x) * 0.5;
        var b3y = (b0y + b6y) * 0.5;
        var d01x = b1x - b0x;
        var d01y = b1y - b0y;
        var d03x = b3x - b0x;
        var d03y = b3y - b0y;
        var b4x = b3x + d01x;
        var b4y = b3y + d01y;
        var b5x = b2x + d03x;
        var b5y = b2y + d03y;
        var b7x = b6x + d01x;
        var b7y = b6y + d01y;
        var rx = worldSize[3];
        var ry = worldSize[4];
        var r01x = rx * d01x;
        var r01y = rx * d01y;
        var r03x = ry * d03x;
        var r03y = ry * d03y;
        // c0   c1        c4   c5
        //  |---|          |---|
        //  |   |          |   |
        //  |---|          |---|
        // c2   c3        c6   c7
        //
        // c8   c9       c12   c13
        //  |---|          |---|
        //  |   |          |   |
        //  |---|          |---|
        //c10   c11      c14   c15
        var c0x = b0x;
        var c0y = b0y;
        var c1x = c0x + r01x;
        var c1y = c0y + r01y;
        var c2x = c0x + r03x;
        var c2y = c0y + r03y;
        var c3x = c2x + r01x;
        var c3y = c2y + r01y;
        var iuv = voffset * 2 - 1;
        uvs[++iuv] = c0x;
        uvs[++iuv] = c0y;
        uvs[++iuv] = c1x;
        uvs[++iuv] = c1y;
        uvs[++iuv] = c2x;
        uvs[++iuv] = c2y;
        uvs[++iuv] = c3x;
        uvs[++iuv] = c3y;
        var c5x = b2x;
        var c5y = b2y;
        var c4x = b2x - r01x;
        var c4y = b2y - r01y;
        var c6x = c4x + r03x;
        var c6y = c4y + r03y;
        var c7x = c6x + r01x;
        var c7y = c6y + r01y;
        uvs[++iuv] = c4x;
        uvs[++iuv] = c4y;
        uvs[++iuv] = c5x;
        uvs[++iuv] = c5y;
        uvs[++iuv] = c6x;
        uvs[++iuv] = c6y;
        uvs[++iuv] = c7x;
        uvs[++iuv] = c7y;
        var c10x = b6x;
        var c10y = b6y;
        var c8x = c10x - r03x;
        var c8y = c10y - r03y;
        var c11x = c10x + r01x;
        var c11y = c10y + r01y;
        var c9x = c8x + r01x;
        var c9y = c8y + r01y;
        uvs[++iuv] = c8x;
        uvs[++iuv] = c8y;
        uvs[++iuv] = c9x;
        uvs[++iuv] = c9y;
        uvs[++iuv] = c10x;
        uvs[++iuv] = c10y;
        uvs[++iuv] = c11x;
        uvs[++iuv] = c11y;
        var c15x = b8x;
        var c15y = b8y;
        var c14x = c15x - r01x;
        var c14y = c15y - r01y;
        var c13x = c15x - r03x;
        var c13y = c15y - r03y;
        var c12x = c13x - r01x;
        var c12y = c13y - r01y;
        uvs[++iuv] = c12x;
        uvs[++iuv] = c12y;
        uvs[++iuv] = c13x;
        uvs[++iuv] = c13y;
        uvs[++iuv] = c14x;
        uvs[++iuv] = c14y;
        uvs[++iuv] = c15x;
        uvs[++iuv] = c15y;
        //     16  17  23  24
        //      |---|  |---|
        //      |   |  |   |
        // 18--19--20  25--26--27
        //  |       |  |       |
        //  |       |  |       |
        // 21------22  28------29
        var c16x = c1x;
        var c16y = c1y;
        var c17x = b1x;
        var c17y = b1y;
        var c18x = c2x;
        var c18y = c2y;
        var c19x = c3x;
        var c19y = c3y;
        var c20x = c17x + r03x;
        var c20y = c17y + r03y;
        var c21x = b3x;
        var c21y = b3y;
        var c22x = b4x;
        var c22y = b4y;
        uvs[++iuv] = c16x;
        uvs[++iuv] = c16y;
        uvs[++iuv] = c17x;
        uvs[++iuv] = c17y;
        uvs[++iuv] = c18x;
        uvs[++iuv] = c18y;
        uvs[++iuv] = c19x;
        uvs[++iuv] = c19y;
        uvs[++iuv] = c20x;
        uvs[++iuv] = c20y;
        uvs[++iuv] = c21x;
        uvs[++iuv] = c21y;
        uvs[++iuv] = c22x;
        uvs[++iuv] = c22y;
        var c23x = c17x;
        var c23y = c17y;
        var c24x = c4x;
        var c24y = c4y;
        var c25x = c20x;
        var c25y = c20y;
        var c26x = c6x;
        var c26y = c6y;
        var c27x = c7x;
        var c27y = c7y;
        var c28x = c22x;
        var c28y = c22y;
        var c29x = b5x;
        var c29y = b5y;
        uvs[++iuv] = c23x;
        uvs[++iuv] = c23y;
        uvs[++iuv] = c24x;
        uvs[++iuv] = c24y;
        uvs[++iuv] = c25x;
        uvs[++iuv] = c25y;
        uvs[++iuv] = c26x;
        uvs[++iuv] = c26y;
        uvs[++iuv] = c27x;
        uvs[++iuv] = c27y;
        uvs[++iuv] = c28x;
        uvs[++iuv] = c28y;
        uvs[++iuv] = c29x;
        uvs[++iuv] = c29y;
        // 30------31  37------38
        //  |       |  |       |
        //  |       |  |       |
        // 32--33--34  39--40--41
        //      |   |  |   |
        //      |---|  |---|
        //     35  36  42  43
        var c30x = c21x;
        var c30y = c21y;
        var c31x = c22x;
        var c31y = c22y;
        var c32x = c8x;
        var c32y = c8y;
        var c33x = c9x;
        var c33y = c9y;
        var c34x = b7x - r03x;
        var c34y = b7y - r03y;
        var c35x = c11x;
        var c35y = c11y;
        var c36x = b7x;
        var c36y = b7y;
        uvs[++iuv] = c30x;
        uvs[++iuv] = c30y;
        uvs[++iuv] = c31x;
        uvs[++iuv] = c31y;
        uvs[++iuv] = c32x;
        uvs[++iuv] = c32y;
        uvs[++iuv] = c33x;
        uvs[++iuv] = c33y;
        uvs[++iuv] = c34x;
        uvs[++iuv] = c34y;
        uvs[++iuv] = c35x;
        uvs[++iuv] = c35y;
        uvs[++iuv] = c36x;
        uvs[++iuv] = c36y;
        var c37x = c31x;
        var c37y = c31y;
        var c38x = c29x;
        var c38y = c29y;
        var c39x = c34x;
        var c39y = c34y;
        var c40x = c12x;
        var c40y = c12y;
        var c41x = c13x;
        var c41y = c13y;
        var c42x = c36x;
        var c42y = c36y;
        var c43x = c14x;
        var c43y = c14y;
        uvs[++iuv] = c37x;
        uvs[++iuv] = c37y;
        uvs[++iuv] = c38x;
        uvs[++iuv] = c38y;
        uvs[++iuv] = c39x;
        uvs[++iuv] = c39y;
        uvs[++iuv] = c40x;
        uvs[++iuv] = c40y;
        uvs[++iuv] = c41x;
        uvs[++iuv] = c41y;
        uvs[++iuv] = c42x;
        uvs[++iuv] = c42y;
        uvs[++iuv] = c43x;
        uvs[++iuv] = c43y;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var BuilderRectangleRounded = /** @class */ (function (_super) {
        __extends(BuilderRectangleRounded, _super);
        function BuilderRectangleRounded(buffer, vertexOffset, indexOffset) {
            var _this = _super.call(this, buffer, vertexOffset, indexOffset, RECTANGLE_ROUNDED_VERTEX_COUNT, RECTANGLE_ROUNDED_INDEX_COUNT) || this;
            _this.radius = 0;
            _this.corner = 0;
            return _this;
        }
        BuilderRectangleRounded.prototype.init = function () {
            var buffer = this.buffer;
            buffer.updateIndices();
            buildRectangleRoundedIndex(buffer.indices, this.vertexOffset, this.indexOffset);
            this.inited |= BuilderFlag.INDEX;
        };
        BuilderRectangleRounded.prototype.update = function (shape) {
            var buffer = this.buffer;
            this.updateVertexStepAndUv(buffer, shape);
            this.updateColor(buffer, shape);
        };
        BuilderRectangleRounded.prototype.updateVertexStepAndUv = function (buffer, shape) {
            var size = shape.size;
            var sizeX = size.x;
            var sizeY = size.y;
            var radius = shape.radius;
            var isSizeChanged = sizeX !== this.sizeX || sizeY !== this.sizeY || radius !== this.radius;
            var transformLocalId = toTransformLocalId(shape);
            var isTransformChanged = this.transformLocalId !== transformLocalId;
            var stroke = shape.stroke;
            var strokeAlign = stroke.align;
            var strokeWidth = stroke.enable ? stroke.width : 0;
            var strokeSide = stroke.side;
            var strokeStyle = stroke.style;
            var isStrokeChanged = this.strokeAlign !== strokeAlign ||
                this.strokeWidth !== strokeWidth ||
                this.strokeSide !== strokeSide ||
                this.strokeStyle !== strokeStyle;
            var corner = shape.corner;
            var isCornerChanged = corner !== this.corner;
            var texture = toTexture(shape);
            var textureTransformId = toTextureTransformId(texture);
            var isTextureChanged = texture !== this.texture || textureTransformId !== this.textureTransformId;
            var isVertexChanged = isSizeChanged || isStrokeChanged;
            var isNotInited = !(this.inited & BuilderFlag.VERTEX_STEP_AND_UV);
            if (isNotInited ||
                isVertexChanged ||
                isTransformChanged ||
                isCornerChanged ||
                isTextureChanged) {
                this.inited |= BuilderFlag.VERTEX_STEP_AND_UV;
                this.sizeX = sizeX;
                this.sizeY = sizeY;
                this.radius = radius;
                this.transformLocalId = transformLocalId;
                this.strokeAlign = strokeAlign;
                this.strokeWidth = strokeWidth;
                this.strokeSide = strokeSide;
                this.strokeStyle = strokeStyle;
                this.corner = corner;
                this.texture = texture;
                this.textureTransformId = textureTransformId;
                // Vertices
                var voffset = this.vertexOffset;
                buffer.updateVertices();
                buildRectangleRoundedVertex(buffer.vertices, voffset, 0, 0, sizeX, sizeY, strokeAlign, strokeWidth, radius, shape.transform.internalTransform, RECTANGLE_ROUNDED_WORLD_SIZE);
                // Steps
                if (isNotInited || isVertexChanged || isCornerChanged || isTransformChanged) {
                    buffer.updateSteps();
                    buildRectangleRoundedStep(buffer.steps, voffset, strokeWidth, strokeSide, strokeStyle, corner, RECTANGLE_ROUNDED_WORLD_SIZE);
                }
                // UVs
                if (isNotInited || isVertexChanged || isTextureChanged) {
                    buffer.updateUvs();
                    buildRectangleRoundedUv(buffer.uvs, voffset, toTextureUvs(texture), RECTANGLE_ROUNDED_WORLD_SIZE);
                }
            }
        };
        return BuilderRectangleRounded;
    }(BuilderBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var createRectangleRoundedUploaded = function (buffer, shape, voffset, ioffset, antialiasWeight) {
        var tcount = toTextBufferCount(shape);
        var tvcount = tcount << TEXT_VERTEX_COUNT_SHIFT;
        var ticount = tcount << TEXT_INDEX_COUNT_SHIFT;
        var vcount = RECTANGLE_ROUNDED_VERTEX_COUNT + tvcount;
        var icount = RECTANGLE_ROUNDED_INDEX_COUNT + ticount;
        if (buffer.check(voffset, ioffset, vcount, icount)) {
            return new EShapeUploadedImpl(buffer, voffset, ioffset, vcount, icount, [
                new BuilderRectangleRounded(buffer, voffset, ioffset),
                new BuilderText(buffer, voffset + RECTANGLE_ROUNDED_VERTEX_COUNT, ioffset + RECTANGLE_ROUNDED_INDEX_COUNT, tvcount, ticount)
            ]).init(shape);
        }
        return null;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var createButtonUploaded = function (buffer, shape, voffset, ioffset, antialiasWeight) {
        return createRectangleRoundedUploaded(buffer, shape, voffset, ioffset, antialiasWeight);
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var hitTestRectangleRounded_ = function (x, y, ax, ay, r, corner) {
        var bx0 = -ax + r;
        if (x <= bx0) {
            var by0 = -ay + r;
            if (y <= by0 && corner & EShapeCorner.TOP_LEFT) {
                // Top-left corner
                var dx = x - bx0;
                var dy = y - by0;
                return dx * dx + dy * dy <= r * r;
            }
            else {
                var by1 = +ay - r;
                if (by1 <= y && corner & EShapeCorner.BOTTOM_LEFT) {
                    // Bottom-left corner
                    var dx = x - bx0;
                    var dy = y - by1;
                    return dx * dx + dy * dy <= r * r;
                }
                else {
                    // Middle-left box
                    return -ax <= x;
                }
            }
        }
        else {
            var bx1 = +ax - r;
            if (bx1 <= x) {
                var by0 = -ay + r;
                if (y <= by0 && corner & EShapeCorner.TOP_RIGHT) {
                    // Top-right corner
                    var dx = x - bx1;
                    var dy = y - by0;
                    return dx * dx + dy * dy <= r * r;
                }
                else {
                    var by1 = +ay - r;
                    if (by1 <= y && corner & EShapeCorner.BOTTOM_RIGHT) {
                        // Bottom-right corner
                        var dx = x - bx1;
                        var dy = y - by1;
                        return dx * dx + dy * dy <= r * r;
                    }
                    else {
                        // Middle-right box
                        return x <= +ax;
                    }
                }
            }
            else {
                return -ay <= y && y <= +ay;
            }
        }
    };
    var hitTestRectangleRounded = function (shape, x, y, ax, ay, sw, ss) {
        var fill = shape.fill;
        if (fill.enable || 0 < sw) {
            var r = shape.radius * Math.min(ax, ay);
            var corner = shape.corner;
            if (hitTestRectangleRounded_(x, y, ax, ay, r, corner)) {
                if (fill.enable) {
                    return true;
                }
                else {
                    var s = sw * ss;
                    var wx = Math.max(0.0, ax - s);
                    var wy = Math.max(0.0, ay - s);
                    var wr = Math.max(0.0, r - s);
                    if (!hitTestRectangleRounded_(x, y, wx, wy, wr, corner)) {
                        var strokeSide = shape.stroke.side;
                        if (strokeSide === EShapeStrokeSide.ALL) {
                            return true;
                        }
                        else {
                            if (x <= -wx + wr) {
                                var hasLeftSide = !!(strokeSide & EShapeStrokeSide.LEFT);
                                if (y <= -wy + wr) {
                                    var hasTopSide = !!(strokeSide & EShapeStrokeSide.TOP);
                                    if (hasTopSide && hasLeftSide) {
                                        return true;
                                    }
                                    else if (hasTopSide) {
                                        return -wx <= y;
                                    }
                                    else if (hasLeftSide) {
                                        return x <= -wx;
                                    }
                                    else {
                                        return false;
                                    }
                                }
                                else if (+wy - wr <= y) {
                                    var hasBottomSide = !!(strokeSide & EShapeStrokeSide.BOTTOM);
                                    if (hasBottomSide && hasLeftSide) {
                                        return true;
                                    }
                                    else if (hasBottomSide) {
                                        return +wx <= y;
                                    }
                                    else if (hasLeftSide) {
                                        return x <= -wx;
                                    }
                                    else {
                                        return false;
                                    }
                                }
                                else {
                                    return hasLeftSide;
                                }
                            }
                            else if (+wx - wr <= x) {
                                var hasRightSide = !!(strokeSide & EShapeStrokeSide.RIGHT);
                                if (y <= -wy + wr) {
                                    var hasTopSide = !!(strokeSide & EShapeStrokeSide.TOP);
                                    if (hasTopSide && hasRightSide) {
                                        return true;
                                    }
                                    else if (hasTopSide) {
                                        return -wx <= y;
                                    }
                                    else if (hasRightSide) {
                                        return +wx <= x;
                                    }
                                    else {
                                        return false;
                                    }
                                }
                                else if (+wy - wr <= y) {
                                    var hasBottomSide = !!(strokeSide & EShapeStrokeSide.BOTTOM);
                                    if (hasBottomSide && hasRightSide) {
                                        return true;
                                    }
                                    else if (hasBottomSide) {
                                        return +wx <= y;
                                    }
                                    else if (hasRightSide) {
                                        return +wx <= x;
                                    }
                                    else {
                                        return false;
                                    }
                                }
                                else {
                                    return hasRightSide;
                                }
                            }
                            else {
                                if (y <= -wy + wr) {
                                    return !!(strokeSide & EShapeStrokeSide.TOP);
                                }
                                else if (+wy - wr <= y) {
                                    return !!(strokeSide & EShapeStrokeSide.BOTTOM);
                                }
                                else {
                                    return false;
                                }
                            }
                        }
                    }
                }
            }
        }
        return false;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeRectangleRounded = /** @class */ (function (_super) {
        __extends(EShapeRectangleRounded, _super);
        function EShapeRectangleRounded(type) {
            if (type === void 0) { type = EShapeType.RECTANGLE_ROUNDED; }
            return _super.call(this, type) || this;
        }
        EShapeRectangleRounded.prototype.clone = function () {
            return new EShapeRectangleRounded(this.type).copy(this);
        };
        EShapeRectangleRounded.prototype.containsAbs = function (x, y, ax, ay, sw, ss, sa) {
            if (_super.prototype.containsAbsBBox.call(this, x, y, ax, ay)) {
                return hitTestRectangleRounded(this, x, y, ax, ay, sw, ss);
            }
            return false;
        };
        return EShapeRectangleRounded;
    }(EShapePrimitive));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeButton = /** @class */ (function (_super) {
        __extends(EShapeButton, _super);
        function EShapeButton(type) {
            if (type === void 0) { type = EShapeType.BUTTON; }
            var _this = _super.call(this, type) || this;
            _this._isToggle = false;
            _this._isGrouped = false;
            return _this;
        }
        Object.defineProperty(EShapeButton.prototype, "isToggle", {
            get: function () {
                return this._isToggle;
            },
            set: function (isToggle) {
                this._isToggle = isToggle;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeButton.prototype, "isGrouped", {
            /**
             * All the sibling buttons whose `isGrouped` is true is considered to to be grouped.
             */
            get: function () {
                return this._isGrouped;
            },
            set: function (isGrouped) {
                this._isGrouped = isGrouped;
            },
            enumerable: false,
            configurable: true
        });
        EShapeButton.prototype.copy = function (source, part) {
            _super.prototype.copy.call(this, source, part);
            if (source instanceof EShapeButton) {
                this._isToggle = source.isToggle;
                this._isGrouped = source.isGrouped;
            }
            return this;
        };
        EShapeButton.prototype.clone = function () {
            return new EShapeButton(this.type).copy(this);
        };
        EShapeButton.prototype.serialize = function (manager) {
            var result = _super.prototype.serialize.call(this, manager);
            var isToggle = this._isToggle ? 1 : 0;
            var isGrouped = this._isGrouped ? 2 : 0;
            result[15] = manager.addResource("[".concat(isToggle | isGrouped, "]"));
            return result;
        };
        return EShapeButton;
    }(EShapeRectangleRounded));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var deserializeButton = function (item, manager, shape) {
        shape = shape || new EShapeButton();
        var resources = manager.resources;
        var resourceId = item[15];
        if (0 <= resourceId && resourceId < resources.length) {
            var parsed = manager.getExtension(resourceId);
            if (parsed == null) {
                parsed = JSON.parse(resources[resourceId]);
                manager.setExtension(resourceId, parsed);
            }
            shape.isToggle = !!(parsed[0] & 1);
            shape.isGrouped = !!(parsed[0] & 2);
        }
        return deserializeBase(item, manager, shape);
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeButtonRuntimeAction = /** @class */ (function (_super) {
        __extends(EShapeButtonRuntimeAction, _super);
        function EShapeButtonRuntimeAction(runtime) {
            var _this = _super.call(this, EShapeRuntimeReset.COLOR_FILL_AND_STROKE |
                EShapeRuntimeReset.COLOR_TEXT |
                EShapeRuntimeReset.COLOR_TEXT_OUTLINE |
                EShapeRuntimeReset.CURSOR) || this;
            var fill = runtime.fill;
            var fillColor = fill.color;
            var fillColorOnHovered = _this.toOnHovered(fillColor);
            var fillColorOnPressed = fillColorOnHovered * 2;
            _this._fillColor = fillColor;
            _this._fillColorDisabled = UtilRgb.toGrayscale(fillColor);
            _this._fillColorPressed = UtilRgb.darken(fillColor, fillColorOnPressed);
            _this._fillColorHovered = UtilRgb.darken(fillColor, fillColorOnHovered);
            var fillAlpha = fill.alpha;
            _this._fillAlpha = fillAlpha;
            _this._fillAlphaDisabled = fillAlpha * 0.5;
            var stroke = runtime.stroke;
            var strokeColor = stroke.color;
            var strokeColorOnHovered = _this.toOnHovered(strokeColor);
            var strokeColorOnPressed = strokeColorOnHovered * 2;
            _this._strokeColor = strokeColor;
            _this._strokeColorDisabled = UtilRgb.toGrayscale(strokeColor);
            _this._strokeColorPressed = UtilRgb.darken(strokeColor, strokeColorOnPressed);
            _this._strokeColorHovered = UtilRgb.darken(strokeColor, strokeColorOnHovered);
            var strokeAlpha = stroke.alpha;
            _this._strokeAlpha = strokeAlpha;
            _this._strokeAlphaDisabled = strokeAlpha * 0.5;
            var text = runtime.text;
            var textColor = text.color;
            _this._textColor = textColor;
            _this._textColorDisabled = UtilRgb.toGrayscale(textColor);
            var textAlpha = text.alpha;
            _this._textAlpha = textAlpha;
            _this._textAlphaDisabled = textAlpha * 0.5;
            var textOutline = text.outline;
            var textOutlineColor = textOutline.color;
            _this._textOutlineColor = textOutlineColor;
            _this._textOutlineColorDisabled = UtilRgb.toGrayscale(textOutlineColor);
            var textOutlineAlpha = textOutline.alpha;
            _this._textOutlineAlpha = textOutlineAlpha;
            _this._textOutlineAlphaDisabled = textOutlineAlpha * 0.5;
            return _this;
        }
        EShapeButtonRuntimeAction.prototype.toOnHovered = function (color) {
            var luma = UtilRgb.toLuma(color);
            if (128 <= luma) {
                var t = (luma - 128) / 127;
                return +0.15 * (1 - t) + t * 0.03;
            }
            else {
                var t = (127 - luma) / 127;
                return -0.15 * (1 - t) - t * 0.175;
            }
        };
        EShapeButtonRuntimeAction.prototype.execute = function (shape, runtime, time) {
            var state = shape.state;
            shape.fill.set(undefined, this.getFillColor(state), this.getFillAlpha(state));
            shape.stroke.set(undefined, this.getStrokeColor(state), this.getStrokeAlpha(state));
            shape.text.set(undefined, this.getTextColor(state), this.getTextAlpha(state));
            shape.text.outline.set(undefined, this.getTextOutlineColor(state), this.getTextOutlineAlpha(state));
            shape.cursor = this.getCursor(state);
            runtime.written |= this.reset;
        };
        EShapeButtonRuntimeAction.prototype.getFillColor = function (state) {
            if (state.inDisabled) {
                return this._fillColorDisabled;
            }
            else if (state.isPressed || state.isActive) {
                return this._fillColorPressed;
            }
            else if (state.isFocused || state.isHovered) {
                return this._fillColorHovered;
            }
            else {
                return this._fillColor;
            }
        };
        EShapeButtonRuntimeAction.prototype.getFillAlpha = function (state) {
            if (state.inDisabled) {
                return this._fillAlphaDisabled;
            }
            else {
                return this._fillAlpha;
            }
        };
        EShapeButtonRuntimeAction.prototype.getStrokeColor = function (state) {
            if (state.inDisabled) {
                return this._strokeColorDisabled;
            }
            else if (state.isPressed || state.isActive) {
                return this._strokeColorPressed;
            }
            else if (state.isFocused || state.isHovered) {
                return this._strokeColorHovered;
            }
            else {
                return this._strokeColor;
            }
        };
        EShapeButtonRuntimeAction.prototype.getStrokeAlpha = function (state) {
            if (state.inDisabled) {
                return this._strokeAlphaDisabled;
            }
            else {
                return this._strokeAlpha;
            }
        };
        EShapeButtonRuntimeAction.prototype.getTextColor = function (state) {
            if (state.inDisabled) {
                return this._textColorDisabled;
            }
            else {
                return this._textColor;
            }
        };
        EShapeButtonRuntimeAction.prototype.getTextAlpha = function (state) {
            if (state.inDisabled) {
                return this._textAlphaDisabled;
            }
            else {
                return this._textAlpha;
            }
        };
        EShapeButtonRuntimeAction.prototype.getTextOutlineColor = function (state) {
            if (state.inDisabled) {
                return this._textOutlineColorDisabled;
            }
            else {
                return this._textOutlineColor;
            }
        };
        EShapeButtonRuntimeAction.prototype.getTextOutlineAlpha = function (state) {
            if (state.inDisabled) {
                return this._textOutlineAlphaDisabled;
            }
            else {
                return this._textOutlineAlpha;
            }
        };
        EShapeButtonRuntimeAction.prototype.getCursor = function (state) {
            if (state.isActionable) {
                return "pointer";
            }
            return "";
        };
        return EShapeButtonRuntimeAction;
    }(EShapeActionRuntimeBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeButtonRuntimeActionToggle = /** @class */ (function (_super) {
        __extends(EShapeButtonRuntimeActionToggle, _super);
        function EShapeButtonRuntimeActionToggle(runtime) {
            var _this = _super.call(this, EShapeRuntimeReset.COLOR_FILL_AND_STROKE |
                EShapeRuntimeReset.COLOR_TEXT |
                EShapeRuntimeReset.COLOR_TEXT_OUTLINE |
                EShapeRuntimeReset.CURSOR) || this;
            var fill = runtime.fill;
            var fillColorActive = fill.color;
            _this._fillColorActive = fillColorActive;
            var fillColorActiveOnHovered = _this.toOnHovered(fillColorActive);
            var fillColorActiveOnPressed = fillColorActiveOnHovered * 2;
            _this._fillColorActivePressed = UtilRgb.darken(fillColorActive, fillColorActiveOnPressed);
            _this._fillColorActiveHovered = UtilRgb.darken(fillColorActive, fillColorActiveOnHovered);
            var fillColor = 0xe7e5e7;
            _this._fillColor = fillColor;
            var fillColorOnHovered = _this.toOnHovered(fillColor);
            var fillColorOnPressed = fillColorOnHovered * 2;
            _this._fillColorPressed = UtilRgb.darken(fillColor, fillColorOnPressed);
            _this._fillColorHovered = UtilRgb.darken(fillColor, fillColorOnHovered);
            var fillAlpha = fill.alpha;
            _this._fillAlpha = fillAlpha;
            _this._fillAlphaDisabled = fillAlpha * 0.5;
            var stroke = runtime.stroke;
            var strokeColorActive = stroke.color;
            _this._strokeColorActive = strokeColorActive;
            var strokeColorActiveOnHovered = _this.toOnHovered(strokeColorActive);
            var strokeColorActiveOnPressed = strokeColorActiveOnHovered * 2;
            _this._strokeColorActivePressed = UtilRgb.darken(strokeColorActive, strokeColorActiveOnPressed);
            _this._strokeColorActiveHovered = UtilRgb.darken(strokeColorActive, strokeColorActiveOnHovered);
            var strokeColor = 0xe7e5e7;
            _this._strokeColor = strokeColor;
            var strokeColorOnHovered = _this.toOnHovered(strokeColor);
            var strokeColorOnPressed = strokeColorOnHovered * 2;
            _this._strokeColorPressed = UtilRgb.darken(strokeColor, strokeColorOnPressed);
            _this._strokeColorGrayscaleHovered = UtilRgb.darken(strokeColor, strokeColorOnHovered);
            var strokeAlpha = stroke.alpha;
            _this._strokeAlpha = strokeAlpha;
            _this._strokeAlphaDisabled = strokeAlpha * 0.5;
            var text = runtime.text;
            var textColor = text.color;
            _this._textColorActive = textColor;
            _this._textColorDisabled = UtilRgb.toGrayscale(textColor);
            _this._textColor = 0x4f4f4f;
            var textAlpha = text.alpha;
            _this._textAlpha = textAlpha;
            _this._textAlphaDisabled = textAlpha * 0.5;
            var textOutline = text.outline;
            var textOutlineColor = textOutline.color;
            _this._textOutlineColor = textOutlineColor;
            _this._textOutlineColorDisabled = UtilRgb.toGrayscale(textOutlineColor);
            var textOutlineAlpha = textOutline.alpha;
            _this._textOutlineAlpha = textOutlineAlpha;
            _this._textOutlineAlphaDisabled = textOutlineAlpha * 0.5;
            return _this;
        }
        EShapeButtonRuntimeActionToggle.prototype.toOnHovered = function (color) {
            var luma = UtilRgb.toLuma(color);
            if (128 <= luma) {
                var t = (luma - 128) / 127;
                return +0.15 * (1 - t) + t * 0.03;
            }
            else {
                var t = (127 - luma) / 127;
                return -0.15 * (1 - t) - t * 0.175;
            }
        };
        EShapeButtonRuntimeActionToggle.prototype.execute = function (shape, runtime, time) {
            var state = shape.state;
            shape.fill.set(undefined, this.getFillColor(state), this.getFillAlpha(state));
            shape.stroke.set(undefined, this.getStrokeColor(state), this.getStrokeAlpha(state));
            shape.text.set(undefined, this.getTextColor(state), this.getTextAlpha(state));
            shape.text.outline.set(undefined, this.getTextOutlineColor(state), this.getTextOutlineAlpha(state));
            shape.cursor = this.getCursor(state);
            runtime.written |= this.reset;
        };
        EShapeButtonRuntimeActionToggle.prototype.getFillColor = function (state) {
            if (state.inDisabled) {
                return this._fillColor;
            }
            else if (state.isActive) {
                if (state.isPressed) {
                    return this._fillColorActivePressed;
                }
                else if (state.isFocused || state.isHovered) {
                    return this._fillColorActiveHovered;
                }
                else {
                    return this._fillColorActive;
                }
            }
            else {
                if (state.isPressed) {
                    return this._fillColorPressed;
                }
                else if (state.isFocused || state.isHovered) {
                    return this._fillColorHovered;
                }
                else {
                    return this._fillColor;
                }
            }
        };
        EShapeButtonRuntimeActionToggle.prototype.getFillAlpha = function (state) {
            if (state.inDisabled) {
                return this._fillAlphaDisabled;
            }
            else {
                return this._fillAlpha;
            }
        };
        EShapeButtonRuntimeActionToggle.prototype.getStrokeColor = function (state) {
            if (state.inDisabled) {
                return this._strokeColor;
            }
            else if (state.isActive) {
                if (state.isPressed) {
                    return this._strokeColorActivePressed;
                }
                else if (state.isFocused || state.isHovered) {
                    return this._strokeColorActiveHovered;
                }
                else {
                    return this._strokeColorActive;
                }
            }
            else {
                if (state.isPressed) {
                    return this._strokeColorPressed;
                }
                else if (state.isFocused || state.isHovered) {
                    return this._strokeColorGrayscaleHovered;
                }
                else {
                    return this._strokeColor;
                }
            }
        };
        EShapeButtonRuntimeActionToggle.prototype.getStrokeAlpha = function (state) {
            if (state.inDisabled) {
                return this._strokeAlphaDisabled;
            }
            else {
                return this._strokeAlpha;
            }
        };
        EShapeButtonRuntimeActionToggle.prototype.getTextColor = function (state) {
            if (state.inDisabled) {
                return this._textColorDisabled;
            }
            else if (state.isActive) {
                return this._textColorActive;
            }
            else {
                return this._textColor;
            }
        };
        EShapeButtonRuntimeActionToggle.prototype.getTextAlpha = function (state) {
            if (state.inDisabled) {
                return this._textAlphaDisabled;
            }
            else {
                return this._textAlpha;
            }
        };
        EShapeButtonRuntimeActionToggle.prototype.getTextOutlineColor = function (state) {
            if (state.inDisabled) {
                return this._textOutlineColorDisabled;
            }
            else {
                return this._textOutlineColor;
            }
        };
        EShapeButtonRuntimeActionToggle.prototype.getTextOutlineAlpha = function (state) {
            if (state.inDisabled) {
                return this._textOutlineAlphaDisabled;
            }
            else {
                return this._textOutlineAlpha;
            }
        };
        EShapeButtonRuntimeActionToggle.prototype.getCursor = function (state) {
            if (state.isActionable) {
                return "pointer";
            }
            return "";
        };
        return EShapeButtonRuntimeActionToggle;
    }(EShapeActionRuntimeBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeButtonRuntime = /** @class */ (function (_super) {
        __extends(EShapeButtonRuntime, _super);
        function EShapeButtonRuntime(shape) {
            var _this = _super.call(this, shape) || this;
            if (shape instanceof EShapeButton) {
                _this._isToggle = shape.isToggle;
                _this._isGrouped = shape.isGrouped;
            }
            return _this;
        }
        EShapeButtonRuntime.prototype.isActionable = function () {
            return true;
        };
        EShapeButtonRuntime.prototype.initialize = function (shape) {
            this.actions.unshift(this._isToggle
                ? new EShapeButtonRuntimeActionToggle(this)
                : new EShapeButtonRuntimeAction(this));
            _super.prototype.initialize.call(this, shape);
        };
        EShapeButtonRuntime.prototype.onClick = function (shape, e) {
            var state = shape.state;
            var wasClicked = state.isClicked;
            state.lock();
            _super.prototype.onClick.call(this, shape, e);
            if (!wasClicked && state.isClicked) {
                if (this._isToggle) {
                    state.isActive = !state.isActive;
                }
                else {
                    if (!state.isActive) {
                        state.isActivated = true;
                    }
                }
            }
            state.unlock();
        };
        EShapeButtonRuntime.prototype.onStateChange = function (shape, newState, oldState) {
            _super.prototype.onStateChange.call(this, shape, newState, oldState);
            if (this._isToggle && this._isGrouped && newState.is(EShapeState.ACTIVATED)) {
                this.onActivated(shape);
            }
        };
        EShapeButtonRuntime.prototype.onActivated = function (shape) {
            // Deactivate other group buttons
            var parent = shape.parent;
            if (parent != null) {
                var children = parent.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    var child = children[i];
                    if (child !== shape &&
                        child instanceof EShapeButton &&
                        child.isToggle &&
                        child.isGrouped) {
                        child.state.isActive = false;
                    }
                }
            }
        };
        return EShapeButtonRuntime;
    }(EShapeRuntimeImpl));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadShapeButton = function () {
        EShapeUploadeds[EShapeType.BUTTON] = createButtonUploaded;
        EShapeDeserializers[EShapeType.BUTTON] = deserializeButton;
        EShapeRuntimes[EShapeType.BUTTON] = EShapeButtonRuntime;
        EShapeCapabilities.set(EShapeType.BUTTON, EShapeCapability.PRIMITIVE | EShapeCapability.STROKE_SIDE | EShapeCapability.BORDER_RADIUS);
    };

    var CIRCLE_VERTEX_COUNT = 9;
    var CIRCLE_INDEX_COUNT = 8;
    var CIRCLE_WORLD_SIZE = [0, 0];
    var CIRCLE_WORK_POINT = new pixi_js.Point();
    var buildCircleIndex = function (indices, voffset, ioffset) {
        var ii = ioffset * 3 - 1;
        indices[++ii] = voffset;
        indices[++ii] = voffset + 1;
        indices[++ii] = voffset + 3;
        indices[++ii] = voffset + 1;
        indices[++ii] = voffset + 4;
        indices[++ii] = voffset + 3;
        indices[++ii] = voffset + 1;
        indices[++ii] = voffset + 2;
        indices[++ii] = voffset + 4;
        indices[++ii] = voffset + 2;
        indices[++ii] = voffset + 5;
        indices[++ii] = voffset + 4;
        indices[++ii] = voffset + 3;
        indices[++ii] = voffset + 4;
        indices[++ii] = voffset + 6;
        indices[++ii] = voffset + 4;
        indices[++ii] = voffset + 7;
        indices[++ii] = voffset + 6;
        indices[++ii] = voffset + 4;
        indices[++ii] = voffset + 5;
        indices[++ii] = voffset + 7;
        indices[++ii] = voffset + 5;
        indices[++ii] = voffset + 8;
        indices[++ii] = voffset + 7;
    };
    var buildCircleVertex = function (vertices, voffset, originX, originY, sizeX, sizeY, strokeAlign, strokeWidth, internalTransform, worldSize) {
        // Calculate the transformed positions
        //
        //  0       1       2
        // |-------|-------|
        // |3      |4      |5
        // |-------|-------|
        // |6      |7      |8
        // |-------|-------|
        //
        var work = CIRCLE_WORK_POINT;
        var s = strokeAlign * strokeWidth;
        var sx = sizeX * 0.5 + (0 <= sizeX ? +s : -s);
        var sy = sizeY * 0.5 + (0 <= sizeY ? +s : -s);
        work.set(-sx + originX, -sy + originY);
        internalTransform.apply(work, work);
        var x0 = work.x;
        var y0 = work.y;
        work.set(0 + originX, -sy + originY);
        internalTransform.apply(work, work);
        var x1 = work.x;
        var y1 = work.y;
        var dx = x1 - x0;
        var dy = y1 - y0;
        work.set(originX, originY);
        internalTransform.apply(work, work);
        var x4 = work.x;
        var y4 = work.y;
        var x7 = x4 + (x4 - x1);
        var y7 = y4 + (y4 - y1);
        var x3 = x4 - dx;
        var y3 = y4 - dy;
        // Vertices
        var iv = voffset * 2 - 1;
        vertices[++iv] = x0;
        vertices[++iv] = y0;
        vertices[++iv] = x1;
        vertices[++iv] = y1;
        vertices[++iv] = x1 + dx;
        vertices[++iv] = y1 + dy;
        vertices[++iv] = x3;
        vertices[++iv] = y3;
        vertices[++iv] = x4;
        vertices[++iv] = y4;
        vertices[++iv] = x4 + dx;
        vertices[++iv] = y4 + dy;
        vertices[++iv] = x7 - dx;
        vertices[++iv] = y7 - dy;
        vertices[++iv] = x7;
        vertices[++iv] = y7;
        vertices[++iv] = x7 + dx;
        vertices[++iv] = y7 + dy;
        worldSize[0] = toLength(x0, y0, x1, y1);
        worldSize[1] = toLength(x0, y0, x3, y3);
    };
    var buildCircleStep = function (steps, voffset, strokeWidth, strokeStyle, worldSize) {
        var scaleInvariant = toScaleInvariant(strokeStyle);
        var ax = worldSize[0];
        var ay = worldSize[1];
        var e = toPackedI4x64(1, scaleInvariant, 1, 1);
        var c11 = toPackedF2x1024(1, 1);
        var c01 = toPackedF2x1024(0, 1);
        var c10 = toPackedF2x1024(1, 0);
        var c00 = toPackedF2x1024(0, 0);
        var is = voffset * 6 - 1;
        steps[++is] = strokeWidth;
        steps[++is] = e;
        steps[++is] = ax;
        steps[++is] = ay;
        steps[++is] = c11;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = e;
        steps[++is] = ax;
        steps[++is] = ay;
        steps[++is] = c01;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = e;
        steps[++is] = ax;
        steps[++is] = ay;
        steps[++is] = c11;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = e;
        steps[++is] = ax;
        steps[++is] = ay;
        steps[++is] = c10;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = e;
        steps[++is] = ax;
        steps[++is] = ay;
        steps[++is] = c00;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = e;
        steps[++is] = ax;
        steps[++is] = ay;
        steps[++is] = c10;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = e;
        steps[++is] = ax;
        steps[++is] = ay;
        steps[++is] = c11;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = e;
        steps[++is] = ax;
        steps[++is] = ay;
        steps[++is] = c01;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = e;
        steps[++is] = ax;
        steps[++is] = ay;
        steps[++is] = c11;
        steps[++is] = 0;
    };
    var buildCircleUv = function (uvs, voffset, textureUvs) {
        var x0 = textureUvs.x0;
        var x1 = textureUvs.x1;
        var x2 = textureUvs.x2;
        var x3 = textureUvs.x3;
        var y0 = textureUvs.y0;
        var y1 = textureUvs.y1;
        var y2 = textureUvs.y2;
        var y3 = textureUvs.y3;
        // UVs
        var iuv = voffset * 2 - 1;
        uvs[++iuv] = x0;
        uvs[++iuv] = y0;
        uvs[++iuv] = 0.5 * (x0 + x1);
        uvs[++iuv] = 0.5 * (y0 + y1);
        uvs[++iuv] = x1;
        uvs[++iuv] = y1;
        uvs[++iuv] = 0.5 * (x0 + x3);
        uvs[++iuv] = 0.5 * (y0 + y3);
        uvs[++iuv] = 0.5 * (x0 + x2);
        uvs[++iuv] = 0.5 * (y0 + y2);
        uvs[++iuv] = 0.5 * (x1 + x2);
        uvs[++iuv] = 0.5 * (y1 + y2);
        uvs[++iuv] = x3;
        uvs[++iuv] = y3;
        uvs[++iuv] = 0.5 * (x3 + x2);
        uvs[++iuv] = 0.5 * (y3 + y2);
        uvs[++iuv] = x2;
        uvs[++iuv] = y2;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var BuilderCircle = /** @class */ (function (_super) {
        __extends(BuilderCircle, _super);
        function BuilderCircle(buffer, vertexOffset, indexOffset) {
            return _super.call(this, buffer, vertexOffset, indexOffset, CIRCLE_VERTEX_COUNT, CIRCLE_INDEX_COUNT) || this;
        }
        BuilderCircle.prototype.init = function () {
            var buffer = this.buffer;
            buffer.updateIndices();
            var voffset = this.vertexOffset;
            buildCircleIndex(buffer.indices, voffset, this.indexOffset);
            this.inited |= BuilderFlag.INDEX;
        };
        BuilderCircle.prototype.update = function (shape) {
            var buffer = this.buffer;
            this.updateVertexAndStep(buffer, shape);
            this.updateColor(buffer, shape);
            this.updateUv(buffer, shape);
        };
        BuilderCircle.prototype.updateVertexAndStep = function (buffer, shape) {
            var size = shape.size;
            var sizeX = size.x;
            var sizeY = size.y;
            var isSizeChanged = sizeX !== this.sizeX || sizeY !== this.sizeY;
            var transformLocalId = toTransformLocalId(shape);
            var isTransformChanged = this.transformLocalId !== transformLocalId;
            var stroke = shape.stroke;
            var strokeAlign = stroke.align;
            var strokeWidth = stroke.enable ? stroke.width : 0;
            var strokeStyle = stroke.style;
            var isStrokeChanged = this.strokeAlign !== strokeAlign ||
                this.strokeWidth !== strokeWidth ||
                this.strokeStyle !== strokeStyle;
            var isNotInited = !(this.inited & BuilderFlag.VERTEX_AND_STEP);
            if (isNotInited || isSizeChanged || isTransformChanged || isStrokeChanged) {
                this.inited |= BuilderFlag.VERTEX_AND_STEP;
                this.sizeX = sizeX;
                this.sizeY = sizeY;
                this.transformLocalId = transformLocalId;
                this.strokeAlign = strokeAlign;
                this.strokeWidth = strokeWidth;
                this.strokeStyle = strokeStyle;
                // Buffer
                buffer.updateVertices();
                buffer.updateSteps();
                buildCircleVertex(buffer.vertices, this.vertexOffset, 0, 0, sizeX, sizeY, strokeAlign, strokeWidth, shape.transform.internalTransform, CIRCLE_WORLD_SIZE);
                buildCircleStep(buffer.steps, this.vertexOffset, strokeWidth, strokeStyle, CIRCLE_WORLD_SIZE);
            }
        };
        BuilderCircle.prototype.updateUv = function (buffer, shape) {
            var texture = toTexture(shape);
            var textureTransformId = toTextureTransformId(texture);
            var isNotInited = !(this.inited & BuilderFlag.UV);
            if (isNotInited ||
                texture !== this.texture ||
                textureTransformId !== this.textureTransformId) {
                this.inited |= BuilderFlag.UV;
                this.texture = texture;
                this.textureTransformId = textureTransformId;
                buffer.updateUvs();
                var textureUvs = toTextureUvs(texture);
                buildCircleUv(buffer.uvs, this.vertexOffset, textureUvs);
            }
        };
        return BuilderCircle;
    }(BuilderBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var createCircleUploaded = function (buffer, shape, voffset, ioffset, antialiasWeight) {
        var tcount = toTextBufferCount(shape);
        var tvcount = tcount << TEXT_VERTEX_COUNT_SHIFT;
        var ticount = tcount << TEXT_INDEX_COUNT_SHIFT;
        var vcount = CIRCLE_VERTEX_COUNT + tvcount;
        var icount = CIRCLE_INDEX_COUNT + ticount;
        if (buffer.check(voffset, ioffset, vcount, icount)) {
            return new EShapeUploadedImpl(buffer, voffset, ioffset, vcount, icount, [
                new BuilderCircle(buffer, voffset, ioffset),
                new BuilderText(buffer, voffset + CIRCLE_VERTEX_COUNT, ioffset + CIRCLE_INDEX_COUNT, tvcount, ticount)
            ]).init(shape);
        }
        return null;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var deserializeCircle = function (item, manager, shape) {
        return deserializeBase(item, manager, shape || new EShapeCircle());
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadShapeCircle = function () {
        EShapeUploadeds[EShapeType.CIRCLE] = createCircleUploaded;
        EShapeDeserializers[EShapeType.CIRCLE] = deserializeCircle;
    };

    var toVectorLength = function (v) {
        return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
    };

    var LINE_FMIN = 0.00001;
    var LINE_NPREV = [0, 1];
    var LINE_NNEXT = [0, 1];
    var toPointCount = function (points) {
        if (points) {
            return points.formatted.plength;
        }
        return 0;
    };
    var toLinePointCount = function (points) {
        var pointCount = toPointCount(points);
        return ((pointCount >> 4) + (0 < (pointCount & 0xf) ? 1 : 0)) << 4;
    };
    var toLineVertexCount = function (pointCount, isClosed) {
        if (isClosed) {
            return (pointCount << 2) + 2;
        }
        else {
            return pointCount << 2;
        }
    };
    var toLineIndexCount = function (pointCount, isClosed) {
        return toLineVertexCount(pointCount, isClosed) - 2;
    };
    var buildLineIndex = function (indices, voffset, ioffset, icount) {
        var ii = ioffset * 3 - 1;
        var iimax = (ioffset + icount) * 3 - 1;
        var io = voffset;
        for (; ii < iimax;) {
            indices[++ii] = io + 0;
            indices[++ii] = io + 2;
            indices[++ii] = io + 1;
            indices[++ii] = io + 1;
            indices[++ii] = io + 2;
            indices[++ii] = io + 3;
            io += 2;
        }
    };
    var buildLineUv = function (uvs, steps, voffset, vcount, textureUvs, length) {
        var lengthInverse = 1 / Math.max(LINE_FMIN, length);
        var x0 = textureUvs.x0;
        var x1 = textureUvs.x1;
        var x2 = textureUvs.x2;
        var x3 = textureUvs.x3;
        var y0 = textureUvs.y0;
        var y1 = textureUvs.y1;
        var y2 = textureUvs.y2;
        var y3 = textureUvs.y3;
        var dx01 = x1 - x0;
        var dy01 = y1 - y0;
        var dx32 = x2 - x3;
        var dy32 = y2 - y3;
        var iuv = (voffset << 1) - 1;
        var iuvmax = ((voffset + vcount) << 1) - 1;
        var is = voffset * 6 - 9;
        for (; iuv < iuvmax;) {
            var r = steps[(is += 12)] * lengthInverse;
            uvs[++iuv] = x0 + r * dx01;
            uvs[++iuv] = y0 + r * dy01;
            uvs[++iuv] = x3 + r * dx32;
            uvs[++iuv] = y3 + r * dy32;
        }
    };
    var TRANSFORMED_POINT_VALUES;
    var buildLineVertexStep = function (vertices, steps, voffset, vcount, pointCount, pointsClosed, pointValues, pointSegments, strokeWidth, strokeStyle, internalTransform) {
        var transformedPointValues = TRANSFORMED_POINT_VALUES;
        if (transformedPointValues == null) {
            transformedPointValues = [];
            TRANSFORMED_POINT_VALUES = transformedPointValues;
        }
        var a = internalTransform.a;
        var b = internalTransform.b;
        var c = internalTransform.c;
        var d = internalTransform.d;
        var tx = internalTransform.tx;
        var ty = internalTransform.ty;
        for (var i = 0; i < pointCount; ++i) {
            var iv = i << 1;
            var x = pointValues[iv];
            var y = pointValues[iv + 1];
            transformedPointValues[iv] = a * x + c * y + tx;
            transformedPointValues[iv + 1] = b * x + d * y + ty;
        }
        return buildTransformedLineVertexStep(vertices, steps, voffset, vcount, pointCount, pointsClosed, transformedPointValues, pointSegments, strokeWidth, strokeStyle);
    };
    var fillTransformedLineVertexStep = function (iv, vertices, is, steps, px, py, strokeWidth, nprev, nnext, lprev, lnext, llo, e0, e1) {
        var d = toNormalPacked(nprev, nnext);
        var l = Math.min(lprev, lnext);
        vertices[++iv] = px;
        vertices[++iv] = py;
        steps[++is] = strokeWidth;
        steps[++is] = e0;
        steps[++is] = d;
        steps[++is] = llo;
        steps[++is] = llo;
        steps[++is] = l;
        vertices[++iv] = px;
        vertices[++iv] = py;
        steps[++is] = strokeWidth;
        steps[++is] = e1;
        steps[++is] = d;
        steps[++is] = llo;
        steps[++is] = llo;
        steps[++is] = l;
    };
    var buildTransformedLineVertexStep = function (vertices, steps, voffset, vcount, lineVertexCount, lineIsClosed, lineVertices, lineSegments, strokeWidth, strokeStyle) {
        var lineSegmentsLength = lineSegments.length;
        if (0 < lineSegmentsLength) {
            if (lineIsClosed) {
                var lmax = 0;
                var lprev = 0;
                var ivoffset = voffset;
                var iseg = 0;
                var iprevseg = lineSegments[0];
                for (var i = 1; i < lineSegmentsLength; ++i) {
                    iseg = lineSegments[i];
                    if (2 <= iseg - iprevseg) {
                        lprev = buildTransformedLineOpenSegmentVertexStep(vertices, steps, ivoffset, -1, lineVertices, iprevseg, iseg, lineVertexCount, strokeWidth, strokeStyle, lprev);
                        lmax = Math.max(lmax, lprev);
                        ivoffset += toLineVertexCount(iseg - iprevseg, false);
                    }
                    iprevseg = iseg;
                }
                // Last
                iseg = lineSegments[0] + lineVertexCount;
                if (2 <= iseg - iprevseg) {
                    lprev = buildTransformedLineOpenSegmentVertexStep(vertices, steps, ivoffset, voffset + vcount - ivoffset, lineVertices, iprevseg, iseg, lineVertexCount, strokeWidth, strokeStyle, lprev);
                    lmax = Math.max(lmax, lprev);
                    ivoffset += toLineVertexCount(iseg - iprevseg, false);
                }
                else {
                    buildTransformedLineEmptyVertexStep(vertices, steps, ivoffset, voffset + vcount - ivoffset, lineVertices, iprevseg, iseg, lineVertexCount, strokeWidth, strokeStyle, lprev);
                }
                return lmax;
            }
            else {
                var lmax = 0;
                var lprev = 0;
                var ivoffset = voffset;
                // First
                var iseg = lineSegments[0];
                if (2 <= iseg) {
                    lprev = buildTransformedLineOpenSegmentVertexStep(vertices, steps, ivoffset, -1, lineVertices, 0, iseg, lineVertexCount, strokeWidth, strokeStyle, lprev);
                    lmax = Math.max(lmax, lprev);
                    ivoffset += toLineVertexCount(iseg, false);
                }
                // Middle
                var iprevseg = iseg;
                for (var i = 1; i < lineSegmentsLength; ++i) {
                    iseg = lineSegments[i];
                    if (2 <= iseg - iprevseg) {
                        lprev = buildTransformedLineOpenSegmentVertexStep(vertices, steps, ivoffset, -1, lineVertices, iprevseg, iseg, lineVertexCount, strokeWidth, strokeStyle, lprev);
                        lmax = Math.max(lmax, lprev);
                        ivoffset += toLineVertexCount(iseg - iprevseg, false);
                    }
                    iprevseg = iseg;
                }
                // Last
                iseg = lineVertexCount;
                if (2 <= iseg - iprevseg) {
                    lprev = buildTransformedLineOpenSegmentVertexStep(vertices, steps, ivoffset, voffset + vcount - ivoffset, lineVertices, iprevseg, iseg, lineVertexCount, strokeWidth, strokeStyle, lprev);
                    lmax = Math.max(lmax, lprev);
                    ivoffset += toLineVertexCount(iseg - iprevseg, false);
                }
                else {
                    buildTransformedLineEmptyVertexStep(vertices, steps, ivoffset, voffset + vcount - ivoffset, lineVertices, iprevseg, iseg, lineVertexCount, strokeWidth, strokeStyle, lprev);
                }
                return lmax;
            }
        }
        else {
            if (lineIsClosed) {
                return buildTransformedLineClosedSegmentVertexStep(vertices, steps, voffset, vcount, lineVertices, 0, lineVertexCount, lineVertexCount, strokeWidth, strokeStyle);
            }
            else {
                return buildTransformedLineOpenSegmentVertexStep(vertices, steps, voffset, vcount, lineVertices, 0, lineVertexCount, lineVertexCount, strokeWidth, strokeStyle, 0);
            }
        }
    };
    var buildTransformedLineEmptyVertexStep = function (vertices, steps, voffset, vcount, lineVertices, lineVertexFrom, lineVertexTo, lineVertexCount, strokeWidth, strokeStyle, length) {
        if (0 <= vcount) {
            var scaleInvariant = toScaleInvariant(strokeStyle);
            var dash = toDash(strokeStyle);
            var e3 = toPackedI4x64(3, scaleInvariant, dash, 0);
            var e5 = toPackedI4x64(5, scaleInvariant, dash, 0);
            var iv = (voffset << 1) - 1;
            var is = voffset * 6 - 1;
            var ivmax = ((voffset + vcount) << 1) - 1;
            var ifirst = lineVertexFrom % lineVertexCount << 1;
            var px = lineVertices[ifirst];
            var py = lineVertices[ifirst + 1];
            for (; iv < ivmax;) {
                vertices[++iv] = px;
                vertices[++iv] = py;
                steps[++is] = 0;
                steps[++is] = e3;
                steps[++is] = 0;
                steps[++is] = length;
                steps[++is] = length;
                steps[++is] = 0;
                vertices[++iv] = px;
                vertices[++iv] = py;
                steps[++is] = 0;
                steps[++is] = e5;
                steps[++is] = 0;
                steps[++is] = length;
                steps[++is] = length;
                steps[++is] = 0;
            }
        }
        return 0;
    };
    var buildTransformedLineOpenSegmentVertexStep = function (vertices, steps, voffset, vcount, lineVertices, lineVertexFrom, lineVertexTo, lineVertexCount, strokeWidth, strokeStyle, length) {
        var scaleInvariant = toScaleInvariant(strokeStyle);
        var dash = toDash(strokeStyle);
        var e3 = toPackedI4x64(3, scaleInvariant, dash, 0);
        var e4 = toPackedI4x64(4, scaleInvariant, dash, 0);
        var e5 = toPackedI4x64(5, scaleInvariant, dash, 0);
        var e6 = toPackedI4x64(6, scaleInvariant, dash, 0);
        // First segment
        var ifirst = lineVertexFrom % lineVertexCount << 1;
        var px = lineVertices[ifirst];
        var py = lineVertices[ifirst + 1];
        var isecond = (lineVertexFrom + 1) % lineVertexCount << 1;
        var pnextx = lineVertices[isecond];
        var pnexty = lineVertices[isecond + 1];
        var pprevx = px - (pnextx - px);
        var pprevy = py - (pnexty - py);
        var nprev = LINE_NPREV;
        var nnext = LINE_NNEXT;
        toVector(pprevx, pprevy, px, py, nprev);
        toVector(px, py, pnextx, pnexty, nnext);
        var lprev = toVectorLength(nprev);
        var lnext = lprev;
        toNormal(nprev, lprev);
        toNormal(nnext, lnext);
        var iv = (voffset << 1) - 1;
        var is = voffset * 6 - 1;
        var l = 0;
        fillTransformedLineVertexStep(iv, vertices, is, steps, px, py, strokeWidth, nprev, nnext, lprev, lnext, length, e3, e5);
        iv += 4;
        is += 12;
        fillTransformedLineVertexStep(iv, vertices, is, steps, px, py, strokeWidth, nprev, nnext, lprev, lnext, l, e4, e6);
        iv += 4;
        is += 12;
        // Middle segments
        for (var i = lineVertexFrom + 1, imax = lineVertexTo - 1; i < imax; ++i) {
            pprevx = px;
            pprevy = py;
            px = pnextx;
            py = pnexty;
            nprev[0] = nnext[0];
            nprev[1] = nnext[1];
            lprev = lnext;
            var imiddle = (i + 1) % lineVertexCount << 1;
            pnextx = lineVertices[imiddle];
            pnexty = lineVertices[imiddle + 1];
            toVector(px, py, pnextx, pnexty, nnext);
            lnext = toVectorLength(nnext);
            toNormal(nnext, lnext);
            l += lprev;
            fillTransformedLineVertexStep(iv, vertices, is, steps, px, py, strokeWidth, nprev, nnext, lprev, lnext, l, e3, e5);
            iv += 4;
            is += 12;
            fillTransformedLineVertexStep(iv, vertices, is, steps, px, py, strokeWidth, nprev, nnext, lprev, lnext, l, e4, e6);
            iv += 4;
            is += 12;
        }
        // Last segment
        pprevx = px;
        pprevy = py;
        px = pnextx;
        py = pnexty;
        nprev[0] = nnext[0];
        nprev[1] = nnext[1];
        lprev = lnext;
        pnextx = px + (px - pprevx);
        pnexty = py + (py - pprevy);
        toVector(px, py, pnextx, pnexty, nnext);
        toNormal(nnext, lnext);
        l += lprev;
        fillTransformedLineVertexStep(iv, vertices, is, steps, px, py, strokeWidth, nprev, nnext, lprev, lnext, l, e3, e5);
        iv += 4;
        is += 12;
        fillTransformedLineVertexStep(iv, vertices, is, steps, px, py, strokeWidth, nprev, nnext, lprev, lnext, l, e4, e6);
        iv += 4;
        is += 12;
        // Total length
        var is0 = voffset * 6 - 1;
        for (var i = is0, imax = is0 + 12; i < imax; i += 6) {
            steps[i + 5] = length;
        }
        for (var i = is0 + 12; i < is; i += 6) {
            steps[i + 5] = l;
        }
        // Fill the rest
        if (0 <= vcount) {
            var d = toNormalPacked(nprev, nnext);
            var ivmax = ((voffset + vcount) << 1) - 1;
            for (; iv < ivmax;) {
                vertices[++iv] = px;
                vertices[++iv] = py;
                steps[++is] = 0;
                steps[++is] = e3;
                steps[++is] = d;
                steps[++is] = l;
                steps[++is] = l;
                steps[++is] = 0;
                vertices[++iv] = px;
                vertices[++iv] = py;
                steps[++is] = 0;
                steps[++is] = e5;
                steps[++is] = d;
                steps[++is] = l;
                steps[++is] = l;
                steps[++is] = 0;
            }
        }
        return l;
    };
    var buildTransformedLineClosedSegmentVertexStep = function (vertices, steps, voffset, vcount, lineVertices, lineVertexFrom, lineVertexTo, lineVertexCount, strokeWidth, strokeStyle) {
        var scaleInvariant = toScaleInvariant(strokeStyle);
        var dash = toDash(strokeStyle);
        var e3 = toPackedI4x64(3, scaleInvariant, dash, 0);
        var e4 = toPackedI4x64(4, scaleInvariant, dash, 0);
        var e5 = toPackedI4x64(5, scaleInvariant, dash, 0);
        var e6 = toPackedI4x64(6, scaleInvariant, dash, 0);
        var ilast = (lineVertexTo - 1) % lineVertexCount << 1;
        var pprevx = 0;
        var pprevy = 0;
        var px = lineVertices[ilast];
        var py = lineVertices[ilast + 1];
        var ifirst = lineVertexFrom % lineVertexCount << 1;
        var pnextx = lineVertices[ifirst];
        var pnexty = lineVertices[ifirst + 1];
        var nprev = LINE_NPREV;
        var nnext = LINE_NNEXT;
        toVector(pprevx, pprevy, px, py, nprev);
        toVector(px, py, pnextx, pnexty, nnext);
        var lprev = toVectorLength(nprev);
        var lnext = toVectorLength(nnext);
        toNormal(nprev, lprev);
        toNormal(nnext, lnext);
        var l = 0;
        var iv = (voffset << 1) - 1;
        var is = voffset * 6 - 1;
        for (var i = lineVertexFrom; i < lineVertexTo; ++i) {
            pprevx = px;
            pprevy = py;
            px = pnextx;
            py = pnexty;
            nprev[0] = nnext[0];
            nprev[1] = nnext[1];
            lprev = lnext;
            var imiddle = (i + 1) % lineVertexCount << 1;
            pnextx = lineVertices[imiddle];
            pnexty = lineVertices[imiddle + 1];
            toVector(px, py, pnextx, pnexty, nnext);
            lnext = toVectorLength(nnext);
            toNormal(nnext, lnext);
            l += lprev;
            fillTransformedLineVertexStep(iv, vertices, is, steps, px, py, strokeWidth, nprev, nnext, lprev, lnext, l, e3, e5);
            iv += 4;
            is += 12;
            fillTransformedLineVertexStep(iv, vertices, is, steps, px, py, strokeWidth, nprev, nnext, lprev, lnext, l, e4, e6);
            iv += 4;
            is += 12;
        }
        // Last segment
        pprevx = px;
        pprevy = py;
        px = pnextx;
        py = pnexty;
        nprev[0] = nnext[0];
        nprev[1] = nnext[1];
        lprev = lnext;
        var isecond = (lineVertexFrom + 1) % lineVertexCount << 1;
        pnextx = lineVertices[isecond];
        pnexty = lineVertices[isecond + 1];
        toVector(px, py, pnextx, pnexty, nnext);
        lnext = toVectorLength(nnext);
        toNormal(nnext, lnext);
        l += lprev;
        fillTransformedLineVertexStep(iv, vertices, is, steps, px, py, strokeWidth, nprev, nnext, lprev, lnext, l, e3, e5);
        iv += 4;
        is += 12;
        // Total length
        for (var i = voffset * 6 - 1; i < is; i += 6) {
            steps[i + 5] = -l;
        }
        // Fill the rest
        if (0 <= vcount) {
            var d = toNormalPacked(nprev, nnext);
            var ivmax = ((voffset + vcount) << 1) - 1;
            for (; iv < ivmax;) {
                vertices[++iv] = px;
                vertices[++iv] = py;
                steps[++is] = strokeWidth;
                steps[++is] = e3;
                steps[++is] = d;
                steps[++is] = l;
                steps[++is] = -l;
                steps[++is] = 0;
                vertices[++iv] = px;
                vertices[++iv] = py;
                steps[++is] = strokeWidth;
                steps[++is] = e5;
                steps[++is] = d;
                steps[++is] = l;
                steps[++is] = -l;
                steps[++is] = 0;
            }
        }
        return l;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var BuilderLine = /** @class */ (function (_super) {
        __extends(BuilderLine, _super);
        function BuilderLine(buffer, vertexOffset, indexOffset, vertexCount, indexCount) {
            var _this = _super.call(this, buffer, vertexOffset, indexOffset, vertexCount, indexCount) || this;
            _this.pointId = -1;
            _this.pointCount = 0;
            _this.pointsClosed = false;
            _this.length = 1;
            return _this;
        }
        BuilderLine.prototype.init = function () {
            var buffer = this.buffer;
            buffer.updateIndices();
            buildLineIndex(buffer.indices, this.vertexOffset, this.indexOffset, this.indexCount);
            this.inited |= BuilderFlag.INDEX;
        };
        BuilderLine.prototype.reinit = function (buffer, shape, vertexOffset, indexOffset) {
            var pointCount = toLinePointCount(shape.points);
            var vertexCount = toLineVertexCount(pointCount, true);
            var indexCount = toLineIndexCount(pointCount, true);
            if (this.buffer !== buffer ||
                this.vertexOffset !== vertexOffset ||
                this.indexOffset !== indexOffset ||
                this.vertexCount !== vertexCount ||
                this.indexCount !== indexCount) {
                if (buffer.check(vertexOffset, indexOffset, vertexCount, indexCount)) {
                    this.inited = BuilderFlag.NONE;
                    this.buffer = buffer;
                    this.vertexOffset = vertexOffset;
                    this.indexOffset = indexOffset;
                    this.vertexCount = vertexCount;
                    this.indexCount = indexCount;
                    this.init();
                    return true;
                }
                else {
                    return false;
                }
            }
            else {
                return true;
            }
        };
        BuilderLine.prototype.isCompatible = function (shape) {
            var vcount = toLineVertexCount(toLinePointCount(shape.points), true);
            return vcount === this.vertexCount;
        };
        BuilderLine.prototype.update = function (shape) {
            var buffer = this.buffer;
            this.updateLineVertexStep(buffer, shape);
            this.updateColor(buffer, shape);
            this.updateLineUv(buffer, shape);
        };
        BuilderLine.prototype.updateLineVertexStep = function (buffer, shape) {
            var points = shape.points;
            if (points) {
                var pointId = points.id;
                var formatted = points.formatted;
                var pointCount = formatted.length;
                var pointsClosed = !!(formatted.style & EShapePointsStyle.CLOSED);
                var isPointChanged = pointId !== this.pointId ||
                    pointCount !== this.pointCount ||
                    pointsClosed !== this.pointsClosed;
                var stroke = shape.stroke;
                var strokeWidth = stroke.enable ? stroke.width : 0;
                var strokeStyle = stroke.style;
                var isStrokeWidthChanged = this.strokeWidth !== strokeWidth || this.strokeStyle !== strokeStyle;
                var transformLocalId = toTransformLocalId(shape);
                var isTransformChanged = this.transformLocalId !== transformLocalId;
                var isNotInited = !(this.inited & BuilderFlag.VERTEX_AND_STEP);
                if (isNotInited || isPointChanged || isTransformChanged || isStrokeWidthChanged) {
                    this.inited |= BuilderFlag.VERTEX_AND_STEP;
                    this.pointId = pointId;
                    this.pointCount = pointCount;
                    this.pointsClosed = pointsClosed;
                    this.strokeWidth = strokeWidth;
                    this.strokeStyle = strokeStyle;
                    this.transformLocalId = transformLocalId;
                    if (isPointChanged) {
                        // Invalidate the UV buffer
                        this.inited &= ~BuilderFlag.UV;
                    }
                    buffer.updateVertices();
                    buffer.updateSteps();
                    this.length = buildLineVertexStep(buffer.vertices, buffer.steps, this.vertexOffset, this.vertexCount, this.pointCount, this.pointsClosed, formatted.values, formatted.segments, strokeWidth, strokeStyle, shape.transform.internalTransform);
                }
            }
        };
        BuilderLine.prototype.updateLineUv = function (buffer, shape) {
            var texture = toTexture(shape);
            var textureTransformId = toTextureTransformId(texture);
            var isNotInited = !(this.inited & BuilderFlag.UV);
            if (isNotInited ||
                texture !== this.texture ||
                textureTransformId !== this.textureTransformId) {
                this.inited |= BuilderFlag.UV;
                this.texture = texture;
                this.textureTransformId = textureTransformId;
                buffer.updateUvs();
                buildLineUv(buffer.uvs, buffer.steps, this.vertexOffset, this.vertexCount, toTextureUvs(texture), this.length);
            }
        };
        return BuilderLine;
    }(BuilderBase));

    var TRIANGLE_VERTEX_COUNT = 7;
    var TRIANGLE_INDEX_COUNT = 3;
    var TRIANGLE_WORLD_SIZE = [0, 0, 0];
    var TRIANGLE_WORK_POINT = new pixi_js.Point();
    var buildTriangleIndex = function (indices, voffset, ioffset) {
        // Indices
        var ii = ioffset * 3 - 1;
        indices[++ii] = voffset + 0;
        indices[++ii] = voffset + 1;
        indices[++ii] = voffset + 2;
        indices[++ii] = voffset + 0;
        indices[++ii] = voffset + 3;
        indices[++ii] = voffset + 4;
        indices[++ii] = voffset + 0;
        indices[++ii] = voffset + 5;
        indices[++ii] = voffset + 6;
    };
    var buildTriangleVertex = function (vertices, voffset, originX, originY, sizeX, sizeY, strokeAlign, strokeWidth, internalTransform, worldSize) {
        var s = strokeAlign * strokeWidth;
        var sx = sizeX * 0.5 + (0 <= sizeX ? +s : -s);
        var sy = sizeY * 0.5 + (0 <= sizeY ? +s : -s);
        var sz = Math.sqrt(sx * sx + 4 * sy * sy);
        var sw = (2 * sx * sy) / (sx + sz);
        var work = TRIANGLE_WORK_POINT;
        work.set(originX, originY - sy);
        internalTransform.apply(work, work);
        var x0 = work.x;
        var y0 = work.y;
        work.set(originX, originY);
        internalTransform.apply(work, work);
        var tx = work.x;
        var ty = work.y;
        work.set(originX + sx, originY);
        internalTransform.apply(work, work);
        var dx = tx - x0;
        var dy = ty - y0;
        var x1 = work.x + dx;
        var y1 = work.y + dy;
        var x2 = tx + (tx - work.x) + dx;
        var y2 = ty + (ty - work.y) + dy;
        work.set(originX, originY + sy - sw); // Incenter of a triangle
        internalTransform.apply(work, work);
        var x3 = work.x;
        var y3 = work.y;
        // World size
        var xb = tx + dx;
        var yb = ty + dy;
        worldSize[0] = toLength(xb, yb, x3, y3);
        worldSize[1] = toLength(x1, y1, xb, yb);
        worldSize[2] = toLength(x0, y0, tx, ty);
        // Vertices
        var iv = (voffset << 1) - 1;
        vertices[++iv] = x3;
        vertices[++iv] = y3;
        vertices[++iv] = x0;
        vertices[++iv] = y0;
        vertices[++iv] = x1;
        vertices[++iv] = y1;
        vertices[++iv] = x1;
        vertices[++iv] = y1;
        vertices[++iv] = x2;
        vertices[++iv] = y2;
        vertices[++iv] = x2;
        vertices[++iv] = y2;
        vertices[++iv] = x0;
        vertices[++iv] = y0;
    };
    var buildTriangleStep = function (steps, voffset, strokeWidth, strokeStyle, worldSize) {
        var scaleInvariant = toScaleInvariant(strokeStyle);
        var s = worldSize[0];
        var e = toPackedI4x64(0, scaleInvariant, 1, 1);
        var c00 = toPackedF2x1024(0, 0);
        var c10 = toPackedF2x1024(1, 0);
        var c01 = toPackedF2x1024(0, 1);
        // 000
        var is = voffset * 6 - 1;
        steps[++is] = strokeWidth;
        steps[++is] = e;
        steps[++is] = s;
        steps[++is] = s;
        steps[++is] = c00;
        steps[++is] = 0;
        // 100
        steps[++is] = strokeWidth;
        steps[++is] = e;
        steps[++is] = s;
        steps[++is] = s;
        steps[++is] = c10;
        steps[++is] = 0;
        // 100
        steps[++is] = strokeWidth;
        steps[++is] = e;
        steps[++is] = s;
        steps[++is] = s;
        steps[++is] = c10;
        steps[++is] = 0;
        // 010
        steps[++is] = strokeWidth;
        steps[++is] = e;
        steps[++is] = s;
        steps[++is] = s;
        steps[++is] = c01;
        steps[++is] = 0;
        // 010
        steps[++is] = strokeWidth;
        steps[++is] = e;
        steps[++is] = s;
        steps[++is] = s;
        steps[++is] = c01;
        steps[++is] = 0;
        // 100
        steps[++is] = strokeWidth;
        steps[++is] = e;
        steps[++is] = s;
        steps[++is] = s;
        steps[++is] = c10;
        steps[++is] = 0;
        // 100
        steps[++is] = strokeWidth;
        steps[++is] = e;
        steps[++is] = s;
        steps[++is] = s;
        steps[++is] = c10;
        steps[++is] = 0;
    };
    var buildTriangleUv = function (uvs, textureUvs, voffset, worldSize) {
        var x0 = textureUvs.x0;
        var x1 = textureUvs.x1;
        var x2 = textureUvs.x2;
        var x3 = textureUvs.x3;
        var y0 = textureUvs.y0;
        var y1 = textureUvs.y1;
        var y2 = textureUvs.y2;
        var y3 = textureUvs.y3;
        var x4 = 0.5 * (x0 + x1);
        var y4 = 0.5 * (y0 + y1);
        var c = 1 - (0.5 * worldSize[0]) / worldSize[2];
        var x5 = x4 + c * (x3 - x0);
        var y5 = y4 + c * (y3 - y0);
        var iuv = (voffset << 1) - 1;
        uvs[++iuv] = x5;
        uvs[++iuv] = y5;
        uvs[++iuv] = x4;
        uvs[++iuv] = y4;
        uvs[++iuv] = x2;
        uvs[++iuv] = y2;
        uvs[++iuv] = x2;
        uvs[++iuv] = y2;
        uvs[++iuv] = x3;
        uvs[++iuv] = y3;
        uvs[++iuv] = x3;
        uvs[++iuv] = y3;
        uvs[++iuv] = x4;
        uvs[++iuv] = y4;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var BuilderMarkerBase = /** @class */ (function (_super) {
        __extends(BuilderMarkerBase, _super);
        function BuilderMarkerBase() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        BuilderMarkerBase.prototype.updateColor = function (buffer, shape) {
            var colorFill = 0xffffff;
            var alphaFill = 1;
            var points = shape.points;
            if (points != null) {
                var container = points.getMarker();
                if (container != null) {
                    var marker = this.toMarker(container);
                    var fill = marker.fill;
                    colorFill = fill.color;
                    alphaFill = shape.visible && fill.enable ? fill.alpha : 0;
                }
            }
            var stroke = shape.stroke;
            var colorStroke = stroke.color;
            var alphaStroke = shape.visible && stroke.enable && 0 < stroke.width ? stroke.alpha : 0;
            var isNotInited = !(this.inited & BuilderFlag.COLOR);
            if (isNotInited ||
                colorFill !== this.colorFill ||
                alphaFill !== this.alphaFill ||
                colorStroke !== this.colorStroke ||
                alphaStroke !== this.alphaStroke) {
                this.inited |= BuilderFlag.COLOR;
                this.colorFill = colorFill;
                this.alphaFill = alphaFill;
                this.colorStroke = colorStroke;
                this.alphaStroke = alphaStroke;
                buffer.updateColors();
                buildColor(colorFill, alphaFill, colorStroke, alphaStroke, this.vertexOffset, this.vertexCount, buffer.colors);
            }
        };
        return BuilderMarkerBase;
    }(BuilderBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var BuilderMarkerTriangle = /** @class */ (function (_super) {
        __extends(BuilderMarkerTriangle, _super);
        function BuilderMarkerTriangle(buffer, vertexOffset, indexOffset) {
            var _this = _super.call(this, buffer, vertexOffset, indexOffset, TRIANGLE_VERTEX_COUNT, TRIANGLE_INDEX_COUNT) || this;
            _this.pointId = -1;
            return _this;
        }
        BuilderMarkerTriangle.prototype.init = function () {
            var buffer = this.buffer;
            buffer.updateIndices();
            buildTriangleIndex(buffer.indices, this.vertexOffset, this.indexOffset);
            this.inited |= BuilderFlag.INDEX;
        };
        BuilderMarkerTriangle.prototype.update = function (shape) {
            var buffer = this.buffer;
            this.updateVertexStepAndUv(buffer, shape);
            this.updateColor(buffer, shape);
        };
        BuilderMarkerTriangle.prototype.updateVertexStepAndUv = function (buffer, shape) {
            var _a;
            var points = shape.points;
            if (points == null) {
                return;
            }
            var container = points.getMarker();
            if (container == null) {
                return;
            }
            var marker = this.toMarker(container);
            var size = marker.size;
            var sizeX = size.x;
            var sizeY = size.y;
            var isSizeChanged = sizeX !== this.sizeX || sizeY !== this.sizeY;
            var transformLocalId = toTransformLocalId(shape);
            var isTransformChanged = this.transformLocalId !== transformLocalId;
            var stroke = shape.stroke;
            var strokeAlign = stroke.align;
            var strokeWidth = stroke.enable ? stroke.width : 0;
            var strokeStyle = stroke.style;
            var isStrokeChanged = this.strokeAlign !== strokeAlign ||
                this.strokeWidth !== strokeWidth ||
                this.strokeStyle !== strokeStyle;
            var texture = toTexture(shape);
            var textureTransformId = toTextureTransformId(texture);
            var isTextureChanged = texture !== this.texture || textureTransformId !== this.textureTransformId;
            var isVertexChanged = isSizeChanged || isStrokeChanged;
            var pointId = points.id;
            var isPointChanged = pointId !== this.pointId;
            var isNotInited = !(this.inited & BuilderFlag.VERTEX_STEP_AND_UV);
            if (isNotInited ||
                isVertexChanged ||
                isTransformChanged ||
                isTextureChanged ||
                isPointChanged) {
                this.inited |= BuilderFlag.VERTEX_STEP_AND_UV;
                this.sizeX = sizeX;
                this.sizeY = sizeY;
                this.transformLocalId = transformLocalId;
                this.strokeAlign = strokeAlign;
                this.strokeWidth = strokeWidth;
                this.strokeStyle = strokeStyle;
                this.texture = texture;
                this.textureTransformId = textureTransformId;
                this.pointId = pointId;
                var voffset = this.vertexOffset;
                var internalTransform = ((_a = BuilderMarkerTriangle.WORK) !== null && _a !== void 0 ? _a : (BuilderMarkerTriangle.WORK = new pixi_js.Matrix()));
                internalTransform.copyFrom(marker.transform).prepend(shape.transform.internalTransform);
                buffer.updateVertices();
                buildTriangleVertex(buffer.vertices, voffset, 0, 0, sizeX, sizeY, strokeAlign, strokeWidth, internalTransform, TRIANGLE_WORLD_SIZE);
                if (isNotInited || isVertexChanged || isTransformChanged) {
                    buffer.updateSteps();
                    buildTriangleStep(buffer.steps, voffset, strokeWidth, strokeStyle, TRIANGLE_WORLD_SIZE);
                }
                if (isNotInited || isVertexChanged || isTextureChanged) {
                    buffer.updateUvs();
                    buildTriangleUv(buffer.uvs, toTextureUvs(texture), voffset, TRIANGLE_WORLD_SIZE);
                }
            }
        };
        return BuilderMarkerTriangle;
    }(BuilderMarkerBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var BuilderMarkerTriangleHead = /** @class */ (function (_super) {
        __extends(BuilderMarkerTriangleHead, _super);
        function BuilderMarkerTriangleHead() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        BuilderMarkerTriangleHead.prototype.toMarker = function (container) {
            return container.head;
        };
        return BuilderMarkerTriangleHead;
    }(BuilderMarkerTriangle));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var BuilderMarkerTriangleTail = /** @class */ (function (_super) {
        __extends(BuilderMarkerTriangleTail, _super);
        function BuilderMarkerTriangleTail() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        BuilderMarkerTriangleTail.prototype.toMarker = function (container) {
            return container.tail;
        };
        return BuilderMarkerTriangleTail;
    }(BuilderMarkerTriangle));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var BuilderMarkerCircle = /** @class */ (function (_super) {
        __extends(BuilderMarkerCircle, _super);
        function BuilderMarkerCircle(buffer, vertexOffset, indexOffset) {
            var _this = _super.call(this, buffer, vertexOffset, indexOffset, CIRCLE_VERTEX_COUNT, CIRCLE_INDEX_COUNT) || this;
            _this.pointId = -1;
            return _this;
        }
        BuilderMarkerCircle.prototype.init = function () {
            var buffer = this.buffer;
            buffer.updateIndices();
            var vertexOffset = this.vertexOffset;
            buildCircleIndex(buffer.indices, vertexOffset, this.indexOffset);
            this.inited |= BuilderFlag.INDEX;
        };
        BuilderMarkerCircle.prototype.update = function (shape) {
            var buffer = this.buffer;
            this.updateVertexAndStep(buffer, shape);
            this.updateColor(buffer, shape);
            this.updateUv(buffer, shape);
        };
        BuilderMarkerCircle.prototype.updateVertexAndStep = function (buffer, shape) {
            var _a;
            var points = shape.points;
            if (points == null) {
                return;
            }
            var container = points.getMarker();
            if (container == null) {
                return;
            }
            var marker = this.toMarker(container);
            var size = marker.size;
            var sizeX = size.x;
            var sizeY = size.y;
            var isSizeChanged = sizeX !== this.sizeX || sizeY !== this.sizeY;
            var transformLocalId = toTransformLocalId(shape);
            var isTransformChanged = this.transformLocalId !== transformLocalId;
            var stroke = shape.stroke;
            var strokeAlign = stroke.align;
            var strokeWidth = stroke.enable ? stroke.width : 0;
            var strokeStyle = stroke.style;
            var isStrokeChanged = this.strokeAlign !== strokeAlign ||
                this.strokeWidth !== strokeWidth ||
                this.strokeStyle !== strokeStyle;
            var pointId = points.id;
            var isPointChanged = pointId !== this.pointId;
            var isNotInited = !(this.inited & BuilderFlag.VERTEX_AND_STEP);
            if (isNotInited ||
                isSizeChanged ||
                isTransformChanged ||
                isStrokeChanged ||
                isPointChanged) {
                this.inited |= BuilderFlag.VERTEX_AND_STEP;
                this.sizeX = sizeX;
                this.sizeY = sizeY;
                this.transformLocalId = transformLocalId;
                this.strokeAlign = strokeAlign;
                this.strokeWidth = strokeWidth;
                this.strokeStyle = strokeStyle;
                this.pointId = pointId;
                // Buffer
                var internalTransform = ((_a = BuilderMarkerCircle.WORK) !== null && _a !== void 0 ? _a : (BuilderMarkerCircle.WORK = new pixi_js.Matrix()));
                internalTransform.copyFrom(marker.transform).prepend(shape.transform.internalTransform);
                buffer.updateVertices();
                buffer.updateSteps();
                buildCircleVertex(buffer.vertices, this.vertexOffset, 0, 0, sizeX, sizeY, strokeAlign, strokeWidth, internalTransform, CIRCLE_WORLD_SIZE);
                buildCircleStep(buffer.steps, this.vertexOffset, strokeWidth, strokeStyle, CIRCLE_WORLD_SIZE);
            }
        };
        BuilderMarkerCircle.prototype.updateUv = function (buffer, shape) {
            var texture = toTexture(shape);
            var textureTransformId = toTextureTransformId(texture);
            var isNotInited = !(this.inited & BuilderFlag.UV);
            if (isNotInited ||
                texture !== this.texture ||
                textureTransformId !== this.textureTransformId) {
                this.inited |= BuilderFlag.UV;
                this.texture = texture;
                this.textureTransformId = textureTransformId;
                buffer.updateUvs();
                var textureUvs = toTextureUvs(texture);
                buildCircleUv(buffer.uvs, this.vertexOffset, textureUvs);
            }
        };
        return BuilderMarkerCircle;
    }(BuilderMarkerBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var BuilderMarkerCircleHead = /** @class */ (function (_super) {
        __extends(BuilderMarkerCircleHead, _super);
        function BuilderMarkerCircleHead() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        BuilderMarkerCircleHead.prototype.toMarker = function (container) {
            return container.head;
        };
        return BuilderMarkerCircleHead;
    }(BuilderMarkerCircle));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var BuilderMarkerCircleTail = /** @class */ (function (_super) {
        __extends(BuilderMarkerCircleTail, _super);
        function BuilderMarkerCircleTail() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        BuilderMarkerCircleTail.prototype.toMarker = function (container) {
            return container.tail;
        };
        return BuilderMarkerCircleTail;
    }(BuilderMarkerCircle));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var BuilderNull = /** @class */ (function () {
        function BuilderNull(buffer, vertexOffset, indexOffset) {
            this.buffer = buffer;
            this.vertexOffset = vertexOffset;
            this.indexOffset = indexOffset;
            this.vertexCount = 0;
            this.indexCount = 0;
            this.texture = null;
        }
        BuilderNull.prototype.init = function () {
            return this;
        };
        BuilderNull.prototype.reinit = function (buffer, shape, vertexOffset, indexOffset) {
            this.buffer = buffer;
            this.vertexOffset = vertexOffset;
            this.indexOffset = indexOffset;
            return true;
        };
        BuilderNull.prototype.isCompatible = function (shape) {
            return true;
        };
        BuilderNull.prototype.update = function (shape) {
            this.texture = toTexture(shape);
        };
        BuilderNull.prototype.buildUnit = function (builder) {
            var texture = this.texture || pixi_js.Texture.WHITE;
            var baseTexture = texture.baseTexture;
            if (baseTexture !== builder.baseTexture) {
                builder.baseTexture = baseTexture;
                var indexOffset = this.indexOffset;
                builder.push(texture, indexOffset);
            }
        };
        return BuilderNull;
    }());

    var RECTANGLE_VERTEX_COUNT = 16;
    var RECTANGLE_INDEX_COUNT = 8;
    var RECTANGLE_WORLD_SIZE = [0, 0];
    var RECTANGLE_WORK_POINT = new pixi_js.Point();
    var buildRectangleIndex = function (indices, voffset, ioffset) {
        // c0     c1   c4     c5
        //  |-----|     |-----|
        //  |     |     |     |
        //  |-----|     |-----|
        // c2     c3   c6     c7
        //
        // c8     c9   c12   c13
        //  |-----|     |-----|
        //  |     |     |     |
        //  |-----|     |-----|
        // c10   c11   c14   c15
        var ii = ioffset * 3 - 1;
        indices[++ii] = voffset + 0;
        indices[++ii] = voffset + 1;
        indices[++ii] = voffset + 2;
        indices[++ii] = voffset + 2;
        indices[++ii] = voffset + 1;
        indices[++ii] = voffset + 3;
        indices[++ii] = voffset + 4;
        indices[++ii] = voffset + 5;
        indices[++ii] = voffset + 6;
        indices[++ii] = voffset + 6;
        indices[++ii] = voffset + 5;
        indices[++ii] = voffset + 7;
        indices[++ii] = voffset + 8;
        indices[++ii] = voffset + 9;
        indices[++ii] = voffset + 10;
        indices[++ii] = voffset + 10;
        indices[++ii] = voffset + 9;
        indices[++ii] = voffset + 11;
        indices[++ii] = voffset + 12;
        indices[++ii] = voffset + 13;
        indices[++ii] = voffset + 14;
        indices[++ii] = voffset + 14;
        indices[++ii] = voffset + 13;
        indices[++ii] = voffset + 15;
    };
    var buildRectangleVertex = function (vertices, voffset, originX, originY, sizeX, sizeY, strokeAlign, strokeWidth, internalTransform, worldSize) {
        // b0      b1      b2
        // |-------|-------|
        // |       |       |
        // b3------b4------b5
        // |       |       |
        // |-------|-------|
        // b6      b7      b8
        var s = strokeAlign * strokeWidth;
        var sx = sizeX * 0.5 + (0 <= sizeX ? +s : -s);
        var sy = sizeY * 0.5 + (0 <= sizeY ? +s : -s);
        var work = RECTANGLE_WORK_POINT;
        work.set(originX - sx, originY - sy);
        internalTransform.apply(work, work);
        var b0x = work.x;
        var b0y = work.y;
        work.set(originX, originY - sy);
        internalTransform.apply(work, work);
        var b1x = work.x;
        var b1y = work.y;
        work.set(originX - sx, originY);
        internalTransform.apply(work, work);
        var b3x = work.x;
        var b3y = work.y;
        var d01x = b1x - b0x;
        var d01y = b1y - b0y;
        var d03x = b3x - b0x;
        var d03y = b3y - b0y;
        var b2x = b1x + d01x;
        var b2y = b1y + d01y;
        var b4x = b3x + d01x;
        var b4y = b3y + d01y;
        var b5x = b2x + d03x;
        var b5y = b2y + d03y;
        var b6x = b3x + d03x;
        var b6y = b3y + d03y;
        var b7x = b6x + d01x;
        var b7y = b6y + d01y;
        var b8x = b7x + d01x;
        var b8y = b7y + d01y;
        // c0     c1   c4     c5
        //  |-----|     |-----|
        //  |     |     |     |
        //  |-----|     |-----|
        // c2     c3   c6     c7
        //
        // c8     c9   c12   c13
        //  |-----|     |-----|
        //  |     |     |     |
        //  |-----|     |-----|
        // c10   c11   c14   c15
        var iv = (voffset << 1) - 1;
        vertices[++iv] = b0x;
        vertices[++iv] = b0y;
        vertices[++iv] = b1x;
        vertices[++iv] = b1y;
        vertices[++iv] = b3x;
        vertices[++iv] = b3y;
        vertices[++iv] = b4x;
        vertices[++iv] = b4y;
        vertices[++iv] = b1x;
        vertices[++iv] = b1y;
        vertices[++iv] = b2x;
        vertices[++iv] = b2y;
        vertices[++iv] = b4x;
        vertices[++iv] = b4y;
        vertices[++iv] = b5x;
        vertices[++iv] = b5y;
        vertices[++iv] = b3x;
        vertices[++iv] = b3y;
        vertices[++iv] = b4x;
        vertices[++iv] = b4y;
        vertices[++iv] = b6x;
        vertices[++iv] = b6y;
        vertices[++iv] = b7x;
        vertices[++iv] = b7y;
        vertices[++iv] = b4x;
        vertices[++iv] = b4y;
        vertices[++iv] = b5x;
        vertices[++iv] = b5y;
        vertices[++iv] = b7x;
        vertices[++iv] = b7y;
        vertices[++iv] = b8x;
        vertices[++iv] = b8y;
        // World size
        worldSize[0] = toLength(b0x, b0y, b1x, b1y);
        worldSize[1] = toLength(b0x, b0y, b3x, b3y);
    };
    var buildRectangleStep = function (voffset, steps, strokeWidth, strokeSide, strokeStyle, worldSize) {
        var scaleInvariant = toScaleInvariant(strokeStyle);
        var ax = worldSize[0];
        var ay = worldSize[1];
        var wt = strokeSide & EShapeStrokeSide.TOP ? 1 : 0;
        var wr = strokeSide & EShapeStrokeSide.RIGHT ? 1 : 0;
        var wb = strokeSide & EShapeStrokeSide.BOTTOM ? 1 : 0;
        var wl = strokeSide & EShapeStrokeSide.LEFT ? 1 : 0;
        var elt = toPackedI4x64(0, scaleInvariant, wl, wt);
        var ert = toPackedI4x64(0, scaleInvariant, wr, wt);
        var elb = toPackedI4x64(0, scaleInvariant, wl, wb);
        var erb = toPackedI4x64(0, scaleInvariant, wr, wb);
        var c11 = toPackedF2x1024(1, 1);
        var c01 = toPackedF2x1024(0, 1);
        var c00 = toPackedF2x1024(0, 0);
        var c10 = toPackedF2x1024(1, 0);
        // c0     c1   c4     c5
        //  |-----|     |-----|
        //  |     |     |     |
        //  |-----|     |-----|
        // c2     c3   c6     c7
        //
        // c8     c9   c12   c13
        //  |-----|     |-----|
        //  |     |     |     |
        //  |-----|     |-----|
        // c10   c11   c14   c15
        var is = voffset * 6 - 1;
        steps[++is] = strokeWidth;
        steps[++is] = elt;
        steps[++is] = ax;
        steps[++is] = ay;
        steps[++is] = c11;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = elt;
        steps[++is] = ax;
        steps[++is] = ay;
        steps[++is] = c01;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = elt;
        steps[++is] = ax;
        steps[++is] = ay;
        steps[++is] = c10;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = elt;
        steps[++is] = ax;
        steps[++is] = ay;
        steps[++is] = c00;
        steps[++is] = 0;
        //
        steps[++is] = strokeWidth;
        steps[++is] = ert;
        steps[++is] = ax;
        steps[++is] = ay;
        steps[++is] = c01;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = ert;
        steps[++is] = ax;
        steps[++is] = ay;
        steps[++is] = c11;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = ert;
        steps[++is] = ax;
        steps[++is] = ay;
        steps[++is] = c00;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = ert;
        steps[++is] = ax;
        steps[++is] = ay;
        steps[++is] = c10;
        steps[++is] = 0;
        //
        steps[++is] = strokeWidth;
        steps[++is] = elb;
        steps[++is] = ax;
        steps[++is] = ay;
        steps[++is] = c10;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = elb;
        steps[++is] = ax;
        steps[++is] = ay;
        steps[++is] = c00;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = elb;
        steps[++is] = ax;
        steps[++is] = ay;
        steps[++is] = c11;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = elb;
        steps[++is] = ax;
        steps[++is] = ay;
        steps[++is] = c01;
        steps[++is] = 0;
        //
        steps[++is] = strokeWidth;
        steps[++is] = erb;
        steps[++is] = ax;
        steps[++is] = ay;
        steps[++is] = c00;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = erb;
        steps[++is] = ax;
        steps[++is] = ay;
        steps[++is] = c10;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = erb;
        steps[++is] = ax;
        steps[++is] = ay;
        steps[++is] = c01;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = erb;
        steps[++is] = ax;
        steps[++is] = ay;
        steps[++is] = c11;
        steps[++is] = 0;
    };
    var buildRectangleUv = function (uvs, voffset, textureUvs) {
        // b0      b1      b2
        // |-------|-------|
        // |       |       |
        // b3------b4------b5
        // |       |       |
        // |-------|-------|
        // b6      b7      b8
        var b0x = textureUvs.x0;
        var b0y = textureUvs.y0;
        var b2x = textureUvs.x1;
        var b2y = textureUvs.y1;
        var b8x = textureUvs.x2;
        var b8y = textureUvs.y2;
        var b6x = textureUvs.x3;
        var b6y = textureUvs.y3;
        var b1x = (b0x + b2x) * 0.5;
        var b1y = (b0y + b2y) * 0.5;
        var b3x = (b0x + b6x) * 0.5;
        var b3y = (b0y + b6y) * 0.5;
        var d01x = b1x - b0x;
        var d01y = b1y - b0y;
        var d03x = b3x - b0x;
        var d03y = b3y - b0y;
        var b4x = b3x + d01x;
        var b4y = b3y + d01y;
        var b5x = b2x + d03x;
        var b5y = b2y + d03y;
        var b7x = b6x + d01x;
        var b7y = b6y + d01y;
        // c0     c1   c4     c5
        //  |-----|     |-----|
        //  |     |     |     |
        //  |-----|     |-----|
        // c2     c3   c6     c7
        //
        // c8     c9   c12   c13
        //  |-----|     |-----|
        //  |     |     |     |
        //  |-----|     |-----|
        // c10   c11   c14   c15
        var iuv = (voffset << 1) - 1;
        uvs[++iuv] = b0x;
        uvs[++iuv] = b0y;
        uvs[++iuv] = b1x;
        uvs[++iuv] = b1y;
        uvs[++iuv] = b3x;
        uvs[++iuv] = b3y;
        uvs[++iuv] = b4x;
        uvs[++iuv] = b4y;
        uvs[++iuv] = b1x;
        uvs[++iuv] = b1y;
        uvs[++iuv] = b2x;
        uvs[++iuv] = b2y;
        uvs[++iuv] = b4x;
        uvs[++iuv] = b4y;
        uvs[++iuv] = b5x;
        uvs[++iuv] = b5y;
        uvs[++iuv] = b3x;
        uvs[++iuv] = b3y;
        uvs[++iuv] = b4x;
        uvs[++iuv] = b4y;
        uvs[++iuv] = b6x;
        uvs[++iuv] = b6y;
        uvs[++iuv] = b7x;
        uvs[++iuv] = b7y;
        uvs[++iuv] = b4x;
        uvs[++iuv] = b4y;
        uvs[++iuv] = b5x;
        uvs[++iuv] = b5y;
        uvs[++iuv] = b7x;
        uvs[++iuv] = b7y;
        uvs[++iuv] = b8x;
        uvs[++iuv] = b8y;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var BuilderMarkerRectangle = /** @class */ (function (_super) {
        __extends(BuilderMarkerRectangle, _super);
        function BuilderMarkerRectangle(buffer, vertexOffset, indexOffset) {
            var _this = _super.call(this, buffer, vertexOffset, indexOffset, RECTANGLE_VERTEX_COUNT, RECTANGLE_INDEX_COUNT) || this;
            _this.pointId = -1;
            return _this;
        }
        BuilderMarkerRectangle.prototype.init = function () {
            var buffer = this.buffer;
            buffer.updateIndices();
            buildRectangleIndex(buffer.indices, this.vertexOffset, this.indexOffset);
            this.inited |= BuilderFlag.INDEX;
        };
        BuilderMarkerRectangle.prototype.update = function (shape) {
            var buffer = this.buffer;
            this.updateVertexStepAndUv(buffer, shape);
            this.updateColor(buffer, shape);
        };
        BuilderMarkerRectangle.prototype.updateVertexStepAndUv = function (buffer, shape) {
            var _a;
            var points = shape.points;
            if (points == null) {
                return;
            }
            var container = points.getMarker();
            if (container == null) {
                return;
            }
            var marker = this.toMarker(container);
            var size = marker.size;
            var sizeX = size.x;
            var sizeY = size.y;
            var isSizeChanged = sizeX !== this.sizeX || sizeY !== this.sizeY;
            var transformLocalId = toTransformLocalId(shape);
            var isTransformChanged = this.transformLocalId !== transformLocalId;
            var stroke = shape.stroke;
            var strokeAlign = stroke.align;
            var strokeWidth = stroke.enable ? stroke.width : 0;
            var strokeSide = stroke.side;
            var strokeStyle = stroke.style;
            var isStrokeChanged = this.strokeAlign !== strokeAlign ||
                this.strokeWidth !== strokeWidth ||
                this.strokeSide !== strokeSide ||
                this.strokeStyle !== strokeStyle;
            var texture = toTexture(shape);
            var textureTransformId = toTextureTransformId(texture);
            var isTextureChanged = texture !== this.texture || textureTransformId !== this.textureTransformId;
            var isVertexChanged = isSizeChanged || isStrokeChanged;
            var pointId = points.id;
            var isPointChanged = pointId !== this.pointId;
            var isNotInited = !(this.inited & BuilderFlag.VERTEX_STEP_AND_UV);
            if (isNotInited ||
                isVertexChanged ||
                isTransformChanged ||
                isTextureChanged ||
                isPointChanged) {
                this.inited |= BuilderFlag.VERTEX_STEP_AND_UV;
                this.sizeX = sizeX;
                this.sizeY = sizeY;
                this.transformLocalId = transformLocalId;
                this.strokeAlign = strokeAlign;
                this.strokeWidth = strokeWidth;
                this.strokeSide = strokeSide;
                this.strokeStyle = strokeStyle;
                this.texture = texture;
                this.textureTransformId = textureTransformId;
                // Vertices
                var voffset = this.vertexOffset;
                var internalTransform = ((_a = BuilderMarkerRectangle.WORK) !== null && _a !== void 0 ? _a : (BuilderMarkerRectangle.WORK = new pixi_js.Matrix()));
                internalTransform.copyFrom(marker.transform).prepend(shape.transform.internalTransform);
                buffer.updateVertices();
                buildRectangleVertex(buffer.vertices, voffset, 0, 0, sizeX, sizeY, strokeAlign, strokeWidth, internalTransform, RECTANGLE_WORLD_SIZE);
                // Steps
                if (isNotInited || isVertexChanged || isTransformChanged) {
                    buffer.updateSteps();
                    buildRectangleStep(voffset, buffer.steps, strokeWidth, strokeSide, strokeStyle, RECTANGLE_WORLD_SIZE);
                }
                // UVs
                if (isNotInited || isVertexChanged || isTextureChanged) {
                    buffer.updateUvs();
                    buildRectangleUv(buffer.uvs, voffset, toTextureUvs(texture));
                }
            }
        };
        return BuilderMarkerRectangle;
    }(BuilderMarkerBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var BuilderMarkerRectangleTail = /** @class */ (function (_super) {
        __extends(BuilderMarkerRectangleTail, _super);
        function BuilderMarkerRectangleTail() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        BuilderMarkerRectangleTail.prototype.toMarker = function (container) {
            return container.tail;
        };
        return BuilderMarkerRectangleTail;
    }(BuilderMarkerRectangle));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var BuilderMarkerRectangleHead = /** @class */ (function (_super) {
        __extends(BuilderMarkerRectangleHead, _super);
        function BuilderMarkerRectangleHead() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        BuilderMarkerRectangleHead.prototype.toMarker = function (container) {
            return container.head;
        };
        return BuilderMarkerRectangleHead;
    }(BuilderMarkerRectangle));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var toMarkerVertexCount = function (type) {
        switch (type) {
            case EShapePointsMarkerType.NONE:
                return 0;
            case EShapePointsMarkerType.CIRCLE:
                return CIRCLE_VERTEX_COUNT;
            case EShapePointsMarkerType.TRIANGLE:
                return TRIANGLE_VERTEX_COUNT;
            case EShapePointsMarkerType.RECTANGLE:
                return RECTANGLE_VERTEX_COUNT;
        }
        return 0;
    };
    var toMarkerIndexCount = function (type) {
        switch (type) {
            case EShapePointsMarkerType.NONE:
                return 0;
            case EShapePointsMarkerType.CIRCLE:
                return CIRCLE_INDEX_COUNT;
            case EShapePointsMarkerType.TRIANGLE:
                return TRIANGLE_INDEX_COUNT;
            case EShapePointsMarkerType.RECTANGLE:
                return RECTANGLE_INDEX_COUNT;
        }
        return 0;
    };
    var toBuilderMarkerHead = function (type, buffer, vertexOffset, indexOffset) {
        switch (type) {
            case EShapePointsMarkerType.NONE:
                return new BuilderNull(buffer, vertexOffset, indexOffset);
            case EShapePointsMarkerType.CIRCLE:
                return new BuilderMarkerCircleHead(buffer, vertexOffset, indexOffset);
            case EShapePointsMarkerType.TRIANGLE:
                return new BuilderMarkerTriangleHead(buffer, vertexOffset, indexOffset);
            case EShapePointsMarkerType.RECTANGLE:
                return new BuilderMarkerRectangleHead(buffer, vertexOffset, indexOffset);
        }
        return new BuilderNull(buffer, vertexOffset, indexOffset);
    };
    var toBuilderMarkerTail = function (type, buffer, vertexOffset, indexOffset) {
        switch (type) {
            case EShapePointsMarkerType.NONE:
                return new BuilderNull(buffer, vertexOffset, indexOffset);
            case EShapePointsMarkerType.CIRCLE:
                return new BuilderMarkerCircleTail(buffer, vertexOffset, indexOffset);
            case EShapePointsMarkerType.TRIANGLE:
                return new BuilderMarkerTriangleTail(buffer, vertexOffset, indexOffset);
            case EShapePointsMarkerType.RECTANGLE:
                return new BuilderMarkerRectangleTail(buffer, vertexOffset, indexOffset);
        }
        return new BuilderNull(buffer, vertexOffset, indexOffset);
    };
    var createLineUploaded = function (buffer, shape, voffset, ioffset, antialiasWeight) {
        // Line
        var points = shape.points;
        var pointCount = toLinePointCount(points);
        var lvcount = toLineVertexCount(pointCount, true);
        var licount = toLineIndexCount(pointCount, true);
        // Markers
        var mttype = EShapePointsMarkerType.NONE;
        var mhtype = EShapePointsMarkerType.NONE;
        if (points && points instanceof EShapeLinePoints) {
            var marker = points.getMarker();
            if (marker) {
                mttype = marker.tail.type;
                mhtype = marker.head.type;
            }
        }
        var mtvcount = toMarkerVertexCount(mttype);
        var mticount = toMarkerIndexCount(mttype);
        var mtvoffset = voffset + lvcount;
        var mtioffset = ioffset + licount;
        var mhvcount = toMarkerVertexCount(mhtype);
        var mhicount = toMarkerIndexCount(mhtype);
        var mhvoffset = mtvoffset + mtvcount;
        var mhioffset = mtioffset + mticount;
        // Text
        var tcount = toTextBufferCount(shape);
        var tvcount = tcount << TEXT_VERTEX_COUNT_SHIFT;
        var ticount = tcount << TEXT_INDEX_COUNT_SHIFT;
        var tvoffset = mhvoffset + mhvcount;
        var tioffset = mhioffset + mhicount;
        // Uploaded
        var vcount = lvcount + mhvcount + mtvcount + tvcount;
        var icount = licount + mhicount + mticount + ticount;
        if (buffer.check(voffset, ioffset, vcount, icount)) {
            return new EShapeUploadedImpl(buffer, voffset, ioffset, vcount, icount, [
                new BuilderLine(buffer, voffset, ioffset, lvcount, licount),
                toBuilderMarkerTail(mttype, buffer, mtvoffset, mtioffset),
                toBuilderMarkerHead(mhtype, buffer, mhvoffset, mhioffset),
                new BuilderText(buffer, tvoffset, tioffset, tvcount, ticount)
            ]).init(shape);
        }
        return null;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeConnectorElbowPointsFiller = /** @class */ (function () {
        function EShapeConnectorElbowPointsFiller(x, y, values) {
            this._threshold = 0.000001;
            this._x = x;
            this._y = y;
            this._z = 0;
            this._values = values;
            values[0] = x;
            values[1] = y;
            this.index = 0;
        }
        Object.defineProperty(EShapeConnectorElbowPointsFiller.prototype, "x", {
            get: function () {
                return this._x;
            },
            set: function (x) {
                if (this._z === 0 || this._threshold < Math.abs(this._x - x)) {
                    this._x = x;
                    var index = this.index;
                    var values = this._values;
                    if (this._z === 1) {
                        values[index + 0] = this._x;
                        values[index + 1] = this._y;
                    }
                    else {
                        values[index + 2] = this._x;
                        values[index + 3] = this._y;
                        this.index += 2;
                        this._z = 1;
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeConnectorElbowPointsFiller.prototype, "y", {
            get: function () {
                return this._y;
            },
            set: function (y) {
                if (this._z === 0 || this._threshold < Math.abs(this._y - y)) {
                    this._y = y;
                    var index = this.index;
                    var values = this._values;
                    if (this._z === 2) {
                        values[index + 0] = this._x;
                        values[index + 1] = this._y;
                    }
                    else {
                        values[index + 2] = this._x;
                        values[index + 3] = this._y;
                        this.index += 2;
                        this._z = 2;
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        EShapeConnectorElbowPointsFiller.prototype.toSide = function (x, y) {
            // y = +x => 0 = x - y
            // y = -x => 0 = x + y
            if (0 <= x - y) {
                if (0 <= x + y) {
                    return 1;
                }
                else {
                    return 0;
                }
            }
            else {
                if (0 <= x + y) {
                    return 2;
                }
                else {
                    return 3;
                }
            }
        };
        EShapeConnectorElbowPointsFiller.prototype.toAxis = function (dx, dy, nx, ny, side) {
            // When (nx, ny) === (0, 0), treat as if side === EShapeAcceptorEdgeSide.ALL.
            var anx = Math.abs(nx);
            var any = Math.abs(ny);
            var threshold = this._threshold;
            if (anx < threshold && any < threshold) {
                if (Math.abs(dx) < Math.abs(dy)) {
                    if (0 <= dy) {
                        return 2; // Bottom
                    }
                    else {
                        return 0; // Top
                    }
                }
                else {
                    if (0 <= dx) {
                        return 1; // Right
                    }
                    else {
                        return 3; // Left
                    }
                }
            }
            var d = null;
            var result = 0;
            var dd = dx * dx + dy * dy;
            if (this._threshold < dd) {
                var f = 1 / Math.sqrt(dd);
                var fx = dx * f;
                var fy = dy * f;
                var d0 = +nx * fx + ny * fy;
                var d1 = -ny * fx + nx * fy;
                var d2 = -d0;
                var d3 = -d1;
                if (side & EShapeAcceptorEdgeSide.TOP) {
                    if (d == null || d < d0) {
                        d = d0;
                        result = this.toSide(nx, ny);
                    }
                }
                if (side & EShapeAcceptorEdgeSide.RIGHT) {
                    if (d == null || d < d1) {
                        d = d1;
                        result = this.toSide(-ny, nx);
                    }
                }
                if (side & EShapeAcceptorEdgeSide.BOTTOM) {
                    if (d == null || d < d2) {
                        d = d2;
                        result = this.toSide(-nx, -ny);
                    }
                }
                if (side & EShapeAcceptorEdgeSide.LEFT) {
                    if (d == null || d < d3) {
                        d = d3;
                        result = this.toSide(ny, -nx);
                    }
                }
            }
            return result;
        };
        EShapeConnectorElbowPointsFiller.prototype.toTailAxis = function (x, y, nx, ny, side) {
            return this.toAxis(x - this.x, y - this.y, nx, ny, side);
        };
        EShapeConnectorElbowPointsFiller.prototype.tail = function (x, y, nx, ny, sxh, syh, margin, side) {
            switch (this.toTailAxis(x, y, nx, ny, side)) {
                case 0:
                    if (this.y - margin <= y) {
                        this.y -= Math.max(margin, syh);
                        this.x = x;
                    }
                    else {
                        this.y = y;
                    }
                    break;
                case 1:
                    if (x <= this.x + margin) {
                        this.x += Math.max(margin, sxh);
                        this.y = y;
                    }
                    else {
                        this.x = x;
                    }
                    break;
                case 2:
                    if (y <= this.y + margin) {
                        this.y += Math.max(margin, sxh);
                        this.x = x;
                    }
                    else {
                        this.y = y;
                    }
                    break;
                case 3:
                    if (this.x - margin <= x) {
                        this.x -= Math.max(margin, sxh);
                        this.y = y;
                    }
                    else {
                        this.x = x;
                    }
                    break;
            }
        };
        EShapeConnectorElbowPointsFiller.prototype.middle = function (x, y) {
            var dx = x - this._x;
            var dy = y - this._y;
            if (Math.abs(dx) < Math.abs(dy)) {
                this.y = y;
            }
            else {
                this.x = x;
            }
        };
        EShapeConnectorElbowPointsFiller.prototype.toHeadAxis = function (x, y, nx, ny, side) {
            return this.toAxis(this.x - x, this.y - y, nx, ny, side);
        };
        EShapeConnectorElbowPointsFiller.prototype.head = function (x, y, nx, ny, sxh, syh, margin, side) {
            switch (this.toHeadAxis(x, y, nx, ny, side)) {
                case 0:
                    if (y - margin <= this.y) {
                        this.y = y - Math.max(margin, syh);
                    }
                    this.x = x;
                    this.y = y;
                    break;
                case 1:
                    if (this.x <= x + margin) {
                        this.x = x + Math.max(margin, sxh);
                    }
                    this.y = y;
                    this.x = x;
                    break;
                case 2:
                    if (this.y <= y + margin) {
                        this.y = y + Math.max(margin, syh);
                    }
                    this.x = x;
                    this.y = y;
                    break;
                case 3:
                    if (x - margin <= this.x) {
                        this.x = x - Math.max(margin, sxh);
                    }
                    this.y = y;
                    this.x = x;
                    break;
            }
        };
        EShapeConnectorElbowPointsFiller.prototype.margin = function (tail, head) {
            var values = this._values;
            // Tail
            var index = this.index;
            if (tail !== 0 && 2 <= index) {
                var x0 = values[0];
                var y0 = values[1];
                var dx = values[2] - x0;
                var dy = values[3] - y0;
                var d = dx * dx + dy * dy;
                var threshold = this._threshold;
                if (threshold < d) {
                    var f = tail / Math.sqrt(dx * dx + dy * dy);
                    if (threshold < Math.abs(f - 1)) {
                        values[0] = x0 + dx * f;
                        values[1] = y0 + dy * f;
                    }
                    else {
                        this.index -= 2;
                    }
                }
            }
            // Head
            index = this.index;
            if (head !== 0 && 2 <= index) {
                var x1 = values[index + 0];
                var y1 = values[index + 1];
                var dx = values[index - 2] - x1;
                var dy = values[index - 1] - y1;
                var d = dx * dx + dy * dy;
                var threshold = this._threshold;
                if (threshold < d) {
                    var f = head / Math.sqrt(dx * dx + dy * dy);
                    if (threshold < Math.abs(f - 1)) {
                        values[index + 0] = x1 + dx * f;
                        values[index + 1] = y1 + dy * f;
                    }
                    else {
                        this.index -= 2;
                    }
                }
            }
            // Remote the rest
            values.length = this.index + 2;
        };
        return EShapeConnectorElbowPointsFiller;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeConnectorElbow = /** @class */ (function (_super) {
        __extends(EShapeConnectorElbow, _super);
        function EShapeConnectorElbow(type) {
            if (type === void 0) { type = EShapeType.CONNECTOR_ELBOW; }
            return _super.call(this, type) || this;
        }
        EShapeConnectorElbow.prototype.fillPoints = function (tail, tailMargin, head, headMargin, body, px, py, values) {
            // Tail
            var tailLocal = tail.local;
            var tailLocalX = tailLocal.x;
            var tailLocalY = tailLocal.y;
            var tailNormal = tail.normal;
            var tailNormalX = tailNormal.x;
            var tailNormalY = tailNormal.y;
            var tailSide = tail.side;
            // Head
            var headLocal = head.local;
            var headLocalX = headLocal.x;
            var headLocalY = headLocal.y;
            var headNormal = head.normal;
            var headNormalX = headNormal.x;
            var headNormalY = headNormal.y;
            var headSide = head.side;
            // Body
            var bodyValues = body.values;
            var bodyValuesLength = bodyValues.length;
            // Values
            var x0 = tailLocalX - px;
            var y0 = tailLocalY - py;
            var x1 = headLocalX - px;
            var y1 = headLocalY - py;
            var cx = (x1 + x0) * 0.5;
            var cy = (y1 + y0) * 0.5;
            var dx = x1 - x0;
            var dy = y1 - y0;
            var sxh = 0.5 * EShapeDefaults.SIZE_X;
            var syh = 0.5 * EShapeDefaults.SIZE_Y;
            var threshold = 0.000001;
            if (Math.abs(dx) < threshold && Math.abs(dy) < threshold) {
                values[0] = x0;
                values[1] = y0;
                values[2] = x1;
                values[3] = y1;
                values.length = 4;
            }
            else {
                var filler = new EShapeConnectorElbowPointsFiller(x0, y0, values);
                if (0 < bodyValuesLength) {
                    var a = Math.atan2(dy, dx);
                    var l = Math.sqrt(dx * dx + dy * dy);
                    var c = Math.cos(a) * l;
                    var s = Math.sin(a) * l;
                    var x3 = bodyValues[0];
                    var y3 = bodyValues[1];
                    var x4 = cx + c * x3 - s * y3;
                    var y4 = cy + c * y3 + s * x3;
                    filler.tail(x4, y4, tailNormalX, tailNormalY, sxh, syh, tailMargin, tailSide);
                    for (var i = 2; i < bodyValuesLength; i += 2) {
                        var x = bodyValues[i + 0];
                        var y = bodyValues[i + 1];
                        var x5 = cx + c * x - s * y;
                        var y5 = cy + c * y + s * x;
                        filler.middle(x5, y5);
                    }
                    filler.head(x1, y1, headNormalX, headNormalY, sxh, syh, headMargin, headSide);
                }
                else {
                    filler.tail(cx, cy, tailNormalX, tailNormalY, sxh, syh, tailMargin, tailSide);
                    filler.head(x1, y1, headNormalX, headNormalY, sxh, syh, headMargin, headSide);
                }
                filler.margin(tailMargin, headMargin);
            }
        };
        return EShapeConnectorElbow;
    }(EShapeConnectorLine));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var deserializeConnectorElbow = function (item, manager, shape) {
        return deserializeBase(item, manager, shape || new EShapeConnectorElbow());
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeConnectorBodies = /** @class */ (function () {
        function EShapeConnectorBodies() {
        }
        EShapeConnectorBodies.from = function (values, tailMargin, headMargin) {
            var result = [];
            var length = values.length;
            if (4 < length) {
                var threshold = 0.000001;
                var x0 = values[0];
                var y0 = values[1];
                if (tailMargin !== 0) {
                    var ex = x0 - values[2];
                    var ey = y0 - values[3];
                    var n = ex * ex + ey * ey;
                    if (threshold < n) {
                        var f = tailMargin / Math.sqrt(n);
                        x0 += ex * f;
                        y0 += ey * f;
                    }
                }
                var x1 = values[length - 2];
                var y1 = values[length - 1];
                if (headMargin !== 0) {
                    var ex = x1 - values[length - 4];
                    var ey = y1 - values[length - 3];
                    var n = ex * ex + ey * ey;
                    if (threshold < n) {
                        var f = headMargin / Math.sqrt(n);
                        x1 += ex * f;
                        y1 += ey * f;
                    }
                }
                var cx = (x1 + x0) * 0.5;
                var cy = (y1 + y0) * 0.5;
                var dx = x1 - x0;
                var dy = y1 - y0;
                var a = Math.atan2(dy, dx);
                var c = Math.cos(a);
                var s = Math.sin(a);
                var l = dx * dx + dy * dy;
                var m = threshold < l ? 1 / Math.sqrt(l) : 1;
                for (var i = 2, imax = length - 2; i < imax; i += 2) {
                    var x = values[i + 0] - cx;
                    var y = values[i + 1] - cy;
                    result.push((c * x + s * y) * m, (c * y - s * x) * m);
                }
            }
            return result;
        };
        return EShapeConnectorBodies;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var deserializeConnectorLine = function (item, manager, shape) {
        return deserializeBase(item, manager, shape || new EShapeConnectorLine());
    };
    var onDeserializedConnectorLine = function (item, shape, mapping, manager) {
        if (shape instanceof EShapeConnectorLine) {
            var resources = manager.resources;
            var resourceId = item[15];
            if (0 <= resourceId && resourceId < resources.length) {
                var parsed = manager.getExtension(resourceId);
                if (parsed == null) {
                    parsed = JSON.parse(resources[resourceId]);
                    manager.setExtension(resourceId, parsed);
                }
                // Lock
                shape.lock(EShapeLockPart.CONNECTOR);
                // Points
                var points = shape.points;
                points.deserialize(parsed[1], manager);
                // Edge
                var edge = shape.edge;
                edge.deserialize(parsed[0], mapping, manager);
                // Body
                var body = shape.body;
                var bodyId = parsed[2];
                if (bodyId != null) {
                    body.deserialize(bodyId, mapping, manager);
                }
                else {
                    // The following is for backward compatibility.
                    body.set(EShapeConnectorBodies.from(points.values, edge.tail.margin, edge.head.margin));
                }
                // Unlock
                shape.unlock(EShapeLockPart.CONNECTOR, true);
            }
        }
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadShapeConnectorElbow = function () {
        EShapeUploadeds[EShapeType.CONNECTOR_ELBOW] = createLineUploaded;
        EShapeDeserializers[EShapeType.CONNECTOR_ELBOW] = deserializeConnectorElbow;
        EShapeOnDeserializeds[EShapeType.CONNECTOR_ELBOW] = onDeserializedConnectorLine;
        EShapeCapabilities.set(EShapeType.CONNECTOR_ELBOW, EShapeCapability.CONNECTOR);
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadShapeConnectorLine = function () {
        EShapeUploadeds[EShapeType.CONNECTOR_LINE] = createLineUploaded;
        EShapeDeserializers[EShapeType.CONNECTOR_LINE] = deserializeConnectorLine;
        EShapeOnDeserializeds[EShapeType.CONNECTOR_LINE] = onDeserializedConnectorLine;
        EShapeCapabilities.set(EShapeType.CONNECTOR_LINE, EShapeCapability.CONNECTOR);
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var BuilderRectanglePivoted = /** @class */ (function (_super) {
        __extends(BuilderRectanglePivoted, _super);
        function BuilderRectanglePivoted(buffer, vertexOffset, indexOffset) {
            return _super.call(this, buffer, vertexOffset, indexOffset, RECTANGLE_VERTEX_COUNT, RECTANGLE_INDEX_COUNT) || this;
        }
        BuilderRectanglePivoted.prototype.init = function () {
            var buffer = this.buffer;
            buffer.updateIndices();
            buildRectangleIndex(buffer.indices, this.vertexOffset, this.indexOffset);
            this.inited |= BuilderFlag.INDEX;
        };
        BuilderRectanglePivoted.prototype.update = function (shape) {
            var buffer = this.buffer;
            this.updateVertexStepAndUv(buffer, shape);
            this.updateColor(buffer, shape);
        };
        BuilderRectanglePivoted.prototype.updateVertexStepAndUv = function (buffer, shape) {
            var size = shape.size;
            var sizeX = size.x;
            var sizeY = size.y;
            var isSizeChanged = sizeX !== this.sizeX || sizeY !== this.sizeY;
            var transformLocalId = toTransformLocalId(shape);
            var isTransformChanged = this.transformLocalId !== transformLocalId;
            var stroke = shape.stroke;
            var strokeAlign = stroke.align;
            var strokeWidth = stroke.enable ? stroke.width : 0;
            var strokeSide = stroke.side;
            var strokeStyle = stroke.style;
            var isStrokeChanged = this.strokeAlign !== strokeAlign ||
                this.strokeWidth !== strokeWidth ||
                this.strokeSide !== strokeSide ||
                this.strokeStyle !== strokeStyle;
            var texture = toTexture(shape);
            var textureTransformId = toTextureTransformId(texture);
            var isTextureChanged = texture !== this.texture || textureTransformId !== this.textureTransformId;
            var isVertexChanged = isSizeChanged || isStrokeChanged;
            var isNotInited = !(this.inited & BuilderFlag.VERTEX_STEP_AND_UV);
            if (isNotInited || isVertexChanged || isTransformChanged || isTextureChanged) {
                this.inited |= BuilderFlag.VERTEX_STEP_AND_UV;
                this.sizeX = sizeX;
                this.sizeY = sizeY;
                this.transformLocalId = transformLocalId;
                this.strokeAlign = strokeAlign;
                this.strokeWidth = strokeWidth;
                this.strokeSide = strokeSide;
                this.strokeStyle = strokeStyle;
                this.texture = texture;
                this.textureTransformId = textureTransformId;
                // Vertices
                var voffset = this.vertexOffset;
                buffer.updateVertices();
                buildRectangleVertex(buffer.vertices, voffset, 0.5 * sizeX, 0.5 * sizeY, sizeX, sizeY, strokeAlign, strokeWidth, shape.transform.internalTransform, RECTANGLE_WORLD_SIZE);
                // Steps
                if (isNotInited || isVertexChanged || isTransformChanged) {
                    buffer.updateSteps();
                    buildRectangleStep(voffset, buffer.steps, strokeWidth, strokeSide, strokeStyle, RECTANGLE_WORLD_SIZE);
                }
                // UVs
                if (isNotInited || isVertexChanged || isTextureChanged) {
                    buffer.updateUvs();
                    buildRectangleUv(buffer.uvs, voffset, toTextureUvs(texture));
                }
            }
        };
        return BuilderRectanglePivoted;
    }(BuilderBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var createRectanglePivotedUploaded = function (buffer, shape, voffset, ioffset, antialiasWeight) {
        var tcount = toTextBufferCount(shape);
        var tvcount = tcount << TEXT_VERTEX_COUNT_SHIFT;
        var ticount = tcount << TEXT_INDEX_COUNT_SHIFT;
        var vcount = RECTANGLE_VERTEX_COUNT + tvcount;
        var icount = RECTANGLE_INDEX_COUNT + ticount;
        if (buffer.check(voffset, ioffset, vcount, icount)) {
            return new EShapeUploadedImpl(buffer, voffset, ioffset, vcount, icount, [
                new BuilderRectanglePivoted(buffer, voffset, ioffset),
                new BuilderText(buffer, voffset + RECTANGLE_VERTEX_COUNT, ioffset + RECTANGLE_INDEX_COUNT, tvcount, ticount)
            ]).init(shape);
        }
        return null;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var createGroupUploaded = function (buffer, shape, voffset, ioffset) {
        var tcount = toTextBufferCount(shape);
        var tvcount = tcount << TEXT_VERTEX_COUNT_SHIFT;
        var ticount = tcount << TEXT_INDEX_COUNT_SHIFT;
        var vcount = tvcount;
        var icount = ticount;
        if (buffer.check(voffset, ioffset, vcount, icount)) {
            return new EShapeUploadedImpl(buffer, voffset, ioffset, vcount, icount, [
                new BuilderText(buffer, voffset, ioffset, tvcount, ticount)
            ]).init(shape);
        }
        return null;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var create = function (name, width, height, container, manager, item, shape) {
        var mode = manager.mode;
        var depth = manager.depth;
        shape = shape || new EShapeEmbedded(name, mode, depth);
        var result = deserializeBase(item, manager, shape);
        var shapeSize = shape.size;
        var sizeX = shapeSize.x;
        var sizeY = shapeSize.y;
        shape.size.set(width, height);
        container.copyTo(shape);
        shape.size.init();
        shape.size.set(sizeX, sizeY);
        if (mode === EShapeResourceManagerDeserializationMode.EDITOR) {
            if (0 < depth) {
                applyDataMappings(shape, manager);
            }
        }
        else {
            applyDataMappings(shape, manager);
        }
        return result;
    };
    var createMissing = function (name, manager, item, shape) {
        var mode = manager.mode;
        var depth = manager.depth;
        shape = shape || new EShapeEmbedded(name, mode, depth);
        var result = deserializeBase(item, manager, shape);
        var size = shape.size;
        var sizeX = size.x;
        var sizeY = size.y;
        var children = shape.children;
        var layer = new EShapeEmbeddedLayer("missing", mode, depth);
        var px = 0.5 * sizeX;
        var py = 0.5 * sizeX;
        layer.transform.position.set(-px, -py);
        layer.size.set(sizeX, sizeY);
        layer.size.init();
        layer.parent = shape;
        var rectangle = new EShapeRectangle();
        rectangle.stroke.color = 0xff0000;
        rectangle.transform.position.set(px, py);
        rectangle.size.copyFrom(shape.size);
        rectangle.attach(layer);
        children.push(layer);
        shape.onChildTransformChange();
        shape.toDirty();
        shape.onAttach();
        shape.size.init();
        if (mode === EShapeResourceManagerDeserializationMode.EDITOR) {
            if (0 < depth) {
                applyDataMappings(shape, manager);
            }
        }
        else {
            applyDataMappings(shape, manager);
        }
        return result;
    };
    var applyDataMappings = function (shape, manager) {
        var mapping = shape.data.getMapping();
        if (mapping != null) {
            var values = mapping.values;
            for (var i = 0, imax = values.length; i < imax; ++i) {
                var value = values[i];
                var source = value[0];
                var mapper = manager.getDataMapper(source);
                if (mapper != null) {
                    var children = shape.children;
                    var destination = manager.getDataDestination(value[1]);
                    var initial = value[2];
                    applyDataMapping(children, mapper, destination, initial);
                }
            }
        }
    };
    var applyDataMapping = function (targets, mapper, destination, initial) {
        for (var i = 0, imax = targets.length; i < imax; ++i) {
            var target = targets[i];
            var targetData = target.data;
            for (var j = 0, jmax = targetData.size(); j < jmax; ++j) {
                var targetDatum = targetData.get(j);
                if (targetDatum && targetDatum.scope !== EShapeDataValueScope.PRIVATE) {
                    mapper.map(targetDatum, destination, initial);
                }
            }
            // Children
            var children = target.children;
            if (0 < children.length) {
                applyDataMapping(children, mapper, destination, initial);
            }
        }
    };
    var deserializeEmbedded = function (item, manager, creator) {
        var pieces = manager.pieces;
        var pieceId = item[15];
        if (pieces && 0 <= pieceId && pieceId < pieces.length) {
            var pieceData = manager.pieceData;
            if (pieceData) {
                var piece = pieces[pieceId];
                var pieceDatum = pieceData.get(piece);
                var shape = creator && creator(piece, manager);
                if (pieceDatum) {
                    return create(piece, pieceDatum.width, pieceDatum.height, pieceDatum.layer, manager, item, shape);
                }
                else {
                    return createMissing(piece, manager, item, shape);
                }
            }
        }
        return null;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var toSubtype = function (target) {
        var result = EShapeAcceptorEdgeType.ALL & target;
        if (result !== 0) {
            return result;
        }
        return EShapeAcceptorEdgeType.HEAD;
    };
    var toSide = function (target) {
        return (EShapeAcceptorEdgeSide.ALL & (target >> 2));
    };
    var toVvisible = function (target) {
        return 0 < (0x1 & (target >> 6));
    };
    var deserializeEmbeddedAcceptorEdge = function (item, manager, shape) {
        shape !== null && shape !== void 0 ? shape : (shape = new EShapeEmbeddedAcceptorEdge());
        var item15 = item[15];
        shape.subtype = toSubtype(item15);
        shape.side = toSide(item15);
        shape.vvisible = toVvisible(item15);
        var result = deserializeBase(item, manager, shape);
        if (shape.vvisible === false) {
            if (manager.mode === EShapeResourceManagerDeserializationMode.VIEWER) {
                shape.visible = false;
            }
        }
        return result;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadShapeEmbedded = function () {
        // Embedded
        EShapeUploadeds[EShapeType.EMBEDDED] = createGroupUploaded;
        EShapeDeserializers[EShapeType.EMBEDDED] = deserializeEmbedded;
        EShapeCapabilities.set(EShapeType.EMBEDDED, EShapeCapability.EMBEDDED);
        // Embedded layer
        EShapeUploadeds[EShapeType.EMBEDDED_LAYER] = createRectanglePivotedUploaded;
        // Embedded acceptor edge
        EShapeUploadeds[EShapeType.EMBEDDED_ACCEPTOR_EDGE] = createCircleUploaded;
        EShapeDeserializers[EShapeType.EMBEDDED_ACCEPTOR_EDGE] = deserializeEmbeddedAcceptorEdge;
        EShapeCapabilities.set(EShapeType.EMBEDDED_ACCEPTOR_EDGE, EShapeCapability.EMBEDDED_ACCEPTOR_EDGE);
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeGroupFillEditor = /** @class */ (function () {
        function EShapeGroupFillEditor(parent) {
            this._parent = parent;
        }
        Object.defineProperty(EShapeGroupFillEditor.prototype, "enable", {
            get: function () {
                var children = this._parent.children;
                if (0 < children.length) {
                    return children[children.length - 1].fill.enable;
                }
                return true;
            },
            set: function (enable) {
                var children = this._parent.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    children[i].fill.enable = enable;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupFillEditor.prototype, "color", {
            get: function () {
                var children = this._parent.children;
                if (0 < children.length) {
                    return children[children.length - 1].fill.color;
                }
                return 0xffffff;
            },
            set: function (color) {
                var children = this._parent.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    children[i].fill.color = color;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupFillEditor.prototype, "alpha", {
            get: function () {
                var children = this._parent.children;
                if (0 < children.length) {
                    return children[children.length - 1].fill.alpha;
                }
                return 1.0;
            },
            set: function (alpha) {
                var children = this._parent.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    children[i].fill.alpha = alpha;
                }
            },
            enumerable: false,
            configurable: true
        });
        EShapeGroupFillEditor.prototype.copy = function (target) {
            var children = this._parent.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                children[i].fill.copy(target);
            }
        };
        EShapeGroupFillEditor.prototype.set = function (enable, color, alpha) {
            var children = this._parent.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                children[i].fill.set(enable, color, alpha);
            }
        };
        EShapeGroupFillEditor.prototype.clone = function () {
            return new EShapeGroupFillEditor(this._parent);
        };
        EShapeGroupFillEditor.prototype.toObject = function () {
            var children = this._parent.children;
            if (0 < children.length) {
                return children[children.length - 1].fill.toObject();
            }
            return {
                enable: true,
                color: 0xffffff,
                alpha: 1.0
            };
        };
        EShapeGroupFillEditor.prototype.serialize = function (manager) {
            return -1;
        };
        EShapeGroupFillEditor.prototype.deserialize = function (target, manager) {
            // DO NOTHING
        };
        return EShapeGroupFillEditor;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeGroupPoints = /** @class */ (function () {
        function EShapeGroupPoints(parent) {
            this._parent = parent;
        }
        Object.defineProperty(EShapeGroupPoints.prototype, "length", {
            get: function () {
                var children = this._parent.children;
                if (0 < children.length) {
                    var points = children[children.length - 1].points;
                    if (points != null) {
                        return points.length;
                    }
                }
                return 0;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupPoints.prototype, "plength", {
            get: function () {
                var children = this._parent.children;
                if (0 < children.length) {
                    var points = children[children.length - 1].points;
                    if (points != null) {
                        return points.plength;
                    }
                }
                return 0;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupPoints.prototype, "id", {
            get: function () {
                var children = this._parent.children;
                if (0 < children.length) {
                    var points = children[children.length - 1].points;
                    if (points != null) {
                        return points.id;
                    }
                }
                return 0;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupPoints.prototype, "values", {
            get: function () {
                var children = this._parent.children;
                if (0 < children.length) {
                    var points = children[children.length - 1].points;
                    if (points != null) {
                        return points.values;
                    }
                }
                return [];
            },
            set: function (values) {
                var children = this._parent.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    var points = children[i].points;
                    if (points != null) {
                        points.values = values;
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupPoints.prototype, "segments", {
            get: function () {
                var children = this._parent.children;
                if (0 < children.length) {
                    var points = children[children.length - 1].points;
                    if (points != null) {
                        return points.segments;
                    }
                }
                return [];
            },
            set: function (segments) {
                var children = this._parent.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    var points = children[i].points;
                    if (points != null) {
                        points.segments = segments;
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupPoints.prototype, "style", {
            get: function () {
                var children = this._parent.children;
                if (0 < children.length) {
                    var points = children[children.length - 1].points;
                    if (points != null) {
                        return points.style;
                    }
                }
                return EShapePointsStyle.NONE;
            },
            set: function (style) {
                var children = this._parent.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    var points = children[i].points;
                    if (points != null) {
                        points.style = style;
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupPoints.prototype, "marker", {
            get: function () {
                var children = this._parent.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    var points = children[i].points;
                    if (points != null) {
                        return points.marker;
                    }
                }
                return EShapePointsMarkerContainerImplNoop.getInstance();
            },
            enumerable: false,
            configurable: true
        });
        EShapeGroupPoints.prototype.getMarker = function () {
            var children = this._parent.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                var points = children[i].points;
                if (points != null) {
                    return points.getMarker();
                }
            }
            return undefined;
        };
        Object.defineProperty(EShapeGroupPoints.prototype, "formatter", {
            get: function () {
                var children = this._parent.children;
                if (0 < children.length) {
                    var points = children[children.length - 1].points;
                    if (points != null) {
                        return points.formatter;
                    }
                }
                return null;
            },
            set: function (formatter) {
                var children = this._parent.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    var points = children[i].points;
                    if (points != null) {
                        points.formatter = formatter;
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupPoints.prototype, "formatted", {
            get: function () {
                var children = this._parent.children;
                if (0 < children.length) {
                    var points = children[children.length - 1].points;
                    if (points != null) {
                        return points.formatted;
                    }
                }
                return this;
            },
            enumerable: false,
            configurable: true
        });
        EShapeGroupPoints.prototype.onSizeChange = function () {
            // DO NOTHING
        };
        EShapeGroupPoints.prototype.copy = function (source) {
            var children = this._parent.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                var points = children[i].points;
                if (points != null) {
                    points.copy(source);
                }
            }
            return this;
        };
        EShapeGroupPoints.prototype.set = function (values, segments, style) {
            var children = this._parent.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                var points = children[i].points;
                if (points != null) {
                    points.set(values, segments, style);
                }
            }
            return this;
        };
        EShapeGroupPoints.prototype.clone = function (parent) {
            return new EShapeGroupPoints(parent);
        };
        EShapeGroupPoints.prototype.toPoints = function (transform) {
            var children = this._parent.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                var points = children[i].points;
                if (points != null) {
                    return points.toPoints(transform);
                }
            }
            return [];
        };
        EShapeGroupPoints.prototype.serialize = function (manager) {
            var children = this._parent.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                var points = children[i].points;
                if (points != null) {
                    return points.serialize(manager);
                }
            }
            return -1;
        };
        return EShapeGroupPoints;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeGroupStrokeEditor = /** @class */ (function () {
        function EShapeGroupStrokeEditor(parent) {
            this._parent = parent;
        }
        Object.defineProperty(EShapeGroupStrokeEditor.prototype, "enable", {
            get: function () {
                var children = this._parent.children;
                if (0 < children.length) {
                    return children[children.length - 1].stroke.enable;
                }
                return false;
            },
            set: function (enable) {
                var children = this._parent.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    children[i].stroke.enable = enable;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupStrokeEditor.prototype, "color", {
            get: function () {
                var children = this._parent.children;
                if (0 < children.length) {
                    return children[children.length - 1].stroke.color;
                }
                return 0xffffff;
            },
            set: function (color) {
                var children = this._parent.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    children[i].stroke.color = color;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupStrokeEditor.prototype, "alpha", {
            get: function () {
                var children = this._parent.children;
                if (0 < children.length) {
                    return children[children.length - 1].stroke.alpha;
                }
                return 1.0;
            },
            set: function (alpha) {
                var children = this._parent.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    children[i].stroke.alpha = alpha;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupStrokeEditor.prototype, "width", {
            get: function () {
                var children = this._parent.children;
                if (0 < children.length) {
                    return children[children.length - 1].stroke.width;
                }
                return 1.0;
            },
            set: function (width) {
                var children = this._parent.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    children[i].stroke.width = width;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupStrokeEditor.prototype, "align", {
            get: function () {
                var children = this._parent.children;
                if (0 < children.length) {
                    return children[children.length - 1].stroke.align;
                }
                return 1.0;
            },
            set: function (align) {
                var children = this._parent.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    children[i].stroke.align = align;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupStrokeEditor.prototype, "side", {
            get: function () {
                var children = this._parent.children;
                if (0 < children.length) {
                    return children[children.length - 1].stroke.side;
                }
                return 1.0;
            },
            set: function (side) {
                var children = this._parent.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    children[i].stroke.side = side;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupStrokeEditor.prototype, "style", {
            get: function () {
                var children = this._parent.children;
                if (0 < children.length) {
                    return children[children.length - 1].stroke.style;
                }
                return EShapeStrokeStyle.NONE;
            },
            set: function (style) {
                var children = this._parent.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    children[i].stroke.style = style;
                }
            },
            enumerable: false,
            configurable: true
        });
        EShapeGroupStrokeEditor.prototype.copy = function (target) {
            var children = this._parent.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                children[i].stroke.copy(target);
            }
        };
        EShapeGroupStrokeEditor.prototype.set = function (enable, color, alpha, width, side) {
            var children = this._parent.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                children[i].stroke.set(enable, color, alpha, width, side);
            }
        };
        EShapeGroupStrokeEditor.prototype.clone = function () {
            return new EShapeGroupStrokeEditor(this._parent);
        };
        EShapeGroupStrokeEditor.prototype.toObject = function () {
            var children = this._parent.children;
            if (0 < children.length) {
                return children[children.length - 1].stroke.toObject();
            }
            return {
                enable: false,
                color: 0xffffff,
                alpha: 1.0,
                width: 1.0,
                align: 0.0,
                side: EShapeStrokeSide.NONE,
                style: EShapeStrokeStyle.NONE
            };
        };
        EShapeGroupStrokeEditor.prototype.serialize = function (manager) {
            return -1;
        };
        EShapeGroupStrokeEditor.prototype.deserialize = function (target, manager) {
            //
        };
        return EShapeGroupStrokeEditor;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeGroup = /** @class */ (function (_super) {
        __extends(EShapeGroup, _super);
        function EShapeGroup(mode, type) {
            if (type === void 0) { type = EShapeType.GROUP; }
            var _this = _super.call(this, type) || this;
            _this._mode = mode;
            var data = new EShapeDataImpl();
            _this.data = data;
            _this.tag = data;
            _this.size = _this.newGroupSize(mode);
            _this.fill = _this.newGroupFill();
            _this.stroke = _this.newGroupStroke();
            _this.text = _this.newGroupText();
            _this._points = _this.newGroupPoints();
            return _this;
        }
        Object.defineProperty(EShapeGroup.prototype, "mode", {
            get: function () {
                return this._mode;
            },
            enumerable: false,
            configurable: true
        });
        EShapeGroup.prototype.newGroupSize = function (mode) {
            var sizeX = EShapeDefaults.SIZE_X;
            var sizeY = EShapeDefaults.SIZE_Y;
            if (mode !== EShapeResourceManagerDeserializationMode.VIEWER) {
                return new EShapeGroupSizeEditor(this, sizeX, sizeY, this.isGroupSizeFittable());
            }
            else {
                return new EShapeGroupSizeViewer(this, sizeX, sizeY, sizeX, sizeY);
            }
        };
        EShapeGroup.prototype.isGroupSizeFittable = function () {
            return true;
        };
        EShapeGroup.prototype.newGroupFill = function () {
            return new EShapeGroupFillEditor(this);
        };
        EShapeGroup.prototype.newGroupStroke = function () {
            return new EShapeGroupStrokeEditor(this);
        };
        EShapeGroup.prototype.newGroupText = function () {
            return new EShapeTextImpl(this, EShapeDefaults.TEXT_VALUE, EShapeDefaults.TEXT_COLOR, EShapeDefaults.TEXT_ALPHA, EShapeDefaults.TEXT_FAMILY, EShapeDefaults.TEXT_SIZE);
        };
        EShapeGroup.prototype.newGroupPoints = function () {
            return new EShapeGroupPoints(this);
        };
        EShapeGroup.prototype.getBoundsSize = function () {
            var size = this.size;
            if (size instanceof EShapeGroupSizeViewer) {
                return size.base;
            }
            else {
                return size;
            }
        };
        EShapeGroup.prototype.onChildTransformChange = function () {
            _super.prototype.onChildTransformChange.call(this);
            this.size.fit();
        };
        Object.defineProperty(EShapeGroup.prototype, "corner", {
            get: function () {
                var children = this.children;
                if (0 < children.length) {
                    return children[children.length - 1].corner;
                }
                return EShapeCorner.ALL;
            },
            set: function (corner) {
                var children = this.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    children[i].corner = corner;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroup.prototype, "gradient", {
            get: function () {
                var children = this.children;
                for (var i = children.length - 1; 0 <= i; --i) {
                    var gradient = children[i].gradient;
                    if (gradient != null) {
                        return gradient;
                    }
                }
                return undefined;
            },
            set: function (gradient) {
                var children = this.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    children[i].gradient = gradient;
                }
            },
            enumerable: false,
            configurable: true
        });
        EShapeGroup.prototype.serializeGradient = function (manager) {
            return -1;
        };
        Object.defineProperty(EShapeGroup.prototype, "radius", {
            get: function () {
                var children = this.children;
                if (0 < children.length) {
                    return children[children.length - 1].radius;
                }
                return 0.5;
            },
            set: function (radius) {
                var children = this.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    children[i].radius = radius;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroup.prototype, "image", {
            get: function () {
                var children = this.children;
                for (var i = children.length - 1; 0 <= i; --i) {
                    var image = children[i].image;
                    if (image != null) {
                        return image;
                    }
                }
                return undefined;
            },
            set: function (image) {
                var children = this.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    children[i].image = image;
                }
            },
            enumerable: false,
            configurable: true
        });
        EShapeGroup.prototype.serializeImage = function (manager) {
            return -1;
        };
        Object.defineProperty(EShapeGroup.prototype, "points", {
            get: function () {
                var children = this.children;
                for (var i = children.length - 1; 0 <= i; --i) {
                    var points = children[i].points;
                    if (points != null) {
                        return this._points;
                    }
                }
                return undefined;
            },
            set: function (points) {
                // DO NOTHING
            },
            enumerable: false,
            configurable: true
        });
        EShapeGroup.prototype.clone = function () {
            var result = this.newClone().copy(this);
            var children = this.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                var clone = children[i].clone();
                clone.parent = result;
                result.children.push(clone);
            }
            EShapeConnectors.moveAll(children, result.children, children, result.children);
            result.onChildTransformChange();
            result.toDirty();
            return result;
        };
        EShapeGroup.prototype.newClone = function () {
            var constructor = this.constructor;
            return new constructor(this._mode, this.type);
        };
        EShapeGroup.prototype.containsAbs = function (x, y, ax, ay, sw, ss, sa) {
            return false;
        };
        return EShapeGroup;
    }(EShapeBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var deserializeGroup = function (item, manager, shape) {
        shape = shape || new EShapeGroup(manager.mode);
        var result = deserializeBase(item, manager, shape);
        shape.size.init();
        return result;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadShapeGroup = function () {
        EShapeUploadeds[EShapeType.GROUP] = createGroupUploaded;
        EShapeDeserializers[EShapeType.GROUP] = deserializeGroup;
        EShapeCapabilities.set(EShapeType.GROUP, EShapeCapability.GROUP);
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeGroupSizeShadowed = /** @class */ (function () {
        function EShapeGroupSizeShadowed(parent, x, y) {
            this._parent = parent;
            this._size = new pixi_js.Point(x, y);
        }
        EShapeGroupSizeShadowed.prototype.init = function () {
            return this;
        };
        Object.defineProperty(EShapeGroupSizeShadowed.prototype, "x", {
            get: function () {
                return this._size.x;
            },
            set: function (x) {
                var size = this._size;
                if (size.x !== x) {
                    var ox = size.x;
                    size.x = x;
                    this.onChange(ox, size.y);
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupSizeShadowed.prototype, "y", {
            get: function () {
                return this._size.y;
            },
            set: function (y) {
                var size = this._size;
                if (size.y !== y) {
                    var oy = size.y;
                    size.y = y;
                    this.onChange(size.x, oy);
                }
            },
            enumerable: false,
            configurable: true
        });
        EShapeGroupSizeShadowed.prototype.set = function (x, y) {
            var isChanged = false;
            var size = this._size;
            var ox = size.x;
            var oy = size.y;
            if (x != null && ox !== x) {
                isChanged = true;
                size.x = x;
            }
            if (y != null && oy !== y) {
                isChanged = true;
                size.y = y;
            }
            if (isChanged) {
                this.onChange(ox, oy);
            }
            return this;
        };
        EShapeGroupSizeShadowed.prototype.clone = function () {
            var size = this._size;
            return new EShapeGroupSizeShadowed(this._parent, size.x, size.y);
        };
        EShapeGroupSizeShadowed.prototype.copy = function () {
            // DO NOTHING
        };
        EShapeGroupSizeShadowed.prototype.copyFrom = function (point) {
            var x = point.x;
            var y = point.y;
            var size = this._size;
            var ox = size.x;
            var oy = size.y;
            if (ox !== x || oy !== y) {
                size.x = x;
                size.y = y;
                this.onChange(ox, oy);
            }
            return this;
        };
        EShapeGroupSizeShadowed.prototype.copyTo = function (point) {
            return this._size.copyTo(point);
        };
        EShapeGroupSizeShadowed.prototype.equals = function (point) {
            return this._size.equals(point);
        };
        EShapeGroupSizeShadowed.prototype.fit = function () {
            return this;
        };
        EShapeGroupSizeShadowed.prototype.onChange = function (ox, oy) {
            this._parent.onSizeChange();
        };
        return EShapeGroupSizeShadowed;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeGroupShadowed = /** @class */ (function (_super) {
        __extends(EShapeGroupShadowed, _super);
        function EShapeGroupShadowed(mode, type) {
            if (type === void 0) { type = EShapeType.GROUP_SHADOWED; }
            return _super.call(this, mode, type) || this;
        }
        EShapeGroupShadowed.prototype.newGroupSize = function (mode) {
            if (mode !== EShapeResourceManagerDeserializationMode.VIEWER) {
                return new EShapeGroupSizeShadowed(this, EShapeDefaults.SIZE_X, EShapeDefaults.SIZE_Y);
            }
            else {
                return _super.prototype.newGroupSize.call(this, mode);
            }
        };
        return EShapeGroupShadowed;
    }(EShapeGroup));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var deserializeGroupShadowed = function (item, manager, shape) {
        shape = shape || new EShapeGroupShadowed(manager.mode);
        var result = deserializeBase(item, manager, shape);
        shape.size.init();
        return result;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadShapeGroupShadowed = function () {
        EShapeUploadeds[EShapeType.GROUP_SHADOWED] = createGroupUploaded;
        EShapeDeserializers[EShapeType.GROUP_SHADOWED] = deserializeGroupShadowed;
        EShapeCapabilities.set(EShapeType.GROUP_SHADOWED, EShapeCapability.GROUP);
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var BuilderRectangle = /** @class */ (function (_super) {
        __extends(BuilderRectangle, _super);
        function BuilderRectangle(buffer, vertexOffset, indexOffset) {
            return _super.call(this, buffer, vertexOffset, indexOffset, RECTANGLE_VERTEX_COUNT, RECTANGLE_INDEX_COUNT) || this;
        }
        BuilderRectangle.prototype.init = function () {
            var buffer = this.buffer;
            buffer.updateIndices();
            buildRectangleIndex(buffer.indices, this.vertexOffset, this.indexOffset);
            this.inited |= BuilderFlag.INDEX;
        };
        BuilderRectangle.prototype.update = function (shape) {
            var buffer = this.buffer;
            this.updateVertexStepAndUv(buffer, shape);
            this.updateColor(buffer, shape);
        };
        BuilderRectangle.prototype.updateVertexStepAndUv = function (buffer, shape) {
            var size = shape.size;
            var sizeX = size.x;
            var sizeY = size.y;
            var isSizeChanged = sizeX !== this.sizeX || sizeY !== this.sizeY;
            var transformLocalId = toTransformLocalId(shape);
            var isTransformChanged = this.transformLocalId !== transformLocalId;
            var stroke = shape.stroke;
            var strokeAlign = stroke.align;
            var strokeWidth = stroke.enable ? stroke.width : 0;
            var strokeSide = stroke.side;
            var strokeStyle = stroke.style;
            var isStrokeChanged = this.strokeAlign !== strokeAlign ||
                this.strokeWidth !== strokeWidth ||
                this.strokeSide !== strokeSide ||
                this.strokeStyle !== strokeStyle;
            var texture = toTexture(shape);
            var textureTransformId = toTextureTransformId(texture);
            var isTextureChanged = texture !== this.texture || textureTransformId !== this.textureTransformId;
            var isVertexChanged = isSizeChanged || isStrokeChanged;
            var isNotInited = !(this.inited & BuilderFlag.VERTEX_STEP_AND_UV);
            if (isNotInited || isVertexChanged || isTransformChanged || isTextureChanged) {
                this.inited |= BuilderFlag.VERTEX_STEP_AND_UV;
                this.sizeX = sizeX;
                this.sizeY = sizeY;
                this.transformLocalId = transformLocalId;
                this.strokeAlign = strokeAlign;
                this.strokeWidth = strokeWidth;
                this.strokeSide = strokeSide;
                this.strokeStyle = strokeStyle;
                this.texture = texture;
                this.textureTransformId = textureTransformId;
                // Vertices
                var voffset = this.vertexOffset;
                buffer.updateVertices();
                buildRectangleVertex(buffer.vertices, voffset, 0, 0, sizeX, sizeY, strokeAlign, strokeWidth, shape.transform.internalTransform, RECTANGLE_WORLD_SIZE);
                // Steps
                if (isNotInited || isVertexChanged || isTransformChanged) {
                    buffer.updateSteps();
                    buildRectangleStep(voffset, buffer.steps, strokeWidth, strokeSide, strokeStyle, RECTANGLE_WORLD_SIZE);
                }
                // UVs
                if (isNotInited || isVertexChanged || isTextureChanged) {
                    buffer.updateUvs();
                    buildRectangleUv(buffer.uvs, voffset, toTextureUvs(texture));
                }
            }
        };
        return BuilderRectangle;
    }(BuilderBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var createRectangleUploaded = function (buffer, shape, voffset, ioffset, antialiasWeight) {
        var tcount = toTextBufferCount(shape);
        var tvcount = tcount << TEXT_VERTEX_COUNT_SHIFT;
        var ticount = tcount << TEXT_INDEX_COUNT_SHIFT;
        var vcount = RECTANGLE_VERTEX_COUNT + tvcount;
        var icount = RECTANGLE_INDEX_COUNT + ticount;
        if (buffer.check(voffset, ioffset, vcount, icount)) {
            return new EShapeUploadedImpl(buffer, voffset, ioffset, vcount, icount, [
                new BuilderRectangle(buffer, voffset, ioffset),
                new BuilderText(buffer, voffset + RECTANGLE_VERTEX_COUNT, ioffset + RECTANGLE_INDEX_COUNT, tvcount, ticount)
            ]).init(shape);
        }
        return null;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeImage = /** @class */ (function (_super) {
        __extends(EShapeImage, _super);
        function EShapeImage(image, type) {
            if (type === void 0) { type = EShapeType.IMAGE; }
            var _this = _super.call(this, type) || this;
            if (image != null) {
                _this.image = image;
                _this.size.set(image.width, image.height);
            }
            _this.fill.alpha = 1;
            return _this;
        }
        EShapeImage.prototype.clone = function () {
            return new EShapeImage(this.image, this.type).copy(this);
        };
        return EShapeImage;
    }(EShapeRectangle));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var deserializeImage = function (item, manager, shape) {
        return deserializeBase(item, manager, shape || new EShapeImage());
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadShapeImage = function () {
        EShapeUploadeds[EShapeType.IMAGE] = createRectangleUploaded;
        EShapeDeserializers[EShapeType.IMAGE] = deserializeImage;
    };

    var IMAGE_SDF_VERTEX_COUNT = 9;
    var IMAGE_SDF_INDEX_COUNT = 8;
    var IMAGE_SDF_WORLD_SIZE = [0, 0];
    var IMAGE_SDF_WORK_POINT = new pixi_js.Point();
    var buildImageSdfIndex = function (indices, voffset, ioffset) {
        var ii = ioffset * 3 - 1;
        indices[++ii] = voffset;
        indices[++ii] = voffset + 1;
        indices[++ii] = voffset + 3;
        indices[++ii] = voffset + 1;
        indices[++ii] = voffset + 4;
        indices[++ii] = voffset + 3;
        indices[++ii] = voffset + 1;
        indices[++ii] = voffset + 2;
        indices[++ii] = voffset + 4;
        indices[++ii] = voffset + 2;
        indices[++ii] = voffset + 5;
        indices[++ii] = voffset + 4;
        indices[++ii] = voffset + 3;
        indices[++ii] = voffset + 4;
        indices[++ii] = voffset + 6;
        indices[++ii] = voffset + 4;
        indices[++ii] = voffset + 7;
        indices[++ii] = voffset + 6;
        indices[++ii] = voffset + 4;
        indices[++ii] = voffset + 5;
        indices[++ii] = voffset + 7;
        indices[++ii] = voffset + 5;
        indices[++ii] = voffset + 8;
        indices[++ii] = voffset + 7;
    };
    var buildImageSdfStep = function (steps, voffset, strokeAlign, strokeWidth, strokeStyle, textureWidth, textureHeight, worldSize) {
        var scaleInvariant = toScaleInvariant(strokeStyle);
        var e = toPackedI4x64(2, scaleInvariant, 1, 1);
        var scaleX = textureWidth / worldSize[0];
        var scaleY = textureHeight / worldSize[1];
        var scaleZ = (scaleX + scaleY) * 0.5;
        var strokeWidthRatio = strokeWidth / 12.0;
        var position = -1 + strokeAlign;
        var is = voffset * 6 - 1;
        steps[++is] = strokeWidthRatio;
        steps[++is] = e;
        steps[++is] = scaleZ;
        steps[++is] = position;
        steps[++is] = 0;
        steps[++is] = 0;
        steps[++is] = strokeWidthRatio;
        steps[++is] = e;
        steps[++is] = scaleY;
        steps[++is] = position;
        steps[++is] = 0;
        steps[++is] = 0;
        steps[++is] = strokeWidthRatio;
        steps[++is] = e;
        steps[++is] = scaleZ;
        steps[++is] = position;
        steps[++is] = 0;
        steps[++is] = 0;
        steps[++is] = strokeWidthRatio;
        steps[++is] = e;
        steps[++is] = scaleX;
        steps[++is] = position;
        steps[++is] = 0;
        steps[++is] = 0;
        steps[++is] = strokeWidthRatio;
        steps[++is] = e;
        steps[++is] = scaleZ;
        steps[++is] = position;
        steps[++is] = 0;
        steps[++is] = 0;
        steps[++is] = strokeWidthRatio;
        steps[++is] = e;
        steps[++is] = scaleX;
        steps[++is] = position;
        steps[++is] = 0;
        steps[++is] = 0;
        steps[++is] = strokeWidthRatio;
        steps[++is] = e;
        steps[++is] = scaleZ;
        steps[++is] = position;
        steps[++is] = 0;
        steps[++is] = 0;
        steps[++is] = strokeWidthRatio;
        steps[++is] = e;
        steps[++is] = scaleY;
        steps[++is] = position;
        steps[++is] = 0;
        steps[++is] = 0;
        steps[++is] = strokeWidthRatio;
        steps[++is] = e;
        steps[++is] = scaleY;
        steps[++is] = position;
        steps[++is] = 0;
        steps[++is] = 0;
    };
    var buildImageSdfVertex = function (vertices, voffset, originX, originY, sizeX, sizeY, internalTransform, worldSize) {
        // Calculate the transformed positions
        //
        // 0       1       2
        // |-------|-------|
        // |       |       |
        // 3-------4-------5
        // |       |       |
        // |-------|-------|
        // 6       7       8
        //
        var work = IMAGE_SDF_WORK_POINT;
        var sx = sizeX * 0.5;
        var sy = sizeY * 0.5;
        work.set(originX - sx, originY - sy);
        internalTransform.apply(work, work);
        var x0 = work.x;
        var y0 = work.y;
        work.set(originX + sx, originY - sy);
        internalTransform.apply(work, work);
        var x2 = work.x;
        var y2 = work.y;
        work.set(originX + sx, originY + sy);
        internalTransform.apply(work, work);
        var x8 = work.x;
        var y8 = work.y;
        var x6 = x0 + (x8 - x2);
        var y6 = y0 + (y8 - y2);
        // Vertices
        var iv = (voffset << 1) - 1;
        vertices[++iv] = x0;
        vertices[++iv] = y0;
        vertices[++iv] = (x0 + x2) * 0.5;
        vertices[++iv] = (y0 + y2) * 0.5;
        vertices[++iv] = x2;
        vertices[++iv] = y2;
        vertices[++iv] = (x0 + x6) * 0.5;
        vertices[++iv] = (y0 + y6) * 0.5;
        vertices[++iv] = (x0 + x8) * 0.5;
        vertices[++iv] = (y0 + y8) * 0.5;
        vertices[++iv] = (x2 + x8) * 0.5;
        vertices[++iv] = (y2 + y8) * 0.5;
        vertices[++iv] = x6;
        vertices[++iv] = y6;
        vertices[++iv] = (x6 + x8) * 0.5;
        vertices[++iv] = (y6 + y8) * 0.5;
        vertices[++iv] = x8;
        vertices[++iv] = y8;
        worldSize[0] = toLength(x0, y0, x2, y2) * 0.5;
        worldSize[1] = toLength(x0, y0, x6, y6) * 0.5;
    };
    var buildImageSdfUv = function (uvs, voffset, textureUv) {
        var x0 = textureUv.x0;
        var y0 = textureUv.y0;
        var x1 = textureUv.x1;
        var y1 = textureUv.y1;
        var x2 = textureUv.x2;
        var y2 = textureUv.y2;
        var x3 = textureUv.x3;
        var y3 = textureUv.y3;
        var iv = (voffset << 1) - 1;
        uvs[++iv] = x0;
        uvs[++iv] = y0;
        uvs[++iv] = (x1 + x0) * 0.5;
        uvs[++iv] = (y1 + y0) * 0.5;
        uvs[++iv] = x1;
        uvs[++iv] = y1;
        uvs[++iv] = (x0 + x3) * 0.5;
        uvs[++iv] = (y0 + y3) * 0.5;
        uvs[++iv] = (x0 + x2) * 0.5;
        uvs[++iv] = (y0 + y2) * 0.5;
        uvs[++iv] = (x1 + x2) * 0.5;
        uvs[++iv] = (y1 + y2) * 0.5;
        uvs[++iv] = x3;
        uvs[++iv] = y3;
        uvs[++iv] = (x3 + x2) * 0.5;
        uvs[++iv] = (y3 + y2) * 0.5;
        uvs[++iv] = x2;
        uvs[++iv] = y2;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var BuilderImageSdf = /** @class */ (function (_super) {
        __extends(BuilderImageSdf, _super);
        function BuilderImageSdf(buffer, vertexOffset, indexOffset) {
            var _this = _super.call(this, buffer, vertexOffset, indexOffset, IMAGE_SDF_VERTEX_COUNT, IMAGE_SDF_INDEX_COUNT) || this;
            _this.textureWidth = -1;
            _this.textureHeight = -1;
            return _this;
        }
        BuilderImageSdf.prototype.init = function () {
            var voffset = this.vertexOffset;
            var buffer = this.buffer;
            buffer.updateIndices();
            buildImageSdfIndex(buffer.indices, voffset, this.indexOffset);
            this.inited |= BuilderFlag.INDEX;
        };
        BuilderImageSdf.prototype.update = function (shape) {
            var buffer = this.buffer;
            this.updateVertexAndStep(buffer, shape);
            this.updateColor(buffer, shape);
            this.updateUv(buffer, shape);
        };
        BuilderImageSdf.prototype.updateVertexAndStep = function (buffer, shape) {
            var size = shape.size;
            var sizeX = size.x;
            var sizeY = size.y;
            var isSizeChanged = sizeX !== this.sizeX || sizeY !== this.sizeY;
            var transformLocalId = toTransformLocalId(shape);
            var isTransformChanged = this.transformLocalId !== transformLocalId;
            var stroke = shape.stroke;
            var strokeAlign = stroke.align;
            var strokeWidth = stroke.enable ? stroke.width : 0;
            var strokeStyle = stroke.style;
            var isStrokeChanged = this.strokeAlign !== strokeAlign ||
                this.strokeWidth !== strokeWidth ||
                this.strokeStyle !== strokeStyle;
            var texture = toTexture(shape);
            var textureWidth = texture.width * texture.resolution;
            var textureHeight = texture.height * texture.resolution;
            var isTextureSizeChanged = this.textureWidth !== textureWidth || this.textureHeight !== textureHeight;
            var isNotInited = !(this.inited & BuilderFlag.VERTEX_AND_STEP);
            if (isNotInited ||
                isSizeChanged ||
                isTransformChanged ||
                isStrokeChanged ||
                isTextureSizeChanged) {
                this.inited |= BuilderFlag.VERTEX_AND_STEP;
                this.sizeX = sizeX;
                this.sizeY = sizeY;
                this.transformLocalId = transformLocalId;
                this.strokeAlign = strokeAlign;
                this.strokeWidth = strokeWidth;
                this.strokeStyle = strokeStyle;
                this.textureWidth = textureWidth;
                this.textureHeight = textureHeight;
                // Vertices
                buffer.updateVertices();
                buildImageSdfVertex(buffer.vertices, this.vertexOffset, 0, 0, sizeX, sizeY, shape.transform.internalTransform, IMAGE_SDF_WORLD_SIZE);
                // Steps
                buffer.updateSteps();
                buildImageSdfStep(buffer.steps, this.vertexOffset, strokeAlign, strokeWidth, strokeStyle, textureWidth, textureHeight, IMAGE_SDF_WORLD_SIZE);
            }
        };
        BuilderImageSdf.prototype.updateUv = function (buffer, shape) {
            var texture = toTexture(shape);
            var textureTransformId = toTextureTransformId(texture);
            var isNotInited = !(this.inited & BuilderFlag.UV);
            if (isNotInited ||
                texture !== this.texture ||
                textureTransformId !== this.textureTransformId) {
                this.inited |= BuilderFlag.UV;
                this.texture = texture;
                this.textureTransformId = textureTransformId;
                buffer.updateUvs();
                buildImageSdfUv(buffer.uvs, this.vertexOffset, toTextureUvs(texture));
            }
        };
        return BuilderImageSdf;
    }(BuilderBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var createImageSdfUploaded = function (buffer, shape, voffset, ioffset, antialiasWeight) {
        var tcount = toTextBufferCount(shape);
        var tvcount = tcount << TEXT_VERTEX_COUNT_SHIFT;
        var ticount = tcount << TEXT_INDEX_COUNT_SHIFT;
        var vcount = IMAGE_SDF_VERTEX_COUNT + tvcount;
        var icount = IMAGE_SDF_INDEX_COUNT + ticount;
        if (buffer.check(voffset, ioffset, vcount, icount)) {
            return new EShapeUploadedImpl(buffer, voffset, ioffset, vcount, icount, [
                new BuilderImageSdf(buffer, voffset, ioffset),
                new BuilderText(buffer, voffset + IMAGE_SDF_VERTEX_COUNT, ioffset + IMAGE_SDF_INDEX_COUNT, tvcount, ticount)
            ]).init(shape);
        }
        return null;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeImageSdf = /** @class */ (function (_super) {
        __extends(EShapeImageSdf, _super);
        function EShapeImageSdf(image, type) {
            if (type === void 0) { type = EShapeType.IMAGE_SDF; }
            return _super.call(this, image, type) || this;
        }
        EShapeImageSdf.prototype.clone = function () {
            return new EShapeImageSdf(this.image, this.type).copy(this);
        };
        return EShapeImageSdf;
    }(EShapeImage));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var deserializeImageSdf = function (item, manager, shape) {
        return deserializeBase(item, manager, shape || new EShapeImageSdf());
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadShapeImageSdf = function () {
        EShapeUploadeds[EShapeType.IMAGE_SDF] = createImageSdfUploaded;
        EShapeDeserializers[EShapeType.IMAGE_SDF] = deserializeImageSdf;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var BuilderLabel = /** @class */ (function () {
        function BuilderLabel(buffer, vertexOffset, indexOffset) {
            this.buffer = buffer;
            this.vertexOffset = vertexOffset;
            this.indexOffset = indexOffset;
            this.vertexCount = 0;
            this.indexCount = 0;
            this.texture = null;
        }
        BuilderLabel.prototype.init = function () {
            return this;
        };
        BuilderLabel.prototype.reinit = function (buffer, shape, vertexOffset, indexOffset) {
            this.buffer = buffer;
            this.vertexOffset = vertexOffset;
            this.indexOffset = indexOffset;
            return true;
        };
        BuilderLabel.prototype.isCompatible = function (shape) {
            return true;
        };
        BuilderLabel.prototype.update = function (shape) {
            this.texture = toTexture(shape);
        };
        BuilderLabel.prototype.buildUnit = function (builder) {
            var texture = this.texture || pixi_js.Texture.WHITE;
            var baseTexture = texture.baseTexture;
            if (baseTexture !== builder.baseTexture) {
                builder.baseTexture = baseTexture;
                var indexOffset = this.indexOffset;
                builder.push(texture, indexOffset);
            }
        };
        return BuilderLabel;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var createLabelUploaded = function (buffer, shape, voffset, ioffset, antialiasWeight) {
        var tcount = toTextBufferCount(shape);
        var tvcount = tcount << TEXT_VERTEX_COUNT_SHIFT;
        var ticount = tcount << TEXT_INDEX_COUNT_SHIFT;
        var vcount = tvcount;
        var icount = ticount;
        if (buffer.check(voffset, ioffset, vcount, icount)) {
            return new EShapeUploadedImpl(buffer, voffset, ioffset, vcount, icount, [
                new BuilderLabel(buffer, voffset, ioffset),
                new BuilderText(buffer, voffset, ioffset, tvcount, ticount)
            ]).init(shape);
        }
        return null;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeLabel = /** @class */ (function (_super) {
        __extends(EShapeLabel, _super);
        function EShapeLabel(type) {
            if (type === void 0) { type = EShapeType.LABEL; }
            return _super.call(this, type) || this;
        }
        EShapeLabel.prototype.clone = function () {
            return new EShapeLabel(this.type).copy(this);
        };
        return EShapeLabel;
    }(EShapePrimitive));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var deserializeLabel = function (item, manager, shape) {
        return deserializeBase(item, manager, shape || new EShapeLabel());
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadShapeLabel = function () {
        EShapeUploadeds[EShapeType.LABEL] = createLabelUploaded;
        EShapeDeserializers[EShapeType.LABEL] = deserializeLabel;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeLine = /** @class */ (function (_super) {
        __extends(EShapeLine, _super);
        function EShapeLine(type) {
            if (type === void 0) { type = EShapeType.LINE; }
            var _this = _super.call(this, type) || this;
            _this._points = new EShapeLinePoints(_this);
            return _this;
        }
        Object.defineProperty(EShapeLine.prototype, "points", {
            get: function () {
                return this._points;
            },
            enumerable: false,
            configurable: true
        });
        EShapeLine.prototype.clone = function () {
            return new EShapeLine(this.type).copy(this);
        };
        EShapeLine.prototype.serialize = function (manager) {
            var result = _super.prototype.serialize.call(this, manager);
            result[15] = this._points.serialize(manager);
            return result;
        };
        return EShapeLine;
    }(EShapeLineBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var deserializeLine = function (item, manager, shape) {
        shape = shape || new EShapeLine();
        var result = deserializeBase(item, manager, shape);
        shape.points.deserialize(item[15], manager);
        var style = shape.points.style;
        var mask = EShapePointsStyle.NON_SCALING_MASK |
            EShapePointsStyle.DOTTED_MASK |
            EShapePointsStyle.DASHED_MASK;
        var deprecated = style & mask;
        if (deprecated) {
            shape.points.style &= ~mask;
            shape.stroke.style |= deprecated;
        }
        return result;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadShapeLine = function () {
        EShapeUploadeds[EShapeType.LINE] = createLineUploaded;
        EShapeDeserializers[EShapeType.LINE] = deserializeLine;
    };

    var buildNullIndex = function (indices, voffset, ioffset, icount) {
        for (var ii = ioffset * 3, iimax = (ioffset + icount) * 3; ii < iimax; ii += 3) {
            indices[ii + 0] = voffset;
            indices[ii + 1] = voffset;
            indices[ii + 2] = voffset;
        }
    };
    var buildNullVertex = function (vertices, voffset, vcount) {
        for (var i = voffset * 2, imax = (voffset + vcount) * 2; i < imax; i += 2) {
            vertices[i + 0] = 0;
            vertices[i + 1] = 0;
        }
    };
    var buildNullStep = function (steps, voffset, vcount) {
        for (var i = voffset * 6, imax = (voffset + vcount) * 6; i < imax; i += 6) {
            steps[i + 0] = 0;
            steps[i + 1] = 0;
            steps[i + 2] = 0;
            steps[i + 3] = 0;
            steps[i + 4] = 0;
            steps[i + 5] = 0;
        }
    };
    var buildNullUv = function (uvs, voffset, vcount) {
        for (var i = voffset * 2, imax = (voffset + vcount) * 2; i < imax; i += 2) {
            uvs[i + 0] = 0;
            uvs[i + 1] = 0;
        }
    };

    var toLineOfAnyPointCount = function (pointCount) {
        return ((pointCount >> 4) + (0 < (pointCount & 0xf) ? 1 : 0)) << 4;
    };
    /**
     * Build a vertex buffer of colors.
     *
     * @param vo Vertex pffset
     * @param vcpp Vertex count per point
     * @param pf Point Fill
     * @param ps Point stroke
     * @param pc Point count
     * @param colors Vertex buffer of colors
     * @param ife True if fills are enabled
     * @param ise True if strokes are enabled
     * @param cfd Default fill color
     * @param afd Default fill alpha
     * @param csd Default stroke color
     * @param asd Default stroke alpha
     */
    var buildLineOfAnyColor = function (vo, vcpp, pf, ps, pc, colors, ife, ise, cfd, afd, csd, asd) {
        if (ife) {
            if (pf.isStaticColor()) {
                var cf = pf.getColor(0, cfd);
                if (pf.isStaticAlpha()) {
                    var af = pf.getAlpha(0, afd);
                    buildLineOfAnyColor0(vo, vcpp, pf, ps, pc, colors, ise, csd, asd, cf, af);
                }
                else {
                    buildLineOfAnyColor1(vo, vcpp, pf, ps, pc, colors, ise, csd, asd, cf, afd);
                }
            }
            else {
                if (pf.isStaticAlpha()) {
                    var af = pf.getAlpha(0, afd);
                    buildLineOfAnyColor2(vo, vcpp, pf, ps, pc, colors, ise, csd, asd, cfd, af);
                }
                else {
                    buildLineOfAnyColor3(vo, vcpp, pf, ps, pc, colors, ise, csd, asd, cfd, afd);
                }
            }
        }
        else {
            if (pf.isStaticColor()) {
                var cf = pf.getColor(0, cfd);
                buildLineOfAnyColor0(vo, vcpp, pf, ps, pc, colors, ise, csd, asd, cf, 0);
            }
            else {
                buildLineOfAnyColor2(vo, vcpp, pf, ps, pc, colors, ise, csd, asd, cfd, 0);
            }
        }
    };
    var buildLineOfAnyColor0 = function (vo, vcpp, pf, ps, pc, colors, ise, csd, asd, cf, af) {
        if (ise) {
            if (ps.isStaticColor()) {
                var cs = ps.getColor(0, csd);
                if (ps.isStaticAlpha()) {
                    var as = ps.getAlpha(0, asd);
                    buildColor(cf, af, cs, as, vo, vcpp * pc, colors);
                }
                else {
                    for (var i = 0, iv = vo; i < pc; i += 1, iv += vcpp) {
                        var as = ps.getAlpha(i, asd);
                        buildColor(cf, af, cs, as, iv, vcpp, colors);
                    }
                }
            }
            else {
                if (ps.isStaticAlpha()) {
                    var as = ps.getAlpha(0, asd);
                    for (var i = 0, iv = vo; i < pc; i += 1, iv += vcpp) {
                        var cs = ps.getColor(i, csd);
                        buildColor(cf, af, cs, as, iv, vcpp, colors);
                    }
                }
                else {
                    for (var i = 0, iv = vo; i < pc; i += 1, iv += vcpp) {
                        var cs = ps.getColor(i, csd);
                        var as = ps.getAlpha(i, asd);
                        buildColor(cf, af, cs, as, iv, vcpp, colors);
                    }
                }
            }
        }
        else {
            if (ps.isStaticColor()) {
                var cs = ps.getColor(0, csd);
                buildColor(cf, af, cs, 0, vo, vcpp * pc, colors);
            }
            else {
                for (var i = 0, iv = vo; i < pc; i += 1, iv += vcpp) {
                    var cs = ps.getColor(i, csd);
                    buildColor(cf, af, cs, 0, iv, vcpp, colors);
                }
            }
        }
    };
    var buildLineOfAnyColor1 = function (vo, vcpp, pf, ps, pc, colors, ise, csd, asd, cf, afd) {
        if (ise) {
            if (ps.isStaticColor()) {
                var cs = ps.getColor(0, csd);
                if (ps.isStaticAlpha()) {
                    var as = ps.getAlpha(0, asd);
                    for (var i = 0, iv = vo; i < pc; i += 1, iv += vcpp) {
                        var af = pf.getAlpha(i, afd);
                        buildColor(cf, af, cs, as, iv, vcpp, colors);
                    }
                }
                else {
                    for (var i = 0, iv = vo; i < pc; i += 1, iv += vcpp) {
                        var af = pf.getAlpha(i, afd);
                        var as = ps.getAlpha(i, asd);
                        buildColor(cf, af, cs, as, iv, vcpp, colors);
                    }
                }
            }
            else {
                if (ps.isStaticAlpha()) {
                    var as = ps.getAlpha(0, asd);
                    for (var i = 0, iv = vo; i < pc; i += 1, iv += vcpp) {
                        var af = pf.getAlpha(i, afd);
                        var cs = ps.getColor(i, csd);
                        buildColor(cf, af, cs, as, iv, vcpp, colors);
                    }
                }
                else {
                    for (var i = 0, iv = vo; i < pc; i += 1, iv += vcpp) {
                        var af = pf.getAlpha(i, afd);
                        var cs = ps.getColor(i, csd);
                        var as = ps.getAlpha(i, asd);
                        buildColor(cf, af, cs, as, iv, vcpp, colors);
                    }
                }
            }
        }
        else {
            if (ps.isStaticColor()) {
                var cs = ps.getColor(0, csd);
                for (var i = 0, iv = vo; i < pc; i += 1, iv += vcpp) {
                    var af = pf.getAlpha(i, afd);
                    buildColor(cf, af, cs, 0, iv, vcpp, colors);
                }
            }
            else {
                for (var i = 0, iv = vo; i < pc; i += 1, iv += vcpp) {
                    var af = pf.getAlpha(i, afd);
                    var cs = ps.getColor(i, csd);
                    buildColor(cf, af, cs, 0, iv, vcpp, colors);
                }
            }
        }
    };
    var buildLineOfAnyColor2 = function (vo, vcpp, pf, ps, pc, colors, ise, csd, asd, cfd, af) {
        if (ise) {
            if (ps.isStaticColor()) {
                var cs = ps.getColor(0, csd);
                if (ps.isStaticAlpha()) {
                    var as = ps.getAlpha(0, asd);
                    for (var i = 0, iv = vo; i < pc; i += 1, iv += vcpp) {
                        var cf = pf.getColor(i, cfd);
                        buildColor(cf, af, cs, as, iv, vcpp, colors);
                    }
                }
                else {
                    for (var i = 0, iv = vo; i < pc; i += 1, iv += vcpp) {
                        var cf = pf.getColor(i, cfd);
                        var as = ps.getAlpha(i, asd);
                        buildColor(cf, af, cs, as, iv, vcpp, colors);
                    }
                }
            }
            else {
                if (ps.isStaticAlpha()) {
                    var as = ps.getAlpha(0, asd);
                    for (var i = 0, iv = vo; i < pc; i += 1, iv += vcpp) {
                        var cf = pf.getColor(i, cfd);
                        var cs = ps.getColor(i, csd);
                        buildColor(cf, af, cs, as, iv, vcpp, colors);
                    }
                }
                else {
                    for (var i = 0, iv = vo; i < pc; i += 1, iv += vcpp) {
                        var cf = pf.getColor(i, cfd);
                        var cs = ps.getColor(i, csd);
                        var as = ps.getAlpha(i, asd);
                        buildColor(cf, af, cs, as, iv, vcpp, colors);
                    }
                }
            }
        }
        else {
            if (ps.isStaticColor()) {
                var cs = ps.getColor(0, csd);
                for (var i = 0, iv = vo; i < pc; i += 1, iv += vcpp) {
                    var cf = pf.getColor(i, cfd);
                    buildColor(cf, af, cs, 0, iv, vcpp, colors);
                }
            }
            else {
                for (var i = 0, iv = vo; i < pc; i += 1, iv += vcpp) {
                    var cf = pf.getColor(i, cfd);
                    var cs = ps.getColor(i, csd);
                    buildColor(cf, af, cs, 0, iv, vcpp, colors);
                }
            }
        }
    };
    var buildLineOfAnyColor3 = function (vo, vcpp, pf, ps, pc, colors, ise, csd, asd, cfd, afd) {
        if (ise) {
            if (ps.isStaticColor()) {
                var cs = ps.getColor(0, csd);
                if (ps.isStaticAlpha()) {
                    var as = ps.getAlpha(0, asd);
                    for (var i = 0, iv = vo; i < pc; i += 1, iv += vcpp) {
                        var cf = pf.getColor(i, cfd);
                        var af = pf.getAlpha(i, afd);
                        buildColor(cf, af, cs, as, iv, vcpp, colors);
                    }
                }
                else {
                    for (var i = 0, iv = vo; i < pc; i += 1, iv += vcpp) {
                        var cf = pf.getColor(i, cfd);
                        var af = pf.getAlpha(i, afd);
                        var as = ps.getAlpha(i, asd);
                        buildColor(cf, af, cs, as, iv, vcpp, colors);
                    }
                }
            }
            else {
                if (ps.isStaticAlpha()) {
                    var as = ps.getAlpha(0, asd);
                    for (var i = 0, iv = vo; i < pc; i += 1, iv += vcpp) {
                        var cf = pf.getColor(i, cfd);
                        var af = pf.getAlpha(i, afd);
                        var cs = ps.getColor(i, csd);
                        buildColor(cf, af, cs, as, iv, vcpp, colors);
                    }
                }
                else {
                    for (var i = 0, iv = vo; i < pc; i += 1, iv += vcpp) {
                        var cf = pf.getColor(i, cfd);
                        var af = pf.getAlpha(i, afd);
                        var cs = ps.getColor(i, csd);
                        var as = ps.getAlpha(i, asd);
                        buildColor(cf, af, cs, as, iv, vcpp, colors);
                    }
                }
            }
        }
        else {
            if (ps.isStaticColor()) {
                var cs = ps.getColor(0, csd);
                for (var i = 0, iv = vo; i < pc; i += 1, iv += vcpp) {
                    var cf = pf.getColor(i, cfd);
                    var af = pf.getAlpha(i, afd);
                    buildColor(cf, af, cs, 0, iv, vcpp, colors);
                }
            }
            else {
                for (var i = 0, iv = vo; i < pc; i += 1, iv += vcpp) {
                    var cf = pf.getColor(i, cfd);
                    var af = pf.getAlpha(i, afd);
                    var cs = ps.getColor(i, csd);
                    buildColor(cf, af, cs, 0, iv, vcpp, colors);
                }
            }
        }
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var BuilderLineOfAny = /** @class */ (function (_super) {
        __extends(BuilderLineOfAny, _super);
        function BuilderLineOfAny(buffer, vertexOffset, indexOffset, vertexCount, indexCount, pointCountReserved, vcountPerPoint, icountPerPoint) {
            var _this = _super.call(this, buffer, vertexOffset, indexOffset, vertexCount, indexCount) || this;
            _this.pointId = -1;
            _this.pointCount = 0;
            _this.pointCountReserved = pointCountReserved;
            _this.pointSizeId = -1;
            _this.pointOffsetId = -1;
            _this.pointFillId = -1;
            _this.pointStrokeId = -1;
            _this.vcountPerPoint = vcountPerPoint;
            _this.icountPerPoint = icountPerPoint;
            return _this;
        }
        BuilderLineOfAny.prototype.reinit = function (buffer, shape, vertexOffset, indexOffset) {
            var pointCount = toLineOfAnyPointCount(toPointCount(shape.points));
            if (this.buffer !== buffer ||
                this.vertexOffset !== vertexOffset ||
                this.indexOffset !== indexOffset ||
                this.pointCountReserved !== pointCount) {
                var vertexCount = pointCount * this.vcountPerPoint;
                var indexCount = pointCount * this.icountPerPoint;
                if (buffer.check(vertexOffset, indexOffset, vertexCount, indexCount)) {
                    this.inited = BuilderFlag.NONE;
                    this.buffer = buffer;
                    this.vertexOffset = vertexOffset;
                    this.indexOffset = indexOffset;
                    this.vertexCount = vertexCount;
                    this.indexCount = indexCount;
                    this.pointCountReserved = pointCount;
                    this.init();
                    return true;
                }
                else {
                    return false;
                }
            }
            else {
                return true;
            }
        };
        BuilderLineOfAny.prototype.isCompatible = function (shape) {
            var pointCount = toLineOfAnyPointCount(toPointCount(shape.points));
            return pointCount === this.pointCountReserved;
        };
        BuilderLineOfAny.prototype.updateLineOfAnyColor = function (buffer, shape, points, vcountPerPoint) {
            var pointFill = points.fill;
            var pointFillId = pointFill.id;
            var isPointFillChanged = pointFillId !== this.pointFillId;
            var fill = shape.fill;
            var isFillEnabled = shape.visible && fill.enable;
            var colorFill = fill.color;
            var alphaFill = isFillEnabled ? fill.alpha : 0;
            var isFillChanged = colorFill !== this.colorFill || alphaFill !== this.alphaFill;
            var pointStroke = points.stroke;
            var pointStrokeId = pointStroke.id;
            var isPointStrokeChanged = pointStrokeId !== this.pointStrokeId;
            var stroke = shape.stroke;
            var isStrokeEnabled = shape.visible && stroke.enable;
            var colorStroke = stroke.color;
            var alphaStroke = isStrokeEnabled ? stroke.alpha : 0;
            var isStrokeChanged = colorStroke !== this.colorStroke || alphaStroke !== this.alphaStroke;
            var isNotInited = !(this.inited & BuilderFlag.COLOR);
            if (isNotInited ||
                isPointFillChanged ||
                isFillChanged ||
                isPointStrokeChanged ||
                isStrokeChanged) {
                this.inited |= BuilderFlag.COLOR;
                this.colorFill = colorFill;
                this.alphaFill = alphaFill;
                this.pointFillId = pointFillId;
                this.colorStroke = colorStroke;
                this.alphaStroke = alphaStroke;
                this.pointStrokeId = pointStrokeId;
                buffer.updateColors();
                buildLineOfAnyColor(this.vertexOffset, vcountPerPoint, pointFill, pointStroke, this.pointCountReserved, buffer.colors, isFillEnabled, isStrokeEnabled, colorFill, alphaFill, colorStroke, alphaStroke);
            }
        };
        return BuilderLineOfAny;
    }(BuilderBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var copyIndex = function (indices, vcountPerPoint, ioffset, icountPerPoint, pointCount) {
        var idiv = vcountPerPoint;
        var ii = ioffset + icountPerPoint;
        for (var i = 1; i < pointCount; ++i) {
            var iid = ii * 3;
            var iis = ioffset * 3;
            for (var j = 0; j < icountPerPoint; ++j) {
                indices[iid + 0] = indices[iis + 0] + idiv;
                indices[iid + 1] = indices[iis + 1] + idiv;
                indices[iid + 2] = indices[iis + 2] + idiv;
                iid += 3;
                iis += 3;
            }
            idiv += vcountPerPoint;
            ii += icountPerPoint;
        }
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var copyStep = function (steps, voffset, vcountPerPoint, pointCount) {
        var iss0 = voffset * 6;
        var isd = (voffset + vcountPerPoint) * 6;
        for (var i = 1; i < pointCount; ++i) {
            var iss = iss0;
            for (var j = 0; j < vcountPerPoint; ++j) {
                steps[isd + 0] = steps[iss + 0];
                steps[isd + 1] = steps[iss + 1];
                steps[isd + 2] = steps[iss + 2];
                steps[isd + 3] = steps[iss + 3];
                steps[isd + 4] = steps[iss + 4];
                steps[isd + 5] = steps[iss + 5];
                isd += 6;
                iss += 6;
            }
        }
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var copyUvs = function (uvs, voffset, vcountPerPoint, pointCount) {
        var iv = voffset + vcountPerPoint;
        for (var i = 1; i < pointCount; ++i) {
            var iuvd = iv << 1;
            var iuvs = voffset << 1;
            for (var j = 0; j < vcountPerPoint; ++j) {
                uvs[iuvd] = uvs[iuvs];
                uvs[iuvd + 1] = uvs[iuvs + 1];
                iuvd += 2;
                iuvs += 2;
            }
            iv += vcountPerPoint;
        }
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var copyVertex = function (vertices, internalTransform, voffset, vcountPerPoint, pointCount, pointsValues, pointOffset) {
        var a = internalTransform.a;
        var b = internalTransform.b;
        var c = internalTransform.c;
        var d = internalTransform.d;
        var i = pointCount - 1;
        var iv = voffset + i * vcountPerPoint;
        if (pointOffset.isStaticX() && pointOffset.isStaticY()) {
            var ox = pointOffset.getX(0);
            var oy = pointOffset.getY(0);
            for (; 0 <= i; --i) {
                var ip = i << 1;
                var px = pointsValues[ip] + ox;
                var py = pointsValues[ip + 1] + oy;
                var dx = a * px + c * py;
                var dy = b * px + d * py;
                var ivd = iv << 1;
                var ivs = voffset << 1;
                for (var j = 0; j < vcountPerPoint; ++j) {
                    vertices[ivd] = vertices[ivs] + dx;
                    vertices[ivd + 1] = vertices[ivs + 1] + dy;
                    ivd += 2;
                    ivs += 2;
                }
                iv -= vcountPerPoint;
            }
        }
        else {
            for (; 0 <= i; --i) {
                var ip = i << 1;
                var px = pointsValues[ip] + pointOffset.getX(i);
                var py = pointsValues[ip + 1] + pointOffset.getY(i);
                var dx = a * px + c * py;
                var dy = b * px + d * py;
                var ivd = iv << 1;
                var ivs = voffset << 1;
                for (var j = 0; j < vcountPerPoint; ++j) {
                    vertices[ivd] = vertices[ivs] + dx;
                    vertices[ivd + 1] = vertices[ivs + 1] + dy;
                    ivd += 2;
                    ivs += 2;
                }
                iv -= vcountPerPoint;
            }
        }
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var isStatic = function (value) {
        return isNumber(value) || value == null;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var toComputed = function (index, value, def) {
        if (isNumber(value)) {
            return value;
        }
        else if (isFunction(value)) {
            return value(index);
        }
        else if (value) {
            return value[index % value.length];
        }
        return def;
    };

    /*
     * Copyright (C) 2020 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeLineOfAnyPointsFillImpl = /** @class */ (function () {
        function EShapeLineOfAnyPointsFillImpl(parent) {
            this._parent = parent;
            this._id = 0;
            this._color = null;
            this._alpha = null;
        }
        Object.defineProperty(EShapeLineOfAnyPointsFillImpl.prototype, "id", {
            get: function () {
                return this._id;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeLineOfAnyPointsFillImpl.prototype, "color", {
            get: function () {
                return this._color;
            },
            set: function (color) {
                this.set(color, undefined);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeLineOfAnyPointsFillImpl.prototype, "alpha", {
            get: function () {
                return this._alpha;
            },
            set: function (alpha) {
                this.set(undefined, alpha);
            },
            enumerable: false,
            configurable: true
        });
        EShapeLineOfAnyPointsFillImpl.prototype.set = function (color, alpha) {
            var isChanged = false;
            if (color !== undefined && this._color !== color) {
                isChanged = true;
                this._color = color;
            }
            if (alpha !== undefined && this._alpha !== alpha) {
                isChanged = true;
                this._alpha = alpha;
            }
            if (isChanged) {
                this._id += 1;
                this._parent.updateUploaded();
            }
        };
        EShapeLineOfAnyPointsFillImpl.prototype.getColor = function (index, def) {
            return toComputed(index, this._color, def);
        };
        EShapeLineOfAnyPointsFillImpl.prototype.getAlpha = function (index, def) {
            return toComputed(index, this._alpha, def);
        };
        EShapeLineOfAnyPointsFillImpl.prototype.isStaticColor = function () {
            return isStatic(this._color);
        };
        EShapeLineOfAnyPointsFillImpl.prototype.isStaticAlpha = function () {
            return isStatic(this._alpha);
        };
        EShapeLineOfAnyPointsFillImpl.prototype.toDirty = function () {
            this._id += 1;
        };
        return EShapeLineOfAnyPointsFillImpl;
    }());

    /*
     * Copyright (C) 2020 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeLineOfAnyPointsPointImpl = /** @class */ (function () {
        function EShapeLineOfAnyPointsPointImpl(parent, defX, defY) {
            this._parent = parent;
            this._id = 0;
            this._x = null;
            this._y = null;
            this._defX = defX;
            this._defY = defY;
            this._limit = null;
            this._limitComputed = 0;
            this._limitId = -1;
            this._limitParentLength = 0;
        }
        Object.defineProperty(EShapeLineOfAnyPointsPointImpl.prototype, "id", {
            get: function () {
                return this._id;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeLineOfAnyPointsPointImpl.prototype, "x", {
            get: function () {
                return this._x;
            },
            set: function (x) {
                this.set(x, undefined);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeLineOfAnyPointsPointImpl.prototype, "y", {
            get: function () {
                return this._y;
            },
            set: function (y) {
                this.set(undefined, y);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeLineOfAnyPointsPointImpl.prototype, "limit", {
            get: function () {
                return this._limit;
            },
            set: function (limit) {
                this._limit = limit;
            },
            enumerable: false,
            configurable: true
        });
        EShapeLineOfAnyPointsPointImpl.prototype.set = function (x, y) {
            var isChanged = false;
            if (x !== undefined && this._x !== x) {
                isChanged = true;
                this._x = x;
            }
            if (y !== undefined && this._y !== y) {
                isChanged = true;
                this._y = y;
            }
            if (isChanged) {
                this._id += 1;
                this._parent.updateUploaded();
            }
        };
        EShapeLineOfAnyPointsPointImpl.prototype.getX = function (index) {
            return toComputed(index, this._x, this._defX);
        };
        EShapeLineOfAnyPointsPointImpl.prototype.getY = function (index) {
            return toComputed(index, this._y, this._defY);
        };
        EShapeLineOfAnyPointsPointImpl.prototype.getLimit = function () {
            var limit = this._limit;
            if (limit != null) {
                return limit;
            }
            this.updateLimitComputed();
            return this._limitComputed;
        };
        EShapeLineOfAnyPointsPointImpl.prototype.updateLimitComputed = function () {
            var limitId = this._id;
            var parent = this._parent;
            var limitParentLength = parent.length;
            if (this._limitId !== limitId || this._limitParentLength !== limitParentLength) {
                this._limitId = limitId;
                this._limitParentLength = limitParentLength;
                this._limitComputed = Math.max(this.calcLimit(this._x, limitParentLength, this._defX), this.calcLimit(this._y, limitParentLength, this._defY));
            }
        };
        EShapeLineOfAnyPointsPointImpl.prototype.calcLimit = function (value, parentLenght, def) {
            if (isNumber(value)) {
                return Math.abs(value);
            }
            else if (isFunction(value)) {
                if (0 < parentLenght) {
                    var result = Math.abs(value(0));
                    for (var i = 1; i < parentLenght; ++i) {
                        result = Math.max(result, Math.abs(value(i)));
                    }
                    return result;
                }
                return 0;
            }
            else if (value != null) {
                var l = value.length;
                if (0 < l) {
                    var result = value[0];
                    for (var i = 1; i < l; ++i) {
                        result = Math.max(result, Math.abs(value[i]));
                    }
                    return result;
                }
                return 0;
            }
            else {
                return Math.abs(def);
            }
        };
        EShapeLineOfAnyPointsPointImpl.prototype.isStaticX = function () {
            return isStatic(this._x);
        };
        EShapeLineOfAnyPointsPointImpl.prototype.isStaticY = function () {
            return isStatic(this._y);
        };
        EShapeLineOfAnyPointsPointImpl.prototype.toDirty = function () {
            this._id += 1;
        };
        return EShapeLineOfAnyPointsPointImpl;
    }());

    /*
     * Copyright (C) 2020 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeLineOfAnyPointsStrokeImpl = /** @class */ (function () {
        function EShapeLineOfAnyPointsStrokeImpl(parent) {
            this._parent = parent;
            this._id = 0;
            this._color = null;
            this._alpha = null;
        }
        Object.defineProperty(EShapeLineOfAnyPointsStrokeImpl.prototype, "id", {
            get: function () {
                return this._id;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeLineOfAnyPointsStrokeImpl.prototype, "color", {
            get: function () {
                return this._color;
            },
            set: function (color) {
                this.set(color, undefined);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeLineOfAnyPointsStrokeImpl.prototype, "alpha", {
            get: function () {
                return this._alpha;
            },
            set: function (alpha) {
                this.set(undefined, alpha);
            },
            enumerable: false,
            configurable: true
        });
        EShapeLineOfAnyPointsStrokeImpl.prototype.set = function (color, alpha) {
            var isChanged = false;
            if (color !== undefined && this._color !== color) {
                isChanged = true;
                this._color = color;
            }
            if (alpha !== undefined && this._alpha !== alpha) {
                isChanged = true;
                this._alpha = alpha;
            }
            if (isChanged) {
                this._id += 1;
                this._parent.updateUploaded();
            }
        };
        EShapeLineOfAnyPointsStrokeImpl.prototype.getColor = function (index, def) {
            return toComputed(index, this._color, def);
        };
        EShapeLineOfAnyPointsStrokeImpl.prototype.getAlpha = function (index, def) {
            return toComputed(index, this._alpha, def);
        };
        EShapeLineOfAnyPointsStrokeImpl.prototype.isStaticColor = function () {
            return isStatic(this._color);
        };
        EShapeLineOfAnyPointsStrokeImpl.prototype.isStaticAlpha = function () {
            return isStatic(this._alpha);
        };
        EShapeLineOfAnyPointsStrokeImpl.prototype.toDirty = function () {
            this._id += 1;
        };
        return EShapeLineOfAnyPointsStrokeImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeLineOfAnyPointsImpl = /** @class */ (function () {
        function EShapeLineOfAnyPointsImpl(parent) {
            this._parent = parent;
            this._values = [];
            this._valuesLength = 0;
            this._segments = [];
            this._length = 0;
            this._plength = 0;
            this._size = new EShapeLineOfAnyPointsPointImpl(this, EShapeDefaults.SIZE_X, EShapeDefaults.SIZE_Y);
            this._offset = new EShapeLineOfAnyPointsPointImpl(this, 0, 0);
            this._fill = new EShapeLineOfAnyPointsFillImpl(parent);
            this._stroke = new EShapeLineOfAnyPointsStrokeImpl(parent);
            this._id = 0;
        }
        Object.defineProperty(EShapeLineOfAnyPointsImpl.prototype, "length", {
            get: function () {
                return this._length;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeLineOfAnyPointsImpl.prototype, "plength", {
            get: function () {
                return this._plength;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeLineOfAnyPointsImpl.prototype, "id", {
            get: function () {
                return this._id;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeLineOfAnyPointsImpl.prototype, "values", {
            get: function () {
                return this._values;
            },
            set: function (values) {
                this.set(values, undefined, undefined);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeLineOfAnyPointsImpl.prototype, "segments", {
            get: function () {
                return this._segments;
            },
            set: function (segments) {
                // DO NOTHING
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeLineOfAnyPointsImpl.prototype, "style", {
            get: function () {
                return EShapePointsStyle.NONE;
            },
            set: function (style) {
                this.set(undefined, undefined, style);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeLineOfAnyPointsImpl.prototype, "marker", {
            get: function () {
                var result = this._marker;
                if (result == null) {
                    result = EShapePointsMarkerContainerImplNoop.getInstance();
                    this._marker = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        EShapeLineOfAnyPointsImpl.prototype.getMarker = function () {
            return undefined;
        };
        Object.defineProperty(EShapeLineOfAnyPointsImpl.prototype, "size", {
            get: function () {
                return this._size;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeLineOfAnyPointsImpl.prototype, "offset", {
            get: function () {
                return this._offset;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeLineOfAnyPointsImpl.prototype, "fill", {
            get: function () {
                return this._fill;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeLineOfAnyPointsImpl.prototype, "stroke", {
            get: function () {
                return this._stroke;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeLineOfAnyPointsImpl.prototype, "formatter", {
            get: function () {
                return null;
            },
            set: function (formatter) {
                // DO NOTHING
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeLineOfAnyPointsImpl.prototype, "formatted", {
            get: function () {
                return this;
            },
            enumerable: false,
            configurable: true
        });
        EShapeLineOfAnyPointsImpl.prototype.onSizeChange = function () {
            // DO NOTHING
        };
        EShapeLineOfAnyPointsImpl.prototype.toFitted = function (x, y) {
            // DO NOTHING
        };
        EShapeLineOfAnyPointsImpl.prototype.copy = function (source) {
            return this.set(source.values, source.segments, source.style);
        };
        EShapeLineOfAnyPointsImpl.prototype.set = function (newValues, newSegments, newStyle) {
            var isDirty = false;
            var isUpdated = false;
            // Values
            if (newValues != null) {
                var values = this._values;
                var valuesLength = this._valuesLength;
                var newValuesLength = newValues.length;
                if (values !== newValues) {
                    var iupdate = Math.min(valuesLength, newValuesLength);
                    for (var i = 0; i < iupdate; ++i) {
                        values[i] = newValues[i];
                    }
                    for (var i = iupdate; i < newValuesLength; ++i) {
                        values.push(newValues[i]);
                    }
                    if (valuesLength !== newValuesLength) {
                        values.length = newValuesLength;
                        this._valuesLength = newValuesLength;
                        isDirty = true;
                    }
                    else {
                        isUpdated = true;
                    }
                }
                else {
                    if (valuesLength !== newValuesLength) {
                        this._valuesLength = newValuesLength;
                        isDirty = true;
                    }
                    else {
                        isUpdated = true;
                    }
                }
                var newLength = newValuesLength >> 1;
                this._length = newLength;
                if (this._plength < newLength) {
                    this._plength = newLength;
                }
            }
            //
            if (isDirty) {
                this._id += 1;
                var parent_1 = this._parent;
                var uploaded = parent_1.uploaded;
                if (uploaded) {
                    if (uploaded.isCompatible(parent_1)) {
                        parent_1.updateUploaded();
                    }
                    else {
                        parent_1.toDirty();
                    }
                }
                else {
                    parent_1.updateUploaded();
                }
            }
            else if (isUpdated) {
                this._id += 1;
                this._parent.updateUploaded();
            }
            return this;
        };
        EShapeLineOfAnyPointsImpl.prototype.updateUploaded = function () {
            this._parent.updateUploaded();
        };
        EShapeLineOfAnyPointsImpl.prototype.clone = function (parent) {
            return new EShapeLineOfAnyPointsImpl(parent).copy(this);
        };
        EShapeLineOfAnyPointsImpl.prototype.toPoints = function (transform) {
            var result = [];
            var values = this.values;
            for (var i = 0, imax = values.length; i < imax; i += 2) {
                var point = new pixi_js.Point(values[i + 0], values[i + 1]);
                result.push(transform.apply(point, point));
            }
            return result;
        };
        EShapeLineOfAnyPointsImpl.prototype.serialize = function (manager) {
            return manager.addResource("[]");
        };
        EShapeLineOfAnyPointsImpl.prototype.calcHitPointAbs = function (x, y, sw, ss, sa, threshold, toRange, tester, result) {
            var formatted = this.formatted;
            var pointCount = formatted.length;
            var pointValues = formatted.values;
            var size = this._size;
            var offset = this._offset;
            var istart = 0;
            var iend = pointCount;
            if (toRange) {
                var s = size.getLimit() * 0.5;
                var o = offset.getLimit();
                var work = EShapeLineOfAnyPointsImpl.WORK_RANGE;
                toRange(x, y, s, s, o, o, threshold, pointValues, work);
                istart = work[0];
                iend = work[1];
            }
            for (var i = istart, imax = Math.min(iend, pointCount); i < imax; ++i) {
                var iv = i << 1;
                var px = pointValues[iv];
                var py = pointValues[iv + 1];
                var sx = size.getX(i) * 0.5;
                var sy = size.getY(i) * 0.5;
                var ox = offset.getX(i);
                var oy = offset.getY(i);
                if (tester(x, y, sx, sy, ox, oy, px, py, sw, ss, sa, i, threshold, result)) {
                    return true;
                }
            }
            return false;
        };
        EShapeLineOfAnyPointsImpl.WORK_RANGE = [0, 0];
        return EShapeLineOfAnyPointsImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var BuilderLineOfCircles = /** @class */ (function (_super) {
        __extends(BuilderLineOfCircles, _super);
        function BuilderLineOfCircles() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        BuilderLineOfCircles.prototype.init = function () {
            var buffer = this.buffer;
            buffer.updateIndices();
            var indices = buffer.indices;
            var voffset = this.vertexOffset;
            var ioffset = this.indexOffset;
            var pointCountReserved = this.pointCountReserved;
            if (0 < pointCountReserved) {
                buildCircleIndex(indices, voffset, ioffset);
                copyIndex(indices, CIRCLE_VERTEX_COUNT, ioffset, CIRCLE_INDEX_COUNT, pointCountReserved);
            }
            this.inited |= BuilderFlag.INDEX;
        };
        BuilderLineOfCircles.prototype.update = function (shape) {
            var points = shape.points;
            if (points instanceof EShapeLineOfAnyPointsImpl) {
                var buffer = this.buffer;
                this.updateVertexAndStep(buffer, shape, points);
                this.updateLineOfAnyColor(buffer, shape, points, CIRCLE_VERTEX_COUNT);
                this.updateUv(buffer, shape);
            }
        };
        BuilderLineOfCircles.prototype.updateVertexAndStep = function (buffer, shape, points) {
            var pointId = points.id;
            var pointOffset = points.offset;
            var pointOffsetId = pointOffset.id;
            var isPointChanged = pointId !== this.pointId || pointOffsetId !== this.pointOffsetId;
            var pointSize = points.size;
            var pointSizeId = pointSize.id;
            var isPointSizeChanged = pointSizeId !== this.pointSizeId;
            var size = shape.size;
            var sizeX = size.x;
            var sizeY = size.y;
            var isSizeChanged = sizeX !== this.sizeX || sizeY !== this.sizeY;
            var transformLocalId = toTransformLocalId(shape);
            var isTransformChanged = this.transformLocalId !== transformLocalId;
            var stroke = shape.stroke;
            var strokeAlign = stroke.align;
            var strokeWidth = stroke.enable ? stroke.width : 0;
            var strokeStyle = stroke.style;
            var isStrokeChanged = this.strokeAlign !== strokeAlign ||
                this.strokeWidth !== strokeWidth ||
                this.strokeStyle !== strokeStyle;
            var isNotInited = !(this.inited & BuilderFlag.VERTEX_AND_STEP);
            if (isNotInited ||
                isPointChanged ||
                isPointSizeChanged ||
                isSizeChanged ||
                isTransformChanged ||
                isStrokeChanged) {
                this.inited |= BuilderFlag.VERTEX_AND_STEP;
                this.pointId = pointId;
                var formatted = points.formatted;
                this.pointCount = formatted.length;
                this.pointOffsetId = pointOffsetId;
                this.pointSizeId = pointSizeId;
                this.sizeX = sizeX;
                this.sizeY = sizeY;
                this.transformLocalId = transformLocalId;
                this.strokeWidth = strokeWidth;
                this.strokeAlign = strokeAlign;
                this.strokeStyle = strokeStyle;
                // Buffer
                buffer.updateVertices();
                buffer.updateSteps();
                var pointCount = this.pointCount;
                var pointsValues = formatted.values;
                var voffset = this.vertexOffset;
                var vertices = buffer.vertices;
                var steps = buffer.steps;
                var internalTransform = shape.transform.internalTransform;
                if (0 < pointCount && pointSize.isStaticX() && pointSize.isStaticY()) {
                    var pointSizeX = pointSize.getX(0);
                    var pointSizeY = pointSize.getY(0);
                    buildCircleVertex(vertices, voffset, 0, 0, pointSizeX, pointSizeY, strokeAlign, strokeWidth, internalTransform, CIRCLE_WORLD_SIZE);
                    copyVertex(vertices, internalTransform, voffset, CIRCLE_VERTEX_COUNT, pointCount, pointsValues, pointOffset);
                    buildCircleStep(steps, voffset, strokeWidth, strokeStyle, CIRCLE_WORLD_SIZE);
                    copyStep(steps, voffset, CIRCLE_VERTEX_COUNT, pointCount);
                }
                else {
                    for (var i = 0; i < pointCount; ++i) {
                        var ip = i << 1;
                        var px = pointsValues[ip] + pointOffset.getX(i);
                        var py = pointsValues[ip + 1] + pointOffset.getY(i);
                        var pointSizeX = pointSize.getX(i);
                        var pointSizeY = pointSize.getY(i);
                        var iv = voffset + i * CIRCLE_VERTEX_COUNT;
                        buildCircleVertex(vertices, iv, px, py, pointSizeX, pointSizeY, strokeAlign, strokeWidth, internalTransform, CIRCLE_WORLD_SIZE);
                        buildCircleStep(steps, iv, strokeWidth, strokeStyle, CIRCLE_WORLD_SIZE);
                    }
                }
                // Fill the rest
                var pointCountReserved = this.pointCountReserved;
                var voffsetReserved = voffset + pointCount * CIRCLE_VERTEX_COUNT;
                var vcountReserved = CIRCLE_VERTEX_COUNT * (pointCountReserved - pointCount);
                buildNullVertex(vertices, voffsetReserved, vcountReserved);
                buildNullStep(steps, voffsetReserved, vcountReserved);
            }
        };
        BuilderLineOfCircles.prototype.updateUv = function (buffer, shape) {
            var texture = toTexture(shape);
            var textureTransformId = toTextureTransformId(texture);
            var isNotInited = !(this.inited & BuilderFlag.UV);
            if (isNotInited ||
                texture !== this.texture ||
                textureTransformId !== this.textureTransformId) {
                this.inited |= BuilderFlag.UV;
                this.texture = texture;
                this.textureTransformId = textureTransformId;
                buffer.updateUvs();
                var uvs = buffer.uvs;
                var voffset = this.vertexOffset;
                var textureUvs = toTextureUvs(texture);
                var pointCountReserved = this.pointCountReserved;
                if (0 < pointCountReserved) {
                    buildCircleUv(uvs, voffset, textureUvs);
                    copyUvs(uvs, voffset, CIRCLE_VERTEX_COUNT, pointCountReserved);
                }
            }
        };
        return BuilderLineOfCircles;
    }(BuilderLineOfAny));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var createLineOfAnyUploaded = function (buffer, shape, voffset, vcountPerPoint, ioffset, icountPerPoint, antialiasWeight, constructor) {
        var tcount = toTextBufferCount(shape);
        var tvcount = tcount << TEXT_VERTEX_COUNT_SHIFT;
        var ticount = tcount << TEXT_INDEX_COUNT_SHIFT;
        var points = shape.points;
        var pointCount = toLineOfAnyPointCount(toPointCount(points));
        var pvcount = pointCount * vcountPerPoint;
        var picount = pointCount * icountPerPoint;
        var vcount = pvcount + tvcount;
        var icount = picount + ticount;
        if (buffer.check(voffset, ioffset, vcount, icount)) {
            return new EShapeUploadedImpl(buffer, voffset, ioffset, vcount, icount, [
                new constructor(buffer, voffset, ioffset, pvcount, picount, pointCount, vcountPerPoint, icountPerPoint),
                new BuilderText(buffer, voffset + pvcount, ioffset + picount, tvcount, ticount)
            ]).init(shape);
        }
        return null;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var createLineOfCirclesUploaded = function (buffer, shape, voffset, ioffset, antialiasWeight) {
        return createLineOfAnyUploaded(buffer, shape, voffset, CIRCLE_VERTEX_COUNT, ioffset, CIRCLE_INDEX_COUNT, antialiasWeight, BuilderLineOfCircles);
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeLineOfCircles = /** @class */ (function (_super) {
        __extends(EShapeLineOfCircles, _super);
        function EShapeLineOfCircles(type) {
            if (type === void 0) { type = EShapeType.LINE_OF_CIRCLES; }
            var _this = _super.call(this, type) || this;
            _this._points = new EShapeLineOfAnyPointsImpl(_this);
            _this._tester = function (x, y, ax, ay, ox, oy, px, py, sw, ss, sa) {
                return _this.containsPointAbs(x, y, ax, ay, ox, oy, px, py, sw, ss, sa);
            };
            return _this;
        }
        Object.defineProperty(EShapeLineOfCircles.prototype, "points", {
            get: function () {
                return this._points;
            },
            enumerable: false,
            configurable: true
        });
        EShapeLineOfCircles.prototype.clone = function () {
            return new EShapeLineOfCircles(this.type).copy(this);
        };
        EShapeLineOfCircles.prototype.containsAbs = function (x, y, ax, ay, sw, ss, sa) {
            var threshold = toThresholdDefault(sw, ss, this._points.size.getLimit());
            if (this.containsAbsBBox(x, y, ax + threshold, ay + threshold)) {
                return this._points.calcHitPointAbs(x, y, sw, ss, sa, threshold, null, this._tester, null);
            }
            return false;
        };
        EShapeLineOfCircles.prototype.containsPointAbs = function (x, y, ax, ay, ox, oy, px, py, sw, ss, sa) {
            return _super.prototype.containsAbs.call(this, x - px - ox, y - py - oy, ax, ay, sw, ss, sa);
        };
        EShapeLineOfCircles.prototype.calcHitPoint = function (x, y, toThreshold, toRange, tester, result) {
            var data = this.toHitTestData(x, y);
            var threshold = (toThreshold || toThresholdDefault)(data.strokeWidth, data.strokeScale, this._points.size.getLimit());
            if (this.containsAbsBBox(data.x, data.y, data.width + threshold, data.height + threshold)) {
                return this._points.calcHitPointAbs(data.x, data.y, data.strokeWidth, data.strokeScale, data.strokeAlign, threshold, toRange, tester || this._tester, result);
            }
            return false;
        };
        return EShapeLineOfCircles;
    }(EShapeCircle));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var deserializeLineOfCircles = function (item, manager, shape) {
        return deserializeBase(item, manager, shape || new EShapeLineOfCircles());
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadShapeLineOfCircles = function () {
        EShapeUploadeds[EShapeType.LINE_OF_CIRCLES] = createLineOfCirclesUploaded;
        EShapeDeserializers[EShapeType.LINE_OF_CIRCLES] = deserializeLineOfCircles;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var BuilderLineOfRectangleRoundeds = /** @class */ (function (_super) {
        __extends(BuilderLineOfRectangleRoundeds, _super);
        function BuilderLineOfRectangleRoundeds(buffer, vertexOffset, indexOffset, vertexCount, indexCount, pointCountReserved, vcountPerPoint, icountPerPoint) {
            var _this = _super.call(this, buffer, vertexOffset, indexOffset, vertexCount, indexCount, pointCountReserved, vcountPerPoint, icountPerPoint) || this;
            _this.radius = 0;
            _this.corner = 0;
            return _this;
        }
        BuilderLineOfRectangleRoundeds.prototype.init = function () {
            var buffer = this.buffer;
            buffer.updateIndices();
            var indices = buffer.indices;
            var voffset = this.vertexOffset;
            var ioffset = this.indexOffset;
            var pointCountReserved = this.pointCountReserved;
            if (0 < pointCountReserved) {
                buildRectangleRoundedIndex(indices, voffset, ioffset);
                copyIndex(indices, RECTANGLE_ROUNDED_VERTEX_COUNT, ioffset, RECTANGLE_ROUNDED_INDEX_COUNT, pointCountReserved);
            }
            this.inited |= BuilderFlag.INDEX;
        };
        BuilderLineOfRectangleRoundeds.prototype.update = function (shape) {
            var points = shape.points;
            if (points instanceof EShapeLineOfAnyPointsImpl) {
                var buffer = this.buffer;
                this.updateVertexStepAndUv(buffer, shape, points);
                this.updateLineOfAnyColor(buffer, shape, points, RECTANGLE_ROUNDED_VERTEX_COUNT);
            }
        };
        BuilderLineOfRectangleRoundeds.prototype.updateVertexStepAndUv = function (buffer, shape, points) {
            var pointId = points.id;
            var pointOffset = points.offset;
            var pointOffsetId = pointOffset.id;
            var isPointChanged = pointId !== this.pointId || pointOffsetId !== this.pointOffsetId;
            var pointSize = points.size;
            var pointSizeId = pointSize.id;
            var isPointSizeChanged = pointSizeId !== this.pointSizeId;
            var size = shape.size;
            var sizeX = size.x;
            var sizeY = size.y;
            var radius = shape.radius;
            var isSizeChanged = sizeX !== this.sizeX || sizeY !== this.sizeY || radius !== this.radius;
            var transformLocalId = toTransformLocalId(shape);
            var isTransformChanged = this.transformLocalId !== transformLocalId;
            var stroke = shape.stroke;
            var strokeAlign = stroke.align;
            var strokeWidth = stroke.enable ? stroke.width : 0;
            var strokeSide = stroke.side;
            var strokeStyle = stroke.style;
            var isStrokeChanged = this.strokeAlign !== strokeAlign ||
                this.strokeWidth !== strokeWidth ||
                this.strokeSide !== strokeSide ||
                this.strokeStyle !== strokeStyle;
            var corner = shape.corner;
            var isCornerChanged = corner !== this.corner;
            var texture = toTexture(shape);
            var textureTransformId = toTextureTransformId(texture);
            var isTextureChanged = texture !== this.texture || textureTransformId !== this.textureTransformId;
            var isVertexChanged = isPointChanged || isPointSizeChanged || isSizeChanged || isStrokeChanged;
            var isNotInited = !(this.inited & BuilderFlag.VERTEX_STEP_AND_UV);
            if (isNotInited ||
                isVertexChanged ||
                isTransformChanged ||
                isCornerChanged ||
                isTextureChanged) {
                this.inited |= BuilderFlag.VERTEX_STEP_AND_UV;
                this.pointId = pointId;
                var formatted = points.formatted;
                this.pointCount = formatted.length;
                this.pointOffsetId = pointOffsetId;
                this.pointSizeId = pointSizeId;
                this.sizeX = sizeX;
                this.sizeY = sizeY;
                this.radius = radius;
                this.transformLocalId = transformLocalId;
                this.strokeAlign = strokeAlign;
                this.strokeWidth = strokeWidth;
                this.strokeSide = strokeSide;
                this.strokeStyle = strokeStyle;
                this.corner = corner;
                this.texture = texture;
                this.textureTransformId = textureTransformId;
                // Buffer
                buffer.updateVertices();
                if (isNotInited || isVertexChanged || isTransformChanged || isCornerChanged) {
                    buffer.updateSteps();
                }
                if (isNotInited || isVertexChanged || isTextureChanged) {
                    buffer.updateUvs();
                }
                var pointCount = this.pointCount;
                var pointsValues = formatted.values;
                var voffset = this.vertexOffset;
                var vertices = buffer.vertices;
                var steps = buffer.steps;
                var uvs = buffer.uvs;
                var internalTransform = shape.transform.internalTransform;
                var textureUvs = toTextureUvs(texture);
                if (0 < pointCount && pointSize.isStaticX() && pointSize.isStaticY()) {
                    var pointSizeX = pointSize.getX(0);
                    var pointSizeY = pointSize.getY(0);
                    // Vertices
                    buildRectangleRoundedVertex(vertices, voffset, 0, 0, pointSizeX, pointSizeY, strokeAlign, strokeWidth, radius, internalTransform, RECTANGLE_ROUNDED_WORLD_SIZE);
                    copyVertex(vertices, internalTransform, voffset, RECTANGLE_ROUNDED_VERTEX_COUNT, pointCount, pointsValues, pointOffset);
                    // Steps
                    if (isNotInited || isVertexChanged || isTransformChanged || isCornerChanged) {
                        buildRectangleRoundedStep(steps, voffset, strokeWidth, strokeSide, strokeStyle, corner, RECTANGLE_ROUNDED_WORLD_SIZE);
                        copyStep(steps, voffset, RECTANGLE_ROUNDED_VERTEX_COUNT, pointCount);
                    }
                    // UVs
                    if (isNotInited || isVertexChanged || isTextureChanged) {
                        buildRectangleRoundedUv(uvs, voffset, textureUvs, RECTANGLE_ROUNDED_WORLD_SIZE);
                        copyUvs(uvs, voffset, RECTANGLE_ROUNDED_VERTEX_COUNT, pointCount);
                    }
                }
                else {
                    for (var i = 0; i < pointCount; ++i) {
                        var ip = i << 1;
                        var px = pointsValues[ip] + pointOffset.getX(i);
                        var py = pointsValues[ip + 1] + pointOffset.getY(i);
                        var pointSizeX = pointSize.getX(i);
                        var pointSizeY = pointSize.getY(i);
                        var iv = voffset + i * RECTANGLE_ROUNDED_VERTEX_COUNT;
                        // Vertices
                        buildRectangleRoundedVertex(vertices, iv, px, py, pointSizeX, pointSizeY, strokeAlign, strokeWidth, radius, internalTransform, RECTANGLE_ROUNDED_WORLD_SIZE);
                        // Steps
                        if (isNotInited || isVertexChanged || isTransformChanged || isCornerChanged) {
                            buildRectangleRoundedStep(steps, iv, strokeWidth, strokeSide, strokeStyle, corner, RECTANGLE_ROUNDED_WORLD_SIZE);
                        }
                        // UVs
                        if (isNotInited || isVertexChanged || isTextureChanged) {
                            buildRectangleRoundedUv(uvs, iv, textureUvs, RECTANGLE_ROUNDED_WORLD_SIZE);
                        }
                    }
                }
                // Fill the rest
                var pointCountReserved = this.pointCountReserved;
                var voffsetReserved = voffset + pointCount * RECTANGLE_ROUNDED_VERTEX_COUNT;
                var vcountReserved = RECTANGLE_ROUNDED_VERTEX_COUNT * (pointCountReserved - pointCount);
                buildNullVertex(vertices, voffsetReserved, vcountReserved);
                buildNullStep(steps, voffsetReserved, vcountReserved);
                buildNullUv(uvs, voffsetReserved, vcountReserved);
            }
        };
        return BuilderLineOfRectangleRoundeds;
    }(BuilderLineOfAny));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var createLineOfRectangleRoundedsUploaded = function (buffer, shape, voffset, ioffset, antialiasWeight) {
        return createLineOfAnyUploaded(buffer, shape, voffset, RECTANGLE_ROUNDED_VERTEX_COUNT, ioffset, RECTANGLE_ROUNDED_INDEX_COUNT, antialiasWeight, BuilderLineOfRectangleRoundeds);
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeLineOfRectangleRoundeds = /** @class */ (function (_super) {
        __extends(EShapeLineOfRectangleRoundeds, _super);
        function EShapeLineOfRectangleRoundeds(type) {
            if (type === void 0) { type = EShapeType.LINE_OF_RECTANGLE_ROUNDEDS; }
            var _this = _super.call(this, type) || this;
            _this._points = new EShapeLineOfAnyPointsImpl(_this);
            _this._tester = function (x, y, ax, ay, ox, oy, px, py, sw, ss, sa) {
                return _this.containsPointAbs(x, y, ax, ay, ox, oy, px, py, sw, ss, sa);
            };
            return _this;
        }
        Object.defineProperty(EShapeLineOfRectangleRoundeds.prototype, "points", {
            get: function () {
                return this._points;
            },
            enumerable: false,
            configurable: true
        });
        EShapeLineOfRectangleRoundeds.prototype.clone = function () {
            return new EShapeLineOfRectangleRoundeds(this.type).copy(this);
        };
        EShapeLineOfRectangleRoundeds.prototype.containsAbs = function (x, y, ax, ay, sw, ss, sa) {
            var threshold = toThresholdDefault(sw, ss, this._points.size.getLimit());
            if (this.containsAbsBBox(x, y, ax + threshold, ay + threshold)) {
                return this._points.calcHitPointAbs(x, y, threshold, sw, ss, sa, null, this._tester, null);
            }
            return false;
        };
        EShapeLineOfRectangleRoundeds.prototype.containsPointAbs = function (x, y, ax, ay, ox, oy, px, py, sw, ss, sa) {
            return _super.prototype.containsAbs.call(this, x - px - ox, y - py - oy, ax, ay, sw, ss, sa);
        };
        EShapeLineOfRectangleRoundeds.prototype.calcHitPoint = function (x, y, toThreshold, toRange, tester, result) {
            var data = this.toHitTestData(x, y);
            var threshold = (toThreshold || toThresholdDefault)(data.strokeWidth, data.strokeScale, this._points.size.getLimit());
            if (this.containsAbsBBox(data.x, data.y, data.width + threshold, data.height + threshold)) {
                return this._points.calcHitPointAbs(data.x, data.y, data.strokeWidth, data.strokeScale, data.strokeAlign, threshold, toRange, tester || this._tester, result);
            }
            return false;
        };
        return EShapeLineOfRectangleRoundeds;
    }(EShapeRectangleRounded));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var deserializeLineOfRectangleRoundeds = function (item, manager, shape) {
        return deserializeBase(item, manager, shape || new EShapeLineOfRectangleRoundeds());
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadShapeLineOfRectangleRoundeds = function () {
        EShapeUploadeds[EShapeType.LINE_OF_RECTANGLE_ROUNDEDS] = createLineOfRectangleRoundedsUploaded;
        EShapeDeserializers[EShapeType.LINE_OF_RECTANGLE_ROUNDEDS] = deserializeLineOfRectangleRoundeds;
        EShapeCapabilities.set(EShapeType.LINE_OF_RECTANGLE_ROUNDEDS, EShapeCapability.PRIMITIVE | EShapeCapability.STROKE_SIDE | EShapeCapability.BORDER_RADIUS);
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var BuilderLineOfRectangles = /** @class */ (function (_super) {
        __extends(BuilderLineOfRectangles, _super);
        function BuilderLineOfRectangles() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        BuilderLineOfRectangles.prototype.init = function () {
            var buffer = this.buffer;
            buffer.updateIndices();
            var indices = buffer.indices;
            var voffset = this.vertexOffset;
            var ioffset = this.indexOffset;
            var pointCountReserved = this.pointCountReserved;
            if (0 < pointCountReserved) {
                buildRectangleIndex(indices, voffset, ioffset);
                copyIndex(indices, RECTANGLE_VERTEX_COUNT, ioffset, RECTANGLE_INDEX_COUNT, pointCountReserved);
            }
            this.inited |= BuilderFlag.INDEX;
        };
        BuilderLineOfRectangles.prototype.update = function (shape) {
            var points = shape.points;
            if (points instanceof EShapeLineOfAnyPointsImpl) {
                var buffer = this.buffer;
                this.updateVertexStepAndUv(buffer, shape, points);
                this.updateLineOfAnyColor(buffer, shape, points, RECTANGLE_VERTEX_COUNT);
            }
        };
        BuilderLineOfRectangles.prototype.updateVertexStepAndUv = function (buffer, shape, points) {
            var pointId = points.id;
            var pointOffset = points.offset;
            var pointOffsetId = pointOffset.id;
            var isPointChanged = pointId !== this.pointId || pointOffsetId !== this.pointOffsetId;
            var pointSize = points.size;
            var pointSizeId = pointSize.id;
            var isPointSizeChanged = pointSizeId !== this.pointSizeId;
            var size = shape.size;
            var sizeX = size.x;
            var sizeY = size.y;
            var isSizeChanged = sizeX !== this.sizeX || sizeY !== this.sizeY;
            var transformLocalId = toTransformLocalId(shape);
            var isTransformChanged = this.transformLocalId !== transformLocalId;
            var stroke = shape.stroke;
            var strokeAlign = stroke.align;
            var strokeWidth = stroke.enable ? stroke.width : 0;
            var strokeSide = stroke.side;
            var strokeStyle = stroke.style;
            var isStrokeChanged = this.strokeAlign !== strokeAlign ||
                this.strokeWidth !== strokeWidth ||
                this.strokeSide !== strokeSide ||
                this.strokeStyle !== strokeStyle;
            var texture = toTexture(shape);
            var textureTransformId = toTextureTransformId(texture);
            var isTextureChanged = texture !== this.texture || textureTransformId !== this.textureTransformId;
            var isVertexChanged = isPointChanged || isPointSizeChanged || isSizeChanged || isStrokeChanged;
            var isNotInited = !(this.inited & BuilderFlag.VERTEX_STEP_AND_UV);
            if (isNotInited || isVertexChanged || isTransformChanged || isTextureChanged) {
                this.inited |= BuilderFlag.VERTEX_STEP_AND_UV;
                this.pointId = pointId;
                var formatted = points.formatted;
                this.pointCount = formatted.length;
                this.pointOffsetId = pointOffsetId;
                this.pointSizeId = pointSizeId;
                this.transformLocalId = transformLocalId;
                this.strokeWidth = strokeWidth;
                this.strokeAlign = strokeAlign;
                this.strokeSide = strokeSide;
                this.strokeStyle = strokeStyle;
                this.texture = texture;
                this.textureTransformId = textureTransformId;
                // Buffer
                buffer.updateVertices();
                if (isNotInited || isVertexChanged || isTransformChanged) {
                    buffer.updateSteps();
                }
                if (isNotInited || isVertexChanged || isTextureChanged) {
                    buffer.updateUvs();
                }
                var pointCount = this.pointCount;
                var pointsValues = formatted.values;
                var voffset = this.vertexOffset;
                var vertices = buffer.vertices;
                var steps = buffer.steps;
                var uvs = buffer.uvs;
                var internalTransform = shape.transform.internalTransform;
                var textureUvs = toTextureUvs(texture);
                if (0 < pointCount && pointSize.isStaticX() && pointSize.isStaticY()) {
                    var pointSizeX = pointSize.getX(0);
                    var pointSizeY = pointSize.getY(0);
                    // Vertices
                    buildRectangleVertex(vertices, voffset, 0, 0, pointSizeX, pointSizeY, strokeAlign, strokeWidth, internalTransform, RECTANGLE_WORLD_SIZE);
                    copyVertex(vertices, internalTransform, voffset, RECTANGLE_VERTEX_COUNT, pointCount, pointsValues, pointOffset);
                    // Steps
                    if (isNotInited || isVertexChanged || isTransformChanged) {
                        buildRectangleStep(voffset, steps, strokeWidth, strokeSide, strokeStyle, RECTANGLE_WORLD_SIZE);
                        copyStep(steps, voffset, RECTANGLE_VERTEX_COUNT, pointCount);
                    }
                    // UVs
                    if (isNotInited || isVertexChanged || isTextureChanged) {
                        buildRectangleUv(uvs, voffset, textureUvs);
                        copyUvs(uvs, voffset, RECTANGLE_VERTEX_COUNT, pointCount);
                    }
                }
                else {
                    for (var i = 0; i < pointCount; ++i) {
                        var ip = i << 1;
                        var px = pointsValues[ip] + pointOffset.getX(i);
                        var py = pointsValues[ip + 1] + pointOffset.getY(i);
                        var pointSizeX = pointSize.getX(i);
                        var pointSizeY = pointSize.getY(i);
                        var iv = voffset + i * RECTANGLE_VERTEX_COUNT;
                        // Vertices
                        buildRectangleVertex(vertices, iv, px, py, pointSizeX, pointSizeY, strokeAlign, strokeWidth, internalTransform, RECTANGLE_WORLD_SIZE);
                        // Steps
                        if (isNotInited || isVertexChanged || isTransformChanged) {
                            buildRectangleStep(iv, steps, strokeWidth, strokeSide, strokeStyle, RECTANGLE_WORLD_SIZE);
                        }
                        // UVs
                        if (isNotInited || isVertexChanged || isTextureChanged) {
                            buildRectangleUv(uvs, iv, textureUvs);
                        }
                    }
                }
                // Fill the rest
                var pointCountReserved = this.pointCountReserved;
                var voffsetReserved = voffset + pointCount * RECTANGLE_VERTEX_COUNT;
                var vcountReserved = RECTANGLE_VERTEX_COUNT * (pointCountReserved - pointCount);
                buildNullVertex(vertices, voffsetReserved, vcountReserved);
                buildNullStep(steps, voffsetReserved, vcountReserved);
                buildNullUv(uvs, voffsetReserved, vcountReserved);
            }
        };
        return BuilderLineOfRectangles;
    }(BuilderLineOfAny));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var createLineOfRectanglesUploaded = function (buffer, shape, voffset, ioffset, antialiasWeight) {
        return createLineOfAnyUploaded(buffer, shape, voffset, RECTANGLE_VERTEX_COUNT, ioffset, RECTANGLE_INDEX_COUNT, antialiasWeight, BuilderLineOfRectangles);
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeLineOfRectangles = /** @class */ (function (_super) {
        __extends(EShapeLineOfRectangles, _super);
        function EShapeLineOfRectangles(type) {
            if (type === void 0) { type = EShapeType.LINE_OF_RECTANGLES; }
            var _this = _super.call(this, type) || this;
            _this._points = new EShapeLineOfAnyPointsImpl(_this);
            _this._tester = function (x, y, ax, ay, ox, oy, px, py, sw, ss, sa) {
                return _this.containsPointAbs(x, y, ax, ay, ox, oy, px, py, sw, ss, sa);
            };
            return _this;
        }
        Object.defineProperty(EShapeLineOfRectangles.prototype, "points", {
            get: function () {
                return this._points;
            },
            enumerable: false,
            configurable: true
        });
        EShapeLineOfRectangles.prototype.clone = function () {
            return new EShapeLineOfRectangles(this.type).copy(this);
        };
        EShapeLineOfRectangles.prototype.containsAbs = function (x, y, ax, ay, sw, ss, sa) {
            var threshold = toThresholdDefault(sw, ss, this._points.size.getLimit());
            if (this.containsAbsBBox(x, y, ax + threshold, ay + threshold)) {
                return this._points.calcHitPointAbs(x, y, sw, ss, sa, threshold, null, this._tester, null);
            }
            return false;
        };
        EShapeLineOfRectangles.prototype.containsPointAbs = function (x, y, ax, ay, ox, oy, px, py, sw, ss, sa) {
            return _super.prototype.containsAbs.call(this, x - px - ox, y - py - oy, ax, ay, sw, ss, sa);
        };
        EShapeLineOfRectangles.prototype.calcHitPoint = function (x, y, toThreshold, toRange, tester, result) {
            var data = this.toHitTestData(x, y);
            var threshold = (toThreshold || toThresholdDefault)(data.strokeWidth, data.strokeScale, this._points.size.getLimit());
            if (this.containsAbsBBox(data.x, data.y, data.width + threshold, data.height + threshold)) {
                return this._points.calcHitPointAbs(data.x, data.y, data.strokeWidth, data.strokeScale, data.strokeAlign, threshold, toRange, tester || this._tester, result);
            }
            return false;
        };
        return EShapeLineOfRectangles;
    }(EShapeRectangle));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var deserializeLineOfRectangles = function (item, manager, shape) {
        return deserializeBase(item, manager, shape || new EShapeLineOfRectangles());
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadShapeLineOfRectangles = function () {
        EShapeUploadeds[EShapeType.LINE_OF_RECTANGLES] = createLineOfRectanglesUploaded;
        EShapeDeserializers[EShapeType.LINE_OF_RECTANGLES] = deserializeLineOfRectangles;
        EShapeCapabilities.set(EShapeType.LINE_OF_RECTANGLES, EShapeCapability.PRIMITIVE | EShapeCapability.STROKE_SIDE);
    };

    var TRIANGLE_ROUNDED_VERTEX_COUNT = 22;
    var TRIANGLE_ROUNDED_INDEX_COUNT = 15;
    var TRIANGLE_ROUNDED_WORLD_SIZE = [
        0, 0, 0, 0, 0
    ];
    var TRIANGLE_ROUNDED_WORK_POINT = new pixi_js.Point();
    var buildTriangleRoundedIndex = function (indices, voffset, ioffset) {
        // Top corner
        var ii = ioffset * 3 - 1;
        indices[++ii] = voffset + 0;
        indices[++ii] = voffset + 1;
        indices[++ii] = voffset + 3;
        indices[++ii] = voffset + 1;
        indices[++ii] = voffset + 2;
        indices[++ii] = voffset + 3;
        // Bottom-right corner
        indices[++ii] = voffset + 4;
        indices[++ii] = voffset + 5;
        indices[++ii] = voffset + 7;
        indices[++ii] = voffset + 5;
        indices[++ii] = voffset + 6;
        indices[++ii] = voffset + 7;
        // Bottom-left corner
        indices[++ii] = voffset + 8;
        indices[++ii] = voffset + 9;
        indices[++ii] = voffset + 11;
        indices[++ii] = voffset + 9;
        indices[++ii] = voffset + 10;
        indices[++ii] = voffset + 11;
        // Others
        indices[++ii] = voffset + 12;
        indices[++ii] = voffset + 13;
        indices[++ii] = voffset + 16;
        indices[++ii] = voffset + 13;
        indices[++ii] = voffset + 14;
        indices[++ii] = voffset + 16;
        indices[++ii] = voffset + 14;
        indices[++ii] = voffset + 15;
        indices[++ii] = voffset + 16;
        //
        indices[++ii] = voffset + 12;
        indices[++ii] = voffset + 16;
        indices[++ii] = voffset + 19;
        indices[++ii] = voffset + 16;
        indices[++ii] = voffset + 17;
        indices[++ii] = voffset + 19;
        indices[++ii] = voffset + 17;
        indices[++ii] = voffset + 18;
        indices[++ii] = voffset + 19;
        //
        indices[++ii] = voffset + 12;
        indices[++ii] = voffset + 19;
        indices[++ii] = voffset + 13;
        indices[++ii] = voffset + 19;
        indices[++ii] = voffset + 20;
        indices[++ii] = voffset + 13;
        indices[++ii] = voffset + 20;
        indices[++ii] = voffset + 21;
        indices[++ii] = voffset + 13;
    };
    var buildTriangleRoundedVertex = function (vertices, voffset, originX, originY, sizeX, sizeY, strokeAlign, strokeWidth, radius, internalTransform, worldSize) {
        // Calculate the transformed positions
        var s = strokeAlign * strokeWidth;
        var sx = sizeX * 0.5 + (0 <= sizeX ? +s : -s);
        var sy = sizeY * 0.5 + (0 <= sizeY ? +s : -s);
        var sz = Math.sqrt(sx * sx + 4 * sy * sy);
        var sw = (2 * sx * sy) / (sx + sz);
        var ry = (sw * radius) / (2 * sy);
        var rz = (0.5 * (sz - sw) * radius) / sz;
        var rx = (ry * sz) / (2 * sx);
        var work = TRIANGLE_ROUNDED_WORK_POINT;
        work.set(originX, originY - sy);
        internalTransform.apply(work, work);
        var x1 = work.x;
        var y1 = work.y;
        work.set(originX, originY);
        internalTransform.apply(work, work);
        var tx = work.x;
        var ty = work.y;
        work.set(originX + sx, originY);
        internalTransform.apply(work, work);
        var dx = tx - x1;
        var dy = ty - y1;
        var x4 = work.x + dx;
        var y4 = work.y + dy;
        var x7 = tx + (tx - work.x) + dx;
        var y7 = ty + (ty - work.y) + dy;
        var dx14 = x4 - x1;
        var dy14 = y4 - y1;
        var x2 = x1 + rz * dx14;
        var y2 = y1 + rz * dy14;
        var x3 = x4 - ry * dx14;
        var y3 = y4 - ry * dy14;
        var dx47r = rx * (x7 - x4);
        var dy47r = rx * (y7 - y4);
        var x5 = x4 + dx47r;
        var y5 = y4 + dy47r;
        var x6 = x7 - dx47r;
        var y6 = y7 - dy47r;
        var dx71 = x1 - x7;
        var dy71 = y1 - y7;
        var x8 = x7 + ry * dx71;
        var y8 = y7 + ry * dy71;
        var x9 = x1 - rz * dx71;
        var y9 = y1 - rz * dy71;
        work.set(originX, originY + sy - sw); // Incenter of a triangle
        internalTransform.apply(work, work);
        var x0 = work.x;
        var y0 = work.y;
        var x10 = x1 + radius * (x0 - x1);
        var y10 = y1 + radius * (y0 - y1);
        var x11 = x4 + radius * (x0 - x4);
        var y11 = y4 + radius * (y0 - y4);
        var x12 = x7 + radius * (x0 - x7);
        var y12 = y7 + radius * (y0 - y7);
        // World size
        var xb = tx + dx;
        var yb = ty + dy;
        worldSize[0] = toLength(xb, yb, x0, y0);
        worldSize[1] = rx;
        worldSize[2] = ry;
        worldSize[3] = rz;
        worldSize[4] = 1 - (0.5 * sw) / sy;
        // Vertices
        // Top corner
        var iv = voffset * 2 - 1;
        vertices[++iv] = x10;
        vertices[++iv] = y10;
        vertices[++iv] = x9;
        vertices[++iv] = y9;
        vertices[++iv] = x1;
        vertices[++iv] = y1;
        vertices[++iv] = x2;
        vertices[++iv] = y2;
        // Bottom-right corner
        vertices[++iv] = x11;
        vertices[++iv] = y11;
        vertices[++iv] = x3;
        vertices[++iv] = y3;
        vertices[++iv] = x4;
        vertices[++iv] = y4;
        vertices[++iv] = x5;
        vertices[++iv] = y5;
        // Bottom-left corner
        vertices[++iv] = x12;
        vertices[++iv] = y12;
        vertices[++iv] = x6;
        vertices[++iv] = y6;
        vertices[++iv] = x7;
        vertices[++iv] = y7;
        vertices[++iv] = x8;
        vertices[++iv] = y8;
        // Others
        vertices[++iv] = x0;
        vertices[++iv] = y0;
        vertices[++iv] = x10;
        vertices[++iv] = y10;
        vertices[++iv] = x2;
        vertices[++iv] = y2;
        vertices[++iv] = x3;
        vertices[++iv] = y3;
        vertices[++iv] = x11;
        vertices[++iv] = y11;
        vertices[++iv] = x5;
        vertices[++iv] = y5;
        vertices[++iv] = x6;
        vertices[++iv] = y6;
        vertices[++iv] = x12;
        vertices[++iv] = y12;
        vertices[++iv] = x8;
        vertices[++iv] = y8;
        vertices[++iv] = x9;
        vertices[++iv] = y9;
    };
    var buildTriangleRoundedStep = function (steps, voffset, strokeWidth, strokeStyle, corner, radius, worldSize) {
        var scaleInvariant = toScaleInvariant(strokeStyle);
        var s = worldSize[0];
        var sr = radius * s;
        var w = 1 - radius;
        var e0 = toPackedI4x64(0, scaleInvariant, 1, 1);
        var e1 = toPackedI4x64(1, scaleInvariant, 1, 1);
        var c00 = toPackedF2x1024(0, 0);
        var c10 = toPackedF2x1024(1, 0);
        var c11 = toPackedF2x1024(1, 1);
        var c01 = toPackedF2x1024(0, 1);
        var cww = toPackedF2x1024(w, w);
        var c1w = toPackedF2x1024(1, w);
        var cw1 = toPackedF2x1024(w, 1);
        var cw0 = toPackedF2x1024(w, 0);
        // Top corner
        var is = voffset * 6 - 1;
        if (corner & EShapeCorner.TOP) {
            // 001
            steps[++is] = strokeWidth;
            steps[++is] = e1;
            steps[++is] = sr;
            steps[++is] = sr;
            steps[++is] = c00;
            steps[++is] = 0;
            // 101
            steps[++is] = strokeWidth;
            steps[++is] = e1;
            steps[++is] = sr;
            steps[++is] = sr;
            steps[++is] = c10;
            steps[++is] = 0;
            // 111
            steps[++is] = strokeWidth;
            steps[++is] = e1;
            steps[++is] = sr;
            steps[++is] = sr;
            steps[++is] = c11;
            steps[++is] = 0;
            // 011
            steps[++is] = strokeWidth;
            steps[++is] = e1;
            steps[++is] = sr;
            steps[++is] = sr;
            steps[++is] = c01;
            steps[++is] = 0;
        }
        else {
            // ww0
            steps[++is] = strokeWidth;
            steps[++is] = e0;
            steps[++is] = s;
            steps[++is] = s;
            steps[++is] = cww;
            steps[++is] = 0;
            // 1w0
            steps[++is] = strokeWidth;
            steps[++is] = e0;
            steps[++is] = s;
            steps[++is] = s;
            steps[++is] = c1w;
            steps[++is] = 0;
            // 110
            steps[++is] = strokeWidth;
            steps[++is] = e0;
            steps[++is] = s;
            steps[++is] = s;
            steps[++is] = c11;
            steps[++is] = 0;
            // w10
            steps[++is] = strokeWidth;
            steps[++is] = e0;
            steps[++is] = s;
            steps[++is] = s;
            steps[++is] = cw1;
            steps[++is] = 0;
        }
        // Bottom-right corner
        if (corner & EShapeCorner.BOTTOM_RIGHT) {
            // 001
            steps[++is] = strokeWidth;
            steps[++is] = e1;
            steps[++is] = sr;
            steps[++is] = sr;
            steps[++is] = c00;
            steps[++is] = 0;
            // 101
            steps[++is] = strokeWidth;
            steps[++is] = e1;
            steps[++is] = sr;
            steps[++is] = sr;
            steps[++is] = c10;
            steps[++is] = 0;
            // 111
            steps[++is] = strokeWidth;
            steps[++is] = e1;
            steps[++is] = sr;
            steps[++is] = sr;
            steps[++is] = c11;
            steps[++is] = 0;
            // 011
            steps[++is] = strokeWidth;
            steps[++is] = e1;
            steps[++is] = sr;
            steps[++is] = sr;
            steps[++is] = c01;
            steps[++is] = 0;
        }
        else {
            // ww0
            steps[++is] = strokeWidth;
            steps[++is] = e0;
            steps[++is] = s;
            steps[++is] = s;
            steps[++is] = cww;
            steps[++is] = 0;
            // 1w0
            steps[++is] = strokeWidth;
            steps[++is] = e0;
            steps[++is] = s;
            steps[++is] = s;
            steps[++is] = c1w;
            steps[++is] = 0;
            // 110
            steps[++is] = strokeWidth;
            steps[++is] = e0;
            steps[++is] = s;
            steps[++is] = s;
            steps[++is] = c11;
            steps[++is] = 0;
            // w10
            steps[++is] = strokeWidth;
            steps[++is] = e0;
            steps[++is] = s;
            steps[++is] = s;
            steps[++is] = cw1;
            steps[++is] = 0;
        }
        // Bottom-left corner
        if (corner & EShapeCorner.BOTTOM_LEFT) {
            // 001
            steps[++is] = strokeWidth;
            steps[++is] = e1;
            steps[++is] = sr;
            steps[++is] = sr;
            steps[++is] = c00;
            steps[++is] = 0;
            // 101
            steps[++is] = strokeWidth;
            steps[++is] = e1;
            steps[++is] = sr;
            steps[++is] = sr;
            steps[++is] = c10;
            steps[++is] = 0;
            // 111
            steps[++is] = strokeWidth;
            steps[++is] = e1;
            steps[++is] = sr;
            steps[++is] = sr;
            steps[++is] = c11;
            steps[++is] = 0;
            // 011
            steps[++is] = strokeWidth;
            steps[++is] = e1;
            steps[++is] = sr;
            steps[++is] = sr;
            steps[++is] = c01;
            steps[++is] = 0;
        }
        else {
            // ww0
            steps[++is] = strokeWidth;
            steps[++is] = e0;
            steps[++is] = s;
            steps[++is] = s;
            steps[++is] = cww;
            steps[++is] = 0;
            // 1w0
            steps[++is] = strokeWidth;
            steps[++is] = e0;
            steps[++is] = s;
            steps[++is] = s;
            steps[++is] = c1w;
            steps[++is] = 0;
            // 110
            steps[++is] = strokeWidth;
            steps[++is] = e0;
            steps[++is] = s;
            steps[++is] = s;
            steps[++is] = c11;
            steps[++is] = 0;
            // w10
            steps[++is] = strokeWidth;
            steps[++is] = e0;
            steps[++is] = s;
            steps[++is] = s;
            steps[++is] = cw1;
            steps[++is] = 0;
        }
        // Others
        // 000
        steps[++is] = strokeWidth;
        steps[++is] = e0;
        steps[++is] = s;
        steps[++is] = s;
        steps[++is] = c00;
        steps[++is] = 0;
        // w00
        steps[++is] = strokeWidth;
        steps[++is] = e0;
        steps[++is] = s;
        steps[++is] = s;
        steps[++is] = cw0;
        steps[++is] = 0;
        // 100
        steps[++is] = strokeWidth;
        steps[++is] = e0;
        steps[++is] = s;
        steps[++is] = s;
        steps[++is] = c10;
        steps[++is] = 0;
        // 100
        steps[++is] = strokeWidth;
        steps[++is] = e0;
        steps[++is] = s;
        steps[++is] = s;
        steps[++is] = c10;
        steps[++is] = 0;
        // w00
        steps[++is] = strokeWidth;
        steps[++is] = e0;
        steps[++is] = s;
        steps[++is] = s;
        steps[++is] = cw0;
        steps[++is] = 0;
        // 100
        steps[++is] = strokeWidth;
        steps[++is] = e0;
        steps[++is] = s;
        steps[++is] = s;
        steps[++is] = c10;
        steps[++is] = 0;
        // 100
        steps[++is] = strokeWidth;
        steps[++is] = e0;
        steps[++is] = s;
        steps[++is] = s;
        steps[++is] = c10;
        steps[++is] = 0;
        // w00
        steps[++is] = strokeWidth;
        steps[++is] = e0;
        steps[++is] = s;
        steps[++is] = s;
        steps[++is] = cw0;
        steps[++is] = 0;
        // 100
        steps[++is] = strokeWidth;
        steps[++is] = e0;
        steps[++is] = s;
        steps[++is] = s;
        steps[++is] = c10;
        steps[++is] = 0;
        // 100
        steps[++is] = strokeWidth;
        steps[++is] = e0;
        steps[++is] = s;
        steps[++is] = s;
        steps[++is] = c10;
        steps[++is] = 0;
    };
    var buildTriangleRoundedUv = function (uvs, voffset, textureUvs, radius, worldSize) {
        var x0 = textureUvs.x0;
        var x1 = textureUvs.x1;
        var x2 = textureUvs.x2;
        var x3 = textureUvs.x3;
        var y0 = textureUvs.y0;
        var y1 = textureUvs.y1;
        var y2 = textureUvs.y2;
        var y3 = textureUvs.y3;
        var x4 = 0.5 * (x0 + x1);
        var y4 = 0.5 * (y0 + y1);
        var c = worldSize[4];
        var x5 = x4 + c * (x3 - x0);
        var y5 = y4 + c * (y3 - y0);
        var rx = worldSize[1];
        var ry = worldSize[2];
        var rz = worldSize[3];
        var x6 = x4 + rz * (x3 - x4);
        var y6 = y4 + rz * (y3 - y4);
        var x7 = x4 + radius * (x5 - x4);
        var y7 = y4 + radius * (y5 - y4);
        var x8 = x4 + rz * (x2 - x4);
        var y8 = y4 + rz * (y2 - y4);
        var x9 = x2 + ry * (x4 - x2);
        var y9 = y2 + ry * (y4 - y2);
        var x10 = x2 + radius * (x5 - x2);
        var y10 = y2 + radius * (y5 - y2);
        var x11 = x2 + rx * (x3 - x2);
        var y11 = y2 + rx * (y3 - y2);
        var x12 = x3 + rx * (x2 - x3);
        var y12 = y3 + rx * (y2 - y3);
        var x13 = x3 + radius * (x5 - x3);
        var y13 = y3 + radius * (y5 - y3);
        var x14 = x3 + ry * (x4 - x3);
        var y14 = y3 + ry * (y4 - y3);
        // Uvs
        // Top corner
        var iuv = voffset * 2 - 1;
        uvs[++iuv] = x7;
        uvs[++iuv] = y7;
        uvs[++iuv] = x6;
        uvs[++iuv] = y6;
        uvs[++iuv] = x4;
        uvs[++iuv] = y4;
        uvs[++iuv] = x8;
        uvs[++iuv] = y8;
        // Bottom-right corner
        uvs[++iuv] = x10;
        uvs[++iuv] = y10;
        uvs[++iuv] = x9;
        uvs[++iuv] = y9;
        uvs[++iuv] = x2;
        uvs[++iuv] = y2;
        uvs[++iuv] = x11;
        uvs[++iuv] = y11;
        // Bottom-left corner
        uvs[++iuv] = x13;
        uvs[++iuv] = y13;
        uvs[++iuv] = x12;
        uvs[++iuv] = y12;
        uvs[++iuv] = x3;
        uvs[++iuv] = y3;
        uvs[++iuv] = x14;
        uvs[++iuv] = y14;
        // Others
        uvs[++iuv] = x5;
        uvs[++iuv] = y5;
        uvs[++iuv] = x7;
        uvs[++iuv] = y7;
        uvs[++iuv] = x8;
        uvs[++iuv] = y8;
        uvs[++iuv] = x9;
        uvs[++iuv] = y9;
        uvs[++iuv] = x10;
        uvs[++iuv] = y10;
        uvs[++iuv] = x11;
        uvs[++iuv] = y11;
        uvs[++iuv] = x12;
        uvs[++iuv] = y12;
        uvs[++iuv] = x13;
        uvs[++iuv] = y13;
        uvs[++iuv] = x14;
        uvs[++iuv] = y14;
        uvs[++iuv] = x6;
        uvs[++iuv] = y6;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var BuilderLineOfTriangleRoundeds = /** @class */ (function (_super) {
        __extends(BuilderLineOfTriangleRoundeds, _super);
        function BuilderLineOfTriangleRoundeds(buffer, vertexOffset, indexOffset, vertexCount, indexCount, pointCountReserved, vcountPerPoint, icountPerPoint) {
            var _this = _super.call(this, buffer, vertexOffset, indexOffset, vertexCount, indexCount, pointCountReserved, vcountPerPoint, icountPerPoint) || this;
            _this.radius = 0;
            _this.corner = 0;
            return _this;
        }
        BuilderLineOfTriangleRoundeds.prototype.init = function () {
            var buffer = this.buffer;
            buffer.updateIndices();
            var voffset = this.vertexOffset;
            var ioffset = this.indexOffset;
            var pointCountReserved = this.pointCountReserved;
            if (0 < pointCountReserved) {
                buildTriangleRoundedIndex(buffer.indices, voffset, ioffset);
                copyIndex(buffer.indices, TRIANGLE_ROUNDED_VERTEX_COUNT, ioffset, TRIANGLE_ROUNDED_INDEX_COUNT, pointCountReserved);
            }
            this.inited |= BuilderFlag.INDEX;
        };
        BuilderLineOfTriangleRoundeds.prototype.update = function (shape) {
            var points = shape.points;
            if (points instanceof EShapeLineOfAnyPointsImpl) {
                var buffer = this.buffer;
                this.updateVertexStepAndUv(buffer, shape, points);
                this.updateLineOfAnyColor(buffer, shape, points, TRIANGLE_ROUNDED_VERTEX_COUNT);
            }
        };
        BuilderLineOfTriangleRoundeds.prototype.updateVertexStepAndUv = function (buffer, shape, points) {
            var pointId = points.id;
            var pointOffset = points.offset;
            var pointOffsetId = pointOffset.id;
            var isPointChanged = pointId !== this.pointId || pointOffsetId !== this.pointOffsetId;
            var pointSize = points.size;
            var pointSizeId = pointSize.id;
            var isPointSizeChanged = pointSizeId !== this.pointSizeId;
            var size = shape.size;
            var sizeX = size.x;
            var sizeY = size.y;
            var isSizeChanged = sizeX !== this.sizeX || sizeY !== this.sizeY;
            var radius = shape.radius;
            var isRadiusChanged = radius !== this.radius;
            var transformLocalId = toTransformLocalId(shape);
            var isTransformChanged = this.transformLocalId !== transformLocalId;
            var stroke = shape.stroke;
            var strokeAlign = stroke.align;
            var strokeWidth = stroke.enable ? stroke.width : 0;
            var strokeStyle = stroke.style;
            var isStrokeChanged = this.strokeAlign !== strokeAlign ||
                this.strokeWidth !== strokeWidth ||
                this.strokeStyle !== strokeStyle;
            var corner = shape.corner;
            var isCornerChanged = this.corner !== corner;
            var texture = toTexture(shape);
            var textureTransformId = toTextureTransformId(texture);
            var isTextureChanged = texture !== this.texture || textureTransformId !== this.textureTransformId;
            var isVertexChanged = isPointChanged ||
                isPointSizeChanged ||
                isSizeChanged ||
                isRadiusChanged ||
                isStrokeChanged;
            var isNotInited = !(this.inited & BuilderFlag.VERTEX_STEP_AND_UV);
            if (isNotInited ||
                isVertexChanged ||
                isTransformChanged ||
                isCornerChanged ||
                isTextureChanged) {
                this.inited |= BuilderFlag.VERTEX_STEP_AND_UV;
                this.pointId = pointId;
                var formatted = points.formatted;
                this.pointCount = formatted.length;
                this.pointOffsetId = pointOffsetId;
                this.pointSizeId = pointSizeId;
                this.sizeX = sizeX;
                this.sizeY = sizeY;
                this.radius = radius;
                this.transformLocalId = transformLocalId;
                this.strokeAlign = strokeAlign;
                this.strokeWidth = strokeWidth;
                this.strokeStyle = strokeStyle;
                this.corner = corner;
                this.texture = texture;
                this.textureTransformId = textureTransformId;
                // Buffer
                buffer.updateVertices();
                if (isNotInited || isVertexChanged || isTransformChanged || isCornerChanged) {
                    buffer.updateSteps();
                }
                if (isNotInited || isVertexChanged || isTextureChanged) {
                    buffer.updateUvs();
                }
                var pointCount = this.pointCount;
                var pointsValues = formatted.values;
                var voffset = this.vertexOffset;
                var vertices = buffer.vertices;
                var steps = buffer.steps;
                var uvs = buffer.uvs;
                var internalTransform = shape.transform.internalTransform;
                var textureUvs = toTextureUvs(texture);
                if (0 < pointCount && pointSize.isStaticX() && pointSize.isStaticY()) {
                    var pointSizeX = pointSize.getX(0);
                    var pointSizeY = pointSize.getY(0);
                    // Vertices
                    buildTriangleRoundedVertex(vertices, voffset, 0, 0, pointSizeX, pointSizeY, strokeAlign, strokeWidth, radius, internalTransform, TRIANGLE_ROUNDED_WORLD_SIZE);
                    copyVertex(vertices, internalTransform, voffset, TRIANGLE_ROUNDED_VERTEX_COUNT, pointCount, pointsValues, pointOffset);
                    // Steps
                    if (isNotInited || isVertexChanged || isTransformChanged || isCornerChanged) {
                        buildTriangleRoundedStep(steps, voffset, strokeWidth, strokeStyle, corner, radius, TRIANGLE_ROUNDED_WORLD_SIZE);
                        copyStep(steps, voffset, TRIANGLE_ROUNDED_VERTEX_COUNT, pointCount);
                    }
                    // UVs
                    if (isNotInited || isVertexChanged || isTextureChanged) {
                        buildTriangleRoundedUv(uvs, voffset, textureUvs, radius, TRIANGLE_ROUNDED_WORLD_SIZE);
                        copyUvs(uvs, voffset, TRIANGLE_ROUNDED_VERTEX_COUNT, pointCount);
                    }
                }
                else {
                    for (var i = 0; i < pointCount; ++i) {
                        var ip = i << 1;
                        var px = pointsValues[ip] + pointOffset.getX(i);
                        var py = pointsValues[ip + 1] + pointOffset.getY(i);
                        var pointSizeX = pointSize.getX(i);
                        var pointSizeY = pointSize.getY(i);
                        var iv = voffset + i * TRIANGLE_ROUNDED_VERTEX_COUNT;
                        // Vertices
                        buildTriangleRoundedVertex(vertices, iv, px, py, pointSizeX, pointSizeY, strokeAlign, strokeWidth, radius, internalTransform, TRIANGLE_ROUNDED_WORLD_SIZE);
                        // Steps
                        if (isNotInited || isVertexChanged || isTransformChanged || isCornerChanged) {
                            buildTriangleRoundedStep(steps, iv, strokeWidth, strokeStyle, corner, radius, TRIANGLE_ROUNDED_WORLD_SIZE);
                        }
                        // UVs
                        if (isNotInited || isVertexChanged || isTextureChanged) {
                            buildTriangleRoundedUv(uvs, iv, textureUvs, radius, TRIANGLE_ROUNDED_WORLD_SIZE);
                        }
                    }
                }
                // Fill the rest
                var pointCountReserved = this.pointCountReserved;
                var voffsetReserved = voffset + pointCount * TRIANGLE_ROUNDED_VERTEX_COUNT;
                var vcountReserved = TRIANGLE_ROUNDED_VERTEX_COUNT * (pointCountReserved - pointCount);
                buildNullVertex(vertices, voffsetReserved, vcountReserved);
                buildNullStep(steps, voffsetReserved, vcountReserved);
                buildNullUv(uvs, voffsetReserved, vcountReserved);
            }
        };
        return BuilderLineOfTriangleRoundeds;
    }(BuilderLineOfAny));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var createLineOfTriangleRoundedsUploaded = function (buffer, shape, voffset, ioffset, antialiasWeight) {
        return createLineOfAnyUploaded(buffer, shape, voffset, TRIANGLE_ROUNDED_VERTEX_COUNT, ioffset, TRIANGLE_ROUNDED_INDEX_COUNT, antialiasWeight, BuilderLineOfTriangleRoundeds);
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var containsCorner_ = function (shape, x, y, r, aw, sw, ss) {
        var fill = shape.fill;
        if (fill.enable) {
            if (x * x + y * y <= r * r) {
                return true;
            }
        }
        else {
            if (0 < sw) {
                var d = x * x + y * y;
                if (d <= r * r) {
                    var w = Math.max(0.0, r * (1 - (sw * ss) / aw));
                    if (w * w <= d) {
                        return true;
                    }
                }
            }
        }
        return false;
    };
    var containsCorner = function (shape, x, y, x0, y0, x1, y1, x2, y2, x3, y3, r12, r13, aw, radius, sw, ss) {
        var xl = x1 + r12 * (x2 - x1) - x0;
        var yl = y1 + r12 * (y2 - y1) - y0;
        var n = Math.sqrt(xl * xl + yl * yl);
        var threshold = 0.00001;
        if (threshold < n) {
            var ni = 1 / n;
            var nlx = xl * ni;
            var nly = yl * ni;
            var xr = x1 + r13 * (x3 - x1) - x0;
            var yr = y1 + r13 * (y3 - y1) - y0;
            var nrx = xr * ni;
            var nry = yr * ni;
            var det = nlx * nry - nrx * nly;
            if (threshold < Math.abs(det)) {
                var deti = 1 / det;
                var xc = x - x0;
                var yc = y - y0;
                var dx = (+nry * xc - nrx * yc) * deti;
                var dy = (-nly * xc + nlx * yc) * deti;
                if (containsCorner_(shape, dx, dy, n, aw * radius, sw, ss)) {
                    return true;
                }
            }
        }
        return false;
    };
    var hitTestTriangleRounded = function (shape, x, y, ax, ay, sw, ss) {
        var a = (2 * ay) / ax;
        if (hitTestTriangleFilled(x, y, a, -ay, +ay)) {
            var az = Math.sqrt(ax * ax + 4 * ay * ay);
            var aw = (2 * ax * ay) / (ax + az);
            var radius = shape.radius;
            var x0 = 0;
            var y0 = ay - aw;
            var x1 = 0;
            var y1 = -ay;
            var x4 = +ax;
            var y4 = +ay;
            var x7 = -x4;
            var y7 = +y4;
            var x10 = x1 + radius * (x0 - x1);
            var y10 = y1 + radius * (y0 - y1);
            var x11 = x4 + radius * (x0 - x4);
            var y11 = y4 + radius * (y0 - y4);
            var y12 = +y11;
            var x12 = -x11;
            var c0 = -a * x + y10 - y <= 0;
            var c1 = +a * x + y10 - y <= 0;
            var c2 = y <= y11;
            var corner = shape.corner;
            if (!c0 && !c1 && corner & EShapeCorner.TOP) {
                // Top corner
                var rz = (0.5 * (az - aw) * radius) / az;
                if (containsCorner(shape, x, y, x10, y10, x1, y1, x7, y7, x4, y4, rz, rz, aw, radius, sw, ss)) {
                    return true;
                }
            }
            else if (!c0 && !c2 && corner & EShapeCorner.BOTTOM_LEFT) {
                // Bottom-left corner
                var ry = (aw * radius) / (2 * ay);
                var rx = (ry * az) / (2 * ax);
                if (containsCorner(shape, x, y, x12, y12, x7, y7, x4, y4, x1, y1, rx, ry, aw, radius, sw, ss)) {
                    return true;
                }
            }
            else if (!c1 && !c2 && corner & EShapeCorner.BOTTOM_RIGHT) {
                // Bottom-right corner
                var ry = (aw * radius) / (2 * ay);
                var rx = (ry * az) / (2 * ax);
                if (containsCorner(shape, x, y, x11, y11, x4, y4, x1, y1, x7, y7, ry, rx, aw, radius, sw, ss)) {
                    return true;
                }
            }
            else {
                // Others
                var fill = shape.fill;
                if (fill.enable) {
                    return true;
                }
                else {
                    if (0 < sw) {
                        var s = sw * ss;
                        var cy = ay - aw;
                        var ay1 = cy + ((-ay - cy) * Math.max(0.0, aw - s)) / aw;
                        var ay2 = ay - s;
                        if (!hitTestTriangleFilled(x, y, a, ay1, ay2)) {
                            return true;
                        }
                    }
                }
            }
        }
        return false;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeTriangleRounded = /** @class */ (function (_super) {
        __extends(EShapeTriangleRounded, _super);
        function EShapeTriangleRounded(type) {
            if (type === void 0) { type = EShapeType.TRIANGLE_ROUNDED; }
            return _super.call(this, type) || this;
        }
        EShapeTriangleRounded.prototype.clone = function () {
            return new EShapeTriangleRounded(this.type).copy(this);
        };
        EShapeTriangleRounded.prototype.containsAbs = function (x, y, ax, ay, sw, ss, sa) {
            if (_super.prototype.containsAbsBBox.call(this, x, y, ax, ay)) {
                return hitTestTriangleRounded(this, x, y, ax, ay, sw, ss);
            }
            return false;
        };
        return EShapeTriangleRounded;
    }(EShapePrimitive));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeLineOfTriangleRoundeds = /** @class */ (function (_super) {
        __extends(EShapeLineOfTriangleRoundeds, _super);
        function EShapeLineOfTriangleRoundeds(type) {
            if (type === void 0) { type = EShapeType.LINE_OF_TRIANGLE_ROUNDEDS; }
            var _this = _super.call(this, type) || this;
            _this._points = new EShapeLineOfAnyPointsImpl(_this);
            _this._tester = function (x, y, ax, ay, ox, oy, px, py, sw, ss, sa) {
                return _this.containsPointAbs(x, y, ax, ay, ox, oy, px, py, sw, ss, sa);
            };
            return _this;
        }
        Object.defineProperty(EShapeLineOfTriangleRoundeds.prototype, "points", {
            get: function () {
                return this._points;
            },
            enumerable: false,
            configurable: true
        });
        EShapeLineOfTriangleRoundeds.prototype.clone = function () {
            return new EShapeLineOfTriangleRoundeds(this.type).copy(this);
        };
        EShapeLineOfTriangleRoundeds.prototype.containsAbs = function (x, y, ax, ay, sw, ss, sa) {
            var threshold = toThresholdDefault(sw, ss, this._points.size.getLimit());
            if (this.containsAbsBBox(x, y, ax + threshold, ay + threshold)) {
                return this._points.calcHitPointAbs(x, y, sw, ss, sa, threshold, null, this._tester, null);
            }
            return false;
        };
        EShapeLineOfTriangleRoundeds.prototype.containsPointAbs = function (x, y, ax, ay, ox, oy, px, py, sw, ss, sa) {
            return _super.prototype.containsAbs.call(this, x - px - ox, y - py - oy, ax, ay, sw, ss, sa);
        };
        EShapeLineOfTriangleRoundeds.prototype.calcHitPoint = function (x, y, toThreshold, toRange, tester, result) {
            var data = this.toHitTestData(x, y);
            var threshold = (toThreshold || toThresholdDefault)(data.strokeWidth, data.strokeScale, this._points.size.getLimit());
            if (this.containsAbsBBox(data.x, data.y, data.width + threshold, data.height + threshold)) {
                return this._points.calcHitPointAbs(data.x, data.y, data.strokeWidth, data.strokeScale, data.strokeAlign, threshold, toRange, tester || this._tester, result);
            }
            return false;
        };
        return EShapeLineOfTriangleRoundeds;
    }(EShapeTriangleRounded));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var deserializeLineOfTriangleRoundeds = function (item, manager, shape) {
        return deserializeBase(item, manager, shape || new EShapeLineOfTriangleRoundeds());
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadShapeLineOfTriangleRoundeds = function () {
        EShapeUploadeds[EShapeType.LINE_OF_TRIANGLE_ROUNDEDS] = createLineOfTriangleRoundedsUploaded;
        EShapeDeserializers[EShapeType.LINE_OF_TRIANGLE_ROUNDEDS] = deserializeLineOfTriangleRoundeds;
        EShapeCapabilities.set(EShapeType.LINE_OF_TRIANGLE_ROUNDEDS, EShapeCapability.PRIMITIVE | EShapeCapability.STROKE_SIDE | EShapeCapability.BORDER_RADIUS);
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var BuilderLineOfTriangles = /** @class */ (function (_super) {
        __extends(BuilderLineOfTriangles, _super);
        function BuilderLineOfTriangles() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        BuilderLineOfTriangles.prototype.init = function () {
            var buffer = this.buffer;
            buffer.updateIndices();
            var indices = buffer.indices;
            var voffset = this.vertexOffset;
            var ioffset = this.indexOffset;
            var pointCountReserved = this.pointCountReserved;
            if (0 < pointCountReserved) {
                buildTriangleIndex(indices, voffset, ioffset);
                copyIndex(indices, TRIANGLE_VERTEX_COUNT, ioffset, TRIANGLE_INDEX_COUNT, pointCountReserved);
            }
            this.inited |= BuilderFlag.INDEX;
        };
        BuilderLineOfTriangles.prototype.update = function (shape) {
            var points = shape.points;
            if (points instanceof EShapeLineOfAnyPointsImpl) {
                var buffer = this.buffer;
                this.updateVertexStepAndUvs(buffer, shape, points);
                this.updateLineOfAnyColor(buffer, shape, points, TRIANGLE_VERTEX_COUNT);
            }
        };
        BuilderLineOfTriangles.prototype.updateVertexStepAndUvs = function (buffer, shape, points) {
            var pointId = points.id;
            var pointOffset = points.offset;
            var pointOffsetId = pointOffset.id;
            var isPointChanged = pointId !== this.pointId || pointOffsetId !== this.pointOffsetId;
            var pointSize = points.size;
            var pointSizeId = pointSize.id;
            var isPointSizeChanged = pointSizeId !== this.pointSizeId;
            var size = shape.size;
            var sizeX = size.x;
            var sizeY = size.y;
            var isSizeChanged = sizeX !== this.sizeX || sizeY !== this.sizeY;
            var transformLocalId = toTransformLocalId(shape);
            var isTransformChanged = this.transformLocalId !== transformLocalId;
            var stroke = shape.stroke;
            var strokeAlign = stroke.align;
            var strokeWidth = stroke.enable ? stroke.width : 0;
            var strokeStyle = stroke.style;
            var isStrokeChanged = this.strokeAlign !== strokeAlign ||
                this.strokeWidth !== strokeWidth ||
                this.strokeStyle !== strokeStyle;
            var texture = toTexture(shape);
            var textureTransformId = toTextureTransformId(texture);
            var isTextureChanged = texture !== this.texture || textureTransformId !== this.textureTransformId;
            var isVertexChanged = isPointChanged || isPointSizeChanged || isSizeChanged || isStrokeChanged;
            var isNotInited = !(this.inited & BuilderFlag.VERTEX_STEP_AND_UV);
            if (isNotInited || isVertexChanged || isTransformChanged || isTextureChanged) {
                this.inited |= BuilderFlag.VERTEX_STEP_AND_UV;
                this.pointId = pointId;
                var formatted = points.formatted;
                this.pointCount = formatted.length;
                this.pointOffsetId = pointOffsetId;
                this.pointSizeId = pointSizeId;
                this.sizeX = sizeX;
                this.sizeY = sizeY;
                this.transformLocalId = transformLocalId;
                this.strokeAlign = strokeAlign;
                this.strokeWidth = strokeWidth;
                this.strokeStyle = strokeStyle;
                this.texture = texture;
                this.textureTransformId = textureTransformId;
                // Buffer
                buffer.updateVertices();
                if (isNotInited || isVertexChanged || isTransformChanged) {
                    buffer.updateSteps();
                }
                if (isNotInited || isVertexChanged || isTextureChanged) {
                    buffer.updateUvs();
                }
                var pointCount = this.pointCount;
                var pointsValues = formatted.values;
                var voffset = this.vertexOffset;
                var vertices = buffer.vertices;
                var steps = buffer.steps;
                var uvs = buffer.uvs;
                var textureUvs = toTextureUvs(texture);
                var internalTransform = shape.transform.internalTransform;
                if (0 < pointCount && pointSize.isStaticX() && pointSize.isStaticY()) {
                    var pointSizeX = pointSize.getX(0);
                    var pointSizeY = pointSize.getY(0);
                    buildTriangleVertex(vertices, voffset, 0, 0, pointSizeX, pointSizeY, strokeAlign, strokeWidth, internalTransform, TRIANGLE_WORLD_SIZE);
                    copyVertex(vertices, internalTransform, voffset, TRIANGLE_VERTEX_COUNT, pointCount, pointsValues, pointOffset);
                    if (isNotInited || isVertexChanged || isTransformChanged) {
                        buildTriangleStep(steps, voffset, strokeWidth, strokeStyle, TRIANGLE_WORLD_SIZE);
                        copyStep(steps, voffset, TRIANGLE_VERTEX_COUNT, pointCount);
                    }
                    if (isNotInited || isVertexChanged || isTextureChanged) {
                        buildTriangleUv(uvs, textureUvs, voffset, TRIANGLE_WORLD_SIZE);
                        copyUvs(uvs, voffset, TRIANGLE_VERTEX_COUNT, pointCount);
                    }
                }
                else {
                    for (var i = 0; i < pointCount; ++i) {
                        var ip = i << 1;
                        var px = pointsValues[ip] + pointOffset.getX(i);
                        var py = pointsValues[ip + 1] + pointOffset.getY(i);
                        var pointSizeX = pointSize.getX(i);
                        var pointSizeY = pointSize.getY(i);
                        var iv = voffset + i * TRIANGLE_VERTEX_COUNT;
                        buildTriangleVertex(vertices, iv, px, py, pointSizeX, pointSizeY, strokeAlign, strokeWidth, internalTransform, TRIANGLE_WORLD_SIZE);
                        if (isNotInited || isVertexChanged || isTransformChanged) {
                            buildTriangleStep(steps, iv, strokeWidth, strokeStyle, TRIANGLE_WORLD_SIZE);
                        }
                        if (isNotInited || isVertexChanged || isTextureChanged) {
                            buildTriangleUv(uvs, textureUvs, iv, TRIANGLE_WORLD_SIZE);
                        }
                    }
                }
                // Fill the rest
                var pointCountReserved = this.pointCountReserved;
                var voffsetReserved = voffset + pointCount * TRIANGLE_VERTEX_COUNT;
                var vcountReserved = TRIANGLE_VERTEX_COUNT * (pointCountReserved - pointCount);
                buildNullVertex(vertices, voffsetReserved, vcountReserved);
                buildNullStep(steps, voffsetReserved, vcountReserved);
                buildNullUv(uvs, voffsetReserved, vcountReserved);
            }
        };
        return BuilderLineOfTriangles;
    }(BuilderLineOfAny));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var createLineOfTrianglesUploaded = function (buffer, shape, voffset, ioffset, antialiasWeight) {
        return createLineOfAnyUploaded(buffer, shape, voffset, TRIANGLE_VERTEX_COUNT, ioffset, TRIANGLE_INDEX_COUNT, antialiasWeight, BuilderLineOfTriangles);
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeTriangle = /** @class */ (function (_super) {
        __extends(EShapeTriangle, _super);
        function EShapeTriangle(type) {
            if (type === void 0) { type = EShapeType.TRIANGLE; }
            return _super.call(this, type) || this;
        }
        EShapeTriangle.prototype.clone = function () {
            return new EShapeTriangle(this.type).copy(this);
        };
        EShapeTriangle.prototype.containsAbs = function (x, y, ax, ay, sw, ss, sa) {
            if (_super.prototype.containsAbsBBox.call(this, x, y, ax, ay)) {
                return hitTestTriangle(this, x, y, ax, ay, sw, ss);
            }
            return false;
        };
        return EShapeTriangle;
    }(EShapePrimitive));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeLineOfTriangles = /** @class */ (function (_super) {
        __extends(EShapeLineOfTriangles, _super);
        function EShapeLineOfTriangles(type) {
            if (type === void 0) { type = EShapeType.LINE_OF_TRIANGLES; }
            var _this = _super.call(this, type) || this;
            _this._points = new EShapeLineOfAnyPointsImpl(_this);
            _this._tester = function (x, y, ax, ay, ox, oy, px, py, sw, ss, sa) {
                return _this.containsPointAbs(x, y, ax, ay, ox, oy, px, py, sw, ss, sa);
            };
            return _this;
        }
        Object.defineProperty(EShapeLineOfTriangles.prototype, "points", {
            get: function () {
                return this._points;
            },
            enumerable: false,
            configurable: true
        });
        EShapeLineOfTriangles.prototype.clone = function () {
            return new EShapeLineOfTriangles(this.type).copy(this);
        };
        EShapeLineOfTriangles.prototype.containsAbs = function (x, y, ax, ay, sw, ss, sa) {
            var threshold = toThresholdDefault(sw, ss, this._points.size.getLimit());
            if (this.containsAbsBBox(x, y, ax + threshold, ay + threshold)) {
                return this._points.calcHitPointAbs(x, y, sw, ss, sa, threshold, null, this._tester, null);
            }
            return false;
        };
        EShapeLineOfTriangles.prototype.containsPointAbs = function (x, y, ax, ay, ox, oy, px, py, sw, ss, sa) {
            return _super.prototype.containsAbs.call(this, x - px - ox, y - py - oy, ax, ay, sw, ss, sa);
        };
        EShapeLineOfTriangles.prototype.calcHitPoint = function (x, y, toThreshold, toRange, tester, result) {
            var data = this.toHitTestData(x, y);
            var threshold = (toThreshold || toThresholdDefault)(data.strokeWidth, data.strokeScale, this._points.size.getLimit());
            if (this.containsAbsBBox(data.x, data.y, data.width + threshold, data.height + threshold)) {
                return this._points.calcHitPointAbs(data.x, data.y, data.strokeWidth, data.strokeScale, data.strokeAlign, threshold, toRange, tester || this._tester, result);
            }
            return false;
        };
        return EShapeLineOfTriangles;
    }(EShapeTriangle));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var deserializeLineOfTriangles = function (item, manager, shape) {
        return deserializeBase(item, manager, shape || new EShapeLineOfTriangles());
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadShapeLineOfTriangles = function () {
        EShapeUploadeds[EShapeType.LINE_OF_TRIANGLES] = createLineOfTrianglesUploaded;
        EShapeDeserializers[EShapeType.LINE_OF_TRIANGLES] = deserializeLineOfTriangles;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var createNullUploaded = function (buffer, shape, voffset, ioffset) {
        return new EShapeUploadedImpl(buffer, voffset, ioffset, 0, 0, [
            new BuilderNull(buffer, voffset, ioffset)
        ]).init(shape);
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeNull = /** @class */ (function (_super) {
        __extends(EShapeNull, _super);
        function EShapeNull(type) {
            if (type === void 0) { type = EShapeType.NULL; }
            return _super.call(this, type) || this;
        }
        EShapeNull.prototype.clone = function () {
            return new EShapeNull(this.type).copy(this);
        };
        return EShapeNull;
    }(EShapePrimitive));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var deserializeNull = function (item, manager, shape) {
        return deserializeBase(item, manager, shape || new EShapeNull());
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadShapeNull = function () {
        EShapeUploadeds[EShapeType.NULL] = createNullUploaded;
        EShapeDeserializers[EShapeType.NULL] = deserializeNull;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var deserializeRectangle = function (item, manager, shape) {
        return deserializeBase(item, manager, shape || new EShapeRectangle());
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadShapeRectangle = function () {
        EShapeUploadeds[EShapeType.RECTANGLE] = createRectangleUploaded;
        EShapeDeserializers[EShapeType.RECTANGLE] = deserializeRectangle;
        EShapeCapabilities.set(EShapeType.RECTANGLE, EShapeCapability.PRIMITIVE | EShapeCapability.STROKE_SIDE);
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var deserializeRectanglePivoted = function (item, manager, shape) {
        return deserializeBase(item, manager, shape || new EShapeRectanglePivoted());
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadShapeRectanglePivoted = function () {
        EShapeUploadeds[EShapeType.RECTANGLE_PIVOTED] = createRectanglePivotedUploaded;
        EShapeDeserializers[EShapeType.RECTANGLE_PIVOTED] = deserializeRectanglePivoted;
        EShapeCapabilities.set(EShapeType.RECTANGLE_PIVOTED, EShapeCapability.PRIMITIVE | EShapeCapability.STROKE_SIDE);
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var deserializeRectangleRounded = function (item, manager, shape) {
        return deserializeBase(item, manager, shape || new EShapeRectangleRounded());
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadShapeRectangleRounded = function () {
        EShapeUploadeds[EShapeType.RECTANGLE_ROUNDED] = createRectangleRoundedUploaded;
        EShapeDeserializers[EShapeType.RECTANGLE_ROUNDED] = deserializeRectangleRounded;
        EShapeCapabilities.set(EShapeType.RECTANGLE_ROUNDED, EShapeCapability.PRIMITIVE | EShapeCapability.STROKE_SIDE | EShapeCapability.BORDER_RADIUS);
    };

    var SEMICIRCLE_VERTEX_COUNT = 6;
    var SEMICIRCLE_INDEX_COUNT = 4;
    var SEMICIRCLE_WORLD_SIZE = [0, 0];
    var SEMICIRCLE_WORK_POINT = new pixi_js.Point();
    var buildSemicircleIndex = function (indices, voffset, ioffset) {
        var ii = ioffset * 3 - 1;
        indices[++ii] = voffset;
        indices[++ii] = voffset + 1;
        indices[++ii] = voffset + 3;
        indices[++ii] = voffset + 1;
        indices[++ii] = voffset + 4;
        indices[++ii] = voffset + 3;
        indices[++ii] = voffset + 1;
        indices[++ii] = voffset + 2;
        indices[++ii] = voffset + 4;
        indices[++ii] = voffset + 2;
        indices[++ii] = voffset + 5;
        indices[++ii] = voffset + 4;
    };
    var buildSemicircleVertex = function (vertices, voffset, originX, originY, sizeX, sizeY, strokeAlign, strokeWidth, internalTransform, worldSize) {
        // Calculate the transformed positions
        //
        //  0       1       2
        // |-------|-------|
        // |3      |4      |5
        // |-------|-------|
        //
        var work = SEMICIRCLE_WORK_POINT;
        var s = strokeAlign * strokeWidth;
        var sx = sizeX * 0.5 + (0 <= sizeX ? +s : -s);
        var sy = sizeY * 0.5 + (0 <= sizeY ? +s : -s);
        work.set(-sx + originX, -sy + originY);
        internalTransform.apply(work, work);
        var x0 = work.x;
        var y0 = work.y;
        work.set(0 + originX, -sy + originY);
        internalTransform.apply(work, work);
        var x1 = work.x;
        var y1 = work.y;
        var dx = x1 - x0;
        var dy = y1 - y0;
        work.set(originX, originY);
        internalTransform.apply(work, work);
        var x4 = work.x;
        var y4 = work.y;
        var x3 = x4 - dx;
        var y3 = y4 - dy;
        // Vertices
        var iv = voffset * 2 - 1;
        vertices[++iv] = x0;
        vertices[++iv] = y0;
        vertices[++iv] = x1;
        vertices[++iv] = y1;
        vertices[++iv] = x1 + dx;
        vertices[++iv] = y1 + dy;
        vertices[++iv] = x3;
        vertices[++iv] = y3;
        vertices[++iv] = x4;
        vertices[++iv] = y4;
        vertices[++iv] = x4 + dx;
        vertices[++iv] = y4 + dy;
        worldSize[0] = toLength(x0, y0, x1, y1);
        worldSize[1] = toLength(x0, y0, x3, y3);
    };
    var buildSemicircleStep = function (steps, voffset, strokeWidth, strokeStyle, worldSize) {
        var scaleInvariant = toScaleInvariant(strokeStyle);
        var ws0 = worldSize[0];
        var ws1 = worldSize[1];
        var e = toPackedI4x64(1, scaleInvariant, 1, 1);
        var c11 = toPackedF2x1024(1, 1);
        var c01 = toPackedF2x1024(0, 1);
        var c10 = toPackedF2x1024(1, 0);
        var c00 = toPackedF2x1024(0, 0);
        var is = voffset * 6 - 1;
        steps[++is] = strokeWidth;
        steps[++is] = e;
        steps[++is] = ws0;
        steps[++is] = ws1;
        steps[++is] = c11;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = e;
        steps[++is] = ws0;
        steps[++is] = ws1;
        steps[++is] = c01;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = e;
        steps[++is] = ws0;
        steps[++is] = ws1;
        steps[++is] = c11;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = e;
        steps[++is] = ws0;
        steps[++is] = ws1;
        steps[++is] = c10;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = e;
        steps[++is] = ws0;
        steps[++is] = ws1;
        steps[++is] = c00;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = e;
        steps[++is] = ws0;
        steps[++is] = ws1;
        steps[++is] = c10;
        steps[++is] = 0;
    };
    var buildSemicircleUv = function (uvs, voffset, textureUvs) {
        var x0 = textureUvs.x0;
        var x1 = textureUvs.x1;
        var x2 = textureUvs.x2;
        var x3 = textureUvs.x3;
        var y0 = textureUvs.y0;
        var y1 = textureUvs.y1;
        var y2 = textureUvs.y2;
        var y3 = textureUvs.y3;
        // UVs
        var iuv = voffset * 2 - 1;
        uvs[++iuv] = x0;
        uvs[++iuv] = y0;
        uvs[++iuv] = 0.5 * (x0 + x1);
        uvs[++iuv] = 0.5 * (y0 + y1);
        uvs[++iuv] = x1;
        uvs[++iuv] = y1;
        uvs[++iuv] = 0.5 * (x0 + x3);
        uvs[++iuv] = 0.5 * (y0 + y3);
        uvs[++iuv] = 0.5 * (x0 + x2);
        uvs[++iuv] = 0.5 * (y0 + y2);
        uvs[++iuv] = 0.5 * (x1 + x2);
        uvs[++iuv] = 0.5 * (y1 + y2);
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var BuilderSemicircle = /** @class */ (function (_super) {
        __extends(BuilderSemicircle, _super);
        function BuilderSemicircle(buffer, vertexOffset, indexOffset) {
            return _super.call(this, buffer, vertexOffset, indexOffset, SEMICIRCLE_VERTEX_COUNT, SEMICIRCLE_INDEX_COUNT) || this;
        }
        BuilderSemicircle.prototype.init = function () {
            var buffer = this.buffer;
            buffer.updateIndices();
            var voffset = this.vertexOffset;
            buildSemicircleIndex(buffer.indices, voffset, this.indexOffset);
            this.inited |= BuilderFlag.INDEX;
        };
        BuilderSemicircle.prototype.update = function (shape) {
            var buffer = this.buffer;
            this.updateVertexAndStep(buffer, shape);
            this.updateColor(buffer, shape);
            this.updateUv(buffer, shape);
        };
        BuilderSemicircle.prototype.updateVertexAndStep = function (buffer, shape) {
            var size = shape.size;
            var sizeX = size.x;
            var sizeY = size.y;
            var isSizeChanged = sizeX !== this.sizeX || sizeY !== this.sizeY;
            var transformLocalId = toTransformLocalId(shape);
            var isTransformChanged = this.transformLocalId !== transformLocalId;
            var stroke = shape.stroke;
            var strokeAlign = stroke.align;
            var strokeWidth = stroke.enable ? stroke.width : 0;
            var strokeStyle = stroke.style;
            var isStrokeChanged = this.strokeAlign !== strokeAlign ||
                this.strokeWidth !== strokeWidth ||
                this.strokeStyle !== strokeStyle;
            var isNotInited = !(this.inited & BuilderFlag.VERTEX_AND_STEP);
            if (isNotInited || isSizeChanged || isTransformChanged || isStrokeChanged) {
                this.inited |= BuilderFlag.VERTEX_AND_STEP;
                this.sizeX = sizeX;
                this.sizeY = sizeY;
                this.transformLocalId = transformLocalId;
                this.strokeAlign = strokeAlign;
                this.strokeWidth = strokeWidth;
                this.strokeStyle = strokeStyle;
                // Buffer
                buffer.updateVertices();
                buffer.updateSteps();
                buildSemicircleVertex(buffer.vertices, this.vertexOffset, 0, 0, sizeX, sizeY, strokeAlign, strokeWidth, shape.transform.internalTransform, SEMICIRCLE_WORLD_SIZE);
                buildSemicircleStep(buffer.steps, this.vertexOffset, strokeWidth, strokeStyle, SEMICIRCLE_WORLD_SIZE);
            }
        };
        BuilderSemicircle.prototype.updateUv = function (buffer, shape) {
            var texture = toTexture(shape);
            var textureTransformId = toTextureTransformId(texture);
            var isNotInited = !(this.inited & BuilderFlag.UV);
            if (isNotInited ||
                texture !== this.texture ||
                textureTransformId !== this.textureTransformId) {
                this.inited |= BuilderFlag.UV;
                this.texture = texture;
                this.textureTransformId = textureTransformId;
                buffer.updateUvs();
                var textureUvs = toTextureUvs(texture);
                buildSemicircleUv(buffer.uvs, this.vertexOffset, textureUvs);
            }
        };
        return BuilderSemicircle;
    }(BuilderBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var createSemicircleUploaded = function (buffer, shape, voffset, ioffset, antialiasWeight) {
        var tcount = toTextBufferCount(shape);
        var tvcount = tcount << TEXT_VERTEX_COUNT_SHIFT;
        var ticount = tcount << TEXT_INDEX_COUNT_SHIFT;
        var vcount = SEMICIRCLE_VERTEX_COUNT + tvcount;
        var icount = SEMICIRCLE_INDEX_COUNT + ticount;
        if (buffer.check(voffset, ioffset, vcount, icount)) {
            return new EShapeUploadedImpl(buffer, voffset, ioffset, vcount, icount, [
                new BuilderSemicircle(buffer, voffset, ioffset),
                new BuilderText(buffer, voffset + SEMICIRCLE_VERTEX_COUNT, ioffset + SEMICIRCLE_INDEX_COUNT, tvcount, ticount)
            ]).init(shape);
        }
        return null;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var hitTestSemicircle = function (shape, x, y, ax, ay, sw, ss) {
        if (y <= 0) {
            return hitTestCircle(shape, x, y, ax, ay, sw, ss);
        }
        return false;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A semicircle shape.
     *
     * @beta
     */
    var EShapeSemicircle = /** @class */ (function (_super) {
        __extends(EShapeSemicircle, _super);
        function EShapeSemicircle(type) {
            if (type === void 0) { type = EShapeType.SEMICIRCLE; }
            var _this = _super.call(this, type) || this;
            _this.stroke.side = EShapeStrokeSide.ALL & ~EShapeStrokeSide.BOTTOM;
            return _this;
        }
        EShapeSemicircle.prototype.clone = function () {
            return new EShapeSemicircle(this.type).copy(this);
        };
        EShapeSemicircle.prototype.containsAbs = function (x, y, ax, ay, sw, ss, sa) {
            if (_super.prototype.containsAbsBBox.call(this, x, y, ax, ay)) {
                return hitTestSemicircle(this, x, y, ax, ay, sw, ss);
            }
            return false;
        };
        return EShapeSemicircle;
    }(EShapePrimitive));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var deserializeSemicircle = function (item, manager, shape) {
        return deserializeBase(item, manager, shape || new EShapeSemicircle());
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadShapeSemicircle = function () {
        EShapeUploadeds[EShapeType.SEMICIRCLE] = createSemicircleUploaded;
        EShapeDeserializers[EShapeType.SEMICIRCLE] = deserializeSemicircle;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var BuilderTriangle = /** @class */ (function (_super) {
        __extends(BuilderTriangle, _super);
        function BuilderTriangle(buffer, vertexOffset, indexOffset) {
            return _super.call(this, buffer, vertexOffset, indexOffset, TRIANGLE_VERTEX_COUNT, TRIANGLE_INDEX_COUNT) || this;
        }
        BuilderTriangle.prototype.init = function () {
            var buffer = this.buffer;
            buffer.updateIndices();
            buildTriangleIndex(buffer.indices, this.vertexOffset, this.indexOffset);
            this.inited |= BuilderFlag.INDEX;
        };
        BuilderTriangle.prototype.update = function (shape) {
            var buffer = this.buffer;
            this.updateVertexStepAndUv(buffer, shape);
            this.updateColor(buffer, shape);
        };
        BuilderTriangle.prototype.updateVertexStepAndUv = function (buffer, shape) {
            var size = shape.size;
            var sizeX = size.x;
            var sizeY = size.y;
            var isSizeChanged = sizeX !== this.sizeX || sizeY !== this.sizeY;
            var transformLocalId = toTransformLocalId(shape);
            var isTransformChanged = this.transformLocalId !== transformLocalId;
            var stroke = shape.stroke;
            var strokeAlign = stroke.align;
            var strokeWidth = stroke.enable ? stroke.width : 0;
            var strokeStyle = stroke.style;
            var isStrokeChanged = this.strokeAlign !== strokeAlign ||
                this.strokeWidth !== strokeWidth ||
                this.strokeStyle !== strokeStyle;
            var texture = toTexture(shape);
            var textureTransformId = toTextureTransformId(texture);
            var isTextureChanged = texture !== this.texture || textureTransformId !== this.textureTransformId;
            var isVertexChanged = isSizeChanged || isStrokeChanged;
            var isNotInited = !(this.inited & BuilderFlag.VERTEX_STEP_AND_UV);
            if (isNotInited || isVertexChanged || isTransformChanged || isTextureChanged) {
                this.inited |= BuilderFlag.VERTEX_STEP_AND_UV;
                this.sizeX = sizeX;
                this.sizeY = sizeY;
                this.transformLocalId = transformLocalId;
                this.strokeAlign = strokeAlign;
                this.strokeWidth = strokeWidth;
                this.strokeStyle = strokeStyle;
                this.texture = texture;
                this.textureTransformId = textureTransformId;
                var voffset = this.vertexOffset;
                buffer.updateVertices();
                buildTriangleVertex(buffer.vertices, voffset, 0, 0, sizeX, sizeY, strokeAlign, strokeWidth, shape.transform.internalTransform, TRIANGLE_WORLD_SIZE);
                if (isNotInited || isVertexChanged || isTransformChanged) {
                    buffer.updateSteps();
                    buildTriangleStep(buffer.steps, voffset, strokeWidth, strokeStyle, TRIANGLE_WORLD_SIZE);
                }
                if (isNotInited || isVertexChanged || isTextureChanged) {
                    buffer.updateUvs();
                    buildTriangleUv(buffer.uvs, toTextureUvs(texture), voffset, TRIANGLE_WORLD_SIZE);
                }
            }
        };
        return BuilderTriangle;
    }(BuilderBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var createTriangleUploaded = function (buffer, shape, voffset, ioffset, antialiasWeight) {
        var tcount = toTextBufferCount(shape);
        var tvcount = tcount << TEXT_VERTEX_COUNT_SHIFT;
        var ticount = tcount << TEXT_INDEX_COUNT_SHIFT;
        var vcount = TRIANGLE_VERTEX_COUNT + tvcount;
        var icount = TRIANGLE_INDEX_COUNT + ticount;
        if (buffer.check(voffset, ioffset, vcount, icount)) {
            return new EShapeUploadedImpl(buffer, voffset, ioffset, vcount, icount, [
                new BuilderTriangle(buffer, voffset, ioffset),
                new BuilderText(buffer, voffset + TRIANGLE_VERTEX_COUNT, ioffset + TRIANGLE_INDEX_COUNT, tvcount, ticount)
            ]).init(shape);
        }
        return null;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var deserializeTriangle = function (item, manager, shape) {
        return deserializeBase(item, manager, shape || new EShapeTriangle());
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadShapeTriangle = function () {
        EShapeUploadeds[EShapeType.TRIANGLE] = createTriangleUploaded;
        EShapeDeserializers[EShapeType.TRIANGLE] = deserializeTriangle;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var BuilderTriangleRounded = /** @class */ (function (_super) {
        __extends(BuilderTriangleRounded, _super);
        function BuilderTriangleRounded(buffer, vertexOffset, indexOffset) {
            var _this = _super.call(this, buffer, vertexOffset, indexOffset, TRIANGLE_ROUNDED_VERTEX_COUNT, TRIANGLE_ROUNDED_INDEX_COUNT) || this;
            _this.radius = 0;
            _this.corner = 0;
            return _this;
        }
        BuilderTriangleRounded.prototype.init = function () {
            var buffer = this.buffer;
            buffer.updateIndices();
            buildTriangleRoundedIndex(buffer.indices, this.vertexOffset, this.indexOffset);
            this.inited |= BuilderFlag.INDEX;
        };
        BuilderTriangleRounded.prototype.update = function (shape) {
            var buffer = this.buffer;
            this.updateVertexStepAndUv(buffer, shape);
            this.updateColor(buffer, shape);
        };
        BuilderTriangleRounded.prototype.updateVertexStepAndUv = function (buffer, shape) {
            var size = shape.size;
            var sizeX = size.x;
            var sizeY = size.y;
            var isSizeChanged = sizeX !== this.sizeX || sizeY !== this.sizeY;
            var radius = shape.radius;
            var isRadiusChanged = radius !== this.radius;
            var transformLocalId = toTransformLocalId(shape);
            var isTransformChanged = this.transformLocalId !== transformLocalId;
            var stroke = shape.stroke;
            var strokeAlign = stroke.align;
            var strokeWidth = stroke.enable ? stroke.width : 0;
            var strokeStyle = stroke.style;
            var isStrokeChanged = this.strokeAlign !== strokeAlign ||
                this.strokeWidth !== strokeWidth ||
                this.strokeStyle !== strokeStyle;
            var corner = shape.corner;
            var isCornerChanged = corner !== this.corner;
            var texture = toTexture(shape);
            var textureTransformId = toTextureTransformId(texture);
            var isTextureChanged = texture !== this.texture || textureTransformId !== this.textureTransformId;
            var isVertexChanged = isSizeChanged || isRadiusChanged || isStrokeChanged;
            var isNotInited = !(this.inited & BuilderFlag.VERTEX_STEP_AND_UV);
            if (isNotInited ||
                isVertexChanged ||
                isTransformChanged ||
                isCornerChanged ||
                isTextureChanged) {
                this.inited |= BuilderFlag.VERTEX_STEP_AND_UV;
                this.sizeX = sizeX;
                this.sizeY = sizeY;
                this.radius = radius;
                this.transformLocalId = transformLocalId;
                this.strokeAlign = strokeAlign;
                this.strokeWidth = strokeWidth;
                this.strokeStyle = strokeStyle;
                this.corner = corner;
                this.texture = texture;
                this.textureTransformId = textureTransformId;
                var voffset = this.vertexOffset;
                buffer.updateVertices();
                buildTriangleRoundedVertex(buffer.vertices, voffset, 0, 0, sizeX, sizeY, strokeAlign, strokeWidth, radius, shape.transform.internalTransform, TRIANGLE_ROUNDED_WORLD_SIZE);
                if (isNotInited || isVertexChanged || isTransformChanged || isCornerChanged) {
                    buffer.updateSteps();
                    buildTriangleRoundedStep(buffer.steps, voffset, strokeWidth, strokeStyle, corner, radius, TRIANGLE_ROUNDED_WORLD_SIZE);
                }
                if (isNotInited || isVertexChanged || isTextureChanged) {
                    buffer.updateUvs();
                    buildTriangleRoundedUv(buffer.uvs, voffset, toTextureUvs(texture), radius, TRIANGLE_ROUNDED_WORLD_SIZE);
                }
            }
        };
        return BuilderTriangleRounded;
    }(BuilderBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var createTriangleRoundedUploaded = function (buffer, shape, voffset, ioffset, antialiasWeight) {
        var tcount = toTextBufferCount(shape);
        var tvcount = tcount << TEXT_VERTEX_COUNT_SHIFT;
        var ticount = tcount << TEXT_INDEX_COUNT_SHIFT;
        var vcount = TRIANGLE_ROUNDED_VERTEX_COUNT + tvcount;
        var icount = TRIANGLE_ROUNDED_INDEX_COUNT + ticount;
        if (buffer.check(voffset, ioffset, vcount, icount)) {
            return new EShapeUploadedImpl(buffer, voffset, ioffset, vcount, icount, [
                new BuilderTriangleRounded(buffer, voffset, ioffset),
                new BuilderText(buffer, voffset + TRIANGLE_ROUNDED_VERTEX_COUNT, ioffset + TRIANGLE_ROUNDED_INDEX_COUNT, tvcount, ticount)
            ]).init(shape);
        }
        return null;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var deserializeTriangleRounded = function (item, manager, shape) {
        return deserializeBase(item, manager, shape || new EShapeTriangleRounded());
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadShapeTriangleRounded = function () {
        EShapeUploadeds[EShapeType.TRIANGLE_ROUNDED] = createTriangleRoundedUploaded;
        EShapeDeserializers[EShapeType.TRIANGLE_ROUNDED] = deserializeTriangleRounded;
        EShapeCapabilities.set(EShapeType.TRIANGLE_ROUNDED, EShapeCapability.PRIMITIVE | EShapeCapability.STROKE_SIDE | EShapeCapability.BORDER_RADIUS);
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadShapeAll = function () {
        loadShapeBar();
        loadShapeButton();
        loadShapeCircle();
        loadShapeConnectorElbow();
        loadShapeConnectorLine();
        loadShapeEmbedded();
        loadShapeGroupShadowed();
        loadShapeGroup();
        loadShapeImage();
        loadShapeImageSdf();
        loadShapeLabel();
        loadShapeLine();
        loadShapeNull();
        loadShapeRectanglePivoted();
        loadShapeRectangleRounded();
        loadShapeRectangle();
        loadShapeSemicircle();
        loadShapeTriangleRounded();
        loadShapeTriangle();
        loadShapeLineOfCircles();
        loadShapeLineOfRectangleRoundeds();
        loadShapeLineOfRectangles();
        loadShapeLineOfTriangleRoundeds();
        loadShapeLineOfTriangles();
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DImage = /** @class */ (function (_super) {
        __extends(DImage, _super);
        function DImage() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DImage.prototype.getType = function () {
            return "DImage";
        };
        return DImage;
    }(DImageBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuItemBase = /** @class */ (function (_super) {
        __extends(DMenuItemBase, _super);
        function DMenuItemBase(options) {
            var _a;
            var _this = _super.call(this, options) || this;
            _this._value = (_a = options === null || options === void 0 ? void 0 : options.value) !== null && _a !== void 0 ? _a : null;
            return _this;
        }
        DMenuItemBase.prototype.init = function (options) {
            var _this = this;
            _super.prototype.init.call(this, options);
            this.on(UtilPointerEvent.tap, function (e) {
                _this.onClick(e);
            });
        };
        DMenuItemBase.prototype.onClick = function (e) {
            if (this.state.isActionable) {
                this.activate(e);
            }
        };
        DMenuItemBase.prototype.activate = function (e) {
            this.onSelect(e);
        };
        Object.defineProperty(DMenuItemBase.prototype, "value", {
            get: function () {
                return this._value;
            },
            set: function (value) {
                this._value = value;
            },
            enumerable: false,
            configurable: true
        });
        DMenuItemBase.prototype.hasSelection = function (target) {
            return target && target.selection && target.selection.add;
        };
        DMenuItemBase.prototype.getSelection = function () {
            var parent = this.parent;
            while (parent) {
                if (this.hasSelection(parent)) {
                    return parent.selection;
                }
                parent = parent.parent;
            }
            return null;
        };
        DMenuItemBase.prototype.onSelect = function (e) {
            this.emit("select", this._value, this);
            var selection = this.getSelection();
            if (selection) {
                selection.add(this);
            }
        };
        DMenuItemBase.prototype.onKeyDown = function (e) {
            if (UtilKeyboardEvent.isActivateKey(e)) {
                this.onKeyDownActivate(e);
            }
            return _super.prototype.onKeyDown.call(this, e);
        };
        DMenuItemBase.prototype.onKeyDownActivate = function (e) {
            if (this.state.isActionable && this.state.isFocused) {
                this.activate(e);
                return true;
            }
            return false;
        };
        DMenuItemBase.prototype.getType = function () {
            return "DMenuItemBase";
        };
        return DMenuItemBase;
    }(DImage));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuItem = /** @class */ (function (_super) {
        __extends(DMenuItem, _super);
        function DMenuItem() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuItem.prototype.getContext = function () {
            var parent = this.parent;
            while (parent) {
                if (parent.getContext) {
                    return parent.getContext();
                }
                parent = parent.parent;
            }
            return null;
        };
        DMenuItem.prototype.getCloseable = function () {
            var parent = this.parent;
            while (parent) {
                if (parent.getCloseable) {
                    return parent.getCloseable();
                }
                parent = parent.parent;
            }
            return null;
        };
        DMenuItem.prototype.getType = function () {
            return "DMenuItem";
        };
        return DMenuItem;
    }(DMenuItemBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuItemText = /** @class */ (function (_super) {
        __extends(DMenuItemText, _super);
        function DMenuItemText() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuItemText.prototype.init = function (options) {
            _super.prototype.init.call(this, options);
            this.initOnOver(options);
            this.initShortcuts(options);
        };
        DMenuItemText.prototype.initOnOver = function (options) {
            var _this = this;
            this.on(UtilPointerEvent.over, function () {
                var context = _this.getContext();
                if (context != null) {
                    var parent_1 = _this.parent;
                    if (parent_1 instanceof DBase) {
                        context.trim(_this.getCloseable());
                    }
                }
            });
        };
        DMenuItemText.prototype.initShortcuts = function (options) {
            var shortcuts = this._shortcuts;
            if (shortcuts != null && 0 < shortcuts.length) {
                var shortcut = shortcuts[0];
                var shortcutText = this.newShortcutText();
                this._shortcutText = shortcutText;
                this.snippet.add(shortcutText, true);
                shortcutText.text = UtilKeyboardEvent.toString(shortcut);
            }
            else {
                this._shortcutText = null;
            }
            this._shortcutMargin = this.theme.getShortcutTextMargin();
        };
        DMenuItemText.prototype.newShortcutText = function () {
            var _a, _b;
            return new DDynamicText(new DDynamicTextStyle(this, this.theme, (_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.text) === null || _b === void 0 ? void 0 : _b.style));
        };
        DMenuItemText.prototype.updateShortcutText = function () {
            var text = this._shortcutText;
            var margin = this._shortcutMargin;
            if (text != null && margin != null) {
                var auto = this._auto;
                var textX = 0;
                if (auto.width.isOn) {
                    textX = margin;
                }
                else {
                    textX = this.width - text.width - margin;
                }
                var textY = 0;
                var padding = this._padding;
                var ptop = padding.getTop();
                if (auto.height.isOn) {
                    textY = ptop;
                }
                else {
                    textY = ptop + (this.height - ptop - padding.getBottom() - text.height) * 0.5;
                }
                text.position.set(textX, textY);
            }
        };
        DMenuItemText.prototype.updateShortcutColor = function () {
            var shortcutText = this._shortcutText;
            if (shortcutText != null) {
                var theme = this.theme;
                var state = this.state;
                shortcutText.style.fill = theme.getShortcutColor(state);
                shortcutText.alpha = theme.getShortcutAlpha(state);
            }
        };
        DMenuItemText.prototype.onReflow = function () {
            _super.prototype.onReflow.call(this);
            this.updateShortcutColor();
            this.updateShortcutText();
        };
        DMenuItemText.prototype.getType = function () {
            return "DMenuItemText";
        };
        DMenuItemText.prototype.onSelect = function (e) {
            _super.prototype.onSelect.call(this, e);
            var closeable = this.getCloseable();
            if (closeable != null) {
                closeable.emit("select", this.value, this, closeable);
            }
        };
        DMenuItemText.prototype.onShortcut = function (e) {
            _super.prototype.onShortcut.call(this, e);
            this.activate(e);
        };
        return DMenuItemText;
    }(DMenuItem));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuItemCheck = /** @class */ (function (_super) {
        __extends(DMenuItemCheck, _super);
        function DMenuItemCheck() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuItemCheck.prototype.init = function (options) {
            _super.prototype.init.call(this, options);
            if (options === null || options === void 0 ? void 0 : options.check) {
                this.state.isActive = true;
            }
        };
        DMenuItemCheck.prototype.getType = function () {
            return "DMenuItemCheck";
        };
        DMenuItemCheck.prototype.onSelect = function (e) {
            this.state.isActive = !this.state.isActive;
            _super.prototype.onSelect.call(this, e);
        };
        return DMenuItemCheck;
    }(DMenuItemText));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuItemCheckIsCompatible = function (options) {
        return "check" in options;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DLinkMenuItemId = {
        OPEN_LINK: 0,
        OPEN_LINK_IN_NEW_WINDOW: 1,
        COPY_LINK_ADDRESS: 2
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenus = /** @class */ (function () {
        function DMenus() {
        }
        DMenus.addItemCreator = function (creator) {
            this.CREATORS.push(creator);
        };
        DMenus.setItemCreatorDefault = function (creator) {
            this.CREATOR_DEFAULT = creator;
        };
        DMenus.setMenuCreator = function (creator) {
            this.MENU_CREATOR = creator;
        };
        DMenus.newItemOf = function (creators, creatorDefault, options, sticky) {
            for (var i = 0, imax = creators.length; i < imax; ++i) {
                var created = creators[i](options, sticky);
                if (created != null) {
                    return created;
                }
            }
            if (creatorDefault) {
                return creatorDefault(options, sticky);
            }
            return null;
        };
        DMenus.newItem = function (options, sticky) {
            return this.newItemOf(this.CREATORS, this.CREATOR_DEFAULT, options, sticky);
        };
        DMenus.newItemsOf = function (creator, parent, items, sticky) {
            for (var i = 0, imax = items.length; i < imax; ++i) {
                var item = items[i];
                if (item instanceof pixi_js.DisplayObject) {
                    parent.addChild(item);
                }
                else if (item != null) {
                    var created = creator.newItem(item, sticky);
                    if (created != null) {
                        parent.addChild(created);
                    }
                    else {
                        throw new Error("No matching menu item creator found: ".concat(JSON.stringify(item)));
                    }
                }
            }
        };
        DMenus.newItems = function (parent, items, sticky) {
            this.newItemsOf(this, parent, items, sticky);
        };
        DMenus.newMenu = function (options) {
            if (this.MENU_CREATOR != null) {
                return this.MENU_CREATOR(options);
            }
            else {
                throw new Error("Missing DMenu creator.");
            }
        };
        DMenus.CREATORS = [];
        DMenus.CREATOR_DEFAULT = null;
        return DMenus;
    }());

    /*
     * Copyright (C) 2021 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DLinkMenu = /** @class */ (function () {
        function DLinkMenu(parent, options) {
            this._parent = parent;
            this._options = options;
            this._isEnabled = true;
        }
        Object.defineProperty(DLinkMenu.prototype, "enable", {
            get: function () {
                return this._isEnabled;
            },
            set: function (enable) {
                this._isEnabled = enable;
            },
            enumerable: false,
            configurable: true
        });
        DLinkMenu.prototype.open = function (target) {
            this.get().open(target);
        };
        DLinkMenu.prototype.get = function () {
            var _this = this;
            var result = this._menu;
            if (result == null) {
                result = this.toMenu(this._options);
                this._menu = result;
                result.on("select", function (value, item, menu) {
                    _this.onSelect(value, item, menu);
                });
            }
            return result;
        };
        DLinkMenu.prototype.toMenu = function (options) {
            if (options instanceof pixi_js.DisplayObject) {
                return options;
            }
            return this.newMenu(options);
        };
        DLinkMenu.prototype.newMenu = function (options) {
            return DMenus.newMenu(options);
        };
        DLinkMenu.prototype.onSelect = function (value, item, menu) {
            var parent = this._parent;
            switch (value) {
                case DLinkMenuItemId.OPEN_LINK:
                    parent.open(false);
                    break;
                case DLinkMenuItemId.OPEN_LINK_IN_NEW_WINDOW:
                    parent.open(true);
                    break;
                case DLinkMenuItemId.COPY_LINK_ADDRESS:
                    parent.copy();
                    break;
            }
        };
        return DLinkMenu;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DLinkTarget = {
        AUTO: 0,
        THIS_WINDOW: 1,
        NEW_WINDOW: 2
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var getSelection = function (element) {
        var selection = document.getSelection();
        if (selection) {
            var range = document.createRange();
            range.selectNodeContents(element);
            selection.removeAllRanges();
            selection.addRange(range);
        }
        return selection;
    };
    var toClipboardData = function (e) {
        return e.clipboardData || window.clipboardData;
    };
    var copyUsingDiv = function (text) {
        var div = document.createElement("div");
        div.setAttribute("style", "-webkit-user-select: text !important");
        div.textContent = "Dummy";
        document.body.appendChild(div);
        var selection = getSelection(div);
        var result = false;
        if (selection) {
            var handler = function (e) {
                if (e.target === div) {
                    var clipboardData = toClipboardData(e);
                    clipboardData.setData("text/plain", text);
                    result = clipboardData.getData("text/plain") === text;
                    e.preventDefault();
                }
            };
            document.addEventListener("copy", handler);
            try {
                document.execCommand("copy");
            }
            finally {
                document.removeEventListener("copy", handler);
            }
            selection.removeAllRanges();
        }
        document.body.removeChild(div);
        return result;
    };
    var copyUsingSpan = function (text) {
        var div = document.createElement("div");
        div.setAttribute("style", "-webkit-user-select: text !important");
        var span = document.createElement("span");
        span.innerText = text;
        var root = div.attachShadow ? div.attachShadow({ mode: "open" }) : div;
        root.appendChild(span);
        document.body.appendChild(div);
        var result = false;
        var selection = getSelection(div);
        if (selection) {
            result = document.execCommand("copy");
            selection.removeAllRanges();
        }
        document.body.removeChild(div);
        return result;
    };
    var copyUsingWindow = function (window, text) {
        if (typeof ClipboardEvent === "undefined") {
            var clipboardData = window.clipboardData;
            if (typeof clipboardData !== "undefined" && typeof clipboardData.setData !== "undefined") {
                clipboardData.setData("Text", text);
                return true;
            }
        }
        return false;
    };
    var UtilClipboard = /** @class */ (function (_super) {
        __extends(UtilClipboard, _super);
        function UtilClipboard() {
            var _this = _super.call(this) || this;
            var element = document.body;
            element.addEventListener("copy", function (e) {
                if (e.target === element) {
                    e.preventDefault();
                    e.stopPropagation();
                    _this.emit("copy", toClipboardData(e));
                }
            });
            element.addEventListener("cut", function (e) {
                if (e.target === element) {
                    e.preventDefault();
                    e.stopPropagation();
                    _this.emit("cut", toClipboardData(e));
                }
            });
            element.addEventListener("paste", function (e) {
                if (e.target === element) {
                    e.preventDefault();
                    e.stopPropagation();
                    _this.emit("paste", toClipboardData(e));
                }
            });
            return _this;
        }
        UtilClipboard.copy = function (text) {
            var clipboard = navigator.clipboard;
            if (clipboard && clipboard.writeText) {
                clipboard.writeText(text);
            }
            else {
                if (!copyUsingWindow(window, text)) {
                    if (!copyUsingDiv(text)) {
                        if (navigator.userAgent.indexOf("Edge") < 0) {
                            copyUsingSpan(text);
                        }
                    }
                }
            }
        };
        return UtilClipboard;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DLink = /** @class */ (function () {
        function DLink(options) {
            this._options = options;
            this._url = options === null || options === void 0 ? void 0 : options.url;
            this._target = this.toNormalizedTarget(options === null || options === void 0 ? void 0 : options.target);
            this._checker = options === null || options === void 0 ? void 0 : options.checker;
            this._isEnabled = true;
        }
        Object.defineProperty(DLink.prototype, "enable", {
            get: function () {
                return this._isEnabled;
            },
            set: function (enable) {
                this._isEnabled = enable;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DLink.prototype, "url", {
            get: function () {
                return this._url;
            },
            set: function (url) {
                this._url = url;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DLink.prototype, "target", {
            get: function () {
                return this._target;
            },
            set: function (target) {
                this._target = this.toNormalizedTarget(target);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DLink.prototype, "checker", {
            get: function () {
                return this._checker;
            },
            set: function (checker) {
                this._checker = checker;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DLink.prototype, "menu", {
            get: function () {
                var result = this._menu;
                if (result == null) {
                    result = this.newMenu();
                    this._menu = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DLink.prototype.newMenu = function () {
            var options = this._options;
            if (options) {
                var menu = options.menu;
                if (menu) {
                    return new DLinkMenu(this, menu);
                }
            }
            var result = DLink.MENU;
            if (result == null) {
                result = new DLinkMenu(this, DThemes.getInstance().get("DLink").getMenuOptions());
                DLink.MENU = result;
            }
            return result;
        };
        DLink.prototype.toStringifiedUrl = function (target, onResolved) {
            var url = isFunction(target) ? target() : target;
            if (url != null) {
                if (isString(url)) {
                    onResolved(url);
                }
                else {
                    url.then(function (resolved) {
                        if (resolved != null) {
                            onResolved(resolved);
                        }
                    });
                }
            }
        };
        DLink.prototype.toNormalizedUrl = function (url) {
            var a = DLink.ANCHOR_ELEMENT || document.createElement("a");
            DLink.ANCHOR_ELEMENT = a;
            a.href = url;
            return a.href;
        };
        DLink.prototype.toNormalizedTarget = function (target) {
            return toEnum(target !== null && target !== void 0 ? target : DLinkTarget.AUTO, DLinkTarget);
        };
        /**
         * Copys the URL to the clipboard.
         */
        DLink.prototype.copy = function () {
            var _this = this;
            this.toStringifiedUrl(this._url, function (url) {
                UtilClipboard.copy(_this.toNormalizedUrl(url));
            });
        };
        DLink.prototype.open = function (x) {
            var _this = this;
            this.toStringifiedUrl(this._url, function (url) {
                var inNewWindow = x === true || x === false ? x : _this.inNewWindow(x);
                _this.check(url, inNewWindow, function () {
                    _this.exec(url, inNewWindow);
                });
            });
        };
        DLink.prototype.check = function (url, inNewWindow, onResolved) {
            var checker = this._checker;
            if (checker) {
                var checked = checker();
                if (checked === true) {
                    onResolved();
                }
                else if (checked === false) ;
                else {
                    checked.then(function (resolved) {
                        if (resolved) {
                            onResolved();
                        }
                    });
                }
            }
            else {
                onResolved();
            }
        };
        /**
         * Opens the given URL.
         *
         * @param url An URL to be opened
         * @param inNewWindow True to open in a new window.
         */
        DLink.prototype.exec = function (url, inNewWindow) {
            if (inNewWindow) {
                var a_1 = document.createElement("a");
                a_1.href = url;
                a_1.target = "_blank";
                a_1.style.display = "none";
                a_1.rel = "noopener noreferrer";
                document.body.appendChild(a_1);
                a_1.click();
                setTimeout(function () {
                    document.body.removeChild(a_1);
                }, 100);
            }
            else {
                window.location.href = url;
            }
        };
        /**
         * Returns true if the URL need to be opened in a new window.
         *
         * @param e An event object.
         */
        DLink.prototype.inNewWindow = function (e) {
            switch (this._target) {
                case DLinkTarget.NEW_WINDOW:
                    return true;
                case DLinkTarget.THIS_WINDOW:
                    return false;
                case DLinkTarget.AUTO:
                    if (e != null) {
                        var oe = e instanceof pixi_js.InteractionEvent ? e.data.originalEvent : e;
                        return (oe.ctrlKey ||
                            oe.shiftKey ||
                            oe.altKey ||
                            oe.metaKey ||
                            ("button" in oe && oe.button !== 0));
                    }
                    return false;
            }
        };
        DLink.prototype.onClick = function (base, e) {
            if (this._target === DLinkTarget.AUTO) {
                var oe = e.data.originalEvent;
                if (("pointerType" in oe && oe.pointerType !== "mouse") || "touches" in oe) {
                    var menu = this.menu;
                    if (menu.enable) {
                        if (this._isEnabled && base.state.isActionable) {
                            menu.open(base);
                        }
                        return true;
                    }
                }
            }
            if (this._isEnabled) {
                return false;
            }
            return true;
        };
        return DLink;
    }());

    /*
     * Copyright (C) 2021 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DLinks = /** @class */ (function () {
        function DLinks() {
        }
        DLinks.toStateOptions = function (target, options) {
            if (options) {
                if (target === DLinkTarget.NEW_WINDOW || target === "NEW_WINDOW") {
                    var state = options.state;
                    if (state == null) {
                        options.state = DBaseState.NEW_WINDOW;
                    }
                    else if (isString(state)) {
                        if (state !== DBaseState.NEW_WINDOW) {
                            options.state = [state, DBaseState.NEW_WINDOW];
                        }
                    }
                    else if (isArray(state)) {
                        if (state.indexOf(DBaseState.NEW_WINDOW) < 0) {
                            state.push(DBaseState.NEW_WINDOW);
                        }
                    }
                    else {
                        var values = state.values;
                        if (values == null) {
                            state.values = DBaseState.NEW_WINDOW;
                        }
                        else if (isString(values)) {
                            if (values !== DBaseState.NEW_WINDOW) {
                                state.values = [values, DBaseState.NEW_WINDOW];
                            }
                        }
                        else {
                            if (values.indexOf(DBaseState.NEW_WINDOW) < 0) {
                                values.push(DBaseState.NEW_WINDOW);
                            }
                        }
                    }
                }
            }
            return options;
        };
        return DLinks;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuItemLink = /** @class */ (function (_super) {
        __extends(DMenuItemLink, _super);
        function DMenuItemLink() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuItemLink.prototype.toLinkOptions = function (options) {
            if (options) {
                return {
                    url: this.toUrl(options.url),
                    target: options.target,
                    checker: this.toChecker(options.checker),
                    menu: options.menu
                };
            }
            return undefined;
        };
        DMenuItemLink.prototype.toUrl = function (url) {
            var _this = this;
            if (isString(url) || url == null) {
                return url;
            }
            else {
                return function () {
                    return url(_this);
                };
            }
        };
        DMenuItemLink.prototype.toChecker = function (checker) {
            var _this = this;
            if (checker != null) {
                return function () {
                    return checker(_this);
                };
            }
            return undefined;
        };
        DMenuItemLink.prototype.init = function (options) {
            _super.prototype.init.call(this, DLinks.toStateOptions(options === null || options === void 0 ? void 0 : options.target, options));
        };
        Object.defineProperty(DMenuItemLink.prototype, "link", {
            get: function () {
                var result = this._link;
                if (result == null) {
                    result = new DLink(this.toLinkOptions(this._options));
                    this._link = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DMenuItemLink.prototype.onClick = function (e) {
            if (!this.link.onClick(this, e)) {
                _super.prototype.onClick.call(this, e);
            }
        };
        DMenuItemLink.prototype.getType = function () {
            return "DMenuItemLink";
        };
        DMenuItemLink.prototype.onSelect = function (e) {
            _super.prototype.onSelect.call(this, e);
            this.link.open(e);
        };
        DMenuItemLink.prototype.open = function (inNewWindow) {
            this.link.open(inNewWindow);
        };
        DMenuItemLink.prototype.onShortcut = function (e) {
            _super.prototype.onShortcut.call(this, e);
            this.activate(e);
        };
        return DMenuItemLink;
    }(DMenuItemText));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuItemLinkIsCompatible = function (options) {
        return "url" in options;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuItemMenu = /** @class */ (function (_super) {
        __extends(DMenuItemMenu, _super);
        function DMenuItemMenu() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuItemMenu.prototype.init = function (options) {
            _super.prototype.init.call(this, options);
            this.initHover(options);
        };
        DMenuItemMenu.prototype.initHover = function (options) {
            var _this = this;
            this.on(UtilPointerEvent.over, function () {
                if (_this.state.isActionable) {
                    _this.open();
                }
            });
        };
        DMenuItemMenu.prototype.toMenu = function (options) {
            var menu = options === null || options === void 0 ? void 0 : options.menu;
            if (menu instanceof pixi_js.DisplayObject) {
                return menu;
            }
            return this.newMenu(menu);
        };
        DMenuItemMenu.prototype.newMenu = function (options) {
            return DMenus.newMenu(options);
        };
        Object.defineProperty(DMenuItemMenu.prototype, "menu", {
            get: function () {
                var _this = this;
                var result = this._menu;
                if (result == null) {
                    result = this.toMenu(this._options);
                    result.on("select", function (value, item, menu) {
                        _this.onMenuSelect(value, item, menu);
                    });
                    this._menu = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DMenuItemMenu.prototype.getType = function () {
            return "DMenuItemMenu";
        };
        DMenuItemMenu.prototype.open = function () {
            var menu = this.menu;
            if (menu.isHidden()) {
                this.onOpen(menu);
            }
        };
        DMenuItemMenu.prototype.onOpen = function (menu) {
            var context = this.getContext();
            if (context != null) {
                menu.open(this, this.getCloseable(), context);
            }
        };
        DMenuItemMenu.prototype.close = function () {
            this.menu.close();
        };
        DMenuItemMenu.prototype.toggle = function () {
            var menu = this.menu;
            if (menu.isHidden()) {
                this.onOpen(menu);
            }
            else {
                menu.close();
            }
        };
        DMenuItemMenu.prototype.onSelect = function (e) {
            this.open();
            _super.prototype.onSelect.call(this, e);
        };
        DMenuItemMenu.prototype.onMenuSelect = function (value, item, menu) {
            var closeable = this.getCloseable();
            if (closeable != null) {
                closeable.emit("select", value, item, closeable);
            }
        };
        DMenuItemMenu.prototype.onKeyDown = function (e) {
            if (UtilKeyboardEvent.isArrowRightKey(e)) {
                this.onKeyDownArrowRight(e);
            }
            return _super.prototype.onKeyDown.call(this, e);
        };
        DMenuItemMenu.prototype.onKeyDownArrowRight = function (e) {
            if (this.state.isActionable && this.state.isFocused) {
                this.onSelect(e);
                return true;
            }
            return false;
        };
        return DMenuItemMenu;
    }(DMenuItem));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuItemMenuIsCompatible = function (options) {
        return "menu" in options;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuItemMenuToSubMenuOptions = function (options, sticky) {
        var menu = options.menu;
        if (!(menu instanceof pixi_js.DisplayObject)) {
            if (menu.sticky == null) {
                menu.sticky = sticky;
            }
            if (menu.align == null) {
                menu.align = UtilAttachAlign.RIGHT;
            }
        }
        return options;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuItemSeparatorReflowable = /** @class */ (function (_super) {
        __extends(DMenuItemSeparatorReflowable, _super);
        function DMenuItemSeparatorReflowable(base) {
            var _this = _super.call(this) || this;
            base.snippet.add(_this, true);
            base.reflowable.add(_this);
            return _this;
        }
        DMenuItemSeparatorReflowable.prototype.onReflow = function (base, width, height) {
            var state = base.state;
            var border = base.border;
            var borderWidth = border.getWidth(state);
            var borderColor = border.getColor(state);
            if (borderColor != null) {
                var borderAlpha = border.getAlpha(state);
                var borderAlign = border.getAlign(state);
                var padding = base.padding;
                var middle = height * 0.5;
                this.clear();
                this.lineStyle(borderWidth, borderColor, borderAlpha, borderAlign);
                this.moveTo(padding.getLeft(), middle);
                this.lineTo(width - padding.getRight(), middle);
                this.visible = true;
            }
            else {
                this.clear();
                this.visible = false;
            }
        };
        return DMenuItemSeparatorReflowable;
    }(pixi_js.Graphics));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuItemSeparatorIsCompatible = function (options) {
        return "separator" in options;
    };
    var DMenuItemSeparator = /** @class */ (function (_super) {
        __extends(DMenuItemSeparator, _super);
        function DMenuItemSeparator() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuItemSeparator.prototype.initReflowable = function () {
            new DMenuItemSeparatorReflowable(this);
        };
        DMenuItemSeparator.prototype.getType = function () {
            return "DMenuItemSeparator";
        };
        return DMenuItemSeparator;
    }(DMenuItemBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuItemSpace = /** @class */ (function (_super) {
        __extends(DMenuItemSpace, _super);
        function DMenuItemSpace() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuItemSpace.prototype.getType = function () {
            return "DMenuItemSpace";
        };
        return DMenuItemSpace;
    }(DLayoutSpace));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuItemSpaceIsCompatible = function (options) {
        return "space" in options;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadMenuItem = function () {
        DMenus.addItemCreator(function (options) {
            if (DMenuItemCheckIsCompatible(options)) {
                return new DMenuItemCheck(options);
            }
            return null;
        });
        DMenus.addItemCreator(function (options) {
            if (DMenuItemLinkIsCompatible(options)) {
                return new DMenuItemLink(options);
            }
            return null;
        });
        DMenus.addItemCreator(function (options, sticky) {
            if (DMenuItemMenuIsCompatible(options)) {
                return new DMenuItemMenu(DMenuItemMenuToSubMenuOptions(options, sticky));
            }
            return null;
        });
        DMenus.addItemCreator(function (options) {
            if (DMenuItemSeparatorIsCompatible(options)) {
                return new DMenuItemSeparator(options);
            }
            return null;
        });
        DMenus.addItemCreator(function (options) {
            if (DMenuItemSpaceIsCompatible(options)) {
                return new DMenuItemSpace(options);
            }
            return null;
        });
        DMenus.setItemCreatorDefault(function (options) {
            return new DMenuItemText(options);
        });
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuItemExpandableBody = /** @class */ (function (_super) {
        __extends(DMenuItemExpandableBody, _super);
        function DMenuItemExpandableBody() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuItemExpandableBody.prototype.getType = function () {
            return "DMenuItemExpandableBody";
        };
        return DMenuItemExpandableBody;
    }(DLayoutVertical));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuItemExpandableHeader = /** @class */ (function (_super) {
        __extends(DMenuItemExpandableHeader, _super);
        function DMenuItemExpandableHeader() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuItemExpandableHeader.prototype.getSelection = function () {
            return null;
        };
        DMenuItemExpandableHeader.prototype.getType = function () {
            return "DMenuItemExpandableHeader";
        };
        return DMenuItemExpandableHeader;
    }(DMenuItemBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuItemExpandables = /** @class */ (function () {
        function DMenuItemExpandables() {
        }
        DMenuItemExpandables.addItemCreator = function (creator) {
            this.CREATORS.push(creator);
        };
        DMenuItemExpandables.setItemCreatorDefault = function (creator) {
            this.CREATOR_DEFAULT = creator;
        };
        DMenuItemExpandables.newItem = function (options, sticky) {
            return (DMenus.newItemOf(this.CREATORS, this.CREATOR_DEFAULT, options, sticky) ||
                DMenus.newItem(options, sticky));
        };
        DMenuItemExpandables.newItems = function (parent, items, sticky) {
            DMenus.newItemsOf(this, parent, items, sticky);
        };
        DMenuItemExpandables.CREATORS = [];
        DMenuItemExpandables.CREATOR_DEFAULT = null;
        return DMenuItemExpandables;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuItemExpandable = /** @class */ (function (_super) {
        __extends(DMenuItemExpandable, _super);
        function DMenuItemExpandable() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuItemExpandable.prototype.init = function (options) {
            var _this = this;
            var _a;
            _super.prototype.init.call(this, options);
            // Header
            var theme = this.theme;
            var header = this.toHeader(theme, options);
            this._header = header;
            header.on("select", function () {
                _this.toggle();
            });
            this.addChild(header);
            // Body
            var body = this.toBody(theme, options);
            this._body = body;
            var sticky = (_a = options === null || options === void 0 ? void 0 : options.sticky) !== null && _a !== void 0 ? _a : false;
            this.newItems(body, sticky, theme, options);
            this.addChild(body);
            //
            if (this.state.isActive) {
                this.onActivated();
            }
            else {
                this.onDeactivated();
            }
        };
        DMenuItemExpandable.prototype.newItems = function (body, sticky, theme, options) {
            var items = options === null || options === void 0 ? void 0 : options.items;
            if (items != null) {
                DMenuItemExpandables.newItems(body, items, sticky);
            }
        };
        DMenuItemExpandable.prototype.toHeader = function (theme, options) {
            if (options) {
                if (options.header instanceof pixi_js.DisplayObject) {
                    return options.header;
                }
                else {
                    return this.newHeader(theme, options.header);
                }
            }
            return this.newHeader(theme);
        };
        DMenuItemExpandable.prototype.newHeader = function (theme, options) {
            return new DMenuItemExpandableHeader(options);
        };
        DMenuItemExpandable.prototype.toBody = function (theme, options) {
            var body = options === null || options === void 0 ? void 0 : options.body;
            if (body) {
                if (body instanceof pixi_js.DisplayObject) {
                    return body;
                }
                else {
                    return this.newBody(theme, body);
                }
            }
            return this.newBody(theme);
        };
        DMenuItemExpandable.prototype.newBody = function (theme, options) {
            return new DMenuItemExpandableBody(options);
        };
        DMenuItemExpandable.prototype.open = function () {
            this.state.isActive = true;
        };
        DMenuItemExpandable.prototype.close = function () {
            this.state.isActive = false;
        };
        DMenuItemExpandable.prototype.toggle = function () {
            this.state.isActive = !this.state.isActive;
        };
        DMenuItemExpandable.prototype.onActivated = function () {
            var body = this._body;
            if (body instanceof DBase) {
                body.show();
            }
            else {
                body.visible = true;
            }
        };
        DMenuItemExpandable.prototype.onDeactivated = function () {
            var body = this._body;
            if (body instanceof DBase) {
                body.hide();
            }
            else {
                body.visible = false;
            }
        };
        DMenuItemExpandable.prototype.onStateChange = function (newState, oldState) {
            _super.prototype.onStateChange.call(this, newState, oldState);
            if (newState.isActive) {
                if (!oldState.isActive) {
                    this.onActivated();
                }
            }
            else {
                if (oldState.isActive) {
                    this.onDeactivated();
                }
            }
        };
        DMenuItemExpandable.prototype.onKeyDown = function (e) {
            if (UtilKeyboardEvent.isArrowRightKey(e)) {
                if (this.state.isActionable && !this.state.isActive) {
                    var header = this._header;
                    if (header instanceof DBase && header.state.isFocused) {
                        this.state.isActive = true;
                    }
                }
            }
            else if (UtilKeyboardEvent.isArrowLeftKey(e)) {
                if (this.state.isActionable && this.state.isActive) {
                    // Move the focus
                    var header = this._header;
                    if (header instanceof DBase) {
                        header.focus();
                    }
                    else {
                        this.focus();
                    }
                    // Deactivate
                    this.state.isActive = false;
                    // Key handling
                    _super.prototype.onKeyDown.call(this, e);
                    return true;
                }
            }
            return _super.prototype.onKeyDown.call(this, e);
        };
        DMenuItemExpandable.prototype.getType = function () {
            return "DMenuItemExpandable";
        };
        return DMenuItemExpandable;
    }(DLayoutVertical));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuItemExpandableIsCompatible = function (options) {
        return "header" in options;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuItemExpandableItemCheck = /** @class */ (function (_super) {
        __extends(DMenuItemExpandableItemCheck, _super);
        function DMenuItemExpandableItemCheck() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuItemExpandableItemCheck.prototype.getType = function () {
            return "DMenuItemExpandableItemCheck";
        };
        return DMenuItemExpandableItemCheck;
    }(DMenuItemCheck));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuItemExpandableItemLink = /** @class */ (function (_super) {
        __extends(DMenuItemExpandableItemLink, _super);
        function DMenuItemExpandableItemLink() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuItemExpandableItemLink.prototype.getType = function () {
            return "DMenuItemExpandableItemLink";
        };
        return DMenuItemExpandableItemLink;
    }(DMenuItemLink));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuItemExpandableItemSeparator = /** @class */ (function (_super) {
        __extends(DMenuItemExpandableItemSeparator, _super);
        function DMenuItemExpandableItemSeparator() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuItemExpandableItemSeparator.prototype.getType = function () {
            return "DMenuItemExpandableItemSeparator";
        };
        return DMenuItemExpandableItemSeparator;
    }(DMenuItemSeparator));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuItemExpandableItemSpace = /** @class */ (function (_super) {
        __extends(DMenuItemExpandableItemSpace, _super);
        function DMenuItemExpandableItemSpace() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuItemExpandableItemSpace.prototype.getType = function () {
            return "DMenuItemExpandableItemSpace";
        };
        return DMenuItemExpandableItemSpace;
    }(DMenuItemSpace));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuItemExpandableItemText = /** @class */ (function (_super) {
        __extends(DMenuItemExpandableItemText, _super);
        function DMenuItemExpandableItemText() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuItemExpandableItemText.prototype.getType = function () {
            return "DMenuItemExpandableItemText";
        };
        return DMenuItemExpandableItemText;
    }(DMenuItemText));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadMenuItemExpandable = function () {
        DMenus.addItemCreator(function (options) {
            if (DMenuItemExpandableIsCompatible(options)) {
                return new DMenuItemExpandable(options);
            }
            return null;
        });
        DMenuItemExpandables.addItemCreator(function (options) {
            if (DMenuItemCheckIsCompatible(options)) {
                return new DMenuItemExpandableItemCheck(options);
            }
            return null;
        });
        DMenuItemExpandables.addItemCreator(function (options) {
            if (DMenuItemLinkIsCompatible(options)) {
                return new DMenuItemExpandableItemLink(options);
            }
            return null;
        });
        DMenuItemExpandables.addItemCreator(function (options) {
            if (DMenuItemSeparatorIsCompatible(options)) {
                return new DMenuItemExpandableItemSeparator(options);
            }
            return null;
        });
        DMenuItemExpandables.addItemCreator(function (options) {
            if (DMenuItemSpaceIsCompatible(options)) {
                return new DMenuItemExpandableItemSpace(options);
            }
            return null;
        });
        DMenuItemExpandables.setItemCreatorDefault(function (options) {
            return new DMenuItemExpandableItemText(options);
        });
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuSidedItemCheck = /** @class */ (function (_super) {
        __extends(DMenuSidedItemCheck, _super);
        function DMenuSidedItemCheck() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuSidedItemCheck.prototype.getType = function () {
            return "DMenuSidedItemCheck";
        };
        return DMenuSidedItemCheck;
    }(DMenuItemCheck));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuSidedItemLink = /** @class */ (function (_super) {
        __extends(DMenuSidedItemLink, _super);
        function DMenuSidedItemLink() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuSidedItemLink.prototype.getSelection = function () {
            return null;
        };
        DMenuSidedItemLink.prototype.getType = function () {
            return "DMenuSidedItemLink";
        };
        return DMenuSidedItemLink;
    }(DMenuItemLink));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuSidedItemMenu = /** @class */ (function (_super) {
        __extends(DMenuSidedItemMenu, _super);
        function DMenuSidedItemMenu() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuSidedItemMenu.prototype.initHover = function (options) {
            // DO NOTHING
        };
        DMenuSidedItemMenu.prototype.onMenuSelect = function (value, item, menu) {
            _super.prototype.onMenuSelect.call(this, value, item, menu);
            var selection = _super.prototype.getSelection.call(this);
            if (selection) {
                selection.add(item);
            }
        };
        DMenuSidedItemMenu.prototype.onOpen = function (menu) {
            menu.open(this, this);
        };
        DMenuSidedItemMenu.prototype.getSelection = function () {
            return null;
        };
        DMenuSidedItemMenu.prototype.getType = function () {
            return "DMenuSidedItemMenu";
        };
        return DMenuSidedItemMenu;
    }(DMenuItemMenu));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuSidedItemSeparator = /** @class */ (function (_super) {
        __extends(DMenuSidedItemSeparator, _super);
        function DMenuSidedItemSeparator() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuSidedItemSeparator.prototype.getType = function () {
            return "DMenuSidedItemSeparator";
        };
        return DMenuSidedItemSeparator;
    }(DMenuItemSeparator));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuSidedItemSpace = /** @class */ (function (_super) {
        __extends(DMenuSidedItemSpace, _super);
        function DMenuSidedItemSpace() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuSidedItemSpace.prototype.getType = function () {
            return "DMenuSidedItemSpace";
        };
        return DMenuSidedItemSpace;
    }(DMenuItemSpace));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuSidedItemText = /** @class */ (function (_super) {
        __extends(DMenuSidedItemText, _super);
        function DMenuSidedItemText() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuSidedItemText.prototype.getType = function () {
            return "DMenuSidedItemText";
        };
        return DMenuSidedItemText;
    }(DMenuItemText));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuSideds = /** @class */ (function () {
        function DMenuSideds() {
        }
        DMenuSideds.addItemCreator = function (creator) {
            this.CREATORS.push(creator);
        };
        DMenuSideds.setItemCreatorDefault = function (creator) {
            this.CREATOR_DEFAULT = creator;
        };
        DMenuSideds.newItem = function (options, sticky) {
            return (DMenus.newItemOf(this.CREATORS, this.CREATOR_DEFAULT, options, sticky) ||
                DMenus.newItem(options, sticky));
        };
        DMenuSideds.newItems = function (parent, items, sticky) {
            DMenus.newItemsOf(this, parent, items, sticky);
        };
        DMenuSideds.CREATORS = [];
        DMenuSideds.CREATOR_DEFAULT = null;
        return DMenuSideds;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadMenuSidedItem = function () {
        DMenuSideds.setItemCreatorDefault(function (options) {
            return new DMenuSidedItemText(options);
        });
        DMenuSideds.addItemCreator(function (options) {
            if (DMenuItemSpaceIsCompatible(options)) {
                return new DMenuSidedItemSpace(options);
            }
            return null;
        });
        DMenuSideds.addItemCreator(function (options) {
            if (DMenuItemSeparatorIsCompatible(options)) {
                return new DMenuSidedItemSeparator(options);
            }
            return null;
        });
        DMenuSideds.addItemCreator(function (options, sticky) {
            if (DMenuItemMenuIsCompatible(options)) {
                return new DMenuSidedItemMenu(DMenuItemMenuToSubMenuOptions(options, sticky));
            }
            return null;
        });
        DMenuSideds.addItemCreator(function (options) {
            if (DMenuItemLinkIsCompatible(options)) {
                return new DMenuSidedItemLink(options);
            }
            return null;
        });
        DMenuSideds.addItemCreator(function (options) {
            if (DMenuItemCheckIsCompatible(options)) {
                return new DMenuSidedItemCheck(options);
            }
            return null;
        });
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuSidedItemExpandables = /** @class */ (function () {
        function DMenuSidedItemExpandables() {
        }
        DMenuSidedItemExpandables.addItemCreator = function (creator) {
            this.CREATORS.push(creator);
        };
        DMenuSidedItemExpandables.setItemCreatorDefault = function (creator) {
            this.CREATOR_DEFAULT = creator;
        };
        DMenuSidedItemExpandables.newItem = function (options, sticky) {
            return (DMenus.newItemOf(this.CREATORS, this.CREATOR_DEFAULT, options, sticky) ||
                DMenuSideds.newItem(options, sticky));
        };
        DMenuSidedItemExpandables.newItems = function (parent, items, sticky) {
            DMenus.newItemsOf(this, parent, items, sticky);
        };
        DMenuSidedItemExpandables.CREATORS = [];
        DMenuSidedItemExpandables.CREATOR_DEFAULT = null;
        return DMenuSidedItemExpandables;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuSidedItemExpandable = /** @class */ (function (_super) {
        __extends(DMenuSidedItemExpandable, _super);
        function DMenuSidedItemExpandable() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuSidedItemExpandable.prototype.newItems = function (body, sticky, theme, options) {
            if (options != null && options.items != null) {
                DMenuSidedItemExpandables.newItems(body, options.items, sticky);
            }
        };
        DMenuSidedItemExpandable.prototype.getType = function () {
            return "DMenuSidedItemExpandable";
        };
        return DMenuSidedItemExpandable;
    }(DMenuItemExpandable));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuSidedItemExpandableItemCheck = /** @class */ (function (_super) {
        __extends(DMenuSidedItemExpandableItemCheck, _super);
        function DMenuSidedItemExpandableItemCheck() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuSidedItemExpandableItemCheck.prototype.getType = function () {
            return "DMenuSidedItemExpandableItemCheck";
        };
        return DMenuSidedItemExpandableItemCheck;
    }(DMenuItemExpandableItemCheck));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuSidedItemExpandableItemLink = /** @class */ (function (_super) {
        __extends(DMenuSidedItemExpandableItemLink, _super);
        function DMenuSidedItemExpandableItemLink() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuSidedItemExpandableItemLink.prototype.getType = function () {
            return "DMenuSidedItemExpandableItemLink";
        };
        return DMenuSidedItemExpandableItemLink;
    }(DMenuItemLink));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuItemExpandableItemMenu = /** @class */ (function (_super) {
        __extends(DMenuItemExpandableItemMenu, _super);
        function DMenuItemExpandableItemMenu() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuItemExpandableItemMenu.prototype.getType = function () {
            return "DMenuItemExpandableItemMenu";
        };
        return DMenuItemExpandableItemMenu;
    }(DMenuItemMenu));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuSidedItemExpandableItemMenu = /** @class */ (function (_super) {
        __extends(DMenuSidedItemExpandableItemMenu, _super);
        function DMenuSidedItemExpandableItemMenu() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuSidedItemExpandableItemMenu.prototype.onOpen = function (menu) {
            menu.open(this, this);
        };
        DMenuSidedItemExpandableItemMenu.prototype.getType = function () {
            return "DMenuSidedItemExpandableItemMenu";
        };
        return DMenuSidedItemExpandableItemMenu;
    }(DMenuItemExpandableItemMenu));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuSidedItemExpandableItemSeparator = /** @class */ (function (_super) {
        __extends(DMenuSidedItemExpandableItemSeparator, _super);
        function DMenuSidedItemExpandableItemSeparator() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuSidedItemExpandableItemSeparator.prototype.getType = function () {
            return "DMenuSidedItemSeparator";
        };
        return DMenuSidedItemExpandableItemSeparator;
    }(DMenuItemExpandableItemSeparator));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuSidedItemExpandableItemSpace = /** @class */ (function (_super) {
        __extends(DMenuSidedItemExpandableItemSpace, _super);
        function DMenuSidedItemExpandableItemSpace() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuSidedItemExpandableItemSpace.prototype.getType = function () {
            return "DMenuSidedItemExpandableItemSpace";
        };
        return DMenuSidedItemExpandableItemSpace;
    }(DMenuItemExpandableItemSpace));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuSidedItemExpandableItemText = /** @class */ (function (_super) {
        __extends(DMenuSidedItemExpandableItemText, _super);
        function DMenuSidedItemExpandableItemText() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuSidedItemExpandableItemText.prototype.getType = function () {
            return "DMenuSidedItemExpandableItemText";
        };
        return DMenuSidedItemExpandableItemText;
    }(DMenuItemExpandableItemText));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadMenuSidedItemExpandable = function () {
        DMenuSideds.addItemCreator(function (options) {
            if (DMenuItemExpandableIsCompatible(options)) {
                return new DMenuSidedItemExpandable(options);
            }
            return null;
        });
        DMenuSidedItemExpandables.addItemCreator(function (options) {
            if (DMenuItemCheckIsCompatible(options)) {
                return new DMenuSidedItemExpandableItemCheck(options);
            }
            return null;
        });
        DMenuSidedItemExpandables.addItemCreator(function (options) {
            if (DMenuItemLinkIsCompatible(options)) {
                return new DMenuSidedItemExpandableItemLink(options);
            }
            return null;
        });
        DMenuSidedItemExpandables.addItemCreator(function (options, sticky) {
            if (DMenuItemMenuIsCompatible(options)) {
                return new DMenuSidedItemExpandableItemMenu(DMenuItemMenuToSubMenuOptions(options, sticky));
            }
            return null;
        });
        DMenuSidedItemExpandables.addItemCreator(function (options) {
            if (DMenuItemSeparatorIsCompatible(options)) {
                return new DMenuSidedItemExpandableItemSeparator(options);
            }
            return null;
        });
        DMenuSidedItemExpandables.addItemCreator(function (options) {
            if (DMenuItemSpaceIsCompatible(options)) {
                return new DMenuSidedItemExpandableItemSpace(options);
            }
            return null;
        });
        DMenuSidedItemExpandables.setItemCreatorDefault(function (options) {
            return new DMenuSidedItemExpandableItemText(options);
        });
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadMenuItemAll = function () {
        loadMenuItem();
        loadMenuItemExpandable();
        loadMenuSidedItem();
        loadMenuSidedItemExpandable();
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadAll = function () {
        loadMenuItemAll();
        loadShapeAll();
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueMiscEmitEvent = /** @class */ (function (_super) {
        __extends(EShapeActionValueMiscEmitEvent, _super);
        function EShapeActionValueMiscEmitEvent(condition, target) {
            return _super.call(this, EShapeActionValueMiscType.EMIT_EVENT, condition, target, EShapeActionValueOnInputAction.EMIT_EVENT, "") || this;
        }
        return EShapeActionValueMiscEmitEvent;
    }(EShapeActionValueMisc));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueMiscHtmlElement = /** @class */ (function (_super) {
        __extends(EShapeActionValueMiscHtmlElement, _super);
        function EShapeActionValueMiscHtmlElement(subtype, when, initializer) {
            return _super.call(this, subtype, when, "", EShapeActionValueOnInputAction.EMIT_EVENT, initializer) || this;
        }
        return EShapeActionValueMiscHtmlElement;
    }(EShapeActionValueMisc));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueMiscInput = /** @class */ (function (_super) {
        __extends(EShapeActionValueMiscInput, _super);
        function EShapeActionValueMiscInput(subtype, when, target, onInputAction) {
            return _super.call(this, subtype, when, target, onInputAction, "") || this;
        }
        return EShapeActionValueMiscInput;
    }(EShapeActionValueMisc));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueMiscWrite = /** @class */ (function (_super) {
        __extends(EShapeActionValueMiscWrite, _super);
        function EShapeActionValueMiscWrite(subtype, condition, target, value) {
            return _super.call(this, subtype, condition, target, EShapeActionValueOnInputAction.EMIT_EVENT, value) || this;
        }
        return EShapeActionValueMiscWrite;
    }(EShapeActionValueMisc));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var createImageSdf = function (dataUrl, convertToSdf) {
        if (convertToSdf) {
            return toImageElement(dataUrl).then(function (image) {
                var generator = DynamicSDFFontGenerator.getInstance().init();
                generator.updateTexture(image.width, image.height, image.source);
                generator.render();
                var canvas = document.createElement("canvas");
                generator.read(canvas);
                return createImageSdf(canvas.toDataURL(), false);
            });
        }
        else {
            return toImageElement(dataUrl).then(function (image) {
                return new EShapeImageSdf(image);
            });
        }
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var createImage = function (dataUrl) {
        return toImageElement(dataUrl).then(function (image) {
            return new EShapeImage(image);
        });
    };

    var createLine = function (points, segments, strokeWidth, pointsStyle) {
        // Calculate the boundary
        var boundary = toPointsBoundary(points, [0, 0, 0, 0]);
        var cx = (boundary[2] + boundary[0]) * 0.5;
        var cy = (boundary[3] + boundary[1]) * 0.5;
        var sx = boundary[2] - boundary[0];
        var sy = boundary[3] - boundary[1];
        // Calculate values
        var values = [];
        for (var i = 0, imax = points.length; i < imax; i += 2) {
            values.push(points[i] - cx, points[i + 1] - cy);
        }
        // Create a line
        var result = new EShapeLine();
        result.stroke.set(true, undefined, undefined, strokeWidth);
        result.transform.position.set(cx, cy);
        result.size.set(sx, sy);
        result.points.set(values, segments, pointsStyle);
        return result;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeEmbeddeds = /** @class */ (function () {
        function EShapeEmbeddeds() {
        }
        EShapeEmbeddeds.from = function (serializedOrSimple, controller, mode) {
            var _this = this;
            var serialized = DDiagrams.toSerialized(serializedOrSimple);
            var pieces = serialized.pieces;
            return DDiagrams.toPieceData(controller, pieces, mode).then(function (pieceData) {
                return _this.from_(serialized, mode, pieces, pieceData);
            });
        };
        EShapeEmbeddeds.from_ = function (serialized, mode, pieces, pieceData) {
            var _this = this;
            var width = serialized.width;
            var height = serialized.height;
            var container = new EShapeEmbeddedLayerContainer(width, height);
            var manager = new EShapeResourceManagerDeserialization(serialized, pieces, pieceData, mode, 1);
            return DDiagrams.newLayer(serialized, container, manager).then(function () {
                return _this.create(serialized.name, width, height, container, mode, 0);
            });
        };
        EShapeEmbeddeds.create = function (name, width, height, container, mode, depth) {
            var shape = new EShapeEmbedded(name, mode, depth);
            shape.size.set(width, height);
            container.copyTo(shape);
            shape.size.init();
            return shape;
        };
        return EShapeEmbeddeds;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var toSvgUrl = function (svg) {
        return "data:image/svg+xml;base64,".concat(btoa(svg));
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var toGradientImageUrl = function (gradient) {
        var direction = gradient.direction;
        var points = gradient.points;
        var stops = "";
        for (var i = 0, imax = points.length; i < imax; ++i) {
            var point = points[i];
            var color = UtilRgb.toCode(point.color);
            var alpha = point.alpha;
            var offset = point.position * 100;
            stops += "<stop offset=\"".concat(offset, "%\" stop-color=\"#").concat(color, "\" stop-opacity=\"").concat(alpha, "\" />");
        }
        var radian = (direction * Math.PI) / 180;
        var dx = 0.5 * Math.cos(radian);
        var dy = -0.5 * Math.sin(radian);
        var url = toSvgUrl(
        /* eslint-disable prettier/prettier */
        "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"32\" height=\"32\" viewBox=\"0 0 32 32\">" +
            "<defs>" +
            "<linearGradient id=\"o2glkm3aeu2oio\" x1=\"".concat(0.5 - dx, "\" x2=\"").concat(0.5 + dx, "\" y1=\"").concat(0.5 - dy, "\" y2=\"").concat(0.5 + dy, "\">") +
            stops +
            "</linearGradient>" +
            "</defs>" +
            "<rect x=\"0\" y=\"0\" width=\"32\" height=\"32\" stroke=\"none\" fill=\"url(#o2glkm3aeu2oio)\" />" +
            "</svg>"
        /* eslint-enable prettier/prettier */
        );
        return url;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var toSizeRounded = function (value) {
        return Math.round(value * 100) / 100;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var toResized = function (shape, from, to, centerMode, isPerfect) {
        var cposition = EShapeCapabilities.contains(shape, EShapeCapability.POSITION);
        var cwidth = EShapeCapabilities.contains(shape, EShapeCapability.WIDTH);
        var cheight = EShapeCapabilities.contains(shape, EShapeCapability.HEIGHT);
        shape.lock(EShapeLockPart.UPLOADED);
        var position = shape.transform.position;
        if (centerMode) {
            var dx = Math.abs(to.x - from.x);
            var dy = Math.abs(to.y - from.y);
            if (isPerfect) {
                var d = Math.max(dx, dy);
                var s = toSizeNormalized(d + d);
                var x = toSizeRounded(from.x);
                var y = toSizeRounded(from.y);
                var size = shape.size;
                if (cwidth && cheight) {
                    size.set(s, s);
                }
                else if (cwidth) {
                    size.x = s;
                }
                else if (cheight) {
                    size.y = s;
                }
                if (cposition) {
                    position.set(x, y);
                }
            }
            else {
                var w = toSizeNormalized(dx + dx);
                var h = toSizeNormalized(dy + dy);
                var x = toSizeRounded(from.x);
                var y = toSizeRounded(from.y);
                var size = shape.size;
                if (cwidth && cheight) {
                    size.set(w, h);
                }
                else if (cwidth) {
                    size.x = w;
                }
                else if (cheight) {
                    size.y = h;
                }
                if (cposition) {
                    position.set(x, y);
                }
            }
        }
        else {
            if (isPerfect) {
                var dx = to.x - from.x;
                var dy = to.y - from.y;
                var d = Math.max(Math.abs(dx), Math.abs(dy));
                var x2 = from.x + (dx < 0 ? -d : +d);
                var y2 = from.y + (dy < 0 ? -d : +d);
                var hd = d * 0.5;
                var s = toSizeNormalized(d);
                var x = toSizeRounded(Math.min(from.x, x2) + hd);
                var y = toSizeRounded(Math.min(from.y, y2) + hd);
                var size = shape.size;
                if (cwidth && cheight) {
                    size.set(s, s);
                }
                else if (cwidth) {
                    size.x = s;
                }
                else if (cheight) {
                    size.y = s;
                }
                if (cposition) {
                    position.set(x, y);
                }
            }
            else {
                var x0 = Math.min(from.x, to.x);
                var y0 = Math.min(from.y, to.y);
                var x1 = Math.max(from.x, to.x);
                var y1 = Math.max(from.y, to.y);
                var dx = x1 - x0;
                var dy = y1 - y0;
                var px = dx * 0.5;
                var py = dy * 0.5;
                var w = toSizeNormalized(dx);
                var h = toSizeNormalized(dy);
                var x = toSizeRounded(x0 + px);
                var y = toSizeRounded(y0 + py);
                var size = shape.size;
                if (cwidth && cheight) {
                    size.set(w, h);
                }
                else if (cwidth) {
                    size.x = w;
                }
                else if (cheight) {
                    size.y = h;
                }
                if (cposition) {
                    position.set(x, y);
                }
            }
        }
        shape.unlock(EShapeLockPart.UPLOADED, true);
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * @deprecated in favor of {@link EShapeAcceptorEdgeType}.
     */
    var EShapeAcceptorType = EShapeAcceptorEdgeType;

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeEditor = /** @class */ (function () {
        function EShapeEditor() {
            this.localTransform = new pixi_js.Matrix();
            this.internalTransform = new pixi_js.Matrix();
            this.internalTransformParentInverse = new pixi_js.Matrix();
            this.rotation = 0;
            this.size = new pixi_js.Point();
        }
        return EShapeEditor;
    }());

    var EShapePointsStyles = /** @class */ (function () {
        function EShapePointsStyles() {
        }
        EShapePointsStyles.from = function (style) {
            if (isString(style)) {
                return EShapePointsStyle[style];
            }
            else if (isNumber(style)) {
                return style;
            }
            else if (style != null) {
                var result = EShapePointsStyle.NONE;
                for (var i = 0, imax = style.length; i < imax; ++i) {
                    result |= EShapePointsStyle[style[i]];
                }
                return result;
            }
            else {
                return EShapePointsStyle.NONE;
            }
        };
        return EShapePointsStyles;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeResourceManagerSerialization = /** @class */ (function () {
        function EShapeResourceManagerSerialization() {
            this.resources = [];
            this.resourceToIndex = new Map();
            this.data = [];
            this.dataToIndex = new Map();
            this.pieces = [];
            this.pieceToIndex = new Map();
            this.uuids = new Set();
            this.uuidNext = 0;
        }
        EShapeResourceManagerSerialization.prototype.addResource = function (resource) {
            return this.add_(resource, this.resources, this.resourceToIndex);
        };
        EShapeResourceManagerSerialization.prototype.addData = function (data) {
            return this.add_(data, this.data, this.dataToIndex);
        };
        EShapeResourceManagerSerialization.prototype.addPiece = function (piece) {
            return this.add_(piece, this.pieces, this.pieceToIndex);
        };
        EShapeResourceManagerSerialization.prototype.addUuid = function (uuid) {
            if (uuid !== 0) {
                var uuids = this.uuids;
                if (uuids.has(uuid)) {
                    return 0;
                }
                else {
                    uuids.add(uuid);
                    return uuid;
                }
            }
            return 0;
        };
        EShapeResourceManagerSerialization.prototype.updateUuid = function (uuid) {
            var uuids = this.uuids;
            if (uuid !== 0) {
                return uuid;
            }
            else {
                var newUuid = this.newUuid();
                uuids.add(newUuid);
                return newUuid;
            }
        };
        EShapeResourceManagerSerialization.prototype.newUuid = function () {
            var uuids = this.uuids;
            var uuidNext = this.uuidNext;
            while (true) {
                uuidNext += 1;
                if (uuidNext !== 0 && !uuids.has(uuidNext)) {
                    this.uuidNext = uuidNext;
                    return uuidNext;
                }
            }
        };
        EShapeResourceManagerSerialization.prototype.add_ = function (target, array, map) {
            var result = map.get(target);
            if (result != null) {
                return result;
            }
            var index = array.length;
            array.push(target);
            map.set(target, index);
            return index;
        };
        return EShapeResourceManagerSerialization;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var ESnapperGrid = /** @class */ (function (_super) {
        __extends(ESnapperGrid, _super);
        function ESnapperGrid(theme, options) {
            var _a, _b, _c;
            var _this = _super.call(this) || this;
            _this._isVisibleDefault = (_a = options === null || options === void 0 ? void 0 : options.visible) !== null && _a !== void 0 ? _a : theme.isSnapGridVisible();
            _this._isVisible = _this._isVisibleDefault;
            _this._isEnabledDefault = (_b = options === null || options === void 0 ? void 0 : options.enable) !== null && _b !== void 0 ? _b : theme.isSnapGridEnabled();
            _this._isEnabled = _this._isEnabledDefault;
            _this._sizeDefault = (_c = options === null || options === void 0 ? void 0 : options.size) !== null && _c !== void 0 ? _c : theme.getSnapGridSize();
            _this._size = _this._sizeDefault;
            return _this;
        }
        Object.defineProperty(ESnapperGrid.prototype, "visible", {
            get: function () {
                return this._isVisible;
            },
            set: function (visible) {
                if (this._isVisible !== visible) {
                    this._isVisible = visible;
                    this.emit("change", this);
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ESnapperGrid.prototype, "enable", {
            get: function () {
                return this._isEnabled;
            },
            set: function (enable) {
                if (this._isEnabled !== enable) {
                    this._isEnabled = enable;
                    this.emit("change", this);
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ESnapperGrid.prototype, "size", {
            get: function () {
                return this._size;
            },
            set: function (size) {
                if (this._size !== size) {
                    this._size = size;
                    this.emit("change", size, this);
                }
            },
            enumerable: false,
            configurable: true
        });
        ESnapperGrid.prototype.snap = function (value, result) {
            if (this._isEnabled) {
                var size = this._size;
                result.set(value, Math.round(value / size) * size);
            }
        };
        ESnapperGrid.prototype.reset = function () {
            this._isVisible = this._isVisibleDefault;
            this._isEnabled = this._isEnabledDefault;
            this._size = this._sizeDefault;
            this.emit("change", this);
        };
        ESnapperGrid.prototype.serialize = function () {
            return [this._isEnabled ? 1 : 0, this._isVisible ? 1 : 0, this._size];
        };
        ESnapperGrid.prototype.deserialize = function (serialized) {
            this.enable = !!serialized[0];
            if (2 in serialized) {
                this.visible = !!serialized[1];
                this.size = serialized[2];
            }
            else {
                this.visible = this._isVisibleDefault;
                this.size = serialized[1];
            }
        };
        return ESnapperGrid;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var ESnapperResultScale = /** @class */ (function () {
        function ESnapperResultScale() {
            this.distance = NaN;
            this.scale = new pixi_js.Point();
        }
        return ESnapperResultScale;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var ESnapperResult = /** @class */ (function () {
        function ESnapperResult() {
            this.distance = NaN;
            this.result = 0;
            this.threshold = 10;
        }
        ESnapperResult.prototype.reset = function (value, scale) {
            this.distance = NaN;
            this.result = value;
            this.threshold = 0.0001 < scale ? 10 / scale : 10;
        };
        ESnapperResult.prototype.set = function (value, snapped) {
            var newDistance = Math.abs(snapped - value);
            if (newDistance <= this.threshold) {
                var oldDistance = this.distance;
                if (oldDistance !== oldDistance || newDistance < oldDistance) {
                    this.distance = newDistance;
                    this.result = snapped;
                }
            }
        };
        return ESnapperResult;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var ESnapperTargetValueType = {
        HORIZONTAL: 0,
        VERTICAL: 1
    };
    var ESnapperTargetValue = /** @class */ (function () {
        function ESnapperTargetValue(type, position) {
            this.type = type;
            this.position = position;
        }
        ESnapperTargetValue.prototype.serialize = function () {
            return [this.type, this.position];
        };
        return ESnapperTargetValue;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var ESnapperTarget = /** @class */ (function (_super) {
        __extends(ESnapperTarget, _super);
        function ESnapperTarget(theme, options) {
            var _a, _b;
            var _this = _super.call(this) || this;
            _this.values = [];
            _this._isVisibleDefault = (_a = options === null || options === void 0 ? void 0 : options.visible) !== null && _a !== void 0 ? _a : theme.isSnapTargetVisible();
            _this._isVisible = _this._isVisibleDefault;
            _this._isEnabledDefault = (_b = options === null || options === void 0 ? void 0 : options.enable) !== null && _b !== void 0 ? _b : theme.isSnapTargetEnabled();
            _this._isEnabled = _this._isEnabledDefault;
            return _this;
        }
        Object.defineProperty(ESnapperTarget.prototype, "enable", {
            get: function () {
                return this._isEnabled;
            },
            set: function (enable) {
                if (this._isEnabled !== enable) {
                    this._isEnabled = enable;
                    this.emit("change", this);
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ESnapperTarget.prototype, "visible", {
            get: function () {
                return this._isVisible;
            },
            set: function (visible) {
                if (this._isVisible !== visible) {
                    this._isVisible = visible;
                    this.emit("change", this);
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ESnapperTarget.prototype, "size", {
            get: function () {
                return this.values.length;
            },
            enumerable: false,
            configurable: true
        });
        ESnapperTarget.prototype.add = function (target, index) {
            if (index != null) {
                this.values.splice(index, 0, target);
            }
            else {
                this.values.push(target);
            }
            this.emit("change", this);
        };
        ESnapperTarget.prototype.remove = function (index) {
            var values = this.values;
            if (0 <= index && index < values.length) {
                values.splice(index, 1);
                this.emit("change", this);
            }
        };
        ESnapperTarget.prototype.replace = function (index, value) {
            var values = this.values;
            if (0 <= index && index < values.length) {
                var result = values[index];
                values[index] = value;
                this.emit("change", this);
                return result;
            }
            return null;
        };
        ESnapperTarget.prototype.swap = function (indexA, indexB) {
            if (indexA !== indexB) {
                var values = this.values;
                var valueA = values[indexA];
                values[indexA] = values[indexB];
                values[indexB] = valueA;
                this.emit("change", this);
            }
        };
        ESnapperTarget.prototype.snap = function (px, py, x, y) {
            if (this._isEnabled) {
                var values = this.values;
                for (var i = 0, imax = values.length; i < imax; ++i) {
                    var value = values[i];
                    if (value.type === ESnapperTargetValueType.VERTICAL) {
                        x.set(px, value.position);
                    }
                    else {
                        y.set(py, value.position);
                    }
                }
            }
        };
        ESnapperTarget.prototype.reset = function () {
            this._isEnabled = this._isEnabledDefault;
            this._isVisible = this._isVisibleDefault;
            this.values.length = 0;
            this.emit("change", this);
        };
        ESnapperTarget.prototype.serialize = function () {
            var targets = [];
            var values = this.values;
            for (var i = 0, imax = values.length; i < imax; ++i) {
                targets.push(values[i].serialize());
            }
            return [this._isEnabled ? 1 : 0, this._isVisible ? 1 : 0, targets];
        };
        ESnapperTarget.prototype.deserialize = function (serialized) {
            // Availability
            this._isEnabled = !!serialized[0];
            // Visibility
            this._isVisible = !!serialized[1];
            // Values
            var sources = serialized[2];
            var values = this.values;
            values.length = 0;
            for (var i = 0, imax = sources.length; i < imax; ++i) {
                var source = sources[i];
                values.push(new ESnapperTargetValue(source[0], source[1]));
            }
            this.emit("change", this);
        };
        return ESnapperTarget;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EPSILON = 0.00001;
    var ESnapperModifierAnchor = {
        NONE: 0,
        TOP_LEFT: 1,
        TOP_CENTER: 2,
        TOP_RIGHT: 3,
        MIDDLE_LEFT: 4,
        MIDDLE_RIGHT: 5,
        BOTTOM_LEFT: 6,
        BOTTOM_CENTER: 7,
        BOTTOM_RIGHT: 8,
        ROTATION: 9
    };
    var ESnapper = /** @class */ (function (_super) {
        __extends(ESnapper, _super);
        function ESnapper(parent, theme, options) {
            var _a;
            var _this = _super.call(this) || this;
            _this._points = [
                new pixi_js.Point(),
                new pixi_js.Point(),
                new pixi_js.Point(),
                new pixi_js.Point(),
                new pixi_js.Point() // Center
            ];
            _this._normals = [new pixi_js.Point(), new pixi_js.Point()];
            _this._lengths = [1, 1];
            _this._workScale = new pixi_js.Point();
            _this._workSnapResultX = new ESnapperResult();
            _this._workSnapResultY = new ESnapperResult();
            _this._workScaleResult = {
                distance: 0,
                scale: new pixi_js.Point()
            };
            _this._workTranslate = new pixi_js.Point();
            _this._workSnapRectangle = new pixi_js.Rectangle();
            _this._workSnap = new pixi_js.Point();
            _this.grid = new ESnapperGrid(theme, options === null || options === void 0 ? void 0 : options.grid);
            _this.target = new ESnapperTarget(theme, options === null || options === void 0 ? void 0 : options.target);
            _this._parent = parent;
            _this._isEnabledDefault = (_a = options === null || options === void 0 ? void 0 : options.enable) !== null && _a !== void 0 ? _a : theme.isSnapEnabled();
            _this._isEnabled = _this._isEnabledDefault;
            return _this;
        }
        Object.defineProperty(ESnapper.prototype, "enable", {
            get: function () {
                return this._isEnabled;
            },
            set: function (enable) {
                if (this._isEnabled !== enable) {
                    this._isEnabled = enable;
                    this.emit("change", this);
                }
            },
            enumerable: false,
            configurable: true
        });
        ESnapper.prototype.prepare = function (modifier) {
            modifier.updateTransform();
            var localTransform = modifier.transform.localTransform;
            var sx = modifier.width;
            var sy = modifier.height;
            var points = this._points;
            points[0].set(0, 0);
            points[1].set(sx, 0);
            points[2].set(sx, sy);
            points[3].set(0, sy);
            points[4].set(sx * 0.5, sy * 0.5);
            localTransform.apply(points[0], points[0]);
            localTransform.apply(points[1], points[1]);
            localTransform.apply(points[2], points[2]);
            localTransform.apply(points[3], points[3]);
            localTransform.apply(points[4], points[4]);
        };
        ESnapper.prototype.prepareForTranslate = function (modifier) {
            if (this._isEnabled) {
                this.prepare(modifier);
            }
        };
        ESnapper.prototype.snap = function (point, result) {
            var px = point.x;
            var py = point.y;
            var canvas = this._parent.canvas;
            var x = this._workSnapResultX;
            var y = this._workSnapResultY;
            // Canvas
            if (canvas != null) {
                var scale = Math.max(canvas.scale.x, canvas.scale.y);
                x.reset(px, scale);
                y.reset(py, scale);
                x.set(px, 0);
                x.set(px, canvas.width);
                y.set(py, 0);
                y.set(py, canvas.height);
            }
            else {
                x.reset(px, 1);
                y.reset(py, 1);
            }
            // Target
            this.target.snap(px, py, x, y);
            // Grid
            this.grid.snap(px, x);
            this.grid.snap(py, y);
            //
            result.x = isNaN$1(x.distance) ? NaN : x.result;
            result.y = isNaN$1(y.distance) ? NaN : y.result;
            return result;
        };
        ESnapper.prototype.toSnapped = function (point, result) {
            var px = point.x;
            var py = point.y;
            if (this._isEnabled) {
                this.snap(point, result);
                var x = result.x;
                var y = result.y;
                result.set(isNaN$1(x) ? px : x, isNaN$1(y) ? py : y);
            }
            else {
                result.set(px, py);
            }
            return result;
        };
        ESnapper.prototype.toTranslationSnapped = function (delta, result) {
            var dx = delta.x;
            var dy = delta.y;
            var x = NaN;
            var y = NaN;
            if (this._isEnabled) {
                var workTranslate = this._workTranslate;
                var points = this._points;
                for (var i = 0, imax = points.length; i < imax; ++i) {
                    var point = points[i];
                    workTranslate.set(point.x + dx, point.y + dy);
                    this.snap(workTranslate, workTranslate);
                    // X
                    if (!isNaN$1(workTranslate.x)) {
                        var newDx = workTranslate.x - point.x;
                        if (isNaN$1(x) || Math.abs(newDx - dx) < Math.abs(x - dx)) {
                            x = newDx;
                        }
                    }
                    // Y
                    if (!isNaN$1(workTranslate.y)) {
                        var newDy = workTranslate.y - point.y;
                        if (isNaN$1(y) || Math.abs(newDy - dy) < Math.abs(y - dy)) {
                            y = newDy;
                        }
                    }
                }
            }
            result.x = isNaN$1(x) ? dx : x;
            result.y = isNaN$1(y) ? dy : y;
            return result;
        };
        ESnapper.prototype.prepareForRotate = function (modifier) {
            //
        };
        ESnapper.prototype.getGridSizeRotation = function () {
            return 5;
        };
        ESnapper.prototype.toRadian = function (value) {
            return (value / 180) * Math.PI;
        };
        ESnapper.prototype.toDegree = function (value) {
            return (value / Math.PI) * 180;
        };
        ESnapper.prototype.toRotationSnapped = function (baseRotation, deltaRotation) {
            if (this._isEnabled) {
                var gridSize = this.getGridSizeRotation();
                var newRotation = baseRotation + deltaRotation;
                var newRotationDegree = Math.round(this.toDegree(newRotation));
                var newRotationDegreeResidual = newRotationDegree % 90;
                if (Math.abs(newRotationDegreeResidual) <= gridSize) {
                    return this.toRadian(newRotationDegree - newRotationDegreeResidual) - baseRotation;
                }
                else {
                    if (90 - gridSize <= newRotationDegreeResidual) {
                        return (this.toRadian(newRotationDegree + (90 - newRotationDegreeResidual)) -
                            baseRotation);
                    }
                    else if (newRotationDegreeResidual <= -90 + gridSize) {
                        return (this.toRadian(newRotationDegree - (90 + newRotationDegreeResidual)) -
                            baseRotation);
                    }
                    else {
                        return deltaRotation;
                    }
                }
            }
            return deltaRotation;
        };
        ESnapper.prototype.calcNormalizedVector = function (p0, p1, result) {
            var dx = p1.x - p0.x;
            var dy = p1.y - p0.y;
            var l = Math.sqrt(dx * dx + dy * dy);
            if (EPSILON < l) {
                var d = 1 / l;
                result.x = dx * d;
                result.y = dy * d;
            }
            else {
                result.x = 1;
                result.y = 0;
            }
            return l;
        };
        ESnapper.prototype.prepareForScale = function (modifier, anchor) {
            if (this._isEnabled) {
                this.prepare(modifier);
                var points = this._points;
                var normals = this._normals;
                var lengths = this._lengths;
                switch (anchor) {
                    case ESnapperModifierAnchor.TOP_LEFT:
                        lengths[0] = this.calcNormalizedVector(points[1], points[0], normals[0]);
                        lengths[1] = this.calcNormalizedVector(points[3], points[0], normals[1]);
                        break;
                    case ESnapperModifierAnchor.TOP_CENTER:
                        lengths[0] = this.calcNormalizedVector(points[3], points[0], normals[0]);
                        break;
                    case ESnapperModifierAnchor.TOP_RIGHT:
                        lengths[0] = this.calcNormalizedVector(points[0], points[1], normals[0]);
                        lengths[1] = this.calcNormalizedVector(points[2], points[1], normals[1]);
                        break;
                    case ESnapperModifierAnchor.MIDDLE_LEFT:
                        lengths[0] = this.calcNormalizedVector(points[1], points[0], normals[0]);
                        break;
                    case ESnapperModifierAnchor.NONE:
                        break;
                    case ESnapperModifierAnchor.MIDDLE_RIGHT:
                        lengths[0] = this.calcNormalizedVector(points[0], points[1], normals[0]);
                        break;
                    case ESnapperModifierAnchor.BOTTOM_LEFT:
                        lengths[0] = this.calcNormalizedVector(points[2], points[3], normals[0]);
                        lengths[1] = this.calcNormalizedVector(points[0], points[3], normals[1]);
                        break;
                    case ESnapperModifierAnchor.BOTTOM_CENTER:
                        lengths[0] = this.calcNormalizedVector(points[0], points[3], normals[0]);
                        break;
                    case ESnapperModifierAnchor.BOTTOM_RIGHT:
                        lengths[0] = this.calcNormalizedVector(points[3], points[2], normals[0]);
                        lengths[1] = this.calcNormalizedVector(points[1], points[2], normals[1]);
                        break;
                }
            }
        };
        ESnapper.prototype.setScaleSnappedResult = function (distance, length, move, axis, // true => x axis, false y axis
        result) {
            if (EPSILON < length) {
                if (isNaN$1(result.distance) || distance < result.distance) {
                    result.distance = distance;
                    var newScale = 1 + move / length;
                    if (axis) {
                        result.scale.x = newScale;
                    }
                    else {
                        result.scale.y = newScale;
                    }
                }
            }
        };
        ESnapper.prototype.calcScaleSnapped1D = function (transform, point, normal, length, axis, result) {
            var work = this._workScale;
            transform.apply(point, work);
            var tx = work.x;
            var ty = work.y;
            this.snap(work, work);
            var x = work.x;
            var y = work.y;
            // X coordinate
            if (!isNaN$1(x)) {
                var nx = Math.abs(normal.x);
                if (EPSILON < nx) {
                    var dx = (x - tx) / normal.x;
                    var distance = Math.abs(dx);
                    var mx = (x - point.x) / normal.x;
                    this.setScaleSnappedResult(distance, length, mx, axis, result);
                }
            }
            // Y coordinate
            if (!isNaN$1(y)) {
                var ny = Math.abs(normal.y);
                if (EPSILON < ny) {
                    var dy = (y - ty) / normal.y;
                    var distance = Math.abs(dy);
                    var my = (y - point.y) / normal.y;
                    this.setScaleSnappedResult(distance, length, my, axis, result);
                }
            }
        };
        ESnapper.prototype.calcScaleSnappedX = function (transform, point, normal, length, result) {
            this.calcScaleSnapped1D(transform, point, normal, length, true, result);
        };
        ESnapper.prototype.calcScaleSnappedY = function (transform, point, normal, length, result) {
            this.calcScaleSnapped1D(transform, point, normal, length, false, result);
        };
        ESnapper.prototype.calcScaleSnapped2D = function (transform, point, normals, lengths, result) {
            var work = this._workScale;
            transform.apply(point, work);
            var tx = work.x;
            var ty = work.y;
            this.snap(work, work);
            var x = work.x;
            var y = work.y;
            if (isNaN$1(x)) {
                if (isNaN$1(y)) {
                    return;
                }
                else {
                    x = tx;
                }
            }
            else {
                if (isNaN$1(y)) {
                    y = ty;
                }
            }
            // (x, y) = (tx, ty) + normalA * a + normalB * b
            // dx = x - tx
            // dy = y - ty
            // V = ( a, b )^T
            // D = ( dx, dy )^T
            // A = | normalA.x normalB.x |
            //     | normalA.y normalB.y |
            // A V = D
            // det A = normalA.x * normalB.y - normalB.x * normalA.y
            // A^-1 = |  normalB.y -normalB.x | / det A
            //        | -normalA.y  normalA.x |
            var detA = normals[0].x * normals[1].y - normals[1].x * normals[0].y;
            if (EPSILON < Math.abs(detA)) {
                var dx = x - tx;
                var dy = y - ty;
                var distance = Math.abs(dx * dx + dy * dy);
                if (isNaN$1(result.distance) || distance < result.distance) {
                    result.distance = distance;
                    var mdx = x - point.x;
                    var mdy = y - point.y;
                    var mx = (+normals[1].y * mdx - normals[1].x * mdy) / detA;
                    var my = (-normals[0].y * mdx + normals[0].x * mdy) / detA;
                    result.scale.set(1 + mx / lengths[0], 1 + my / lengths[1]);
                }
            }
        };
        ESnapper.prototype.calcScaleSnappedXY = function (transform, pointO, pointX, pointY, normals, lengths, result) {
            this.calcScaleSnapped2D(transform, pointO, normals, lengths, result);
            this.calcScaleSnappedX(transform, pointY, normals[0], lengths[0], result);
            this.calcScaleSnappedY(transform, pointX, normals[1], lengths[1], result);
        };
        ESnapper.prototype.toScaleSnapped = function (transform, anchor, keepRatio, scale) {
            if (this._isEnabled) {
                var points = this._points;
                var normals = this._normals;
                var lengths = this._lengths;
                var work = this._workScaleResult;
                work.distance = NaN;
                work.scale.set(scale.x, scale.y);
                switch (anchor) {
                    case ESnapperModifierAnchor.TOP_LEFT:
                        this.calcScaleSnappedXY(transform, points[0], points[1], points[3], normals, lengths, work);
                        break;
                    case ESnapperModifierAnchor.TOP_CENTER:
                        this.calcScaleSnappedY(transform, points[0], normals[0], lengths[0], work);
                        this.calcScaleSnappedY(transform, points[1], normals[0], lengths[0], work);
                        break;
                    case ESnapperModifierAnchor.TOP_RIGHT:
                        this.calcScaleSnappedXY(transform, points[1], points[0], points[2], normals, lengths, work);
                        break;
                    case ESnapperModifierAnchor.MIDDLE_LEFT:
                        this.calcScaleSnappedX(transform, points[0], normals[0], lengths[0], work);
                        this.calcScaleSnappedX(transform, points[3], normals[0], lengths[0], work);
                        break;
                    case ESnapperModifierAnchor.NONE:
                        break;
                    case ESnapperModifierAnchor.MIDDLE_RIGHT:
                        this.calcScaleSnappedX(transform, points[1], normals[0], lengths[0], work);
                        this.calcScaleSnappedX(transform, points[2], normals[0], lengths[0], work);
                        break;
                    case ESnapperModifierAnchor.BOTTOM_LEFT:
                        this.calcScaleSnappedXY(transform, points[3], points[2], points[0], normals, lengths, work);
                        break;
                    case ESnapperModifierAnchor.BOTTOM_CENTER:
                        this.calcScaleSnappedY(transform, points[2], normals[0], lengths[0], work);
                        this.calcScaleSnappedY(transform, points[3], normals[0], lengths[0], work);
                        break;
                    case ESnapperModifierAnchor.BOTTOM_RIGHT:
                        this.calcScaleSnappedXY(transform, points[2], points[3], points[1], normals, lengths, work);
                        break;
                }
                if (!isNaN$1(work.distance)) {
                    scale.copyFrom(work.scale);
                    if (keepRatio) {
                        switch (anchor) {
                            case ESnapperModifierAnchor.TOP_LEFT:
                            case ESnapperModifierAnchor.TOP_RIGHT:
                            case ESnapperModifierAnchor.BOTTOM_LEFT:
                            case ESnapperModifierAnchor.BOTTOM_RIGHT:
                                scale.x = scale.y = Math.max(scale.x, scale.y);
                                break;
                            case ESnapperModifierAnchor.TOP_CENTER:
                            case ESnapperModifierAnchor.BOTTOM_CENTER:
                                scale.x = scale.y;
                                break;
                            case ESnapperModifierAnchor.MIDDLE_LEFT:
                            case ESnapperModifierAnchor.MIDDLE_RIGHT:
                                scale.y = scale.x;
                                break;
                            case ESnapperModifierAnchor.NONE:
                                break;
                        }
                    }
                    return true;
                }
            }
            return false;
        };
        ESnapper.prototype.reset = function () {
            this.enable = this._isEnabledDefault;
            this.target.reset();
            this.grid.reset();
        };
        ESnapper.prototype.serialize = function () {
            return [this._isEnabled ? 1 : 0, this.target.serialize(), this.grid.serialize()];
        };
        ESnapper.prototype.deserialize = function (serialized) {
            this.enable = !!serialized[0];
            this.target.deserialize(serialized[1]);
            this.grid.deserialize(serialized[2]);
        };
        return ESnapper;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DynamicAtlasItemText = /** @class */ (function (_super) {
        __extends(DynamicAtlasItemText, _super);
        function DynamicAtlasItemText(id, text, baseTexture) {
            var _this = _super.call(this, id, text.width, text.height, 0, baseTexture) || this;
            _this._text = text;
            return _this;
        }
        DynamicAtlasItemText.prototype.render = function (context) {
            var frame = this.frame;
            context.drawImage(this._text.canvas, frame.x, frame.y, frame.width, frame.height);
        };
        return DynamicAtlasItemText;
    }(DynamicAtlasItem));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DynamicFontAtlasFont = /** @class */ (function () {
        function DynamicFontAtlasFont(fontId, size, color, padding) {
            this.id = fontId;
            this.size = size;
            this.color = pixi_js.utils.hex2string(color);
            this.height = size + padding * 2;
            this.measured = false;
            this.ascent = 0;
            this.descent = 0;
        }
        return DynamicFontAtlasFont;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DynamicFontAtlas = /** @class */ (function () {
        function DynamicFontAtlas(fontId, fontSize, fontColor, resolution) {
            this._id = fontId;
            this._canvas = document.createElement("canvas");
            this._context = null;
            var padding = this.toPadding(fontSize);
            this._padding = padding;
            this._font = new DynamicFontAtlasFont(fontId, fontSize, fontColor, padding);
            this._unrefCount = 0;
            this._width = 1;
            this._height = 1;
            this._revisionUpdated = 0;
            this._texture = pixi_js.Texture.from(this._canvas, {
                mipmap: pixi_js.MIPMAP_MODES.OFF,
                resolution: resolution,
                scaleMode: pixi_js.SCALE_MODES.NEAREST
            });
            var characters = new Map();
            characters.set(Character.SPACE, this.newChar(Character.SPACE, DynamicFontAtlasCharacterType.SPACE_R));
            characters.set(Character.TAB, this.newChar(Character.SOFT_TAB, DynamicFontAtlasCharacterType.SPACE_R));
            characters.set(Character.DOTS, this.newChar(Character.DOTS, DynamicFontAtlasCharacterType.LETTER_RNB));
            for (var i = 0, imax = Character.ASCII.length; i < imax; ++i) {
                var ac = Character.ASCII[i];
                characters.set(ac, this.newChar(ac, DynamicFontAtlasCharacterType.LETTER_RNB));
            }
            this._characters = characters;
            this._createds = new Map();
            this._revision = 1;
        }
        DynamicFontAtlas.prototype.toPadding = function (fontSize) {
            return Math.max(3, Math.ceil(fontSize * 0.2));
        };
        Object.defineProperty(DynamicFontAtlas.prototype, "id", {
            get: function () {
                return this._id;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DynamicFontAtlas.prototype, "font", {
            get: function () {
                return this._font;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DynamicFontAtlas.prototype, "width", {
            get: function () {
                return this._width;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DynamicFontAtlas.prototype, "height", {
            get: function () {
                return this._height;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DynamicFontAtlas.prototype, "canvas", {
            get: function () {
                return this._canvas;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DynamicFontAtlas.prototype, "characters", {
            get: function () {
                return this._characters;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DynamicFontAtlas.prototype, "texture", {
            get: function () {
                return this._texture;
            },
            enumerable: false,
            configurable: true
        });
        DynamicFontAtlas.prototype.newChar = function (character, type) {
            var advance = this.getAdvance(character);
            var padding = this._padding;
            var width = Math.ceil(padding + advance + padding);
            var height = this.font.height;
            return new DynamicFontAtlasCharacter(type, character, -width, // Setting X and Y to zeros leads to render the character at the UV coordinate (0, 0).
            -height, width, height, advance);
        };
        DynamicFontAtlas.prototype.add = function (characters, type) {
            var cs = this._characters;
            var cds = this._createds;
            for (var i = 0, imax = characters.length; i < imax;) {
                if (characters.charCodeAt(i) <= 0xff) {
                    // Ignore ASCII characters
                    i += 1;
                    continue;
                }
                var j = i + 1;
                for (; j < imax; ++j) {
                    var cc = characters.charCodeAt(j);
                    if ((0xdc00 <= cc && cc <= 0xdfff) || (0xfe00 <= cc && cc <= 0xfe0f)) {
                        // Low surrogate
                        // Variation selector
                        continue;
                    }
                    break;
                }
                // Increment the reference count or create a new one
                var nac = characters.substring(i, j);
                var c = cs.get(nac);
                if (c != null) {
                    if (!(c.type & DynamicFontAtlasCharacterType.RESERVED)) {
                        if (c.ref === 0) {
                            this._unrefCount -= 1;
                        }
                        c.ref += 1;
                    }
                }
                else {
                    var cd = cds.get(nac);
                    if (cd != null) {
                        cd.ref = 1;
                        cs.set(nac, cd);
                    }
                    else {
                        var newCharacter = this.newChar(nac, type);
                        cs.set(nac, newCharacter);
                        cds.set(nac, newCharacter);
                    }
                    this._revision += 1;
                }
                // Go to the next
                i = j;
            }
        };
        DynamicFontAtlas.prototype.remove = function (characters) {
            var cs = this._characters;
            for (var i = 0, imax = characters.length; i < imax;) {
                if (characters.charCodeAt(i) <= 0xff) {
                    // Ignore ASCII characters
                    i += 1;
                    continue;
                }
                var j = i + 1;
                for (; j < imax; ++j) {
                    var cc = characters.charCodeAt(j);
                    if ((0xdc00 <= cc && cc <= 0xdfff) || (0xfe00 <= cc && cc <= 0xfe0f)) {
                        // Low surrogate
                        // Variation selector
                        continue;
                    }
                    break;
                }
                // Decrement the reference count
                var nac = characters.substring(i, j);
                var c = cs.get(nac);
                if (c != null && 0 < c.ref && !(c.type & DynamicFontAtlasCharacterType.RESERVED)) {
                    c.ref -= 1;
                    if (c.ref === 0) {
                        this._unrefCount += 1;
                    }
                }
                // Go to the next
                i = j;
            }
        };
        DynamicFontAtlas.prototype.cleanup = function () {
            var characters = this._characters;
            if (characters.size >> 1 <= this._unrefCount) {
                characters.forEach(function (char, id) {
                    if (char.ref <= 0) {
                        characters.delete(id);
                    }
                });
                this._revision += 1;
                this._unrefCount = 0;
            }
        };
        DynamicFontAtlas.prototype.get = function (id) {
            return this._characters.get(id);
        };
        DynamicFontAtlas.prototype.getAdvance = function (target) {
            var context = this.getContext();
            if (context != null) {
                return context.measureText(target).width;
            }
            return 0;
        };
        DynamicFontAtlas.prototype.getContext = function () {
            var context = this._context;
            if (context == null) {
                var canvas = this._canvas;
                if (canvas != null) {
                    context = this._context = canvas.getContext("2d", { alpha: true });
                    if (context == null) {
                        return null;
                    }
                }
                else {
                    return null;
                }
            }
            var font = this._font;
            if (context.font !== font.id) {
                context.font = font.id;
                font.id = context.font;
                context.textAlign = "left";
                context.textBaseline = "alphabetic";
                context.lineWidth = 0;
                context.lineCap = "round";
                context.lineJoin = "miter";
                context.miterLimit = 10;
                context.fillStyle = font.color;
                context.strokeStyle = "#0000ff";
            }
            return context;
        };
        DynamicFontAtlas.prototype.update = function () {
            this.cleanup();
            if (this._revisionUpdated < this._revision) {
                this._revisionUpdated = this._revision;
                var canvas = this._canvas;
                if (canvas != null) {
                    var font = this._font;
                    var fontHeight_1 = font.height;
                    var characters = this._characters;
                    var width_1 = (this._width = this.toPowerOf2(Math.ceil(Math.sqrt(characters.size)) * fontHeight_1));
                    var offsetX_1 = this._padding;
                    var x_1 = 0;
                    var y_1 = 0;
                    characters.forEach(function (character) {
                        if (width_1 <= x_1 + character.width) {
                            x_1 = 0;
                            y_1 += fontHeight_1;
                        }
                        character.x = x_1;
                        character.y = y_1;
                        character.origin.x = x_1 + offsetX_1;
                        x_1 += character.width;
                    });
                    var height = (this._height = y_1 + fontHeight_1);
                    // Make an input canvas
                    // Here, we need to reset the context because
                    // context settings will be lost when we set the width/height.
                    var baseTexture = this._texture.baseTexture;
                    var resolution = baseTexture.resolution;
                    var realWidth = Math.ceil(width_1 * resolution);
                    var realHeight = Math.ceil(height * resolution);
                    canvas.width = realWidth;
                    canvas.height = realHeight;
                    var context_1 = this.getContext();
                    if (context_1 != null) {
                        UtilFont.measure(context_1, font);
                        var offsetY_1 = Math.round((fontHeight_1 - (font.ascent + font.descent)) * 0.5 + font.ascent);
                        context_1.save();
                        context_1.scale(resolution, resolution);
                        context_1.clearRect(0, 0, width_1, height);
                        characters.forEach(function (character) {
                            character.origin.y = character.y + offsetY_1;
                            context_1.fillText(character.character, character.origin.x, character.origin.y);
                        });
                        context_1.restore();
                    }
                    baseTexture.setRealSize(realWidth, realHeight);
                    return true;
                }
            }
            return false;
        };
        DynamicFontAtlas.prototype.getRevision = function () {
            return this._revision;
        };
        DynamicFontAtlas.prototype.getRevisionUpdate = function () {
            return this._revisionUpdated;
        };
        Object.defineProperty(DynamicFontAtlas.prototype, "length", {
            get: function () {
                return this._characters.size;
            },
            enumerable: false,
            configurable: true
        });
        DynamicFontAtlas.prototype.destroy = function () {
            var canvas = this._canvas;
            if (canvas != null) {
                this._canvas = null;
            }
            this._characters.clear();
            this._createds.clear();
            this._unrefCount = 0;
        };
        DynamicFontAtlas.prototype.toPowerOf2 = function (size) {
            var result = 32;
            while (result < size) {
                result <<= 1;
            }
            return result;
        };
        return DynamicFontAtlas;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var update = function (atlas) {
        atlas.update();
    };
    var updateAll = function (colorToAltas) {
        colorToAltas.forEach(update);
    };
    var destroy = function (atlas) {
        atlas.update();
    };
    var destroyAll = function (colorToAltas) {
        colorToAltas.forEach(destroy);
    };
    var DynamicFontAtlases = /** @class */ (function () {
        function DynamicFontAtlases(layer) {
            var _this = this;
            this._atlases = new Map();
            this._resolution = layer.renderer.resolution;
            layer.renderer.on("prerender", function () {
                _this.update();
            });
        }
        DynamicFontAtlases.prototype.add = function (fontId, fontSize, fontColor, targets) {
            var atlases = this._atlases;
            var colorToAtlas = atlases.get(fontId);
            if (colorToAtlas == null) {
                colorToAtlas = new Map();
                atlases.set(fontId, colorToAtlas);
            }
            var atlas = colorToAtlas.get(fontColor);
            if (atlas == null) {
                atlas = new DynamicFontAtlas(fontId, fontSize, fontColor, this._resolution);
                colorToAtlas.set(fontColor, atlas);
            }
            atlas.add(targets, DynamicFontAtlasCharacterType.LETTER);
        };
        DynamicFontAtlases.prototype.remove = function (fontId, fontColor, targets) {
            var colorToAtlas = this._atlases.get(fontId);
            if (colorToAtlas != null) {
                var atlas = colorToAtlas.get(fontColor);
                if (atlas != null) {
                    atlas.remove(targets);
                }
            }
        };
        DynamicFontAtlases.prototype.get = function (fontId, fontColor) {
            var atlases = this._atlases;
            var colorToAtlas = atlases.get(fontId);
            if (colorToAtlas == null) {
                return null;
            }
            var atlas = colorToAtlas.get(fontColor);
            if (atlas == null) {
                return null;
            }
            return atlas;
        };
        DynamicFontAtlases.prototype.update = function () {
            this._atlases.forEach(updateAll);
        };
        DynamicFontAtlases.prototype.destroy = function () {
            var atlases = this._atlases;
            atlases.forEach(destroyAll);
            atlases.clear();
        };
        return DynamicFontAtlases;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var isObject = function (target) {
        if (typeof target === "object" &&
            Object.prototype.toString.call(target) === "[object Object]") {
            var prototype = Object.getPrototypeOf(target);
            return prototype == null || prototype === Object.prototype;
        }
        return false;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var Lazy = /** @class */ (function () {
        function Lazy(newInstance, options, base) {
            var _this = this;
            this.instance = null;
            this.newInstance = newInstance;
            this.options = options;
            if (base != null) {
                if (base.state.isActive) {
                    setTimeout(function () {
                        _this.get();
                    }, 0);
                }
                base.on("active", function () {
                    _this.get();
                });
            }
        }
        Lazy.prototype.get = function () {
            var result = this.instance;
            if (result == null) {
                result = new this.newInstance(this.options);
                this.instance = result;
            }
            return result;
        };
        return Lazy;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * Returns a ceiling index of the given value.
     * The array must be sorted in an ascending order.
     *
     * @param array an array sorted in an ascending order
     * @param value a value to be searched
     * @returns a ceiling index of the given value
     */
    var toCeilingIndex = function (array, value, size, offset) {
        var i0 = 0;
        var i1 = Math.floor(array.length / size) - 1;
        while (i0 <= i1) {
            var i2 = i0 + ((i1 - i0) >> 1);
            var v2 = array[i2 * size + offset];
            if (value < v2) {
                i1 = i2 - 1;
            }
            else if (v2 < value) {
                i0 = i2 + 1;
            }
            else {
                return i2;
            }
        }
        return Math.max(i0, i1);
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var toClonedArray = function (target) {
        var result = [];
        for (var i = 0, imax = target.length; i < imax; ++i) {
            result[i] = target[i];
        }
        return result;
    };
    var toClonedObject = function (target) {
        var result = {};
        for (var key in target) {
            if (Object.hasOwnProperty.call(target, key)) {
                result[key] = toCloned(target[key]);
            }
        }
        return result;
    };
    var toCloned = function (target) {
        if (isArray(target)) {
            return toClonedArray(target);
        }
        else if (isObject(target)) {
            return toClonedObject(target);
        }
        return target;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var toId = function (target) {
        if (target != null) {
            if (isString(target)) {
                return target;
            }
            else if (isNumber(target)) {
                return target;
            }
            else if ("id" in target) {
                return target.id;
            }
            else if ("name" in target) {
                return target.name;
            }
            else if ("label" in target) {
                return target.label;
            }
        }
        return 0;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var toLabel$1 = function (target) {
        if (target != null) {
            if (isString(target)) {
                return target;
            }
            else if (isNumber(target)) {
                return String(target);
            }
            else if ("name" in target) {
                return target.name;
            }
            else if ("label" in target) {
                return target.label;
            }
            else if ("id" in target) {
                return target.id;
            }
        }
        return "";
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var toMerged = function (one, other) {
        if (one != null) {
            var o = toCloned(one);
            if (other != null) {
                for (var key in other) {
                    if (Object.prototype.hasOwnProperty.call(other, key)) {
                        var otherValue = other[key];
                        if (isObject(otherValue)) {
                            if (Object.prototype.hasOwnProperty.call(o, key)) {
                                var oneValue = o[key];
                                if (isObject(oneValue)) {
                                    toMerged(oneValue, otherValue);
                                }
                            }
                            else {
                                o[key] = toCloned(otherValue);
                            }
                        }
                        else {
                            if (!Object.prototype.hasOwnProperty.call(o, key)) {
                                o[key] = otherValue;
                            }
                        }
                    }
                }
            }
            return o;
        }
        else if (other != null) {
            return toCloned(other);
        }
        else {
            return {};
        }
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var toString = function (value) {
        return value != null ? String(value) : "";
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var toSvgTexture = function (svg, resolution) {
        return pixi_js.Texture.from(toSvgUrl(svg), {
            resolution: resolution
        });
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var UtilSvgAtlasBuilder = /** @class */ (function () {
        function UtilSvgAtlasBuilder(options) {
            var _a, _b, _c, _d, _e, _f;
            this._width = (_a = options.width) !== null && _a !== void 0 ? _a : 256;
            this._ratio = (_b = options.ratio) !== null && _b !== void 0 ? _b : 1;
            this._margin = (_c = options.margin) !== null && _c !== void 0 ? _c : 3;
            var resolution = options.resolution;
            if (resolution != null) {
                this._resolution = resolution;
            }
            else {
                var dpr = (_d = window.devicePixelRatio) !== null && _d !== void 0 ? _d : 1;
                this._resolution = 2 < dpr ? dpr : dpr * 2;
            }
            this._scaling = (_e = options.scaling) !== null && _e !== void 0 ? _e : pixi_js.settings.SCALE_MODE;
            this._mipmap = (_f = options.mipmap) !== null && _f !== void 0 ? _f : pixi_js.settings.MIPMAP_TEXTURES;
            this._frames = {};
            this._svg = "";
            this._nextX = 0;
            this._nextY = 0;
            this._height = 0;
        }
        Object.defineProperty(UtilSvgAtlasBuilder.prototype, "width", {
            get: function () {
                return this._width;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UtilSvgAtlasBuilder.prototype, "ratio", {
            get: function () {
                return this._ratio;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UtilSvgAtlasBuilder.prototype, "margin", {
            get: function () {
                return this._margin;
            },
            enumerable: false,
            configurable: true
        });
        UtilSvgAtlasBuilder.prototype.add = function (name, width, height, path, frameX, frameY, frameWidth, frameHeight) {
            var frames = this._frames;
            if (!(name in frames)) {
                // Position
                var margin = this._margin;
                var x = this._nextX;
                var y = this._nextY;
                if (this._width <= x + width) {
                    x = 0;
                    y = this._nextY + this._height + margin;
                    this._height = height;
                    this._nextY = y;
                }
                else {
                    this._height = Math.max(this._height, height);
                }
                this._nextX = x + width + margin;
                // Frame
                frames[name] = new pixi_js.Rectangle(x + (frameX !== null && frameX !== void 0 ? frameX : 0), y + (frameY !== null && frameY !== void 0 ? frameY : 0), frameWidth !== null && frameWidth !== void 0 ? frameWidth : width, frameHeight !== null && frameHeight !== void 0 ? frameHeight : height);
                // Svg
                var ratio = this._ratio;
                this._svg += "<g transform=\"translate(".concat(x * ratio, ",").concat(y * ratio, ")\">").concat(path, "</g>");
                return true;
            }
            return false;
        };
        UtilSvgAtlasBuilder.prototype.has = function (name) {
            return name in this._frames;
        };
        Object.defineProperty(UtilSvgAtlasBuilder.prototype, "mappings", {
            get: function () {
                return this.build();
            },
            enumerable: false,
            configurable: true
        });
        UtilSvgAtlasBuilder.prototype.build = function (options) {
            var _a, _b;
            var built = this._built;
            if (built == null || (options === null || options === void 0 ? void 0 : options.force)) {
                var resolution = (_a = options === null || options === void 0 ? void 0 : options.resolution) !== null && _a !== void 0 ? _a : this._resolution;
                var width = this._width;
                var height = Math.pow(2, Math.ceil(Math.log(this._nextY + this._height) / Math.LN2));
                var realWidth = width * resolution;
                var realHeight = height * resolution;
                var ratio = this._ratio;
                var attrWidth = "width=\"".concat(realWidth, "\"");
                var attrHeight = "height=\"".concat(realHeight, "\"");
                var attrViewBox = "viewBox=\"0 0 ".concat(width * ratio, " ").concat(height * ratio, "\"");
                var attrXmlns = "xmlns=\"http://www.w3.org/2000/svg\"";
                var url = toSvgUrl("<svg ".concat(attrWidth, " ").concat(attrHeight, " ").concat(attrViewBox, " ").concat(attrXmlns, ">").concat(this._svg, "</svg>"));
                var scaleMode = (_b = options === null || options === void 0 ? void 0 : options.scaling) !== null && _b !== void 0 ? _b : this._scaling;
                var baseTexture = pixi_js.BaseTexture.from(url, {
                    resolution: resolution,
                    scaleMode: scaleMode,
                    mipmap: this._mipmap
                });
                var frames_1 = this._frames;
                built = this._built = {};
                for (var name_1 in frames_1) {
                    built[name_1] = new pixi_js.Texture(baseTexture, frames_1[name_1]);
                }
            }
            return built;
        };
        return UtilSvgAtlasBuilder;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * An output format.
     */
    var UtilFileAs = {
        TEXT: 0,
        DATA_URL: 1,
        BINARY_STRING: 2,
        ARRAY_BUTTER: 3,
        FILE: 4
    };
    /**
     * An utility class for opening files.
     */
    var UtilFileOpener = /** @class */ (function () {
        function UtilFileOpener(as, facade) {
            this._input = null;
            this._as = as;
            this._facade = facade;
        }
        UtilFileOpener.prototype.open = function () {
            var input = this.getOrCreateInput();
            if (input != null) {
                input.click();
            }
            else {
                this.onCancel();
            }
        };
        UtilFileOpener.prototype.getOrCreateInput = function () {
            var _this = this;
            if ("FileReader" in window && this._input == null) {
                var input_1 = document.createElement("input");
                this._input = input_1;
                input_1.setAttribute("type", "file");
                input_1.setAttribute("style", "display:none");
                input_1.addEventListener("change", function (e) {
                    _this.onInputChange(input_1);
                    input_1.value = "";
                    e.stopImmediatePropagation();
                    e.preventDefault();
                });
                document.body.appendChild(input_1);
            }
            return this._input;
        };
        UtilFileOpener.prototype.onInputChange = function (input) {
            var _this = this;
            var files = input.files;
            if (files != null && 0 < files.length) {
                var file_1 = files[0];
                if (this._as === UtilFileAs.FILE) {
                    this.onOpen(file_1, file_1);
                }
                else {
                    var fileReader = new FileReader();
                    fileReader.onload = function (e) {
                        if (e.target != null) {
                            var target = e.target;
                            _this.onOpen(target.result, file_1);
                        }
                    };
                    fileReader.onabort = function (e) {
                        _this.onAboart(e);
                    };
                    switch (this._as) {
                        case UtilFileAs.TEXT:
                            fileReader.readAsText(file_1);
                            break;
                        case UtilFileAs.DATA_URL:
                            fileReader.readAsDataURL(file_1);
                            break;
                        case UtilFileAs.BINARY_STRING:
                            fileReader.readAsBinaryString(file_1);
                            break;
                        case UtilFileAs.ARRAY_BUTTER:
                            fileReader.readAsArrayBuffer(file_1);
                            break;
                        default:
                            fileReader.readAsText(file_1);
                            break;
                    }
                }
            }
            else {
                this.onCancel();
            }
        };
        UtilFileOpener.prototype.onOpen = function (result, file) {
            var facade = this._facade;
            facade.emit("open", result, file, facade);
        };
        UtilFileOpener.prototype.onAboart = function (e) {
            var facade = this._facade;
            facade.emit("abort", e, facade);
        };
        UtilFileOpener.prototype.onCancel = function () {
            var facade = this._facade;
            facade.emit("cancel", facade);
        };
        return UtilFileOpener;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var UtilHsv = /** @class */ (function () {
        function UtilHsv() {
        }
        /**
         * Returns HSV colors.
         * Ranges of components are:
         *
         * * H: [0, 360)
         * * S: [0, 255]
         * * V: [0, 255]
         *
         * @param color a rgb color
         * @return an array of hsv components
         */
        UtilHsv.fromRgb = function (color) {
            var r = (color & 0xff0000) >> 16;
            var g = (color & 0x00ff00) >> 8;
            var b = (color & 0x0000ff) | 0;
            var max = Math.max(r, g, b);
            var min = Math.min(r, g, b);
            var length = max - min;
            var h = 0;
            if (0 < length) {
                if (r === max) {
                    h = (60 * (g - b)) / length;
                }
                else if (g === max) {
                    h = (60 * (b - r)) / length + 120;
                }
                else if (b === max) {
                    h = (60 * (r - g)) / length + 240;
                }
                if (h < 0) {
                    h += 360;
                }
            }
            var s = (length / max) * 255;
            var v = max;
            return [h, s, v];
        };
        UtilHsv.toRgb = function (h, s, v) {
            var max = v;
            var min = v - (s / 255) * v;
            var length = max - min;
            var r = 0;
            var g = 0;
            var b = 0;
            if (h <= 60) {
                r = max;
                g = (h / 60) * length + min;
                b = min;
            }
            else if (h <= 120) {
                r = ((120 - h) / 60) * length + min;
                g = max;
                b = min;
            }
            else if (h <= 180) {
                r = min;
                g = max;
                b = ((h - 120) / 60) * length + min;
            }
            else if (h <= 240) {
                r = min;
                g = ((240 - h) / 60) * length + min;
                b = max;
            }
            else if (h <= 300) {
                r = ((h - 240) / 60) * length + min;
                g = min;
                b = max;
            }
            else {
                r = max;
                g = min;
                b = ((360 - h) / 60) * length + min;
            }
            r = Math.max(0, Math.min(255, r));
            g = Math.max(0, Math.min(255, g));
            b = Math.max(0, Math.min(255, b));
            return (r << 16) | (g << 8) | b;
        };
        return UtilHsv;
    }());

    /*
     * Copyright (C) 2021 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var UtilInputTextArea = /** @class */ (function (_super) {
        __extends(UtilInputTextArea, _super);
        function UtilInputTextArea() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        UtilInputTextArea.prototype.onElementAttached = function (element, before, after) {
            element.addEventListener("keydown", this._onInputKeyDownBound);
            _super.prototype.onElementAttached.call(this, element, before, after);
        };
        UtilInputTextArea.prototype.onElementDetached = function (element, before, after) {
            element.removeEventListener("keydown", this._onInputKeyDownBound);
            _super.prototype.onElementDetached.call(this, element, before, after);
        };
        UtilInputTextArea.prototype.onInputKeyDown = function (e) {
            if (UtilKeyboardEvent.isOkKey(e)) {
                this._operation.onEnter();
            }
        };
        return UtilInputTextArea;
    }(UtilInput));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var UtilName = /** @class */ (function () {
        function UtilName() {
        }
        UtilName.create = function (type) {
            var mapping = this._mapping;
            if (type in mapping) {
                return "".concat(type, " ").concat(++mapping[type]);
            }
            else {
                mapping[type] = 1;
                return "".concat(type, " 1");
            }
        };
        UtilName._mapping = {};
        return UtilName;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var UtilRgba = /** @class */ (function () {
        function UtilRgba() {
        }
        UtilRgba.toCode = function (color, alpha) {
            var r = (color >> 16) & 0xff;
            var g = (color >> 8) & 0xff;
            var b = color & 0xff;
            return "rgba(".concat(r, ",").concat(g, ",").concat(b, ",").concat(alpha, ")");
        };
        return UtilRgba;
    }());

    var UtilStateBlinker = /** @class */ (function () {
        function UtilStateBlinker(state, delay, interval) {
            var _this = this;
            this._targets = new Set();
            this._state = state;
            this._delay = delay;
            this._interval = interval;
            this._timeout = null;
            this._updateBound = function () {
                _this.update();
            };
        }
        UtilStateBlinker.prototype.start = function () {
            if (this._timeout == null) {
                this._timeout = window.setTimeout(this._updateBound, this._delay);
            }
            return this;
        };
        UtilStateBlinker.prototype.stop = function () {
            var timeout = this._timeout;
            if (timeout != null) {
                this._timeout = null;
                clearTimeout(timeout);
            }
            return this;
        };
        UtilStateBlinker.prototype.add = function (target) {
            this._targets.add(target);
            target.state.set(this._state, this.isOn(Date.now()));
            return this;
        };
        UtilStateBlinker.prototype.remove = function (target) {
            if (this._targets.delete(target)) {
                target.state.remove(this._state);
                return true;
            }
            return false;
        };
        UtilStateBlinker.prototype.contains = function (target) {
            return this._targets.has(target);
        };
        UtilStateBlinker.prototype.clear = function () {
            this._targets.clear();
            return this;
        };
        UtilStateBlinker.prototype.isOn = function (time) {
            return Math.floor(time / this._interval) % 2 === 0;
        };
        UtilStateBlinker.prototype.update = function () {
            var now = Date.now();
            var isOn = this.isOn(now);
            var state = this._state;
            this._targets.forEach(function (target) {
                target.state.set(state, isOn);
            });
            var interval = this._interval;
            this._timeout = window.setTimeout(this._updateBound, interval - (now % interval));
            return this;
        };
        return UtilStateBlinker;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var UtilTransition = /** @class */ (function () {
        function UtilTransition(options) {
            var _a;
            this._duration = (_a = options === null || options === void 0 ? void 0 : options.duration) !== null && _a !== void 0 ? _a : 300;
            this._current = null;
            this._lastUpdate = 0;
            this._updateId = null;
        }
        UtilTransition.prototype.show = function (next, forcibly) {
            var _this = this;
            var updateId = this._updateId;
            if (updateId != null) {
                clearTimeout(updateId);
            }
            var current = this._current;
            if (next !== current) {
                var duration = this._duration;
                var lastUpdate = this._lastUpdate;
                var now = Date.now();
                var remaining = lastUpdate + duration - now;
                if (forcibly === true || remaining <= 0) {
                    this.update(now, next);
                }
                else {
                    this._updateId = window.setTimeout(function () {
                        _this.update(Date.now(), next);
                    }, remaining);
                }
            }
        };
        UtilTransition.prototype.update = function (now, next) {
            var current = this._current;
            if (current !== next) {
                this._lastUpdate = now;
                if (current != null) {
                    current.hide();
                }
                this._current = next;
                if (next != null) {
                    next.show();
                }
            }
        };
        UtilTransition.prototype.hide = function () {
            this.show(null);
        };
        return UtilTransition;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /*!
     * jQuery Mousewheel 3.1.13
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license
     * http://jquery.org/license
     *
     * See also https://github.com/mapbox/mapbox-gl-js/blob/001c7b9/js/ui/handler/scroll_zoom.js
     * and https://github.com/openlayers/openlayers/blob/v5.2.0/src/ol/interaction/MouseWheelZoom.js#L51
     */
    var UtilWheelEvent = /** @class */ (function () {
        function UtilWheelEvent() {
            this._lowest = null;
            this._timestamp = 0;
            this._lineHeight = null;
            this._pageHeight = null;
        }
        UtilWheelEvent.prototype.getNames = function () {
            var result = this._names;
            if (result == null) {
                if ("onwheel" in document || 9 <= document.documentMode) {
                    result = ["wheel"];
                }
                else {
                    result = ["mousewheel", "DOMMouseScroll", "MozMousePixelScroll"];
                }
                this._names = result;
            }
            return result;
        };
        UtilWheelEvent.prototype.on = function (target, handler, useCapture) {
            if (useCapture === void 0) { useCapture = false; }
            var names = this.getNames();
            for (var i = names.length - 1; 0 <= i; --i) {
                var name_1 = names[i];
                target.addEventListener(name_1, handler, useCapture);
            }
        };
        UtilWheelEvent.prototype.off = function (target, handler, useCapture) {
            if (useCapture === void 0) { useCapture = false; }
            var names = this.getNames();
            for (var i = names.length - 1; 0 <= i; --i) {
                var name_2 = names[i];
                target.removeEventListener(name_2, handler, useCapture);
            }
        };
        UtilWheelEvent.prototype.getLineHeight = function () {
            if (this._lineHeight == null) {
                var theme = DThemes.getInstance().get("DBase");
                this._lineHeight = theme.getLineHeight();
            }
            return this._lineHeight;
        };
        UtilWheelEvent.prototype.getPageHeight = function () {
            if (this._pageHeight == null) {
                this._pageHeight = this.getLineHeight() * 12;
            }
            return this._pageHeight;
        };
        UtilWheelEvent.prototype.normalize = function (e) {
            var deltaX = 0;
            var deltaY = 0;
            // Old school scrollwheel delta
            if ("detail" in e) {
                deltaY = e.detail * -1;
            }
            if ("wheelDelta" in e) {
                deltaY = e.wheelDelta;
            }
            if ("wheelDeltaY" in e) {
                deltaY = e.wheelDeltaY;
            }
            if ("wheelDeltaX" in e) {
                deltaX = e.wheelDeltaX * -1;
            }
            // Firefox < 17 horizontal scrolling related to DOMMouseScroll event
            if ("axis" in e && e.axis === e.HORIZONTAL_AXIS) {
                deltaX = deltaY * -1;
                deltaY = 0;
            }
            // New school wheel delta (wheel event)
            if ("deltaY" in e) {
                deltaY = e.deltaY * -1;
            }
            if ("deltaX" in e) {
                deltaX = e.deltaX;
            }
            // No change actually happened, no reason to go any further
            if (deltaY === 0 && deltaX === 0) {
                return null;
            }
            // Store lowest absolute delta to normalize the delta values
            var delta = Math.max(Math.abs(deltaY), Math.abs(deltaX));
            // Reset the this._lowest to better handle multiple device types
            // that give different a different lowestDelta
            // Ex: trackpad = 3 and mouse wheel = 120
            var now = Date.now();
            if (this._timestamp + 200 <= now) {
                this._lowest = null;
            }
            this._timestamp = now;
            //
            var shouldAdjust = e.type === "mousewheel" && delta % 120 === 0;
            if (!this._lowest || delta < this._lowest) {
                this._lowest = delta;
                // Adjust older deltas if necessary
                if (shouldAdjust) {
                    this._lowest /= 40;
                }
            }
            // Adjust older deltas if necessary
            if (shouldAdjust) {
                // Divide all the things by 40!
                delta /= 40;
                deltaX /= 40;
                deltaY /= 40;
            }
            // Get a whole, normalized value for the deltas
            var lowest = this._lowest;
            delta = Math.floor(delta / lowest);
            deltaX = Math[1 <= deltaX ? "floor" : "ceil"](deltaX / lowest);
            deltaY = Math[1 <= deltaY ? "floor" : "ceil"](deltaY / lowest);
            // Mode
            var mode = e.deltaMode || 0;
            if (mode !== 0) {
                var scale = mode === 1 ? this.getLineHeight() : this.getPageHeight();
                delta *= scale;
                deltaX *= scale;
                deltaY *= scale;
            }
            return {
                mode: mode,
                delta: delta,
                deltaX: deltaX,
                deltaY: deltaY,
                lowest: lowest
            };
        };
        UtilWheelEvent.getInstance = function () {
            if (this.INSTANCE == null) {
                this.INSTANCE = new UtilWheelEvent();
            }
            return this.INSTANCE;
        };
        return UtilWheelEvent;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DAnimationEmpty = /** @class */ (function (_super) {
        __extends(DAnimationEmpty, _super);
        function DAnimationEmpty(options) {
            var _a;
            var _this = _super.call(this) || this;
            _this._target = (_a = options === null || options === void 0 ? void 0 : options.target) !== null && _a !== void 0 ? _a : null;
            _this._reverse = false;
            _this._isStarted = false;
            _this._onTime = options === null || options === void 0 ? void 0 : options.onTime;
            _this._onStart = options === null || options === void 0 ? void 0 : options.onStart;
            _this._onEnd = options === null || options === void 0 ? void 0 : options.onEnd;
            return _this;
        }
        Object.defineProperty(DAnimationEmpty.prototype, "target", {
            get: function () {
                return this._target;
            },
            set: function (target) {
                this._target = target;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DAnimationEmpty.prototype, "duration", {
            get: function () {
                return 0;
            },
            set: function (duration) {
                // DO NOTHING
            },
            enumerable: false,
            configurable: true
        });
        DAnimationEmpty.prototype.start = function (reverse) {
            if (reverse === void 0) { reverse = false; }
            this.stop();
            this._isStarted = true;
            this._reverse = reverse;
            // onStart
            this.onStart(reverse);
            if (!this._isStarted) {
                return;
            }
            // onTime
            this.onTime(reverse ? 1 : 0, reverse, 0);
            if (!this._isStarted) {
                return;
            }
            this.onTime(reverse ? 0 : 1, reverse, 0);
            if (this._isStarted) {
                return;
            }
            // OnEnd
            this.onEnd(reverse);
        };
        DAnimationEmpty.prototype.onStart = function (isReverse) {
            var onStart = this._onStart;
            if (onStart != null) {
                onStart(isReverse, this);
            }
            this.emit("start", isReverse, this);
        };
        DAnimationEmpty.prototype.onTime = function (time, isReverse, elapsedTime) {
            var onTime = this._onTime;
            if (onTime != null) {
                onTime(time, isReverse, elapsedTime, this);
            }
            this.emit("time", time, isReverse, elapsedTime, this);
        };
        DAnimationEmpty.prototype.onEnd = function (isReverse) {
            var onEnd = this._onEnd;
            if (onEnd != null) {
                onEnd(isReverse, this);
            }
            this.emit("end", isReverse, this);
        };
        DAnimationEmpty.prototype.isStarted = function () {
            return this._isStarted;
        };
        DAnimationEmpty.prototype.isReverse = function () {
            return this._reverse;
        };
        DAnimationEmpty.prototype.stop = function () {
            this._isStarted = false;
        };
        DAnimationEmpty.prototype.end = function () {
            var isStarted = this._isStarted;
            if (isStarted) {
                this._isStarted = false;
                // OnTime
                var reverse = this._reverse;
                var time = reverse ? 0 : 1;
                this.onTime(time, reverse, 0);
                // OnEnd
                this.onEnd(reverse);
            }
        };
        return DAnimationEmpty;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DAnimationFadeIn = /** @class */ (function (_super) {
        __extends(DAnimationFadeIn, _super);
        function DAnimationFadeIn(options) {
            var _a, _b;
            var _this = _super.call(this, options) || this;
            _this._storedX = 0;
            _this._storedY = 0;
            _this._storedAlpha = 0;
            _this._storedTime = 0;
            _this._storedTarget = null;
            _this._layer = null;
            // Shifts
            var shift = options === null || options === void 0 ? void 0 : options.shift;
            _this._shiftX = (_a = shift === null || shift === void 0 ? void 0 : shift.x) !== null && _a !== void 0 ? _a : 0;
            _this._shiftY = (_b = shift === null || shift === void 0 ? void 0 : shift.y) !== null && _b !== void 0 ? _b : 15;
            _this._onPrerenderBound = function () {
                _this.onPrerender();
            };
            _this._onPostrenderBound = function () {
                _this.onPostrender();
            };
            return _this;
        }
        DAnimationFadeIn.prototype.stop = function () {
            this._storedTime = 0;
            this.removeEventListeners();
            _super.prototype.stop.call(this);
        };
        DAnimationFadeIn.prototype.addEventListeners = function (target) {
            var layer = DApplications.getLayer(target);
            if (layer) {
                this._layer = layer;
                var renderer = layer.renderer;
                renderer.on("prerender", this._onPrerenderBound);
                renderer.on("postrender", this._onPostrenderBound);
            }
        };
        DAnimationFadeIn.prototype.removeEventListeners = function () {
            var layer = this._layer;
            if (layer) {
                this._layer = null;
                var renderer = layer.renderer;
                renderer.off("prerender", this._onPrerenderBound);
                renderer.off("postrender", this._onPostrenderBound);
            }
        };
        DAnimationFadeIn.prototype.onStart = function (isReverse) {
            var target = (this._storedTarget = this._target);
            if (target != null) {
                this._storedTime = 0;
                this.removeEventListeners();
                this.addEventListeners(target);
                if (!isReverse) {
                    target.visible = true;
                }
                _super.prototype.onStart.call(this, isReverse);
            }
        };
        DAnimationFadeIn.prototype.onTime = function (time, isReverse, elapsedTime) {
            var target = this._storedTarget;
            if (target != null) {
                var layer = this._layer;
                if (layer) {
                    this._storedTime = time;
                    _super.prototype.onTime.call(this, time, isReverse, elapsedTime);
                    layer.update();
                }
                else {
                    this._storedTime = time;
                    _super.prototype.onTime.call(this, time, isReverse, elapsedTime);
                }
            }
        };
        DAnimationFadeIn.prototype.onEnd = function (isReverse) {
            var target = this._storedTarget;
            if (target != null) {
                this.removeEventListeners();
                if (isReverse) {
                    target.visible = false;
                }
                _super.prototype.onEnd.call(this, isReverse);
            }
        };
        DAnimationFadeIn.prototype.onPrerender = function () {
            var target = this._storedTarget;
            if (target != null) {
                var storedTime = this._storedTime;
                // Position
                var position = target.unsafe.position;
                this._storedX = position.x;
                this._storedY = position.y;
                position.set(position.x - this._shiftX * (1 - storedTime), position.y - this._shiftY * (1 - storedTime));
                // Alpha
                this._storedAlpha = target.alpha;
                target.alpha = storedTime;
            }
        };
        DAnimationFadeIn.prototype.onPostrender = function () {
            var target = this._storedTarget;
            if (target != null) {
                // Position
                var position = target.unsafe.position;
                position.set(this._storedX, this._storedY);
                // Alpha
                target.alpha = this._storedAlpha;
            }
        };
        return DAnimationFadeIn;
    }(DAnimationBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DApplicationPadding = /** @class */ (function () {
        function DApplicationPadding(padding) {
            var _a, _b, _c, _d;
            if (isNumber(padding)) {
                this.top = padding;
                this.right = padding;
                this.bottom = padding;
                this.left = padding;
            }
            else if (padding != null) {
                this.top = (_a = padding.top) !== null && _a !== void 0 ? _a : 6;
                this.right = (_b = padding.right) !== null && _b !== void 0 ? _b : 6;
                this.bottom = (_c = padding.bottom) !== null && _c !== void 0 ? _c : 6;
                this.left = (_d = padding.left) !== null && _d !== void 0 ? _d : 6;
            }
            else {
                this.top = 6;
                this.right = 6;
                this.bottom = 6;
                this.left = 6;
            }
        }
        DApplicationPadding.prototype.getTheme = function () {
            throw new Error("Not supported");
        };
        DApplicationPadding.prototype.setTheme = function (theme) {
            throw new Error("Not supported");
        };
        DApplicationPadding.prototype.getTop = function () {
            return this.left;
        };
        DApplicationPadding.prototype.getRight = function () {
            return this.right;
        };
        DApplicationPadding.prototype.getBottom = function () {
            return this.bottom;
        };
        DApplicationPadding.prototype.getLeft = function () {
            return this.left;
        };
        DApplicationPadding.prototype.set = function (top, right, bottom, left) {
            if (right == null) {
                this.top = top;
                this.right = top;
                this.bottom = top;
                this.left = top;
            }
            else if (bottom == null) {
                this.top = top;
                this.right = right;
                this.bottom = top;
                this.left = right;
            }
            else if (left == null) {
                this.top = top;
                this.right = right;
                this.bottom = bottom;
                this.left = right;
            }
            else {
                this.top = top;
                this.right = right;
                this.bottom = bottom;
                this.left = left;
            }
        };
        return DApplicationPadding;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * DApplicationLayer options
     */
    var DApplicationLayerOptions = /** @class */ (function () {
        function DApplicationLayerOptions(options) {
            var _a;
            // Root
            var root = options.root;
            this._root = root;
            // Overlay mode or not
            this._overlay = options.overlay;
            // Padding
            this._padding = new DApplicationPadding(options === null || options === void 0 ? void 0 : options.padding);
            // Width & height
            var width = 100;
            var height = 100;
            if (options) {
                if (options.width != null) {
                    width = options.width;
                    if (options.height != null) {
                        height = options.height;
                    }
                    else {
                        height = root.getBoundingClientRect().height;
                    }
                }
                else if (options.height != null) {
                    width = root.getBoundingClientRect().width;
                    height = options.height;
                }
                else {
                    var bbox = root.getBoundingClientRect();
                    width = bbox.width;
                    height = bbox.height;
                }
            }
            else {
                var bbox = root.getBoundingClientRect();
                width = bbox.width;
                height = bbox.height;
            }
            this._isWidthFixed = options.width != null;
            this._isHeightFixed = options.height != null;
            // Background color
            var background = options === null || options === void 0 ? void 0 : options.background;
            var backgroundColor = 0;
            var transparent = true;
            if (background != null) {
                var color = background.color;
                if (color != null) {
                    backgroundColor = color;
                    transparent = false;
                }
            }
            // Resolution
            var resolution = options.resolution;
            // Antialias
            var antialias = (_a = options === null || options === void 0 ? void 0 : options.antialias) !== null && _a !== void 0 ? _a : false;
            // Pixi
            this._pixi = {
                width: width,
                height: height,
                autoStart: false,
                backgroundColor: backgroundColor,
                transparent: transparent,
                resolution: resolution,
                antialias: antialias
            };
        }
        /**
         * Returns a root element.
         * `HTMLCanvasElement` and other DOM elements are created in this element.
         * The default root element is `document.body`.
         */
        DApplicationLayerOptions.prototype.getRootElement = function () {
            return this._root;
        };
        /**
         * Sets a root element and updates the canvas width and height
         * if `updateWidthAndHeight` is not false.
         *
         * @param root new root element
         * @param updateWidthAndHeight false to preserve the canvas width / height
         */
        DApplicationLayerOptions.prototype.setRootElement = function (root, updateWidthAndHeight) {
            if (this._root !== root) {
                this._root = root;
                if (updateWidthAndHeight !== false) {
                    var bbox = root.getBoundingClientRect();
                    var pixi = this._pixi;
                    pixi.width = bbox.width;
                    pixi.height = bbox.height;
                }
            }
            return this;
        };
        /**
         * Returns a canvas width.
         */
        DApplicationLayerOptions.prototype.getWidth = function () {
            return this._pixi.width;
        };
        /**
         * Sets a canvas width.
         *
         * @param width new canvas width
         */
        DApplicationLayerOptions.prototype.setWidth = function (width) {
            this._pixi.width = width;
            return this;
        };
        /**
         * Returns true if the width is fixed.
         *
         * @returns true if the width is fixed.
         */
        DApplicationLayerOptions.prototype.isWidthFixed = function () {
            return this._isWidthFixed;
        };
        /**
         * Makes the canvas width fixed.
         *
         * @param fixed true to make the canvas width fixed
         */
        DApplicationLayerOptions.prototype.setWidthFixed = function (fixed) {
            this._isWidthFixed = fixed;
            return this;
        };
        /**
         * Returns a canvas height.
         */
        DApplicationLayerOptions.prototype.getHeight = function () {
            return this._pixi.height;
        };
        /**
         * Sets a canvas height.
         *
         * @param height new canvas height
         */
        DApplicationLayerOptions.prototype.setHeight = function (height) {
            this._pixi.height = height;
            return this;
        };
        /**
         * Returns true if the height is fixed.
         *
         * @returns true if the height is fixed.
         */
        DApplicationLayerOptions.prototype.isHeightFixed = function () {
            return this._isHeightFixed;
        };
        /**
         * Makes the canvas height fixed.
         *
         * @param fixed true to make the canvas height fixed
         */
        DApplicationLayerOptions.prototype.setHeightFixed = function (fixed) {
            this._isHeightFixed = fixed;
            return this;
        };
        /**
         * Returns padding sizes.
         * The default padding size is 6.
         */
        DApplicationLayerOptions.prototype.getPadding = function () {
            return this._padding;
        };
        /**
         * Sets padding sizes.
         *
         * @param left new left padding
         * @param top new top padding
         * @param right new right padding
         * @param bottom new bottom padding
         */
        DApplicationLayerOptions.prototype.setPadding = function (left, top, right, bottom) {
            var padding = this._padding;
            padding.left = left;
            padding.top = top;
            padding.right = right;
            padding.bottom = bottom;
            return this;
        };
        /**
         * Returns a background color.
         */
        DApplicationLayerOptions.prototype.getBackgroundColor = function () {
            return this._pixi.backgroundColor;
        };
        /**
         * Sets a background color.
         *
         * @param color new background color
         */
        DApplicationLayerOptions.prototype.setBackgroundColor = function (color) {
            this._pixi.backgroundColor = color;
            return this;
        };
        /**
         * Returns an antialias setting.
         * The default antialias setting is false.
         */
        DApplicationLayerOptions.prototype.getAntialias = function () {
            return this._pixi.antialias;
        };
        /**
         * Sets an antialias setting.
         *
         * @param antialias new antialias setting
         */
        DApplicationLayerOptions.prototype.setAntialias = function (antialias) {
            this._pixi.antialias = antialias;
            return this;
        };
        /**
         * Returns true if a layer is supposed to be an overlay layer.
         */
        DApplicationLayerOptions.prototype.isOverlay = function () {
            return this._overlay;
        };
        DApplicationLayerOptions.prototype.getPixiApplicationOptions = function () {
            return this._pixi;
        };
        return DApplicationLayerOptions;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DCommandBase = /** @class */ (function () {
        function DCommandBase() {
        }
        DCommandBase.prototype.isStorable = function () {
            return true;
        };
        DCommandBase.prototype.isClear = function () {
            return false;
        };
        DCommandBase.prototype.isClean = function () {
            return false;
        };
        DCommandBase.prototype.execute = function () {
            return true;
        };
        DCommandBase.prototype.merge = function (target) {
            return false;
        };
        DCommandBase.prototype.isMerged = function () {
            return false;
        };
        DCommandBase.prototype.redo = function () {
            return true;
        };
        DCommandBase.prototype.undo = function () {
            return true;
        };
        DCommandBase.prototype.destroy = function () {
            // DO NOTHING
        };
        return DCommandBase;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DCommandClear = /** @class */ (function (_super) {
        __extends(DCommandClear, _super);
        function DCommandClear() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DCommandClear.prototype.isStorable = function () {
            return false;
        };
        DCommandClear.prototype.isClear = function () {
            return true;
        };
        return DCommandClear;
    }(DCommandBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DControllerCommandImpl = /** @class */ (function (_super) {
        __extends(DControllerCommandImpl, _super);
        function DControllerCommandImpl() {
            var _this = _super.call(this) || this;
            _this._position = 0;
            _this._done = [];
            return _this;
        }
        DControllerCommandImpl.prototype.last = function () {
            var done = this._done;
            var doneLength = done.length;
            if (0 < doneLength) {
                return done[doneLength - 1];
            }
            else {
                return null;
            }
        };
        DControllerCommandImpl.prototype.push = function (command) {
            this.merge(command);
            this.execute(command);
        };
        DControllerCommandImpl.prototype.merge = function (command) {
            var done = this._done;
            var isClear = command.isClear();
            var isStorable = command.isStorable();
            if (isClear || isStorable) {
                var size = isClear ? done.length : this._position;
                if (0 < size) {
                    this.remove(size);
                    this._position = 0;
                    this.emit("change", this);
                }
                this.cleanup();
            }
            var doneLength = done.length;
            if (0 < doneLength) {
                command.merge(done[doneLength - 1]);
            }
        };
        DControllerCommandImpl.prototype.execute = function (command) {
            this.emit("executing", command, this);
            if (command.execute()) {
                return this.onSuccess(command);
            }
            else {
                return this.onFail(command);
            }
        };
        DControllerCommandImpl.prototype.onSuccess = function (command) {
            if (command.isStorable()) {
                if (!command.isMerged()) {
                    this._done.push(command);
                }
                if (!command.isClean()) {
                    this.emit("dirty", this);
                }
            }
            this.emit("change", this);
            this.emit("executed", command, this);
        };
        DControllerCommandImpl.prototype.onFail = function (command) {
            command.destroy();
            this.emit("change", this);
        };
        DControllerCommandImpl.prototype.cleanup = function () {
            var done = this._done;
            var size = done.length - 100;
            if (0 < size) {
                for (var i = 0; i < size; ++i) {
                    done[i].destroy();
                    done.shift();
                }
            }
        };
        DControllerCommandImpl.prototype.remove = function (size) {
            var done = this._done;
            if (0 < size) {
                var ifrom = Math.max(0, done.length - size);
                size = done.length - ifrom;
                if (0 < size) {
                    for (var i = ifrom, imax = done.length; i < imax; ++i) {
                        done[i].destroy();
                    }
                    done.splice(ifrom, done.length - ifrom);
                    return true;
                }
            }
            return false;
        };
        DControllerCommandImpl.prototype.size = function () {
            return this._done.length;
        };
        DControllerCommandImpl.prototype.clear = function () {
            this.push(new DCommandClear());
        };
        DControllerCommandImpl.prototype.redo = function () {
            if (this.isRedoable()) {
                this.doRedo();
            }
        };
        DControllerCommandImpl.prototype.doRedo = function () {
            var done = this._done;
            if (0 < this._position) {
                var current = done[done.length - this._position];
                this._position -= 1;
                this.emit("change", this);
                this.emit("redoing", current, this);
                var result = current.redo();
                if (result === true) {
                    this.onRedoSuccess(current);
                }
                else {
                    this.onRedoFail(current);
                }
            }
        };
        DControllerCommandImpl.prototype.onRedoSuccess = function (redoed) {
            if (!redoed.isClean()) {
                this.emit("dirty", this);
            }
            this.emit("change", this);
            this.emit("redoed", redoed, this);
        };
        DControllerCommandImpl.prototype.onRedoFail = function (command) {
            this.emit("change", this);
        };
        DControllerCommandImpl.prototype.isRedoable = function () {
            return 0 < this._position;
        };
        DControllerCommandImpl.prototype.undo = function () {
            if (this.isUndoable()) {
                this.doUndo();
            }
        };
        DControllerCommandImpl.prototype.doUndo = function () {
            var done = this._done;
            if (this._position < done.length) {
                var current = done[done.length - 1 - this._position];
                this._position += 1;
                this.emit("change", this);
                this.emit("undoing", current, this);
                var result = current.undo();
                if (result === true) {
                    this.onUndoSuccess(current);
                }
                else {
                    this.onUndoFail(current);
                }
            }
        };
        DControllerCommandImpl.prototype.onUndoSuccess = function (undoed) {
            if (!undoed.isClean()) {
                this.emit("dirty", this);
            }
            this.emit("change", this);
            this.emit("undoed", undoed, this);
        };
        DControllerCommandImpl.prototype.onUndoFail = function (command) {
            this.emit("change", this);
        };
        DControllerCommandImpl.prototype.isUndoable = function () {
            return this._position < this._done.length;
        };
        return DControllerCommandImpl;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DControllerKeyboardImpl = /** @class */ (function (_super) {
        __extends(DControllerKeyboardImpl, _super);
        function DControllerKeyboardImpl() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DControllerKeyboardImpl.prototype.init = function (element, stage, focusController) {
            var _this = this;
            element.addEventListener("keydown", function (e) {
                _this.emit("keydown", e);
                var focused = focusController.get();
                if (focused != null) {
                    var current = focused;
                    while (current != null) {
                        if (_this.hasOnKeyDown(current)) {
                            if (current.onKeyDown(e)) {
                                return;
                            }
                        }
                        current = current.parent;
                    }
                }
                if (UtilKeyboardEvent.isFocusKey(e)) {
                    var direction = UtilKeyboardEvent.getFocusDirection(e);
                    var next = focused != null
                        ? focusController.find(focused, false, focused.state.isFocusRoot || direction, direction)
                        : focusController.find(stage, false, true, direction);
                    if (next != null) {
                        focusController.focus(next);
                        e.preventDefault();
                        e.stopImmediatePropagation();
                    }
                }
            });
            element.addEventListener("keyup", function (e) {
                _this.emit("keyup", e);
                var focused = focusController.get();
                if (focused != null) {
                    var current = focused;
                    while (current != null) {
                        if (_this.hasOnKeyUp(current)) {
                            if (current.onKeyUp(e)) {
                                return;
                            }
                        }
                        current = current.parent;
                    }
                }
            });
        };
        DControllerKeyboardImpl.prototype.hasOnKeyDown = function (target) {
            return "onKeyDown" in target;
        };
        DControllerKeyboardImpl.prototype.hasOnKeyUp = function (target) {
            return "onKeyUp" in target;
        };
        return DControllerKeyboardImpl;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DControllers = /** @class */ (function () {
        function DControllers() {
        }
        // Keyboard
        DControllers.getKeyboardController = function () {
            if (this.KEYBOARD == null) {
                this.KEYBOARD = new DControllerKeyboardImpl();
            }
            return this.KEYBOARD;
        };
        DControllers.setKeyboardController = function (instance) {
            var result = this.KEYBOARD;
            this.KEYBOARD = instance;
            return result;
        };
        // Command
        DControllers.getCommandController = function () {
            if (this.COMMAND == null) {
                this.COMMAND = new DControllerCommandImpl();
            }
            return this.COMMAND;
        };
        DControllers.setCommandController = function (instance) {
            var result = this.COMMAND;
            this.COMMAND = instance;
            return result;
        };
        // Document
        DControllers.getDocumentController = function () {
            if (this.DOCUMENT == null) {
                throw new Error("Not supported");
            }
            return this.DOCUMENT;
        };
        DControllers.setDocumentController = function (instance) {
            var result = this.DOCUMENT;
            this.DOCUMENT = instance;
            return result;
        };
        return DControllers;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var isDblClickable = function (target) {
        return target != null && target.onDblClick != null;
    };
    var isWheelable = function (target) {
        return target != null && target.onWheel != null;
    };
    var DApplicationLayer = /** @class */ (function (_super) {
        __extends(DApplicationLayer, _super);
        function DApplicationLayer(application, options) {
            var _this = _super.call(this, options.getPixiApplicationOptions()) || this;
            _this._renderId = null;
            _this._dynamicFontAtlases = null;
            _this._options = options;
            _this._isLocked = false;
            _this._isVisible = true;
            _this._isOverlay = options.isOverlay();
            _this._padding = options.getPadding();
            _this._rootElement = options.getRootElement();
            _this._reflowLimit = 5;
            _this._elementContainer = _this.newElementContainer();
            _this.application = application;
            _this._renderBound = function () {
                if (_this._renderId != null) {
                    _this.render();
                }
            };
            _this.initStage();
            _this.initView();
            _this.initRootElement();
            _this.initFocusHandling();
            _this.initResizeHandling();
            _this.initWheelHandling();
            _this.initDoubleClickHandling();
            return _this;
        }
        DApplicationLayer.prototype.newElementContainer = function () {
            var result = document.createElement("div");
            result.setAttribute("style", "position: absolute; top: 0; left: 0; width: 0; height: 0;" +
                "margin: 0; padding: 0; outline: none;");
            return result;
        };
        DApplicationLayer.prototype.initStage = function () {
            var stage = this.stage;
            stage.layer = this;
            stage.application = this.application;
            stage.interactive = true;
        };
        DApplicationLayer.prototype.initView = function () {
            var view = this.view;
            var style = view.style;
            style.position = "absolute";
            style.top = "0";
            style.left = "0";
            style.width = "100%";
            style.height = "100%";
            style.display = "block";
            style.outline = "none";
            style.webkitTapHighlightColor = "rgba(255,255,255,0)";
            style.webkitUserSelect = "none";
            style.setProperty("-khtml-user-select", "none");
            style.setProperty("-moz-user-select", "none");
            style.setProperty("-ms-user-select", "none");
            style.userSelect = "none";
        };
        DApplicationLayer.prototype.initRootElement = function () {
            var _this = this;
            var view = this.view;
            var isOverlay = this._isOverlay;
            var rootElement = this._rootElement;
            var elementContainer = this._elementContainer;
            // Insert elements
            var insertionPosition = isOverlay ? 2 : 0;
            var children = rootElement.children;
            if (insertionPosition < children.length) {
                var child = children[insertionPosition];
                rootElement.insertBefore(view, child);
                rootElement.insertBefore(elementContainer, child);
            }
            else {
                rootElement.appendChild(view);
                rootElement.appendChild(elementContainer);
            }
            if (isOverlay) {
                var stage_1 = this.stage;
                var oldOnChildrenChange_1 = stage_1.onChildrenChange;
                stage_1.onChildrenChange = function () {
                    _this.onStageDirty();
                    oldOnChildrenChange_1.call(stage_1);
                };
            }
            // Init styles
            var rootElementStyle = rootElement.style;
            if (rootElement !== document.body) {
                var rootElementStylePosition = window.getComputedStyle(rootElement).position;
                if (rootElementStylePosition === "static") {
                    rootElementStyle.position = "relative";
                }
            }
            rootElementStyle.margin = "0";
            rootElementStyle.padding = "0";
            rootElementStyle.overflow = "hidden";
        };
        DApplicationLayer.prototype.initFocusHandling = function () {
            var view = this.view;
            var stage = this.stage;
            var focusController = this.getFocusController();
            view.setAttribute("tabindex", "0");
            DControllers.getKeyboardController().init(view, stage, focusController);
            var interactionManager = this.renderer.plugins.interaction;
            interactionManager.on(UtilPointerEvent.down, function (e) {
                if (e.target == null || e.target === stage) {
                    focusController.clear();
                }
            });
        };
        DApplicationLayer.prototype.initResizeHandling = function () {
            var _this = this;
            var options = this._options;
            var isWidthFixed = options.isWidthFixed();
            var isHeightFixed = options.isHeightFixed();
            if (!isWidthFixed || !isHeightFixed) {
                var onResizeBound = function () {
                    _this.onResize();
                };
                if (window.ResizeObserver != null) {
                    new ResizeObserver(onResizeBound).observe(this._rootElement);
                }
                else {
                    window.addEventListener("resize", onResizeBound);
                    window.addEventListener("orientationchange", onResizeBound);
                }
            }
        };
        DApplicationLayer.prototype.onResize = function () {
            var options = this._options;
            var bboxes = this._rootElement.getClientRects();
            if (bboxes.length <= 0) {
                // The root element size is (0, 0) and not visible.
                // In this case, skip the resizing.
                return;
            }
            var bbox = bboxes[0];
            var newWidth = options.isWidthFixed() ? options.getWidth() : bbox.width;
            var newHeight = options.isHeightFixed() ? options.getHeight() : bbox.height;
            this.renderer.resize(newWidth, newHeight);
            var wasLocked = this._isLocked;
            this._isLocked = true;
            var padding = this._padding;
            var children = this.stage.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                var child = children[i];
                if (child instanceof DBase) {
                    child.onParentResize(newWidth, newHeight, padding);
                }
            }
            this._isLocked = wasLocked;
            if (!this._isLocked && this._renderId == null) {
                this.render();
            }
        };
        DApplicationLayer.prototype.initWheelHandling = function () {
            var global = new pixi_js.Point();
            var util = UtilWheelEvent.getInstance();
            var interactionManager = this.renderer.plugins.interaction;
            util.on(this.view, function (e) {
                var wheelEvent = e;
                UtilPointerEvent.toGlobal(wheelEvent, interactionManager, global);
                var current = interactionManager.hitTest(global);
                var deltas = util.normalize(e);
                if (deltas != null) {
                    while (current != null) {
                        if (isWheelable(current)) {
                            if (current.onWheel(wheelEvent, deltas, global)) {
                                wheelEvent.preventDefault();
                                break;
                            }
                        }
                        current = current.parent;
                    }
                }
            });
        };
        DApplicationLayer.prototype.initDoubleClickHandling = function () {
            var focusController = this.getFocusController();
            var interactionManager = this.renderer.plugins.interaction;
            UtilPointerEvent.onDblClick(this.view, function (e) {
                var focused = focusController.get();
                if (focused != null) {
                    var current = focused;
                    while (current != null) {
                        if (isDblClickable(current)) {
                            if (current.onDblClick(e, interactionManager)) {
                                break;
                            }
                        }
                        current = current.parent;
                    }
                }
            });
        };
        DApplicationLayer.prototype.lock = function () {
            this._isLocked = true;
        };
        DApplicationLayer.prototype.unlock = function () {
            this._isLocked = false;
        };
        DApplicationLayer.prototype.update = function () {
            if (!this._isLocked && this._renderId == null) {
                this._renderId = requestAnimationFrame(this._renderBound);
            }
        };
        DApplicationLayer.prototype.onStageDirty = function () {
            // Update the visibility if this is a overlay layer.
            if (this._isOverlay) {
                if (0 < this.stage.children.length) {
                    // There are more than one children,
                    // therefore must be visible.
                    if (!this._isVisible) {
                        this._isVisible = true;
                        this.view.style.display = "block";
                    }
                }
                else {
                    // There is no child,
                    // therefore must not be visible.
                    if (this._isVisible) {
                        this._isVisible = false;
                        this.view.style.display = "none";
                    }
                }
            }
        };
        DApplicationLayer.prototype.render = function () {
            this.reflow();
            // Please note why the following line is here.
            //
            // Before this line, the update method does not enque a rendering task
            // because `this._renderId` is not null. As a result, this prevents
            // an unintentional rendering loop caused by the refit or the reflow.
            //
            // After this line, the update method enques a rendering task.
            // Namely, in the DisplayObject#render(Renderer) method, allowed to enque
            // a rendering task. For instance, please refer to the DDiagramShape#update().
            this._renderId = null;
            // Render
            _super.prototype.render.call(this);
        };
        Object.defineProperty(DApplicationLayer.prototype, "width", {
            get: function () {
                return this.screen.width;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DApplicationLayer.prototype, "height", {
            get: function () {
                return this.screen.height;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DApplicationLayer.prototype, "padding", {
            get: function () {
                return this._padding;
            },
            enumerable: false,
            configurable: true
        });
        DApplicationLayer.prototype.reflow = function () {
            var children = this.stage.children;
            for (var ilimit = 0, limit = this._reflowLimit; ilimit < limit; ++ilimit) {
                var isDirty = false;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    var child = children[i];
                    if (child instanceof DBase) {
                        child.reflow();
                        isDirty =
                            isDirty || child.isDirty() || child.hasDirty() || child.isHierarchyDirty();
                    }
                }
                // If DBases are changed during the `reflow` process, need to reflow again.
                if (!isDirty) {
                    break;
                }
            }
        };
        DApplicationLayer.prototype.getFocusController = function () {
            return this.application.getFocusController();
        };
        DApplicationLayer.prototype.getRootElement = function () {
            return this._rootElement;
        };
        DApplicationLayer.prototype.getElementContainer = function () {
            return this._elementContainer;
        };
        DApplicationLayer.prototype.getDynamicFontAtlases = function () {
            if (this._dynamicFontAtlases == null) {
                this._dynamicFontAtlases = new DynamicFontAtlases(this);
            }
            return this._dynamicFontAtlases;
        };
        return DApplicationLayer;
    }(pixi_js.Application));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DControllerFocusImpl = /** @class */ (function (_super) {
        __extends(DControllerFocusImpl, _super);
        function DControllerFocusImpl() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._focused = null;
            return _this;
        }
        DControllerFocusImpl.prototype.focus = function (focusable) {
            var previous = this._focused;
            if (previous !== focusable) {
                if (previous != null) {
                    previous.state.isFocused = false;
                }
                this._focused = focusable;
                if (this.isFocusable(focusable)) {
                    focusable.state.isFocused = true;
                }
                this.emit("change", focusable, previous, this);
                return previous;
            }
            return null;
        };
        DControllerFocusImpl.prototype.blur = function (focusable) {
            if (focusable != null && this._focused === focusable) {
                this._focused = null;
                focusable.state.isFocused = false;
                this.emit("change", null, focusable, this);
                return focusable;
            }
            return null;
        };
        DControllerFocusImpl.prototype.clear = function () {
            return this.focus(null);
        };
        DControllerFocusImpl.prototype.set = function (focusable, isFocused) {
            if (isFocused) {
                return this.focus(focusable);
            }
            else {
                return this.blur(focusable);
            }
        };
        DControllerFocusImpl.prototype.get = function () {
            return this._focused;
        };
        DControllerFocusImpl.prototype.findParent = function (mightBeFocusable) {
            var current = mightBeFocusable;
            while (current != null) {
                if (this.isFocusable(current)) {
                    return current;
                }
                else {
                    current = current.parent;
                }
            }
            return null;
        };
        DControllerFocusImpl.prototype.find = function (target, includesTarget, includesTargetChildren, direction, root) {
            if (direction) {
                var result = this.findNext(target, includesTarget, includesTargetChildren);
                if (result != null) {
                    return result;
                }
                if (this.isFocusRoot(target, root)) {
                    return null;
                }
                var parent_1 = target.parent;
                if (parent_1 != null) {
                    var children = parent_1.children;
                    var index = children.indexOf(target);
                    if (0 <= index) {
                        var childrenLength = children.length;
                        if (this.isFocusReverse(parent_1)) {
                            for (var i = index - 1; 0 <= i; --i) {
                                var found = this.findNext(children[i], true, true);
                                if (found != null) {
                                    return found;
                                }
                            }
                            if (!this.isFocusRoot(parent_1, root)) {
                                var found = this.find(parent_1, false, false, true, root);
                                if (found != null) {
                                    return found;
                                }
                            }
                            for (var i = childrenLength - 1; index <= i; --i) {
                                var found = this.findNext(children[i], true, true);
                                if (found != null) {
                                    return found;
                                }
                            }
                        }
                        else {
                            for (var i = index + 1; i < childrenLength; ++i) {
                                var found = this.findNext(children[i], true, true);
                                if (found != null) {
                                    return found;
                                }
                            }
                            if (!this.isFocusRoot(parent_1, root)) {
                                var found = this.find(parent_1, false, false, true, root);
                                if (found != null) {
                                    return found;
                                }
                            }
                            for (var i = 0; i <= index; ++i) {
                                var found = this.findNext(children[i], true, true);
                                if (found != null) {
                                    return found;
                                }
                            }
                        }
                    }
                }
            }
            else {
                var result = this.findPrevious(target, includesTarget, includesTargetChildren);
                if (result != null) {
                    return result;
                }
                var parent_2 = target.parent;
                if (parent_2 != null) {
                    var children = parent_2.children;
                    var index = children.indexOf(target);
                    if (0 <= index) {
                        var childrenLength = children.length;
                        if (this.isFocusReverse(parent_2)) {
                            for (var i = index + 1; i < childrenLength; ++i) {
                                var found = this.findPrevious(children[i], true, true);
                                if (found != null) {
                                    return found;
                                }
                            }
                            if (!this.isFocusRoot(parent_2, root)) {
                                var found = this.find(parent_2, true, false, false, root);
                                if (found != null) {
                                    return found;
                                }
                            }
                            for (var i = 0; i <= index; ++i) {
                                var found = this.findPrevious(children[i], true, true);
                                if (found != null) {
                                    return found;
                                }
                            }
                        }
                        else {
                            for (var i = index - 1; 0 <= i; --i) {
                                var found = this.findPrevious(children[i], true, true);
                                if (found != null) {
                                    return found;
                                }
                            }
                            if (!this.isFocusRoot(parent_2, root)) {
                                var found = this.find(parent_2, true, false, false, root);
                                if (found != null) {
                                    return found;
                                }
                            }
                            for (var i = childrenLength - 1; index <= i; --i) {
                                var found = this.findPrevious(children[i], true, true);
                                if (found != null) {
                                    return found;
                                }
                            }
                        }
                    }
                }
            }
            return null;
        };
        DControllerFocusImpl.prototype.findNext = function (target, includesTarget, includesTargetChildren) {
            // Target itself
            if (includesTarget) {
                if (this.isFocusable(target)) {
                    return target;
                }
            }
            // Target children
            if (includesTargetChildren && this.isFocusableContainer(target) && target.visible) {
                var children = target.children;
                var childrenLength = children.length;
                if (this.isFocusReverse(target)) {
                    for (var i = childrenLength - 1; 0 <= i; --i) {
                        var found = this.findNext(children[i], true, true);
                        if (found != null) {
                            return found;
                        }
                    }
                }
                else {
                    for (var i = 0; i < childrenLength; ++i) {
                        var found = this.findNext(children[i], true, true);
                        if (found != null) {
                            return found;
                        }
                    }
                }
            }
            // Found nothing
            return null;
        };
        DControllerFocusImpl.prototype.findPrevious = function (target, includesTarget, includesTargetChildren) {
            // Target children
            if (includesTargetChildren && this.isFocusableContainer(target) && target.visible) {
                var children = target.children;
                var childrenLength = children.length;
                if (this.isFocusReverse(target)) {
                    for (var i = 0; i < childrenLength; ++i) {
                        var found = this.findPrevious(children[i], true, true);
                        if (found != null) {
                            return found;
                        }
                    }
                }
                else {
                    for (var i = childrenLength - 1; 0 <= i; --i) {
                        var found = this.findPrevious(children[i], true, true);
                        if (found != null) {
                            return found;
                        }
                    }
                }
            }
            // Target itself
            if (includesTarget) {
                if (this.isFocusable(target)) {
                    return target;
                }
            }
            // Found nothing
            return null;
        };
        DControllerFocusImpl.prototype.isFocusable = function (target) {
            return (target != null &&
                "state" in target &&
                target.state.inEnabled &&
                target.state.isFocusable &&
                target.visible);
        };
        DControllerFocusImpl.prototype.isFocusableContainer = function (target) {
            return target != null && "children" in target;
        };
        DControllerFocusImpl.prototype.isFocusRoot = function (target, root) {
            if (target === root) {
                return true;
            }
            return target != null && "state" in target && target.state.isFocusRoot && target.visible;
        };
        DControllerFocusImpl.prototype.isFocusReverse = function (target) {
            return target != null && "state" in target && target.state.isFocusReverse;
        };
        return DControllerFocusImpl;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DApplication = /** @class */ (function () {
        function DApplication(options) {
            var _a, _b;
            DApplications.add(this);
            // Root
            var root = this.toRootElement(options);
            this._root = root;
            this.initFocusHandling(root);
            // Resolution
            var resolution = (_b = (_a = options === null || options === void 0 ? void 0 : options.resolution) !== null && _a !== void 0 ? _a : window.devicePixelRatio) !== null && _b !== void 0 ? _b : 1;
            this._resolution = resolution;
            // Remove the accessibility plugin
            delete pixi_js.Renderer.__plugins.accessibility;
            // Options
            this._options = options;
            // Base layer
            var base = this.newLayerBase(options);
            this._base = base;
            // Overlay layer
            this._isOverlayEnabled = !!(options === null || options === void 0 ? void 0 : options.overlay);
            if (!this._isOverlayEnabled) {
                this._overlay = base;
            }
        }
        Object.defineProperty(DApplication.prototype, "stage", {
            get: function () {
                return this._base.stage;
            },
            enumerable: false,
            configurable: true
        });
        DApplication.prototype.getRootElement = function () {
            return this._root;
        };
        DApplication.prototype.getResolution = function () {
            return this._resolution;
        };
        DApplication.prototype.toRootElement = function (options) {
            var root = options === null || options === void 0 ? void 0 : options.root;
            if (root != null) {
                if (isString(root)) {
                    var found = document.querySelector(root);
                    if (found) {
                        return found;
                    }
                }
                else {
                    return root;
                }
            }
            return document.body;
        };
        DApplication.prototype.toLayerBaseOptions = function (options) {
            var root = this._root;
            var resolution = this._resolution;
            if (options) {
                return new DApplicationLayerOptions({
                    root: root,
                    padding: options.padding,
                    width: options.width,
                    height: options.height,
                    background: options.background,
                    resolution: resolution,
                    antialias: options.antialias,
                    overlay: false
                });
            }
            return new DApplicationLayerOptions({
                root: root,
                resolution: resolution,
                overlay: false
            });
        };
        DApplication.prototype.getFocusController = function () {
            if (this._focus == null) {
                this._focus = new DControllerFocusImpl();
            }
            return this._focus;
        };
        DApplication.prototype.initFocusHandling = function (root) {
            var _this = this;
            var hasFocus = false;
            var onFocus = function () {
                hasFocus = true;
            };
            var onBlured = function () {
                if (!hasFocus) {
                    _this.getFocusController().clear();
                }
            };
            var onBlur = function () {
                hasFocus = false;
                setTimeout(onBlured, 0);
            };
            root.addEventListener("focus", onFocus, true);
            root.addEventListener("blur", onBlur, true);
        };
        DApplication.prototype.newLayerBase = function (options) {
            return new DApplicationLayer(this, this.toLayerBaseOptions(options));
        };
        DApplication.prototype.getLayerBase = function () {
            return this._base;
        };
        DApplication.prototype.toLayerOverlayOptions = function (options) {
            var root = this._root;
            var resolution = this._resolution;
            if (options) {
                return new DApplicationLayerOptions({
                    root: root,
                    padding: options.padding,
                    width: options.width,
                    height: options.height,
                    background: {
                        color: null
                    },
                    resolution: resolution,
                    antialias: options.antialias,
                    overlay: true
                });
            }
            return new DApplicationLayerOptions({
                root: root,
                resolution: resolution,
                overlay: true
            });
        };
        DApplication.prototype.newLayerOverlay = function (options) {
            return new DApplicationLayer(this, this.toLayerOverlayOptions(options));
        };
        DApplication.prototype.getLayerOverlay = function () {
            if (this._isOverlayEnabled) {
                if (this._overlay == null) {
                    this._overlay = this.newLayerOverlay(this._options);
                }
                return this._overlay;
            }
            else {
                return this._base;
            }
        };
        DApplication.prototype.update = function () {
            if (this._isOverlayEnabled) {
                var base = this._base;
                base.update();
                var overlay = this._overlay;
                if (overlay) {
                    overlay.update();
                }
            }
            else {
                return this._base.update();
            }
        };
        DApplication.prototype.render = function () {
            if (this._isOverlayEnabled) {
                var base = this._base;
                base.render();
                var overlay = this._overlay;
                if (overlay) {
                    overlay.render();
                }
            }
            else {
                return this._base.render();
            }
        };
        return DApplication;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DBasePaddingAdjustable = /** @class */ (function (_super) {
        __extends(DBasePaddingAdjustable, _super);
        function DBasePaddingAdjustable(theme, options, callback) {
            var _this = _super.call(this, theme, options, callback) || this;
            _this._atop = 0;
            _this._aright = 0;
            _this._abottom = 0;
            _this._aleft = 0;
            return _this;
        }
        DBasePaddingAdjustable.prototype.getLeft = function () {
            return _super.prototype.getLeft.call(this) + this._aleft;
        };
        DBasePaddingAdjustable.prototype.adjLeft = function (aleft) {
            if (this._aleft !== aleft) {
                this._aleft = aleft;
                var callback = this._callback;
                if (callback) {
                    callback();
                }
            }
        };
        DBasePaddingAdjustable.prototype.getTop = function () {
            return _super.prototype.getTop.call(this) + this._atop;
        };
        DBasePaddingAdjustable.prototype.adjTop = function (atop) {
            if (this._atop !== atop) {
                this._atop = atop;
                var callback = this._callback;
                if (callback) {
                    callback();
                }
            }
        };
        DBasePaddingAdjustable.prototype.getRight = function () {
            return _super.prototype.getRight.call(this) + this._aright;
        };
        DBasePaddingAdjustable.prototype.adjRight = function (aright) {
            if (this._aright !== aright) {
                this._aright = aright;
                var callback = this._callback;
                if (callback) {
                    callback();
                }
            }
        };
        DBasePaddingAdjustable.prototype.getBottom = function () {
            return _super.prototype.getBottom.call(this) + this._abottom;
        };
        DBasePaddingAdjustable.prototype.adjBottom = function (abottom) {
            if (this._abottom !== abottom) {
                this._abottom = abottom;
                var callback = this._callback;
                if (callback) {
                    callback();
                }
            }
        };
        return DBasePaddingAdjustable;
    }(DBasePadding));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DBoard = /** @class */ (function (_super) {
        __extends(DBoard, _super);
        function DBoard() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DBoard.prototype.getType = function () {
            return "DBoard";
        };
        return DBoard;
    }(DBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DButtonCheck = /** @class */ (function (_super) {
        __extends(DButtonCheck, _super);
        function DButtonCheck() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DButtonCheck.prototype.getType = function () {
            return "DButtonCheck";
        };
        return DButtonCheck;
    }(DButtonBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DButtonCheckRight = /** @class */ (function (_super) {
        __extends(DButtonCheckRight, _super);
        function DButtonCheckRight() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DButtonCheckRight.prototype.getType = function () {
            return "DButtonCheckRight";
        };
        return DButtonCheckRight;
    }(DButtonCheck));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DColorGradientPointObservable = /** @class */ (function () {
        function DColorGradientPointObservable(color, alpha, position, selected, callback) {
            this._color = color;
            this._alpha = alpha;
            this._position = position;
            this._callback = callback;
            this._selected = selected;
        }
        DColorGradientPointObservable.prototype.set = function (color, alpha, position, selected) {
            if (this._color !== color ||
                this._alpha !== alpha ||
                this._position !== position ||
                this._selected !== selected) {
                this._color = color;
                this._alpha = alpha;
                this._position = position;
                this._selected = selected;
                this._callback(this);
            }
        };
        Object.defineProperty(DColorGradientPointObservable.prototype, "color", {
            get: function () {
                return this._color;
            },
            set: function (color) {
                if (this._color !== color) {
                    this._color = color;
                    this._callback(this);
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DColorGradientPointObservable.prototype, "alpha", {
            get: function () {
                return this._alpha;
            },
            set: function (alpha) {
                if (this._alpha !== alpha) {
                    this._alpha = alpha;
                    this._callback(this);
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DColorGradientPointObservable.prototype, "position", {
            get: function () {
                return this._position;
            },
            set: function (position) {
                if (this._position !== position) {
                    this._position = position;
                    this._callback(this);
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DColorGradientPointObservable.prototype, "selected", {
            get: function () {
                return this._selected;
            },
            set: function (selected) {
                if (this._selected !== selected) {
                    this._selected = selected;
                    this._callback(this);
                }
            },
            enumerable: false,
            configurable: true
        });
        DColorGradientPointObservable.prototype.toObject = function () {
            return {
                color: this._color,
                alpha: this._alpha,
                position: this._position
            };
        };
        return DColorGradientPointObservable;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var POINT_SORTER = function (a, b) {
        return a.position - b.position;
    };
    var DColorGradientObservable = /** @class */ (function (_super) {
        __extends(DColorGradientObservable, _super);
        function DColorGradientObservable() {
            var _this = _super.call(this) || this;
            var onChangeBound = function (target) {
                _this.onChange(target);
            };
            _this._onChangeBound = onChangeBound;
            var first = new DColorGradientPointObservable(0xffffff, 1, 0, false, onChangeBound);
            var second = new DColorGradientPointObservable(0x808080, 1, 1, true, onChangeBound);
            _this._points = [first, second];
            _this._direction = -90;
            _this._selected = second;
            _this._workColor = [0, 0, 0];
            return _this;
        }
        DColorGradientObservable.prototype.onChange = function (target) {
            var isSelectionChanged = target.selected && this._selected !== target;
            if (isSelectionChanged) {
                var selected = this._selected;
                if (selected != null) {
                    selected._selected = false;
                }
                this._selected = target;
            }
            this._points.sort(POINT_SORTER);
            if (isSelectionChanged) {
                this.emit("selectionchange", this._selected, this);
            }
            this.emit("change", this);
        };
        Object.defineProperty(DColorGradientObservable.prototype, "points", {
            get: function () {
                return this._points;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DColorGradientObservable.prototype, "direction", {
            get: function () {
                return this._direction;
            },
            set: function (direction) {
                if (this._direction !== direction) {
                    this._direction = direction;
                    this.emit("directionchange", direction, this);
                    this.emit("change", this);
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DColorGradientObservable.prototype, "selected", {
            get: function () {
                return this._selected;
            },
            enumerable: false,
            configurable: true
        });
        DColorGradientObservable.prototype.size = function () {
            return this._points.length;
        };
        DColorGradientObservable.prototype.get = function (index) {
            var points = this._points;
            if (0 <= index && index < points.length) {
                return points[index];
            }
            return null;
        };
        DColorGradientObservable.prototype.addAt = function (position) {
            var points = this._points;
            var previous = null;
            for (var i = 0, imax = points.length; i < imax; ++i) {
                var point = points[i];
                if (position <= point.position) {
                    if (previous != null) {
                        var span = point.position - previous.position;
                        if (0.001 < span) {
                            var rgb0 = pixi_js.utils.hex2rgb(point.color, this._workColor);
                            var r0 = rgb0[0];
                            var g0 = rgb0[1];
                            var b0 = rgb0[2];
                            var rgb1 = pixi_js.utils.hex2rgb(previous.color, this._workColor);
                            var r1 = rgb1[0];
                            var g1 = rgb1[1];
                            var b1 = rgb1[2];
                            var ratio = (position - previous.position) / span;
                            var r = r0 * ratio + r1 * (1 - ratio);
                            var g = g0 * ratio + g1 * (1 - ratio);
                            var b = b0 * ratio + b1 * (1 - ratio);
                            var rgb = this._workColor;
                            rgb[0] = r;
                            rgb[1] = g;
                            rgb[2] = b;
                            var color = pixi_js.utils.rgb2hex(rgb);
                            var alpha = point.alpha * ratio + previous.alpha * (1 - ratio);
                            return this.add(color, alpha, position, true);
                        }
                    }
                    else {
                        return this.add(point.color, point.alpha, position, true);
                    }
                }
                previous = point;
            }
            if (previous != null) {
                return this.add(previous.color, previous.alpha, position, true);
            }
            else {
                return this.add(0xffffff, 1.0, position, true);
            }
        };
        DColorGradientObservable.prototype.add = function (color, alpha, position, selected) {
            var onChangeBound = this._onChangeBound;
            var result = new DColorGradientPointObservable(color, alpha, position, selected, onChangeBound);
            this._points.push(result);
            onChangeBound(result);
            return result;
        };
        DColorGradientObservable.prototype.remove = function (point) {
            var points = this._points;
            if (2 < points.length) {
                for (var i = 0, imax = points.length; i < imax; ++i) {
                    if (points[i] === point) {
                        points.splice(i, 1);
                        var isSelectionChanged = this._selected === point;
                        if (isSelectionChanged) {
                            if (i + 1 < imax) {
                                this._selected = points[i];
                            }
                            else {
                                this._selected = points[i - 1];
                            }
                        }
                        if (isSelectionChanged) {
                            this.emit("selectionchange", this._selected, this);
                        }
                        this.emit("change", this);
                        return true;
                    }
                }
            }
            return false;
        };
        DColorGradientObservable.prototype.reset = function () {
            var oldDirection = this._direction;
            this._direction = -90;
            var points = this._points;
            var oldSelected = this._selected;
            var index = oldSelected ? points.indexOf(oldSelected) : -1;
            points.length = 0;
            var onChangeBound = this._onChangeBound;
            points.push(new DColorGradientPointObservable(0xffffff, 0, 0, false, onChangeBound));
            points.push(new DColorGradientPointObservable(0xffffff, 0, 1, false, onChangeBound));
            if (0 <= index && index < points.length) {
                var point = points[index];
                point._selected = true;
                this._selected = point;
            }
            else if (0 < points.length) {
                var point = points[points.length - 1];
                point._selected = true;
                this._selected = point;
            }
            else {
                this._selected = null;
            }
            if (oldSelected !== this._selected) {
                this.emit("selectionchange", this._selected, this);
            }
            if (oldDirection !== this._direction) {
                this.emit("directionchange", this._direction, this);
            }
            this.emit("change", this);
            return this;
        };
        DColorGradientObservable.prototype.toObject = function () {
            var pointsCopy = [];
            var points = this._points;
            for (var i = 0, imax = points.length; i < imax; ++i) {
                pointsCopy.push(points[i].toObject());
            }
            return {
                points: pointsCopy,
                direction: this._direction
            };
        };
        DColorGradientObservable.prototype.fromObject = function (data) {
            var oldDirection = this._direction;
            this._direction = data.direction;
            var points = this._points;
            var oldSelected = this._selected;
            var index = oldSelected ? points.indexOf(oldSelected) : -1;
            points.length = 0;
            var onChangeBound = this._onChangeBound;
            for (var i = 0, imax = data.points.length; i < imax; ++i) {
                var pointLike = data.points[i];
                var point = new DColorGradientPointObservable(pointLike.color, pointLike.alpha, pointLike.position, false, onChangeBound);
                points.push(point);
            }
            points.sort(POINT_SORTER);
            if (0 <= index && index < points.length) {
                var point = points[index];
                point._selected = true;
                this._selected = point;
            }
            else if (0 < points.length) {
                var point = points[points.length - 1];
                point._selected = true;
                this._selected = point;
            }
            else {
                this._selected = null;
            }
            if (oldSelected !== this._selected) {
                this.emit("selectionchange", this._selected, this);
            }
            if (oldDirection !== this._direction) {
                this.emit("directionchange", this._direction, this);
            }
            this.emit("change", this);
            return this;
        };
        return DColorGradientObservable;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DInputLabel = /** @class */ (function (_super) {
        __extends(DInputLabel, _super);
        function DInputLabel() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DInputLabel.prototype.getType = function () {
            return "DInputLabel";
        };
        return DInputLabel;
    }(DText));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DInputAndLabel = /** @class */ (function (_super) {
        __extends(DInputAndLabel, _super);
        function DInputAndLabel(options) {
            var _this = _super.call(this, options) || this;
            _this.addChild((_this._label = new DInputLabel(options === null || options === void 0 ? void 0 : options.label)));
            _this.addChild((_this._input = _this.createInput(options === null || options === void 0 ? void 0 : options.input)));
            var space = options === null || options === void 0 ? void 0 : options.space;
            if (space != null) {
                _this.addChild(new DLayoutSpace(space));
            }
            return _this;
        }
        Object.defineProperty(DInputAndLabel.prototype, "input", {
            get: function () {
                return this._input;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DInputAndLabel.prototype, "label", {
            get: function () {
                return this._label;
            },
            enumerable: false,
            configurable: true
        });
        DInputAndLabel.prototype.getType = function () {
            return "DInputAndLabel";
        };
        return DInputAndLabel;
    }(DLayoutHorizontal));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DInputRealAndLabel = /** @class */ (function (_super) {
        __extends(DInputRealAndLabel, _super);
        function DInputRealAndLabel() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DInputRealAndLabel.prototype.createInput = function (options) {
            return new DInputReal(options);
        };
        return DInputRealAndLabel;
    }(DInputAndLabel));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DInputTextAndLabel = /** @class */ (function (_super) {
        __extends(DInputTextAndLabel, _super);
        function DInputTextAndLabel() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DInputTextAndLabel.prototype.createInput = function (options) {
            return new DInputText(options);
        };
        return DInputTextAndLabel;
    }(DInputAndLabel));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPickerColorAndAlpha = /** @class */ (function () {
        function DPickerColorAndAlpha(colorAndAlpha, onColorChange, onAlphaChange) {
            this._colorAndAlpha = colorAndAlpha;
            this._onColorChange = onColorChange;
            this._onAlphaChange = onAlphaChange;
        }
        Object.defineProperty(DPickerColorAndAlpha.prototype, "color", {
            get: function () {
                return this._colorAndAlpha.color;
            },
            set: function (color) {
                if (this._colorAndAlpha.color !== color) {
                    var callback = this._onColorChange;
                    if (callback != null) {
                        callback(color);
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DPickerColorAndAlpha.prototype, "alpha", {
            get: function () {
                return this._colorAndAlpha.alpha;
            },
            set: function (alpha) {
                if (this._colorAndAlpha.alpha !== alpha) {
                    var callback = this._onAlphaChange;
                    if (callback != null) {
                        callback(alpha);
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        return DPickerColorAndAlpha;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuContext = /** @class */ (function () {
        function DMenuContext(owner) {
            this._owner = owner;
            this._closeables = [];
        }
        DMenuContext.prototype.indexOf = function (target) {
            return this._closeables.indexOf(target);
        };
        DMenuContext.prototype.close = function (index) {
            var closeables = this._closeables;
            var imin = Math.max(0, index);
            for (var i = closeables.length - 1; imin <= i; --i) {
                closeables[i].close();
            }
        };
        DMenuContext.prototype.add = function (closeable) {
            this._closeables.push(closeable);
        };
        DMenuContext.prototype.trim = function (closeable) {
            this.close(this.indexOf(closeable) + 1);
        };
        DMenuContext.prototype.remove = function (closeable) {
            var index = this.indexOf(closeable);
            if (0 <= index) {
                this.close(index + 1);
                this._closeables.splice(index, 1);
            }
        };
        return DMenuContext;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenu = /** @class */ (function (_super) {
        __extends(DMenu, _super);
        function DMenu() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenu.prototype.init = function (options) {
            var _this = this;
            var _a, _b, _c;
            _super.prototype.init.call(this, options);
            this._onPrerenderBound = function () {
                _this.onPrerender();
            };
            this._align = toEnum((_a = options === null || options === void 0 ? void 0 : options.align) !== null && _a !== void 0 ? _a : UtilAttachAlign.BOTTOM, UtilAttachAlign);
            this._fit = (_b = options === null || options === void 0 ? void 0 : options.fit) !== null && _b !== void 0 ? _b : false;
            this._sticky = (_c = options === null || options === void 0 ? void 0 : options.sticky) !== null && _c !== void 0 ? _c : false;
            this._sub = false;
            this._owner = null;
            this._context = null;
            this.visible = false;
            // Event handlers
            UtilClickOutside.apply(this, function () {
                _this.close();
            });
            this.on("select", function () {
                _this.close();
            });
            // Items
            var items = options === null || options === void 0 ? void 0 : options.items;
            if (items) {
                DMenus.newItems(this, items, this._sticky);
            }
            // Overlay
            this._overlay = new UtilOverlay(options);
        };
        DMenu.prototype.findItem = function (value) {
            var children = this.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                var child = children[i];
                if (child instanceof DMenuItem && child.value === value) {
                    return child;
                }
            }
            return null;
        };
        DMenu.prototype.getType = function () {
            return "DMenu";
        };
        DMenu.prototype.getContext = function () {
            return this._context;
        };
        DMenu.prototype.getCloseable = function () {
            return this;
        };
        DMenu.prototype.open = function (owner, closeable, context) {
            var _a;
            if (this.isHidden()) {
                var layer = this._overlay.pick(this, owner);
                this._owner = owner;
                // States
                var children = this.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    var child = children[i];
                    if (child instanceof DBase) {
                        child.state.removeAll(DBaseState.FOCUSED, DBaseState.HOVERED);
                    }
                }
                // Position & size
                var renderer = layer.renderer;
                var onPrerenderBound = this._onPrerenderBound;
                if (this._sticky) {
                    renderer.on("prerender", onPrerenderBound);
                }
                else {
                    renderer.once("prerender", onPrerenderBound);
                }
                if (this._fit) {
                    var bounds = owner.getBounds(false, ((_a = DMenu.WORK_BOUNDS) !== null && _a !== void 0 ? _a : (DMenu.WORK_BOUNDS = new pixi_js.Rectangle())));
                    if (bounds != null) {
                        this.width = bounds.width;
                    }
                }
                // Target
                this._sub = context != null;
                context = context || new DMenuContext(owner);
                if (closeable != null) {
                    context.trim(closeable);
                }
                context.add(this);
                this._context = context;
                // Stage
                layer.stage.addChild(this);
                // Focus
                this._focused = layer.getFocusController().get();
                this.focus();
                // Show
                _super.prototype.show.call(this);
                // Event
                this.emit("open", this);
            }
            return this;
        };
        DMenu.prototype.onPrerender = function () {
            var _a;
            var owner = this._owner;
            if (owner) {
                var bounds = owner.getBounds(false, ((_a = DMenu.WORK_BOUNDS) !== null && _a !== void 0 ? _a : (DMenu.WORK_BOUNDS = new pixi_js.Rectangle())));
                if (bounds) {
                    if (this._fit) {
                        this.width = bounds.width;
                    }
                    var layer = this._overlay.picked;
                    if (layer) {
                        var theme = this.theme;
                        UtilAttach.attach(this, bounds, theme.getOffsetX(), theme.getOffsetY(), layer.width, layer.height, this._align);
                    }
                }
            }
        };
        DMenu.prototype.close = function () {
            if (this.isShown()) {
                // Remove from the context
                var context = this._context;
                if (context) {
                    context.remove(this);
                }
                // Remove the prerender event handler
                var layer = this._overlay.picked;
                if (layer) {
                    layer.renderer.off("prerender", this._onPrerenderBound);
                }
                // Forget the owner
                this._owner = null;
                // Restore the focus
                var focused = this._focused;
                if (focused != null) {
                    this._focused = null;
                    if (layer) {
                        var focusedLayer = DApplications.getLayer(focused);
                        if (focusedLayer != null && layer !== focusedLayer) {
                            focusedLayer.view.focus();
                        }
                        layer.getFocusController().focus(focused);
                    }
                    else {
                        this.blur(true);
                    }
                }
                else {
                    this.blur(true);
                }
                // Visibility
                _super.prototype.hide.call(this);
                // Remove from the tree
                var parent_1 = this.parent;
                if (parent_1) {
                    parent_1.removeChild(this);
                }
                // Emit the event
                this.emit("close", this);
            }
            return this;
        };
        DMenu.prototype.onKeyDown = function (e) {
            UtilKeyboardEvent.moveFocusVertically(e, this, this._overlay);
            if (this.state.isActionable &&
                (UtilKeyboardEvent.isArrowLeftKey(e) || UtilKeyboardEvent.isCancelKey(e))) {
                this.close();
            }
            return _super.prototype.onKeyDown.call(this, e);
        };
        DMenu.prototype.containsGlobalPoint = function (point) {
            return !this._sub;
        };
        return DMenu;
    }(DLayoutVertical));
    DMenus.setMenuCreator(function (options) { return new DMenu(options); });

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A dropdown base class.
     */
    var DDropdownBase = /** @class */ (function (_super) {
        __extends(DDropdownBase, _super);
        function DDropdownBase() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DDropdownBase.prototype.onMenuSelect = function (value, item, menu) {
            this.emit("select", value, item, this);
        };
        DDropdownBase.prototype.onMenuClose = function (menu) {
            if (menu) {
                var onMenuSelectBound = this._onMenuSelectBound;
                if (onMenuSelectBound) {
                    menu.off("select", onMenuSelectBound);
                }
                var onMenuCloseBound = this._onMenuCloseBound;
                if (onMenuCloseBound) {
                    menu.off("close", onMenuCloseBound);
                }
            }
        };
        DDropdownBase.prototype.toMenu = function (theme, options) {
            var menu = options === null || options === void 0 ? void 0 : options.menu;
            if (menu instanceof DMenu) {
                return menu;
            }
            return new DMenu(this.toMenuOptions(theme, menu));
        };
        DDropdownBase.prototype.toMenuOptions = function (theme, options) {
            if (options) {
                if (options.fit == null) {
                    options.fit = true;
                }
                return options;
            }
            return {
                fit: true
            };
        };
        Object.defineProperty(DDropdownBase.prototype, "menu", {
            get: function () {
                var result = this._menu;
                if (result == null) {
                    result = this.toMenu(this.theme, this._options);
                    this._menu = result;
                }
                return result;
            },
            set: function (newMenu) {
                var oldMenu = this._menu;
                if (oldMenu != newMenu) {
                    this._menu = newMenu;
                    this.onMenuReplaced(newMenu, oldMenu);
                }
            },
            enumerable: false,
            configurable: true
        });
        DDropdownBase.prototype.onMenuReplaced = function (newMenu, oldMenu) {
            if (oldMenu != null) {
                this.onMenuClose(oldMenu);
            }
        };
        DDropdownBase.prototype.getType = function () {
            return "DDropdownBase";
        };
        DDropdownBase.prototype.onKeyDown = function (e) {
            if (UtilKeyboardEvent.isArrowDownKey(e)) {
                this.onKeyDownArrowDown(e);
            }
            return _super.prototype.onKeyDown.call(this, e);
        };
        DDropdownBase.prototype.onKeyDownArrowDown = function (e) {
            if (this.state.isActionable && this.state.isFocused) {
                this.activate(e);
                return true;
            }
            return false;
        };
        DDropdownBase.prototype.onActivate = function (e) {
            _super.prototype.onActivate.call(this, e);
            this.open();
        };
        DDropdownBase.prototype.open = function () {
            var menu = this.menu;
            if (menu.isHidden()) {
                this.onMenuOpening(menu);
                menu.open(this);
                this.onMenuOpened(menu);
            }
        };
        DDropdownBase.prototype.onMenuOpening = function (menu) {
            var _this = this;
            // In the case that the menu is created elsewhere,
            // the menu might be opened by other UI elements
            // and the `select` event might be triggered. In
            // that case, we are not supposed to catch that
            // `select` event. This is why the `select` event
            // handler is registered here. Instead of the
            // initialization time.
            var onMenuSelectBound = this._onMenuSelectBound;
            if (onMenuSelectBound == null) {
                onMenuSelectBound = function (value, item, m) {
                    _this.onMenuSelect(value, item, m);
                };
                this._onMenuSelectBound = onMenuSelectBound;
            }
            var onMenuCloseBound = this._onMenuCloseBound;
            if (onMenuCloseBound == null) {
                onMenuCloseBound = function () {
                    _this.onMenuClose(_this._menu);
                };
            }
            menu.on("select", onMenuSelectBound);
            menu.on("close", onMenuCloseBound);
        };
        DDropdownBase.prototype.onMenuOpened = function (menu) {
            this.emit("open", menu, this);
        };
        DDropdownBase.prototype.close = function () {
            this.menu.close();
        };
        return DDropdownBase;
    }(DButtonBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuItems = /** @class */ (function () {
        function DMenuItems() {
        }
        DMenuItems.each = function (menu, iteratee) {
            var children = menu.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                var child = children[i];
                if (child instanceof DMenuItemMenu) {
                    var result = this.each(child.menu, iteratee);
                    if (result != null) {
                        return result;
                    }
                }
                else if (child instanceof DMenuItem) {
                    if (iteratee(child)) {
                        return child;
                    }
                }
            }
            return null;
        };
        DMenuItems.find = function (menu, value) {
            return this.each(menu, function (item) {
                return item.value === value;
            });
        };
        return DMenuItems;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A selector class.
     */
    var DSelect = /** @class */ (function (_super) {
        __extends(DSelect, _super);
        function DSelect(options) {
            var _this = _super.call(this, options) || this;
            // Default value
            _this._value = null;
            var value = options === null || options === void 0 ? void 0 : options.value;
            if (value != null) {
                _this.value = value;
            }
            return _this;
        }
        DSelect.prototype.onMenuSelect = function (newValue, item, menu) {
            _super.prototype.onMenuSelect.call(this, newValue, item, menu);
            var oldValue = this._value;
            if (oldValue !== newValue) {
                this._value = newValue;
                this.text = item;
                this.onValueChange(newValue, oldValue, item);
            }
        };
        DSelect.prototype.onMenuReplaced = function (newMenu, oldMenu) {
            _super.prototype.onMenuReplaced.call(this, newMenu, oldMenu);
            // Update the value
            var value = this._value;
            var item = DMenuItems.find(newMenu, value);
            if (item != null) {
                this._value = value;
                this.text = item;
            }
            else {
                this._value = null;
                this.text = null;
            }
        };
        DSelect.prototype.onValueChange = function (newValue, oldValue, item) {
            this.emit("change", newValue, oldValue, item, this);
        };
        DSelect.prototype.onMenuOpening = function (menu) {
            _super.prototype.onMenuOpening.call(this, menu);
            var value = this._value;
            DMenuItems.each(menu, function (item) {
                item.state.isActive = item.value === value;
            });
        };
        Object.defineProperty(DSelect.prototype, "value", {
            /**
             * Returns a selected value or null.
             */
            get: function () {
                return this._value;
            },
            /**
             * Sets to the specified value.
             */
            set: function (value) {
                if (this._value !== value) {
                    var item = DMenuItems.find(this.menu, value);
                    if (item != null) {
                        this._value = value;
                        this.text = item;
                    }
                    else {
                        this._value = null;
                        this.text = null;
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        DSelect.prototype.getType = function () {
            return "DSelect";
        };
        return DSelect;
    }(DDropdownBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DColorType = {
        CUSTOM: 0,
        STANDARD: 1
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DColorStandard = /** @class */ (function (_super) {
        __extends(DColorStandard, _super);
        function DColorStandard(standards) {
            var _this = _super.call(this) || this;
            _this._standards = standards;
            return _this;
        }
        DColorStandard.prototype.get = function (index) {
            var standards = this._standards;
            if (0 <= index && index < standards.length) {
                return standards[index];
            }
            return null;
        };
        DColorStandard.prototype.set = function (index, color) {
            var standards = this._standards;
            if (0 <= index && index < standards.length) {
                var result = standards[index];
                standards[index] = color;
                this.emit("change", this);
                return result;
            }
            return null;
        };
        DColorStandard.prototype.setAll = function (colors) {
            var isChanged = false;
            var standards = this._standards;
            for (var i = 0, imax = Math.min(colors.length, standards.length); i < imax; ++i) {
                if (standards[i] !== colors[i]) {
                    standards[i] = colors[i];
                    isChanged = true;
                }
            }
            if (isChanged) {
                this.emit("change", this);
            }
            return this;
        };
        DColorStandard.prototype.contains = function (color) {
            var standards = this._standards;
            for (var i = 0, imax = standards.length; i < imax; ++i) {
                if (standards[i] === color) {
                    return true;
                }
            }
            return false;
        };
        DColorStandard.prototype.size = function () {
            return this._standards.length;
        };
        return DColorStandard;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DColorStandards = /** @class */ (function () {
        function DColorStandards() {
        }
        DColorStandards.getInstance = function () {
            var _a;
            return ((_a = this.INSTANCE) !== null && _a !== void 0 ? _a : (this.INSTANCE = this.newInstance()));
        };
        DColorStandards.newInstance = function () {
            var theme = DThemes.get("DColorStandard");
            return new DColorStandard(theme.newColors());
        };
        return DColorStandards;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DColorRecent = /** @class */ (function (_super) {
        __extends(DColorRecent, _super);
        function DColorRecent(recents, capacity) {
            var _this = _super.call(this) || this;
            _this._recents = recents;
            _this._capacity = capacity;
            return _this;
        }
        DColorRecent.prototype.get = function (index) {
            var recents = this._recents;
            if (0 <= index && index < recents.length) {
                return recents[recents.length - 1 - index];
            }
            return null;
        };
        DColorRecent.prototype.set = function (index, colorAndAlpha) {
            var recents = this._recents;
            if (0 <= index && index < recents.length) {
                var result = recents[recents.length - 1 - index];
                recents[recents.length - 1 - index] = {
                    color: colorAndAlpha.color,
                    alpha: colorAndAlpha.alpha
                };
                this.emit("change", this);
                return result;
            }
            return null;
        };
        DColorRecent.prototype.contains = function (colorAndAlpha) {
            var recents = this._recents;
            for (var i = 0, imax = recents.length; i < imax; ++i) {
                var recent = recents[i];
                if (recent.color === colorAndAlpha.color && recent.alpha === colorAndAlpha.alpha) {
                    return true;
                }
            }
            return false;
        };
        DColorRecent.prototype.clear = function () {
            var recents = this._recents;
            if (0 < recents.length) {
                recents.length = 0;
                this.emit("change", this);
            }
            return this;
        };
        DColorRecent.prototype.add = function (colorAndAlpha) {
            var recents = this._recents;
            recents.push({
                color: colorAndAlpha.color,
                alpha: colorAndAlpha.alpha
            });
            if (this._capacity < recents.length) {
                recents.shift();
            }
            this.emit("change", this);
            return this;
        };
        DColorRecent.prototype.addAll = function (colorAndAlphas) {
            var length = colorAndAlphas.length;
            if (0 < length) {
                var recents = this._recents;
                for (var i = 0; i < length; ++i) {
                    var colorAndAlpha = colorAndAlphas[i];
                    recents.push({
                        color: colorAndAlpha.color,
                        alpha: colorAndAlpha.alpha
                    });
                    if (this._capacity < recents.length) {
                        recents.shift();
                    }
                }
                this.emit("change", this);
            }
            return this;
        };
        DColorRecent.prototype.clearAndAddAll = function (colorAndAlphas) {
            var isChanged = false;
            var recents = this._recents;
            if (0 < recents.length) {
                recents.length = 0;
                isChanged = true;
            }
            var length = colorAndAlphas.length;
            if (0 < length) {
                for (var i = 0; i < length; ++i) {
                    var colorAndAlpha = colorAndAlphas[i];
                    recents.push({
                        color: colorAndAlpha.color,
                        alpha: colorAndAlpha.alpha
                    });
                    if (this._capacity < recents.length) {
                        recents.shift();
                    }
                }
                isChanged = true;
            }
            if (isChanged) {
                this.emit("change", this);
            }
            return this;
        };
        DColorRecent.prototype.pop = function () {
            var recents = this._recents;
            var result = recents.shift();
            if (result != null) {
                this.emit("change", this);
                return result;
            }
            return null;
        };
        DColorRecent.prototype.size = function () {
            return this._recents.length;
        };
        return DColorRecent;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DColorRecents = /** @class */ (function () {
        function DColorRecents() {
        }
        DColorRecents.getInstance = function () {
            var _a;
            return ((_a = this.INSTANCE) !== null && _a !== void 0 ? _a : (this.INSTANCE = this.newInstance()));
        };
        DColorRecents.newInstance = function () {
            var theme = DThemes.get("DColorRecent");
            return new DColorRecent(theme.newColors(), theme.getCapacity());
        };
        return DColorRecents;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPickerColor = /** @class */ (function (_super) {
        __extends(DPickerColor, _super);
        function DPickerColor() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(DPickerColor.prototype, "current", {
            get: function () {
                return this._currentPicker;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DPickerColor.prototype, "new", {
            get: function () {
                return this._newPicker;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DPickerColor.prototype, "recent", {
            get: function () {
                return this._recent;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DPickerColor.prototype, "standard", {
            get: function () {
                return this._standard;
            },
            enumerable: false,
            configurable: true
        });
        DPickerColor.prototype.init = function (options) {
            var _this = this;
            _super.prototype.init.call(this, options);
            this._base = 0xff0000;
            this._new = { color: 0xffffff, alpha: 1 };
            this._newPicker = new DPickerColorAndAlpha(this._new, function (color) {
                _this.setColorNew(color);
            }, function (alpha) {
                _this.setAlphaNew(alpha);
            });
            this._current = { color: 0xffffff, alpha: 1 };
            this._currentPicker = new DPickerColorAndAlpha(this._current, function (color) {
                _this.setColorCurrent(color);
            }, function (alpha) {
                _this.setAlphaCurrent(alpha);
            });
            var theme = this.theme;
            var padding = this._padding;
            var paddingTop = padding.getTop();
            var paddingRight = padding.getRight();
            var paddingBottom = padding.getBottom();
            var paddingLeft = padding.getLeft();
            this._pointerPoint = new pixi_js.Point();
            var mainWidth = theme.getMainWidth();
            var mainHeight = theme.getMainHeight();
            var typeSelector = new DSelect({
                parent: this,
                value: DColorType.STANDARD,
                menu: {
                    items: [
                        {
                            value: DColorType.STANDARD,
                            text: {
                                value: theme.toColorTypeLabel(DColorType.STANDARD)
                            }
                        },
                        {
                            value: DColorType.CUSTOM,
                            text: {
                                value: theme.toColorTypeLabel(DColorType.CUSTOM)
                            }
                        }
                    ]
                },
                on: {
                    change: function (value) {
                        _this.onTypeChange(value);
                    }
                }
            });
            this._typeSelector = typeSelector;
            typeSelector.x = paddingLeft;
            typeSelector.y = paddingTop;
            typeSelector.width = mainWidth;
            typeSelector.interactive = true;
            this.addChild(typeSelector);
            // Main
            var mainBaseSprite = new pixi_js.Sprite(theme.getMainBaseTexture());
            this._mainBaseSprite = mainBaseSprite;
            mainBaseSprite.x = paddingLeft;
            mainBaseSprite.y = typeSelector.y + typeSelector.height + theme.getBaseMargin();
            mainBaseSprite.width = mainWidth;
            mainBaseSprite.height = mainHeight;
            mainBaseSprite.interactive = true;
            mainBaseSprite.visible = false;
            this.addChild(mainBaseSprite);
            var mainSprite = new pixi_js.Sprite(theme.getMainTexture());
            this._mainSprite = mainSprite;
            mainSprite.x = paddingLeft;
            mainSprite.y = typeSelector.y + typeSelector.height + theme.getBaseMargin();
            mainSprite.tint = this._base;
            mainSprite.interactive = false;
            mainSprite.visible = false;
            this.addChild(mainSprite);
            // Main event handling
            this._onMainMoveBound = function (e) {
                _this.onMainMove(e);
            };
            this._onMainUpBound = function (e) {
                _this.onMainUp(e);
            };
            mainBaseSprite.on(UtilPointerEvent.down, function (e) {
                _this.onMainDown(e);
            });
            // Base color picker
            var baseSprite = new pixi_js.Sprite(theme.getBaseTexture());
            this._baseSprite = baseSprite;
            baseSprite.x = paddingLeft;
            baseSprite.y = mainBaseSprite.y + mainBaseSprite.height + theme.getBaseMargin();
            baseSprite.interactive = true;
            baseSprite.visible = false;
            this.addChild(baseSprite);
            // Base event
            this._onBaseMoveBound = function (e) {
                _this.onBaseMove(e);
            };
            this._onBaseUpBound = function (e) {
                _this.onBaseUp(e);
            };
            baseSprite.on(UtilPointerEvent.down, function (e) {
                _this.onBaseDown(e);
            });
            // Standard main color
            this._standardColorSprites = [];
            var standardColorSprites = this._standardColorSprites;
            var standardColorCount = theme.getStandardColorCount();
            var standardColorWidth = theme.getStandardColorWidth();
            var standardColorHeight = theme.getStandardColorHeight();
            var standardColorMargin = theme.getStandardColorMargin();
            var standardColorY = typeSelector.y + typeSelector.height + theme.getBaseMargin();
            var standardTexture = theme.getStandardTexture();
            var standard = (this._standard = DColorStandards.getInstance());
            standard.on("change", function () {
                _this.onStandardChange();
            });
            var onStandardClick = function (e) {
                var sprite = e.currentTarget;
                if (sprite instanceof pixi_js.Sprite) {
                    _this.setColorNew(sprite.tint);
                }
            };
            for (var i = 0; i < standardColorCount; ++i) {
                var x = paddingLeft + (i % 10) * (standardColorWidth + standardColorMargin);
                var y = standardColorY + Math.floor(i / 10) * (standardColorHeight + standardColorMargin);
                var sprite = new pixi_js.Sprite(standardTexture);
                var standardColor = standard.get(i);
                if (standardColor != null) {
                    sprite.tint = standardColor;
                    sprite.alpha = 1;
                }
                else {
                    sprite.tint = 0xffffff;
                    sprite.alpha = 1;
                }
                sprite.x = x;
                sprite.y = y;
                sprite.buttonMode = true;
                sprite.interactive = true;
                sprite.on(UtilPointerEvent.tap, onStandardClick);
                standardColorSprites.push(sprite);
            }
            var mainStandardColor = new DLayoutHorizontal({
                width: "auto",
                height: "auto",
                row: 8,
                children: standardColorSprites
            });
            this._mainStandardColor = mainStandardColor;
            mainStandardColor.visible = true;
            this.addChild(mainStandardColor);
            // Alpha picker
            var alphaCheckerboardSprite = new pixi_js.Sprite(theme.getAlphaCheckerboardTexture());
            this._alphaCheckerboardSprite = alphaCheckerboardSprite;
            alphaCheckerboardSprite.x = padding.getLeft();
            alphaCheckerboardSprite.y = baseSprite.y + theme.getBaseHeight() + theme.getBaseMargin();
            alphaCheckerboardSprite.interactive = false;
            this.addChild(alphaCheckerboardSprite);
            var alphaSprite = new pixi_js.Sprite(theme.getAlphaTexture());
            alphaSprite.tint = this._new.color;
            alphaSprite.interactive = true;
            alphaCheckerboardSprite.addChild(alphaSprite);
            // Alpha event
            this._onAlphaMoveBound = function (e) {
                _this.onAlphaMove(e);
            };
            this._onAlphaUpBound = function (e) {
                _this.onAlphaUp(e);
            };
            alphaSprite.on(UtilPointerEvent.down, function (e) {
                _this.onAlphaDown(e);
            });
            // Pointers
            var mainPointerSprite = new pixi_js.Sprite(theme.getMainPointerTexture());
            this._mainPointerSprite = mainPointerSprite;
            mainPointerSprite.x = paddingLeft;
            mainPointerSprite.y = typeSelector.y + typeSelector.height + theme.getBaseMargin();
            mainPointerSprite.anchor.x = 0.5;
            mainPointerSprite.anchor.y = 0.5;
            mainPointerSprite.tint = theme.getMainPointerColor();
            mainPointerSprite.alpha = theme.getMainPointerAlpha();
            mainPointerSprite.interactive = false;
            mainPointerSprite.visible = false;
            this.addChild(mainPointerSprite);
            var alphaPointerSprite = new pixi_js.Sprite(theme.getAlphaPointerTexture());
            this._alphaPointerSprite = alphaPointerSprite;
            alphaPointerSprite.x = mainWidth;
            alphaPointerSprite.y = alphaCheckerboardSprite.height * 0.5;
            alphaPointerSprite.tint = theme.getAlphaPointerColor();
            alphaPointerSprite.alpha = theme.getAlphaPointerAlpha();
            alphaPointerSprite.anchor.set(0.5, 0.5);
            alphaPointerSprite.interactive = false;
            alphaCheckerboardSprite.addChild(alphaPointerSprite);
            var basePointerSprite = new pixi_js.Sprite(theme.getBasePointerTexture());
            this._basePointerSprite = basePointerSprite;
            basePointerSprite.x = 0;
            basePointerSprite.y = baseSprite.height * 0.5;
            basePointerSprite.tint = theme.getBasePointerColor();
            basePointerSprite.alpha = theme.getBasePointerAlpha();
            basePointerSprite.anchor.set(0.5, 0.5);
            basePointerSprite.interactive = false;
            baseSprite.addChild(basePointerSprite);
            // Recently used
            this._recentColorSprites = [];
            var recentColorSprites = this._recentColorSprites;
            var recentColorCount = theme.getRecentColorCount();
            var recentColorWidth = theme.getRecentColorWidth();
            var recentColorHeight = theme.getRecentColorHeight();
            var recentColorMargin = theme.getRecentColorMargin();
            var recentColorY = alphaCheckerboardSprite.y + theme.getAlphaHeight() + theme.getRecentMargin();
            var recentCheckerboardTexture = theme.getRecentCheckerboardTexture();
            var recentTexture = theme.getRecentTexture();
            var recent = (this._recent = DColorRecents.getInstance());
            recent.on("change", function () {
                _this.onRecentChange();
            });
            var onRecentClick = function (e) {
                var sprite = e.currentTarget;
                if (sprite instanceof pixi_js.Sprite) {
                    _this.setColorNew(sprite.tint);
                    _this.setAlphaNew(sprite.alpha);
                }
            };
            for (var i = 0; i < recentColorCount; ++i) {
                var x = paddingLeft + i * (recentColorWidth + recentColorMargin);
                var y = recentColorY;
                var checkerboardSprite = new pixi_js.Sprite(recentCheckerboardTexture);
                checkerboardSprite.x = x;
                checkerboardSprite.y = y;
                checkerboardSprite.interactive = false;
                this.addChild(checkerboardSprite);
                var sprite = new pixi_js.Sprite(recentTexture);
                var recentColorAndAlpha = recent.get(i);
                if (recentColorAndAlpha != null) {
                    sprite.tint = recentColorAndAlpha.color;
                    sprite.alpha = recentColorAndAlpha.alpha;
                }
                else {
                    sprite.tint = 0xffffff;
                    sprite.alpha = 0;
                }
                sprite.x = x;
                sprite.y = y;
                sprite.buttonMode = true;
                sprite.interactive = true;
                sprite.on(UtilPointerEvent.tap, onRecentClick);
                this.addChild(sprite);
                recentColorSprites.push(sprite);
            }
            // Input color
            var inputMargin = theme.getInputMargin();
            var inputLabelWidth = theme.getInputLabelWidth();
            var inputY = recentColorY + recentColorHeight + inputMargin;
            var inputWidth = (mainWidth - inputMargin) * 0.5;
            var inputAndLabelColor = new DInputTextAndLabel({
                parent: this,
                x: paddingLeft,
                y: inputY,
                width: inputWidth,
                label: {
                    width: inputLabelWidth,
                    text: {
                        value: "#"
                    },
                    interactive: DBaseInteractive.NONE
                },
                input: {
                    weight: 1,
                    text: {
                        value: "FFFFFF"
                    },
                    on: {
                        input: function (code) {
                            var color = UtilRgb.fromCode(code);
                            if (color != null) {
                                _this.setColorNew(color);
                            }
                        }
                    }
                }
            });
            this._inputAndLabelColor = inputAndLabelColor;
            var inputHeight = inputAndLabelColor.height;
            var inputAndLabelAlpha = new DInputRealAndLabel({
                parent: this,
                x: paddingLeft,
                y: inputY + inputHeight + inputMargin,
                width: inputWidth,
                label: {
                    width: inputLabelWidth,
                    text: {
                        value: "A"
                    },
                    interactive: DBaseInteractive.NONE
                },
                input: {
                    weight: 1,
                    text: {
                        value: 1
                    },
                    min: 0,
                    max: 1,
                    on: {
                        input: function (value) {
                            _this.setAlphaNew(value);
                        }
                    }
                }
            });
            this._inputAndLabelAlpha = inputAndLabelAlpha;
            // Samples
            var sampleWidth = theme.getSampleWidth();
            var sampleHeight = theme.getSampleHeight();
            var sampleX = paddingLeft + (mainWidth - inputMargin) * 0.5 + inputMargin;
            var sampleY = inputY + (inputHeight + inputMargin + inputAndLabelAlpha.height - sampleHeight) * 0.5;
            var sampleMargin = theme.getSampleMargin();
            var sampleCurrentCheckerboardSprite = new pixi_js.Sprite(theme.getSampleCheckerboardOldTexture());
            this._sampleCurrentCheckerboardSprite = sampleCurrentCheckerboardSprite;
            sampleCurrentCheckerboardSprite.x = sampleX;
            sampleCurrentCheckerboardSprite.y = sampleY;
            sampleCurrentCheckerboardSprite.width = sampleWidth;
            sampleCurrentCheckerboardSprite.height = sampleHeight;
            sampleCurrentCheckerboardSprite.interactive = false;
            this.addChild(sampleCurrentCheckerboardSprite);
            var current = this._current;
            var sampleCurrentSprite = new pixi_js.Sprite(theme.getSampleOldTexture());
            this._sampleCurrentSprite = sampleCurrentSprite;
            sampleCurrentSprite.x = sampleX;
            sampleCurrentSprite.y = sampleY;
            sampleCurrentSprite.tint = current.color;
            sampleCurrentSprite.alpha = current.alpha;
            sampleCurrentSprite.width = sampleWidth;
            sampleCurrentSprite.height = sampleHeight;
            sampleCurrentSprite.interactive = true;
            sampleCurrentSprite.buttonMode = true;
            sampleCurrentSprite.on(UtilPointerEvent.tap, function () {
                _this.setColorNew(current.color);
                _this.setAlphaNew(current.alpha);
            });
            this.addChild(sampleCurrentSprite);
            var sampleNewCheckerboardSprite = new pixi_js.Sprite(theme.getSampleCheckerboardNewTexture());
            this._sampleNewCheckerboardSprite = sampleNewCheckerboardSprite;
            sampleNewCheckerboardSprite.x = sampleX + sampleWidth + sampleMargin;
            sampleNewCheckerboardSprite.y = sampleY;
            sampleNewCheckerboardSprite.width = sampleWidth;
            sampleNewCheckerboardSprite.height = sampleHeight;
            sampleNewCheckerboardSprite.interactive = false;
            this.addChild(sampleNewCheckerboardSprite);
            var sampleNewSprite = new pixi_js.Sprite(theme.getSampleNewTexture());
            this._sampleNewSprite = sampleNewSprite;
            sampleNewSprite.x = sampleX + sampleWidth + sampleMargin;
            sampleNewSprite.y = sampleY;
            sampleNewSprite.tint = this._new.color;
            sampleNewSprite.alpha = this._new.alpha;
            sampleNewSprite.width = sampleWidth;
            sampleNewSprite.height = sampleHeight;
            sampleNewSprite.interactive = false;
            this.addChild(sampleNewSprite);
            // Width
            if (options == null || options.width == null) {
                this.width = paddingLeft + mainWidth + paddingRight;
            }
            // Height
            if (options == null || options.height == null) {
                this.height =
                    inputY +
                        inputAndLabelColor.height +
                        inputMargin +
                        inputAndLabelAlpha.height +
                        paddingBottom;
            }
        };
        DPickerColor.prototype.onMainDown = function (e) {
            this.onMainPick(e.data.global);
            var layer = DApplications.getLayer(this);
            if (layer) {
                var stage = layer.stage;
                stage.on(UtilPointerEvent.move, this._onMainMoveBound);
                stage.on(UtilPointerEvent.up, this._onMainUpBound);
                stage.on(UtilPointerEvent.upoutside, this._onMainUpBound);
            }
        };
        DPickerColor.prototype.onMainMove = function (e) {
            this.onMainPick(e.data.global);
        };
        DPickerColor.prototype.onMainUp = function (e) {
            var layer = DApplications.getLayer(this);
            if (layer) {
                var stage = layer.stage;
                stage.off(UtilPointerEvent.move, this._onMainMoveBound);
                stage.off(UtilPointerEvent.up, this._onMainUpBound);
            }
        };
        DPickerColor.prototype.toMainHex = function (b, w0, w1, shift) {
            return Math.max(0, Math.min(255, w0 * 255 + w1 * ((b >> shift) & 0xff))) << shift;
        };
        DPickerColor.prototype.toMainColor = function (base, tx, ty, width, height) {
            var hw = width * 0.5;
            var ux = Math.max(0, Math.min(1, ((tx - hw) * (1 - ty / height) + hw) / width));
            var uy = Math.max(0, Math.min(1, ty / height));
            var w1 = Math.abs(0.5 * uy - ux);
            var w0 = 1 - w1 - uy;
            var r = this.toMainHex(base, w0, w1, 16);
            var g = this.toMainHex(base, w0, w1, 8);
            var b = this.toMainHex(base, w0, w1, 0);
            return r | g | b;
        };
        DPickerColor.prototype.onMainPick = function (global) {
            var mainBaseSprite = this._mainBaseSprite;
            var point = this._pointerPoint;
            var theme = this.theme;
            var mainWidth = theme.getMainWidth();
            var mainHeight = theme.getMainHeight();
            this.toLocal(global, undefined, point);
            var x = Math.max(0, Math.min(mainWidth, point.x - mainBaseSprite.x));
            var y = Math.max(0, Math.min(mainHeight, point.y - mainBaseSprite.y));
            var mainPointerSprite = this._mainPointerSprite;
            mainPointerSprite.position.set(mainBaseSprite.x + x, mainBaseSprite.y + y);
            this.onColorNew(this.toMainColor(this._base, x, y, mainWidth, mainHeight));
        };
        DPickerColor.prototype.setColorCurrent = function (color) {
            this._sampleCurrentSprite.tint = this._current.color = color;
        };
        DPickerColor.prototype.setAlphaCurrent = function (alpha) {
            this._sampleCurrentSprite.alpha = this._current.alpha = alpha;
        };
        DPickerColor.prototype.setColorNew = function (color) {
            var theme = this.theme;
            var mainWidth = theme.getMainWidth();
            var mainHeight = theme.getMainHeight();
            var mainBaseSprite = this._mainBaseSprite;
            // Base color
            var hsv = UtilHsv.fromRgb(color);
            this._mainSprite.tint = this._base = UtilHsv.toRgb(hsv[0], 255, 255);
            // Move the base pointer
            var basePointerSprite = this._basePointerSprite;
            basePointerSprite.x = Math.max(0, Math.min(1, hsv[0] / 360)) * mainWidth;
            // Move the main pointer
            var ns = Math.max(0, Math.min(1, hsv[1] / 255));
            var nv = Math.max(0, Math.min(1, 1 - hsv[2] / 255));
            var mainPointerSprite = this._mainPointerSprite;
            mainPointerSprite.tint = nv < 0.45 ? theme.getMainPointerColor() : 0xffffff;
            mainPointerSprite.position.set(mainBaseSprite.x + ns * mainWidth, mainBaseSprite.y + nv * mainHeight);
            // New color
            this.onColorNew(color);
        };
        DPickerColor.prototype.onColorNew = function (color) {
            var layer = DApplications.getLayer(this);
            if (layer) {
                layer.lock();
            }
            this._sampleNewSprite.tint = this._new.color = color;
            this._inputAndLabelColor.input.value = UtilRgb.toCode(color);
            this.emit("newcolorchange", color, this);
            if (layer) {
                layer.unlock();
                layer.update();
            }
        };
        DPickerColor.prototype.onBaseDown = function (e) {
            this.onBasePick(e.data.global);
            var layer = DApplications.getLayer(this);
            if (layer) {
                var stage = layer.stage;
                stage.on(UtilPointerEvent.move, this._onBaseMoveBound);
                stage.on(UtilPointerEvent.up, this._onBaseUpBound);
            }
        };
        DPickerColor.prototype.onBaseMove = function (e) {
            this.onBasePick(e.data.global);
        };
        DPickerColor.prototype.onBaseUp = function (e) {
            var layer = DApplications.getLayer(this);
            if (layer) {
                var stage = layer.stage;
                stage.off(UtilPointerEvent.move, this._onBaseMoveBound);
                stage.off(UtilPointerEvent.up, this._onBaseUpBound);
            }
        };
        DPickerColor.prototype.toBaseHex = function (t, shift) {
            return Math.max(0, Math.min(255, t * 6 * 255)) << shift;
        };
        DPickerColor.prototype.toBaseColor = function (t) {
            if (t <= 0.167) {
                return 0xff0000 + this.toBaseHex(t, 8);
            }
            else if (t <= 0.333) {
                t = 0.333 - t;
                return 0x00ff00 + this.toBaseHex(t, 16);
            }
            else if (t <= 0.5) {
                t -= 0.333;
                return 0x00ff00 + this.toBaseHex(t, 0);
            }
            else if (t < 0.667) {
                t = 0.667 - t;
                return 0x0000ff + this.toBaseHex(t, 8);
            }
            else if (t < 0.883) {
                t -= 0.667;
                return 0x0000ff + this.toBaseHex(t, 16);
            }
            else {
                t = 0.883 - t;
                return 0xff0000 + this.toBaseHex(t, 0);
            }
        };
        DPickerColor.prototype.onBasePick = function (global) {
            var point = this._pointerPoint;
            var padding = this._padding;
            var theme = this.theme;
            var mainWidth = theme.getMainWidth();
            this.toLocal(global, undefined, point);
            var x = Math.max(0, Math.min(mainWidth, point.x - padding.getLeft()));
            var basePointerSprite = this._basePointerSprite;
            basePointerSprite.x = x;
            this.onColorBase(this.toBaseColor(x / mainWidth));
        };
        DPickerColor.prototype.setColorBase = function (h) {
            var theme = this.theme;
            var mainWidth = theme.getMainWidth();
            var basePointerSprite = this._basePointerSprite;
            basePointerSprite.x = Math.max(0, Math.min(1, h / 360)) * mainWidth;
            this.onColorBase(UtilHsv.toRgb(h, 255, 255));
        };
        DPickerColor.prototype.onColorBase = function (color) {
            this._mainSprite.tint = this._base = color;
            var mainPointerSprite = this._mainPointerSprite;
            var theme = this.theme;
            var mainWidth = theme.getMainWidth();
            var mainHeight = theme.getMainHeight();
            var padding = this._padding;
            this.onColorNew(this.toMainColor(this._base, mainPointerSprite.x - padding.getLeft(), mainPointerSprite.y - padding.getTop(), mainWidth, mainHeight));
        };
        DPickerColor.prototype.onAlphaDown = function (e) {
            this.onAlphaPick(e.data.global);
            var layer = DApplications.getLayer(this);
            if (layer) {
                var stage = layer.stage;
                stage.on(UtilPointerEvent.move, this._onAlphaMoveBound);
                stage.on(UtilPointerEvent.up, this._onAlphaUpBound);
            }
        };
        DPickerColor.prototype.onAlphaMove = function (e) {
            this.onAlphaPick(e.data.global);
        };
        DPickerColor.prototype.onAlphaUp = function (e) {
            var layer = DApplications.getLayer(this);
            if (layer) {
                var stage = layer.stage;
                stage.off(UtilPointerEvent.move, this._onAlphaMoveBound);
                stage.off(UtilPointerEvent.up, this._onAlphaUpBound);
            }
        };
        DPickerColor.prototype.onAlphaPick = function (global) {
            var point = this._pointerPoint;
            var padding = this._padding;
            var theme = this.theme;
            var mainWidth = theme.getMainWidth();
            this.toLocal(global, undefined, point);
            var x = Math.max(0, Math.min(mainWidth, point.x - padding.getLeft()));
            this._alphaPointerSprite.x = x;
            this.onAlphaNew(x / mainWidth);
        };
        DPickerColor.prototype.setAlphaNew = function (alpha) {
            var theme = this.theme;
            var mainWidth = theme.getMainWidth();
            this._alphaPointerSprite.x = Math.max(0, Math.min(1, alpha)) * mainWidth;
            this.onAlphaNew(alpha);
        };
        DPickerColor.prototype.onAlphaNew = function (alpha) {
            var layer = DApplications.getLayer(this);
            if (layer) {
                layer.lock();
            }
            this._sampleNewSprite.alpha = this._new.alpha = alpha;
            this._inputAndLabelAlpha.input.value = Number(alpha.toFixed(2));
            this.emit("newalphachange", alpha, this);
            if (layer) {
                layer.unlock();
                layer.update();
            }
        };
        DPickerColor.prototype.onRecentChange = function () {
            var sprites = this._recentColorSprites;
            var recent = this._recent;
            for (var i = 0, imax = sprites.length; i < imax; ++i) {
                var sprite = sprites[i];
                var colorAndAlpha = recent.get(i);
                if (colorAndAlpha != null) {
                    sprite.tint = colorAndAlpha.color;
                    sprite.alpha = colorAndAlpha.alpha;
                }
                else {
                    sprite.tint = 0xffffff;
                    sprite.alpha = 0;
                }
            }
        };
        DPickerColor.prototype.onStandardChange = function () {
            var sprites = this._standardColorSprites;
            var standard = this._standard;
            for (var i = 0, imax = sprites.length; i < imax; ++i) {
                var sprite = sprites[i];
                var color = standard.get(i);
                if (color != null) {
                    sprite.tint = color;
                    sprite.alpha = 1;
                }
                else {
                    sprite.tint = 0xffffff;
                    sprite.alpha = 1;
                }
            }
        };
        DPickerColor.prototype.onTypeChange = function (type) {
            switch (type) {
                case DColorType.CUSTOM:
                    this._mainBaseSprite.visible = true;
                    this._mainSprite.visible = true;
                    this._mainPointerSprite.visible = true;
                    this._baseSprite.visible = true;
                    this._mainStandardColor.visible = false;
                    break;
                case DColorType.STANDARD:
                    this._mainBaseSprite.visible = false;
                    this._mainSprite.visible = false;
                    this._mainPointerSprite.visible = false;
                    this._baseSprite.visible = false;
                    this._mainStandardColor.visible = true;
                    break;
                default:
                    return;
            }
        };
        DPickerColor.prototype.getType = function () {
            return "DPickerColor";
        };
        return DPickerColor;
    }(DBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var isEqual = function (a, b) {
        if (a.direction !== b.direction) {
            return false;
        }
        var ap = a.points;
        var bp = b.points;
        if (ap.length !== bp.length) {
            return false;
        }
        for (var j = 0, jmax = ap.length; j < jmax; ++j) {
            var apj = ap[j];
            var bpj = bp[j];
            if (apj.color !== bpj.color || apj.alpha !== bpj.alpha || apj.position !== bpj.position) {
                return false;
            }
        }
        return true;
    };
    var DPickerColorGradientRecent = /** @class */ (function (_super) {
        __extends(DPickerColorGradientRecent, _super);
        function DPickerColorGradientRecent(recents, capacity) {
            var _this = _super.call(this) || this;
            _this._recents = recents;
            _this._capacity = capacity;
            return _this;
        }
        DPickerColorGradientRecent.prototype.getCapacity = function () {
            return this._capacity;
        };
        DPickerColorGradientRecent.prototype.get = function (index) {
            var recents = this._recents;
            if (0 <= index && index < recents.length) {
                return recents[recents.length - 1 - index];
            }
            return null;
        };
        DPickerColorGradientRecent.prototype.set = function (index, points) {
            var recents = this._recents;
            if (0 <= index && index < recents.length) {
                var result = recents[recents.length - 1 - index];
                recents[recents.length - 1 - index] = points;
                this.emit("change", this);
                return result;
            }
            return null;
        };
        DPickerColorGradientRecent.prototype.contains = function (points) {
            var recents = this._recents;
            for (var i = 0, imax = recents.length; i < imax; ++i) {
                if (isEqual(recents[i], points)) {
                    return true;
                }
            }
            return false;
        };
        DPickerColorGradientRecent.prototype.add = function (points) {
            var recents = this._recents;
            recents.push(points);
            if (this._capacity < recents.length) {
                recents.shift();
            }
            this.emit("change", this);
            return this;
        };
        DPickerColorGradientRecent.prototype.pop = function () {
            var recents = this._recents;
            var result = recents.shift();
            if (result != null) {
                this.emit("change", this);
                return result;
            }
            return null;
        };
        DPickerColorGradientRecent.prototype.size = function () {
            return this._recents.length;
        };
        return DPickerColorGradientRecent;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var VERTEX_SHADER = "\nattribute vec2 aPosition;\nattribute vec2 aUv;\nattribute vec4 aColor;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\n\nvarying vec2 vUv;\nvarying vec4 vColor;\n\nvoid main(void) {\n\tvec3 position = vec3(aPosition.x, aPosition.y, 1.0);\n\tgl_Position = vec4((projectionMatrix * translationMatrix * position).xy, 0.0, 1.0);\n\tvUv = aUv;\n\tvColor = aColor;\n}\n";
    var FRAGMENT_SHADER = "\nvarying vec2 vUv;\nvarying vec4 vColor;\n\nuniform sampler2D uSampler;\nuniform vec2 uCheckerColors;\n\nvoid main(void) {\n\tvec4 texture = texture2D(uSampler, vUv);\n\tfloat cy = step( 1.0, mod( gl_FragCoord.y / 10.0, 2.0 ) );\n\tfloat cx = step( 1.0, mod( gl_FragCoord.x / 10.0 + cy, 2.0 ) );\n\tfloat c = mix( uCheckerColors.x, uCheckerColors.y, cx );\n\tgl_FragColor = texture * vec4( mix( vec3( c ), vColor.xyz, vColor.a ), 1.0 );\n}";
    var DPickerColorGradientView = /** @class */ (function (_super) {
        __extends(DPickerColorGradientView, _super);
        function DPickerColorGradientView(nPointsPerData, vertices, uvs, colors, indices, parts, geometry, shader) {
            var _this = _super.call(this, geometry, shader) || this;
            _this.interactive = true;
            _this.interactiveChildren = false;
            _this.cursor = "pointer";
            _this._nPointsPerData = nPointsPerData;
            _this._vertices = vertices;
            _this._uvs = uvs;
            _this._colors = colors;
            _this._indices = indices;
            _this._lastHitIndex = -1;
            _this._workColor = [0, 0, 0];
            _this._workPoint = new pixi_js.Point();
            _this._parts = parts;
            shader.uniforms.uSampler.on("update", function () {
                _this.update();
                DApplications.update(_this);
            });
            _this.update();
            return _this;
        }
        DPickerColorGradientView.prototype.getRectangle = function (index) {
            var parts = this._parts;
            if (0 <= index && index < parts.length) {
                return parts[index].rect;
            }
            return null;
        };
        DPickerColorGradientView.prototype.setRectangle = function (index, x, y, width, height) {
            var parts = this._parts;
            if (0 <= index && index < parts.length) {
                var rect = parts[index].rect;
                rect.x = x;
                rect.y = y;
                rect.width = width;
                rect.height = height;
            }
        };
        DPickerColorGradientView.prototype.getData = function (index) {
            var parts = this._parts;
            if (0 <= index && index < parts.length) {
                return parts[index].data;
            }
            return null;
        };
        DPickerColorGradientView.prototype.setData = function (index, data) {
            var parts = this._parts;
            if (0 <= index && index < parts.length) {
                parts[index].data = data;
            }
        };
        DPickerColorGradientView.prototype.getLastHitIndex = function () {
            return this._lastHitIndex;
        };
        DPickerColorGradientView.prototype.setColors = function (ic, colors, rgb, alpha) {
            colors[ic + 0] = rgb[0];
            colors[ic + 1] = rgb[1];
            colors[ic + 2] = rgb[2];
            colors[ic + 3] = alpha;
            colors[ic + 4] = rgb[0];
            colors[ic + 5] = rgb[1];
            colors[ic + 6] = rgb[2];
            colors[ic + 7] = alpha;
        };
        DPickerColorGradientView.prototype.setColorsHex = function (ic, colors, color, alpha) {
            var rgb = pixi_js.utils.hex2rgb(color, this._workColor);
            this.setColors(ic, colors, rgb, alpha);
        };
        DPickerColorGradientView.prototype.setColorsWhite = function (ic, colors) {
            var rgb = this._workColor;
            rgb[0] = 1;
            rgb[1] = 1;
            rgb[2] = 1;
            this.setColors(ic, colors, rgb, 0);
        };
        DPickerColorGradientView.prototype.setColorsPoint = function (ic, data, index, colors) {
            var point = data.points[index];
            if (point != null) {
                this.setColorsHex(ic, colors, point.color, point.alpha);
            }
            else {
                this.setColorsWhite(ic, colors);
            }
        };
        DPickerColorGradientView.prototype.setVertices = function (iv, vertices, position, rect) {
            var y = rect.y + rect.height * position;
            vertices[iv + 0] = rect.x;
            vertices[iv + 1] = y;
            vertices[iv + 2] = rect.x + rect.width;
            vertices[iv + 3] = y;
        };
        DPickerColorGradientView.prototype.setUvs = function (iv, uvs, position, textureUvs) {
            var x0 = textureUvs.x0 + (textureUvs.x3 - textureUvs.x0) * position;
            var y0 = textureUvs.y0 + (textureUvs.y3 - textureUvs.y0) * position;
            var x1 = textureUvs.x1 + (textureUvs.x2 - textureUvs.x1) * position;
            var y1 = textureUvs.y1 + (textureUvs.y2 - textureUvs.y1) * position;
            uvs[iv + 0] = x0;
            uvs[iv + 1] = y0;
            uvs[iv + 2] = x1;
            uvs[iv + 3] = y1;
        };
        DPickerColorGradientView.prototype.newIndices = function (ii, iv, size, indices) {
            for (var i = 0; i < size; ++i) {
                indices[ii + 0] = iv + 0;
                indices[ii + 1] = iv + 1;
                indices[ii + 2] = iv + 2;
                indices[ii + 3] = iv + 2;
                indices[ii + 4] = iv + 1;
                indices[ii + 5] = iv + 3;
                ii += 6;
                iv += 2;
            }
            return indices;
        };
        DPickerColorGradientView.prototype._calculateBounds = function () {
            var worldTransform = this.transform.worldTransform;
            var rect = this._parts[0].rect;
            var bounds = this._bounds;
            var work = this._workPoint;
            work.set(rect.x, rect.y);
            worldTransform.apply(work, work);
            bounds.addPoint(work);
            work.set(rect.x + rect.width, rect.y + rect.height);
            worldTransform.apply(work, work);
            bounds.addPoint(work);
        };
        DPickerColorGradientView.prototype.update = function () {
            var vertices = this._vertices;
            var uvs = this._uvs;
            var colors = this._colors;
            var indices = this._indices;
            var texture = this.shader.uniforms.uSampler;
            if (texture._uvs == null) {
                texture.updateUvs();
            }
            var textureUvs = texture._uvs;
            var iv = 0;
            var nv = 0;
            var ic = 0;
            var ii = 0;
            var parts = this._parts;
            for (var i = 0, imax = parts.length; i < imax; ++i) {
                var data = parts[i].data;
                var rect = parts[i].rect;
                if (data == null) {
                    this.setVertices(iv, vertices, 0, rect);
                    this.setUvs(iv, uvs, 0, textureUvs);
                    this.setColorsWhite(ic, colors);
                    this.setVertices(iv + 4, vertices, 1, rect);
                    this.setUvs(iv, uvs, 1, textureUvs);
                    this.setColorsWhite(ic + 8, colors);
                    this.newIndices(ii, nv, 1, indices);
                    iv += 4 * 2;
                    ic += 4 * 4;
                    nv += 4;
                    ii += 6;
                }
                else {
                    this.setVertices(iv, vertices, 0, rect);
                    this.setUvs(iv, uvs, 0, textureUvs);
                    this.setColorsPoint(ic, data, 0, colors);
                    iv += 2 * 2;
                    ic += 2 * 4;
                    var pointSize = data.points.length;
                    for (var j = 0, jmax = Math.min(pointSize, this._nPointsPerData); j < jmax; ++j) {
                        var point = data.points[j];
                        this.setVertices(iv, vertices, point.position, rect);
                        this.setUvs(iv, uvs, point.position, textureUvs);
                        this.setColorsHex(ic, colors, point.color, point.alpha);
                        iv += 2 * 2;
                        ic += 2 * 4;
                    }
                    this.setVertices(iv, vertices, 1, rect);
                    this.setUvs(iv, uvs, 1, textureUvs);
                    this.setColorsPoint(ic, data, pointSize - 1, colors);
                    iv += 2 * 2;
                    ic += 2 * 4;
                    this.newIndices(ii, nv, pointSize + 1, indices);
                    ii += (pointSize + 1) * 6;
                    nv += (pointSize + 2) * 2;
                }
            }
            this.size = ii;
            var geometry = this.geometry;
            geometry.getBuffer("aPosition").update();
            geometry.getBuffer("aUv").update();
            geometry.getBuffer("aColor").update();
            geometry.getIndex().update();
        };
        DPickerColorGradientView.prototype.containsPoint = function (point) {
            var local = this.toLocal(point, undefined, this._workPoint);
            var parts = this._parts;
            for (var i = 0, imax = parts.length; i < imax; ++i) {
                var rect = parts[i].rect;
                if (rect.contains(local.x, local.y)) {
                    this._lastHitIndex = i;
                    return true;
                }
            }
            return false;
        };
        DPickerColorGradientView.from = function (size, nPointsPerData, checkerColors, texture) {
            if (texture === void 0) { texture = pixi_js.Texture.WHITE; }
            var vertices = new Float32Array(size * (nPointsPerData + 2) * 2 * 2);
            var uvs = new Float32Array(size * (nPointsPerData + 2) * 2 * 2);
            var colors = new Float32Array(size * (nPointsPerData + 2) * 2 * 4);
            var indices = new Uint16Array(size * (nPointsPerData + 1) * 6);
            var parts = [];
            for (var i = 0; i < size; ++i) {
                parts.push({
                    data: null,
                    rect: new pixi_js.Rectangle()
                });
            }
            var geometry = new pixi_js.Geometry()
                .addIndex(new pixi_js.Buffer(indices, false, true))
                .addAttribute("aPosition", new pixi_js.Buffer(vertices, false, false), 2)
                .addAttribute("aUv", new pixi_js.Buffer(uvs, false, false), 2)
                .addAttribute("aColor", new pixi_js.Buffer(colors, false, false), 4);
            var program = pixi_js.Program.from(VERTEX_SHADER, FRAGMENT_SHADER);
            var shader = new pixi_js.MeshMaterial(texture, {
                program: program,
                uniforms: {
                    uCheckerColors: checkerColors
                }
            });
            return new DPickerColorGradientView(nPointsPerData, vertices, uvs, colors, indices, parts, geometry, shader);
        };
        return DPickerColorGradientView;
    }(pixi_js.Mesh));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPickerColorGradient = /** @class */ (function (_super) {
        __extends(DPickerColorGradient, _super);
        function DPickerColorGradient() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DPickerColorGradient.prototype.init = function (options) {
            var _this = this;
            _super.prototype.init.call(this, options);
            var theme = this.theme;
            var padding = this._padding;
            var paddingTop = padding.getTop();
            var paddingRight = padding.getRight();
            var paddingBottom = padding.getBottom();
            var paddingLeft = padding.getLeft();
            this._work = new pixi_js.Point();
            // Picker
            var gradientPointsWidth = theme.getGradientPointsWidth();
            var gradientPointsMargin = theme.getGradientPointsMargin();
            var picker = new DPickerColor({
                x: paddingLeft + gradientPointsWidth + gradientPointsMargin,
                y: paddingTop
            });
            this._picker = picker;
            picker.on("newcolorchange", function (color) {
                _this.onAnchorColorChange(color);
            });
            picker.on("newalphachange", function (alpha) {
                _this.onAnchorAlphaChange(alpha);
            });
            this.addChild(picker);
            // Points view
            var view = (this._view = DPickerColorGradientView.from(17, 10, theme.getGradientCheckerColors()));
            view.setRectangle(0, paddingLeft, paddingTop, gradientPointsWidth, picker.height);
            this.addChild(view);
            view.on(UtilPointerEvent.down, function (e) {
                if (view.getLastHitIndex() === 0) {
                    _this.onViewDown(e);
                }
            });
            // Anchor
            this._onAnchorDownBound = function (e) {
                _this.onAnchorDown(e);
            };
            this._onAnchorMoveBound = function (e) {
                _this.onAnchorMove(e);
            };
            this._onAnchorUpBound = function (e) {
                _this.onAnchorUp(e);
            };
            this._anchors = [];
            //
            var recentColumn = theme.getGradientRecentColumn();
            var recentWidth = theme.getGradientRecentWidth();
            var recentMargin = theme.getGradientRecentMargin();
            var recentWidthAndMargin = recentWidth + recentMargin;
            var inputLabelWidth = picker.theme.getInputLabelWidth();
            var inputWidth = recentWidth * recentColumn + recentMargin * (recentColumn - 1);
            var inputMargin = 5;
            var inputDirectionMargin = theme.getGradientDirectionMargin();
            var inputDirectionTexture = theme.getGradientDirectionTexture();
            var inputLeft = picker.x + picker.width + inputDirectionMargin;
            var inputDirection = new DInputReal({
                parent: this,
                x: inputLeft + inputLabelWidth + inputMargin,
                y: paddingTop,
                width: inputWidth - (inputLabelWidth + inputMargin) * 2,
                step: 1,
                image: {
                    source: inputDirectionTexture,
                    align: {
                        with: DAlignWith.BORDER
                    },
                    margin: {
                        horizontal: -inputDirectionTexture.width - inputMargin
                    }
                },
                on: {
                    change: function (value) {
                        _this._value._direction = value;
                    }
                }
            });
            // Recent gradients
            var x0 = inputLeft;
            var y0 = inputDirection.y + inputDirection.height + inputDirectionMargin;
            if (DPickerColorGradient.RECENT_COLOR_GRADIENT == null) {
                DPickerColorGradient.RECENT_COLOR_GRADIENT = new DPickerColorGradientRecent(theme.getGradientRecents(), theme.getGradientRecentCount());
            }
            this._recent = DPickerColorGradient.RECENT_COLOR_GRADIENT;
            var recent = this._recent;
            for (var i = 0, imax = recent.getCapacity(); i < imax; ++i) {
                var ix = i % recentColumn;
                var x = x0 + ix * recentWidthAndMargin;
                var iy = (i / recentColumn) | 0;
                var y = y0 + iy * recentWidthAndMargin;
                view.setRectangle(1 + i, x, y, recentWidth, recentWidth);
            }
            recent.on("change", function () {
                _this.onRecentUpdate();
            });
            view.on(UtilPointerEvent.tap, function (e) {
                var lastHitIndex = view.getLastHitIndex();
                if (1 <= lastHitIndex) {
                    _this.onRecentClick(view.getData(lastHitIndex));
                }
            });
            // Points
            var data = new DColorGradientObservable();
            this._value = data;
            data.on("change", function () {
                _this.updateAnchors();
                view.update();
            });
            data.on("selectionchange", function (point) {
                _this.onAnchorSelect(point);
            });
            data.on("directionchange", function (value) {
                inputDirection.value = value;
            });
            view.setData(0, data);
            view.update();
            inputDirection.value = data.direction;
            this.updateAnchors();
            var selected = data.selected;
            if (selected != null) {
                this.onAnchorSelect(selected);
            }
            // Width
            if (options == null || options.width == null) {
                this.width =
                    paddingLeft +
                        gradientPointsWidth +
                        gradientPointsMargin +
                        picker.width +
                        inputDirectionMargin +
                        (recentColumn - 1) * recentMargin +
                        recentColumn * recentWidth +
                        paddingRight;
            }
            // Height
            if (options == null || options.height == null) {
                this.height = paddingTop + picker.height + paddingBottom;
            }
        };
        Object.defineProperty(DPickerColorGradient.prototype, "value", {
            get: function () {
                return this._value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DPickerColorGradient.prototype, "recent", {
            get: function () {
                return this._recent;
            },
            enumerable: false,
            configurable: true
        });
        DPickerColorGradient.prototype.onRecentClick = function (recentData) {
            var value = this._value;
            if (recentData != null) {
                value.fromObject(recentData);
            }
            else {
                value.reset();
            }
        };
        DPickerColorGradient.prototype.onRecentUpdate = function () {
            var recent = this._recent;
            var view = this._view;
            for (var i = 0, imax = recent.size(); i < imax; ++i) {
                view.setData(1 + i, recent.get(i));
            }
            view.update();
            DApplications.update(this);
        };
        DPickerColorGradient.prototype.toAnchorPosition = function (e) {
            var local = this.toLocal(e.data.global, undefined, this._work);
            return Math.max(0, Math.min(1, (local.y - this.padding.getTop()) / this._picker.height));
        };
        DPickerColorGradient.prototype.onViewDown = function (e) {
            this._value.addAt(this.toAnchorPosition(e));
            this.onAnchorDragStart();
        };
        DPickerColorGradient.prototype.onAnchorDown = function (e) {
            var target = e.target;
            if (target instanceof pixi_js.Sprite) {
                var value = this._value;
                var index = this._anchors.indexOf(target);
                if (0 <= index && index < value.points.length) {
                    value.points[index].selected = true;
                    this.onAnchorDragStart();
                }
            }
        };
        DPickerColorGradient.prototype.onAnchorSelect = function (point) {
            var picker = this._picker;
            picker.current.color = point.color;
            picker.current.alpha = point.alpha;
            picker.new.color = point.color;
            picker.new.alpha = point.alpha;
        };
        DPickerColorGradient.prototype.onAnchorColorChange = function (color) {
            var value = this._value;
            if (value != null) {
                var selected = value.selected;
                if (selected != null) {
                    selected.color = color;
                }
            }
        };
        DPickerColorGradient.prototype.onAnchorAlphaChange = function (alpha) {
            var value = this._value;
            if (value != null) {
                var selected = value.selected;
                if (selected != null) {
                    selected.alpha = alpha;
                }
            }
        };
        DPickerColorGradient.prototype.onAnchorDragStart = function () {
            var layer = DApplications.getLayer(this);
            if (layer) {
                var stage = layer.stage;
                stage.on(UtilPointerEvent.move, this._onAnchorMoveBound);
                stage.on(UtilPointerEvent.up, this._onAnchorUpBound);
            }
        };
        DPickerColorGradient.prototype.onAnchorMove = function (e) {
            var value = this._value;
            if (value != null) {
                var selected = value.selected;
                if (selected != null) {
                    selected.position = this.toAnchorPosition(e);
                }
            }
        };
        DPickerColorGradient.prototype.onAnchorUp = function (e) {
            var layer = DApplications.getLayer(this);
            if (layer) {
                var stage = layer.stage;
                stage.off(UtilPointerEvent.move, this._onAnchorMoveBound);
                stage.off(UtilPointerEvent.up, this._onAnchorUpBound);
            }
        };
        DPickerColorGradient.prototype.updateAnchors = function () {
            var theme = this.theme;
            var anchorTexture = theme.getGradientAnchorTexture();
            var anchorOutlinedTexture = theme.getGradientAnchorOutlinedTexture();
            var gradientPointsWidth = theme.getGradientPointsWidth();
            var value = this._value;
            var pointSize = value.points.length;
            var anchors = this._anchors;
            var anchorSize = anchors.length;
            for (var i = anchorSize; i < pointSize; ++i) {
                var newAnchor = new pixi_js.Sprite(anchorTexture);
                newAnchor.anchor.set(0.5, 0.5);
                newAnchor.cursor = "pointer";
                newAnchor.interactive = true;
                newAnchor.on(UtilPointerEvent.down, this._onAnchorDownBound);
                anchors.push(newAnchor);
                this.addChild(newAnchor);
            }
            for (var i = anchorSize - 1; pointSize <= i; --i) {
                var oldAnchor = anchors[i];
                oldAnchor.off(UtilPointerEvent.down, this._onAnchorDownBound);
                oldAnchor.destroy();
            }
            anchors.length = pointSize;
            var y = this.padding.getTop();
            var right = this.padding.getLeft() + gradientPointsWidth;
            var height = this._picker.height;
            for (var i = 0; i < pointSize; ++i) {
                var point = value.points[i];
                var anchor = anchors[i];
                anchor.tint = point.color;
                anchor.position.set(right, y + height * point.position);
                anchor.texture = point.selected ? anchorOutlinedTexture : anchorTexture;
            }
            DApplications.update(this);
        };
        DPickerColorGradient.prototype.onKeyDown = function (e) {
            if (UtilKeyboardEvent.isDeleteKey(e)) {
                var value = this._value;
                if (value != null) {
                    var selected = value.selected;
                    if (selected != null) {
                        value.remove(selected);
                        _super.prototype.onKeyDown.call(this, e);
                        return true;
                    }
                }
            }
            return _super.prototype.onKeyDown.call(this, e);
        };
        DPickerColorGradient.prototype.getType = function () {
            return "DPickerColorGradient";
        };
        DPickerColorGradient.RECENT_COLOR_GRADIENT = null;
        return DPickerColorGradient;
    }(DBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogColorGradient = /** @class */ (function (_super) {
        __extends(DDialogColorGradient, _super);
        function DDialogColorGradient() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DDialogColorGradient.prototype.newContentChildren = function (theme, options) {
            var result = _super.prototype.newContentChildren.call(this, theme, options);
            result.push(this.picker);
            return result;
        };
        DDialogColorGradient.prototype.onOk = function (value) {
            _super.prototype.onOk.call(this, value);
            var picker = this.picker;
            var data = picker.value;
            var recent = picker.recent;
            if (!recent.contains(data)) {
                recent.add(data.toObject());
            }
        };
        Object.defineProperty(DDialogColorGradient.prototype, "value", {
            get: function () {
                return this.picker.value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDialogColorGradient.prototype, "recent", {
            get: function () {
                return this.picker.recent;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDialogColorGradient.prototype, "picker", {
            get: function () {
                var _a;
                var result = this._picker;
                if (result == null) {
                    result = new DPickerColorGradient((_a = this._options) === null || _a === void 0 ? void 0 : _a.picker);
                    this._picker = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DDialogColorGradient.prototype.getResolvedValue = function () {
            return this.picker.value;
        };
        DDialogColorGradient.prototype.onKeyDown = function (e) {
            this.picker.onKeyDown(e);
            return _super.prototype.onKeyDown.call(this, e);
        };
        DDialogColorGradient.prototype.getType = function () {
            return "DDialogColorGradient";
        };
        return DDialogColorGradient;
    }(DDialogFitted));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DButtonColorGradient = /** @class */ (function (_super) {
        __extends(DButtonColorGradient, _super);
        function DButtonColorGradient() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DButtonColorGradient.prototype.init = function (options) {
            var _a;
            _super.prototype.init.call(this, options);
            var source = (_a = options === null || options === void 0 ? void 0 : options.image) === null || _a === void 0 ? void 0 : _a.source;
            if (source === undefined) {
                var theme = this.theme;
                var texture = theme.getViewBaseTexture();
                if (texture instanceof pixi_js.Texture) {
                    var checkers = theme.getCheckerColors();
                    var view = DPickerColorGradientView.from(1, 10, checkers, texture);
                    this._view = view;
                    view.setRectangle(0, 0, 0, texture.width, texture.height);
                    view.setData(0, this.text.computed);
                    view.update();
                    this.image = view;
                }
            }
        };
        DButtonColorGradient.prototype.onActivate = function (e) {
            var _this = this;
            _super.prototype.onActivate.call(this, e);
            var computed = this.text.computed;
            var dialog = this.dialog;
            if (computed != null) {
                dialog.value.fromObject(computed);
            }
            dialog.open(this).then(function (newValue) {
                _this.onValueChange(newValue, _this.toClone(computed));
            });
        };
        DButtonColorGradient.prototype.toClone = function (value) {
            var result = new DColorGradientObservable();
            if (value != null) {
                result.fromObject(value);
            }
            return result;
        };
        DButtonColorGradient.prototype.onValueChange = function (newValue, oldValue) {
            var computed = this.text.computed;
            if (computed != null) {
                computed.fromObject(newValue);
            }
            var view = this._view;
            if (view != null) {
                view.update();
            }
            this.text.compute(true);
            this.emit("change", newValue, oldValue, this);
        };
        Object.defineProperty(DButtonColorGradient.prototype, "dialog", {
            get: function () {
                var _a;
                var dialog = this._dialog;
                if (dialog == null) {
                    var options = (_a = this._options) === null || _a === void 0 ? void 0 : _a.dialog;
                    if (options) {
                        dialog = this.newDialog(options);
                    }
                    else {
                        if (DButtonColorGradient.DIALOG == null) {
                            DButtonColorGradient.DIALOG = this.newDialog({
                                mode: "MENU",
                                sticky: true
                            });
                        }
                        dialog = DButtonColorGradient.DIALOG;
                    }
                    this._dialog = dialog;
                }
                return dialog;
            },
            enumerable: false,
            configurable: true
        });
        DButtonColorGradient.prototype.newDialog = function (options) {
            return new DDialogColorGradient(options);
        };
        Object.defineProperty(DButtonColorGradient.prototype, "value", {
            get: function () {
                return this.text.computed;
            },
            enumerable: false,
            configurable: true
        });
        DButtonColorGradient.prototype.getType = function () {
            return "DButtonColorGradient";
        };
        return DButtonColorGradient;
    }(DButton));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogColor = /** @class */ (function (_super) {
        __extends(DDialogColor, _super);
        function DDialogColor() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DDialogColor.prototype.newContentChildren = function (theme, options) {
            var result = _super.prototype.newContentChildren.call(this, theme, options);
            result.push(this.picker);
            return result;
        };
        DDialogColor.prototype.onOk = function (value) {
            _super.prototype.onOk.call(this, value);
            var picker = this.picker;
            var recent = picker.recent;
            if (!recent.contains(picker.new)) {
                recent.add(picker.new);
            }
        };
        Object.defineProperty(DDialogColor.prototype, "current", {
            get: function () {
                return this.picker.current;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDialogColor.prototype, "new", {
            get: function () {
                return this.picker.new;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDialogColor.prototype, "recent", {
            get: function () {
                return this.picker.recent;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDialogColor.prototype, "picker", {
            get: function () {
                var _a;
                var result = this._picker;
                if (result == null) {
                    result = new DPickerColor((_a = this._options) === null || _a === void 0 ? void 0 : _a.picker);
                    this._picker = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DDialogColor.prototype.getResolvedValue = function () {
            return this.picker.new;
        };
        DDialogColor.prototype.getType = function () {
            return "DDialogColor";
        };
        return DDialogColor;
    }(DDialogFitted));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DButtonColor = /** @class */ (function (_super) {
        __extends(DButtonColor, _super);
        function DButtonColor() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DButtonColor.prototype.onActivate = function (e) {
            var _this = this;
            _super.prototype.onActivate.call(this, e);
            var dialog = this.dialog;
            var computed = this.text.computed;
            if (computed != null) {
                var dialogCurrent = dialog.current;
                dialogCurrent.color = computed.color;
                dialogCurrent.alpha = computed.alpha;
                var dialogNew = dialog.new;
                dialogNew.color = computed.color;
                dialogNew.alpha = computed.alpha;
            }
            dialog.open(this).then(function () {
                _this.onValueChange(_this.toClone(dialog.new), _this.toClone(dialog.current));
            });
        };
        DButtonColor.prototype.toClone = function (value) {
            return {
                color: value.color,
                alpha: value.alpha
            };
        };
        DButtonColor.prototype.onValueChange = function (newValue, oldValue) {
            var computed = this.text.computed;
            if (computed != null) {
                computed.color = newValue.color;
                computed.alpha = newValue.alpha;
            }
            this.onColorChange();
            this.emit("change", newValue, oldValue, this);
        };
        DButtonColor.prototype.onColorChange = function () {
            var image = this.image.get(0);
            if (image != null) {
                var computed = this.text.computed;
                if (computed != null) {
                    image.tint.color = computed.color;
                }
            }
            this.text.compute(true);
        };
        Object.defineProperty(DButtonColor.prototype, "dialog", {
            get: function () {
                var _a;
                var dialog = this._dialog;
                if (dialog == null) {
                    var options = (_a = this._options) === null || _a === void 0 ? void 0 : _a.dialog;
                    if (options) {
                        dialog = this.newDialog(options);
                    }
                    else {
                        if (DButtonColor.DIALOG == null) {
                            DButtonColor.DIALOG = this.newDialog({
                                mode: "MENU",
                                sticky: true
                            });
                        }
                        dialog = DButtonColor.DIALOG;
                    }
                    this._dialog = dialog;
                }
                return dialog;
            },
            enumerable: false,
            configurable: true
        });
        DButtonColor.prototype.newDialog = function (options) {
            return new DDialogColor(options);
        };
        Object.defineProperty(DButtonColor.prototype, "value", {
            get: function () {
                var result = this._value;
                if (result == null) {
                    result = this.newValue();
                    this._value = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DButtonColor.prototype.newValue = function () {
            var _this = this;
            var text = this.text;
            var computed = text.computed;
            return new DPickerColorAndAlpha(computed, function (color) {
                computed.color = color;
                _this.onColorChange();
            }, function (alpha) {
                computed.alpha = alpha;
                text.compute(true);
            });
        };
        DButtonColor.prototype.getType = function () {
            return "DButtonColor";
        };
        return DButtonColor;
    }(DButton));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DButtonDanger = /** @class */ (function (_super) {
        __extends(DButtonDanger, _super);
        function DButtonDanger() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DButtonDanger.prototype.getType = function () {
            return "DButtonDanger";
        };
        return DButtonDanger;
    }(DButton));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DButtonDate = /** @class */ (function (_super) {
        __extends(DButtonDate, _super);
        function DButtonDate() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DButtonDate.prototype.onActivate = function (e) {
            var _this = this;
            var _a, _b;
            _super.prototype.onActivate.call(this, e);
            var value = (_b = (_a = this.text.computed) === null || _a === void 0 ? void 0 : _a.getTime()) !== null && _b !== void 0 ? _b : Date.now();
            var dialog = this.dialog;
            dialog.current = new Date(value);
            dialog.new = new Date(value);
            dialog.page = new Date(value);
            dialog.open(this).then(function () {
                _this.onValueChange(dialog.new, dialog.current);
            });
        };
        DButtonDate.prototype.onValueChange = function (newValue, oldValue) {
            this.text = new Date(newValue.getTime());
            this.emit("change", newValue, oldValue, this);
        };
        Object.defineProperty(DButtonDate.prototype, "dialog", {
            get: function () {
                var _a;
                var dialog = this._dialog;
                if (dialog == null) {
                    var options = (_a = this._options) === null || _a === void 0 ? void 0 : _a.dialog;
                    if (options) {
                        dialog = this.newDialog(options);
                    }
                    else {
                        if (DButtonDate.DIALOG == null) {
                            DButtonDate.DIALOG = this.newDialog({
                                mode: "MENU",
                                sticky: true
                            });
                        }
                        dialog = DButtonDate.DIALOG;
                    }
                    this._dialog = dialog;
                }
                return dialog;
            },
            enumerable: false,
            configurable: true
        });
        DButtonDate.prototype.newDialog = function (options) {
            return new DDialogDate(options);
        };
        Object.defineProperty(DButtonDate.prototype, "value", {
            get: function () {
                var _a;
                return (_a = this.text.computed) !== null && _a !== void 0 ? _a : new Date();
            },
            set: function (value) {
                var computed = this.text.computed;
                if (computed === undefined || computed.getTime() !== value.getTime()) {
                    this.text = value;
                }
            },
            enumerable: false,
            configurable: true
        });
        DButtonDate.prototype.getType = function () {
            return "DButtonDate";
        };
        return DButtonDate;
    }(DButton));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPickerDates = /** @class */ (function () {
        function DPickerDates() {
        }
        DPickerDates.format = function (date) {
            var y = toPadded(String(date.getFullYear()), 4, "0");
            var M = toPadded(String(date.getMonth() + 1), 2, "0");
            var S = toPadded(String(date.getDate()), 2, "0");
            return "".concat(y, "/").concat(M, "/").concat(S);
        };
        return DPickerDates;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPickerTimes = /** @class */ (function () {
        function DPickerTimes() {
        }
        DPickerTimes.format = function (date, mask) {
            var result = "";
            if (mask & DPickerDatetimeMask.HOURS) {
                result += toPadded(String(date.getHours()), 2, "0");
            }
            if (mask & DPickerDatetimeMask.MINUTES) {
                if (0 < result.length) {
                    result += ":";
                }
                result += toPadded(String(date.getMinutes()), 2, "0");
            }
            if (mask & DPickerDatetimeMask.SECONDS) {
                if (0 < result.length) {
                    result += ":";
                }
                result += toPadded(String(date.getSeconds()), 2, "0");
            }
            return result;
        };
        DPickerTimes.toMask = function (options) {
            return DPickerDatetimeMasks.from("DPickerTime", options);
        };
        return DPickerTimes;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPickerDatetimes = /** @class */ (function () {
        function DPickerDatetimes() {
        }
        DPickerDatetimes.format = function (date, mask) {
            var hms = DPickerTimes.format(date, mask);
            if (0 < hms.length) {
                return "".concat(DPickerDates.format(date), " ").concat(hms);
            }
            else {
                return "".concat(DPickerDates.format(date));
            }
        };
        DPickerDatetimes.toMask = function (options) {
            return DPickerDatetimeMasks.from("DPickerDatetime", options);
        };
        return DPickerDatetimes;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DButtonDatetime = /** @class */ (function (_super) {
        __extends(DButtonDatetime, _super);
        function DButtonDatetime() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DButtonDatetime.prototype.onActivate = function (e) {
            var _this = this;
            var _a, _b;
            _super.prototype.onActivate.call(this, e);
            var value = (_b = (_a = this.text.computed) === null || _a === void 0 ? void 0 : _a.getTime()) !== null && _b !== void 0 ? _b : Date.now();
            var dialog = this.dialog;
            dialog.current = new Date(value);
            dialog.new = new Date(value);
            dialog.page = new Date(value);
            dialog.open(this).then(function () {
                _this.onValueChange(dialog.new, dialog.current);
            });
        };
        DButtonDatetime.prototype.onValueChange = function (newValue, oldValue) {
            this.text = new Date(newValue.getTime());
            this.emit("change", newValue, oldValue, this);
        };
        DButtonDatetime.prototype.getDatetimeMask = function () {
            var _a, _b;
            var result = this._datetimeMask;
            if (result == null) {
                result = DPickerDatetimes.toMask((_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.dialog) === null || _b === void 0 ? void 0 : _b.picker);
                this._datetimeMask = result;
            }
            return result;
        };
        Object.defineProperty(DButtonDatetime.prototype, "dialog", {
            get: function () {
                var _a;
                var dialog = this._dialog;
                if (dialog == null) {
                    var options = (_a = this._options) === null || _a === void 0 ? void 0 : _a.dialog;
                    if (options) {
                        dialog = this.newDialog(options);
                    }
                    else {
                        if (DButtonDatetime.DIALOG == null) {
                            DButtonDatetime.DIALOG = this.newDialog({
                                mode: "MENU",
                                sticky: true
                            });
                        }
                        dialog = DButtonDatetime.DIALOG;
                    }
                    this._dialog = dialog;
                }
                return dialog;
            },
            enumerable: false,
            configurable: true
        });
        DButtonDatetime.prototype.newDialog = function (options) {
            return new DDialogDatetime(options);
        };
        Object.defineProperty(DButtonDatetime.prototype, "value", {
            get: function () {
                var _a;
                return (_a = this.text.computed) !== null && _a !== void 0 ? _a : new Date();
            },
            set: function (value) {
                var computed = this.text.computed;
                if (computed === undefined || computed.getTime() !== value.getTime()) {
                    this.text = value;
                }
            },
            enumerable: false,
            configurable: true
        });
        DButtonDatetime.prototype.getType = function () {
            return "DButtonDatetime";
        };
        return DButtonDatetime;
    }(DButton));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A file selector.
     */
    var DButtonFile = /** @class */ (function (_super) {
        __extends(DButtonFile, _super);
        function DButtonFile() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DButtonFile.prototype.getChecker = function () {
            var _a, _b;
            var result = this._checker;
            if (result === undefined) {
                result = (_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.checker) !== null && _b !== void 0 ? _b : null;
                this._checker = result;
            }
            return result;
        };
        DButtonFile.prototype.getOpener = function () {
            var result = this._opener;
            if (result == null) {
                result = this.newOpener();
                this._opener = result;
            }
            return result;
        };
        DButtonFile.prototype.newOpener = function () {
            var _a, _b;
            return new UtilFileOpener(toEnum((_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.as) !== null && _b !== void 0 ? _b : UtilFileAs.TEXT, UtilFileAs), this);
        };
        DButtonFile.prototype.onActivate = function (e) {
            var _this = this;
            _super.prototype.onActivate.call(this, e);
            this.check(function () {
                _this.open();
            });
        };
        DButtonFile.prototype.check = function (onResolve) {
            var checker = this.getChecker();
            if (checker != null) {
                var result = checker();
                if (result === true) {
                    onResolve();
                }
                else if (result === false) ;
                else {
                    result.then(function () {
                        onResolve();
                    });
                }
            }
            else {
                onResolve();
            }
        };
        DButtonFile.prototype.open = function () {
            this.getOpener().open();
        };
        DButtonFile.prototype.getType = function () {
            return "DButtonFile";
        };
        return DButtonFile;
    }(DButton));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DButtonLink = /** @class */ (function (_super) {
        __extends(DButtonLink, _super);
        function DButtonLink() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DButtonLink.prototype.onClick = function (e) {
            if (!this.link.onClick(this, e)) {
                _super.prototype.onClick.call(this, e);
            }
        };
        Object.defineProperty(DButtonLink.prototype, "link", {
            get: function () {
                var result = this._link;
                if (result == null) {
                    result = new DLink(this._options);
                    this._link = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DButtonLink.prototype.onActivate = function (e) {
            _super.prototype.onActivate.call(this, e);
            this.link.open(e);
        };
        DButtonLink.prototype.open = function (inNewWindow) {
            this.link.open(inNewWindow);
        };
        DButtonLink.prototype.getType = function () {
            return "DButtonLink";
        };
        return DButtonLink;
    }(DButtonBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DButtonRadio = /** @class */ (function (_super) {
        __extends(DButtonRadio, _super);
        function DButtonRadio() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DButtonRadio.prototype.getType = function () {
            return "DButtonRadio";
        };
        return DButtonRadio;
    }(DButtonBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DButtonRadioRight = /** @class */ (function (_super) {
        __extends(DButtonRadioRight, _super);
        function DButtonRadioRight() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DButtonRadioRight.prototype.getType = function () {
            return "DButtonRadioRight";
        };
        return DButtonRadioRight;
    }(DButtonRadio));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DButtonRedo = /** @class */ (function (_super) {
        __extends(DButtonRedo, _super);
        function DButtonRedo(options) {
            var _this = _super.call(this, options) || this;
            var state = _this.state;
            var commandController = DControllers.getCommandController();
            state.isDisabled = !commandController.isRedoable();
            commandController.on("change", function () {
                state.isDisabled = !commandController.isRedoable();
            });
            return _this;
        }
        DButtonRedo.prototype.onActivate = function (e) {
            _super.prototype.onActivate.call(this, e);
            DControllers.getCommandController().redo();
        };
        return DButtonRedo;
    }(DButton));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DButtonSecondary = /** @class */ (function (_super) {
        __extends(DButtonSecondary, _super);
        function DButtonSecondary() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DButtonSecondary.prototype.getType = function () {
            return "DButtonSecondary";
        };
        return DButtonSecondary;
    }(DButton));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * {@link DListDataSelection} type.
     */
    var DListDataSelectionType = {
        NONE: 0,
        SINGLE: 1,
        MULTIPLE: 2
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DListItem = /** @class */ (function (_super) {
        __extends(DListItem, _super);
        function DListItem(data, options) {
            var _this = _super.call(this, options) || this;
            _this._data = data;
            _this.on(UtilPointerEvent.tap, function (e) {
                _this.onClick(e);
            });
            return _this;
        }
        Object.defineProperty(DListItem.prototype, "link", {
            get: function () {
                var result = this._link;
                if (result === undefined) {
                    result = this.newLink();
                    this._link = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DListItem.prototype.newLink = function () {
            var link = this._data.accessor.link;
            if (link) {
                return new DLink(this.toLinkOptions(link));
            }
            return null;
        };
        DListItem.prototype.onClick = function (e) {
            var _a;
            if (((_a = this.link) === null || _a === void 0 ? void 0 : _a.onClick(this, e)) !== true) {
                if (this.state.isActionable) {
                    this.activate(e);
                }
            }
        };
        DListItem.prototype.activate = function (e) {
            var value = this._value;
            if (value !== undefined) {
                this.onSelect(e, value);
            }
        };
        DListItem.prototype.toLinkOptions = function (accessor) {
            return {
                url: this.toLinkUrl(accessor.toUrl),
                target: accessor.target,
                checker: this.toLinkChecker(accessor.checker)
            };
        };
        DListItem.prototype.toLinkUrl = function (toUrl) {
            var _this = this;
            return function () {
                var value = _this._value;
                if (value !== undefined) {
                    return toUrl(value);
                }
            };
        };
        DListItem.prototype.toLinkChecker = function (checker) {
            var _this = this;
            if (checker) {
                return function () {
                    var value = _this._value;
                    if (value != null) {
                        return checker(value);
                    }
                    return false;
                };
            }
            return undefined;
        };
        Object.defineProperty(DListItem.prototype, "value", {
            get: function () {
                return this._value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DListItem.prototype, "index", {
            get: function () {
                return this._index;
            },
            enumerable: false,
            configurable: true
        });
        DListItem.prototype.onSelect = function (e, value) {
            var _a;
            this.emit("select", value, this);
            var data = this._data;
            var selection = data.selection;
            if (selection.type !== DListDataSelectionType.MULTIPLE) {
                selection.clearAndAdd(value);
            }
            else {
                var originalEvent = e && "data" in e ? e.data.originalEvent : e;
                if (originalEvent === null || originalEvent === void 0 ? void 0 : originalEvent.ctrlKey) {
                    selection.toggle(value);
                }
                else if (originalEvent === null || originalEvent === void 0 ? void 0 : originalEvent.shiftKey) {
                    var mapped = data.mapped;
                    var last_1 = selection.last;
                    if (value === last_1) {
                        selection.clearAndAdd(value);
                    }
                    else {
                        var isFound_1 = false;
                        var isReverse_1 = false;
                        var newSelection_1 = [];
                        mapped.each(function (item) {
                            if (isFound_1) {
                                if (isReverse_1) {
                                    newSelection_1.unshift(item);
                                    if (item === value) {
                                        return false;
                                    }
                                }
                                else {
                                    newSelection_1.push(item);
                                    if (item === last_1) {
                                        return false;
                                    }
                                }
                            }
                            else {
                                if (item === value) {
                                    isFound_1 = true;
                                    isReverse_1 = false;
                                    newSelection_1.push(item);
                                }
                                else if (item === last_1) {
                                    isFound_1 = true;
                                    isReverse_1 = true;
                                    newSelection_1.push(item);
                                }
                            }
                        });
                        selection.clearAndAddAll(newSelection_1);
                    }
                }
                else {
                    selection.clearAndAdd(value);
                }
            }
            (_a = this._link) === null || _a === void 0 ? void 0 : _a.open(e);
        };
        DListItem.prototype.set = function (value, index, forcibly) {
            var data = this._data;
            var isValueChanged = forcibly || this._value !== value;
            if (isValueChanged) {
                this._value = value;
                this._index = index;
                var accessor = data.accessor;
                this.text = accessor.toLabel(value);
                this.title = accessor.toTitle(value) || "";
                this.image = accessor.toImage(value);
            }
            var state = this.state;
            state.lock();
            state.set(DBaseState.ACTIVE, data.selection.contains(value));
            state.remove(DBaseState.DISABLED);
            state.unlock();
            if (isValueChanged) {
                this.emit("set", value, index, this);
            }
        };
        DListItem.prototype.unset = function () {
            if (this._value !== undefined) {
                this._value = undefined;
                this._index = undefined;
                this.text = undefined;
                this.title = "";
                this.image = undefined;
                var state = this.state;
                state.lock();
                state.add(DBaseState.DISABLED);
                state.remove(DBaseState.ACTIVE);
                state.unlock();
                this.emit("unset", this);
            }
        };
        DListItem.prototype.onKeyDown = function (e) {
            if (UtilKeyboardEvent.isActivateKey(e)) {
                this.onKeyDownActivate(e);
            }
            return _super.prototype.onKeyDown.call(this, e);
        };
        DListItem.prototype.onKeyDownActivate = function (e) {
            if (this.state.isActionable && this.state.isFocused) {
                this.activate(e);
                return true;
            }
            return false;
        };
        DListItem.prototype.getType = function () {
            return "DListItem";
        };
        return DListItem;
    }(DImageBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogSelectListItem = /** @class */ (function (_super) {
        __extends(DDialogSelectListItem, _super);
        function DDialogSelectListItem() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DDialogSelectListItem.prototype.getType = function () {
            return "DDialogSelectListItem";
        };
        return DDialogSelectListItem;
    }(DListItem));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * The primary purpose of this class is to minimize the number of rendered items (e.g., {@link DListItem})
     * as low as possible and to update their positions and states. For this sake, the updater calculates the
     * required number of items whenever their container size changes and creates items if needed.
     */
    var DItemUpdater = /** @class */ (function () {
        function DItemUpdater(data, content, container, options) {
            this._updateItemsCount = 0;
            this._isUpdateItemsCalled = false;
            this._isUpdateItemsCalledForcibly = false;
            this._itemHeight = -1;
            this._itemWidth = -1;
            this._multiplicity = 1;
            this._itemIndexStart = 0;
            this._itemIndexEnd = 0;
            this._workItems = [];
            this._data = data;
            this._content = content;
            this._container = container;
            this._newItem = this.toNewItem(options);
            this._initItem = this.toInitItem(options);
        }
        DItemUpdater.prototype.toNewItem = function (options) {
            return (options === null || options === void 0 ? void 0 : options.newItem) || this.newItem;
        };
        DItemUpdater.prototype.toInitItem = function (options) {
            if (options) {
                var initItem = options.initItem;
                if (initItem) {
                    return initItem;
                }
                if (options.stripe !== false) {
                    return this.initItem;
                }
                return this.initItemNoStriping;
            }
            return this.initItem;
        };
        DItemUpdater.prototype.initItem = function (item, index, data) {
            item.state.isAlternated = index % 2 === 1;
            return item;
        };
        DItemUpdater.prototype.initItemNoStriping = function (item, index, data) {
            return item;
        };
        Object.defineProperty(DItemUpdater.prototype, "multiplicity", {
            get: function () {
                return this._multiplicity;
            },
            enumerable: false,
            configurable: true
        });
        DItemUpdater.prototype.lock = function () {
            this._updateItemsCount += 1;
            if (this._updateItemsCount === 1) {
                this._isUpdateItemsCalled = false;
                this._isUpdateItemsCalledForcibly = false;
            }
        };
        DItemUpdater.prototype.unlock = function (callIfNeeded) {
            this._updateItemsCount -= 1;
            if (this._updateItemsCount === 0) {
                if (callIfNeeded && this._isUpdateItemsCalled) {
                    this.update(this._isUpdateItemsCalledForcibly);
                }
                this._isUpdateItemsCalled = false;
                this._isUpdateItemsCalledForcibly = false;
            }
        };
        DItemUpdater.prototype.update = function (forcibly) {
            var _this = this;
            if (0 < this._updateItemsCount) {
                this._isUpdateItemsCalled = true;
                if (forcibly) {
                    this._isUpdateItemsCalledForcibly = true;
                }
                return;
            }
            var content = this._content;
            var contentParent = content.parent;
            if (contentParent == null) {
                return;
            }
            var container = this._container;
            var items = container.children;
            var height = contentParent.height;
            var data = this._data;
            var mapped = this.toMapped(data);
            var dataSize = mapped.size();
            var oldItemIndexStart = this._itemIndexStart;
            var oldItemIndexEnd = this._itemIndexEnd;
            var oldItemCount = oldItemIndexEnd - oldItemIndexStart;
            var newItem = this._newItem;
            var initItem = this._initItem;
            var itemHeight = this._itemHeight;
            var itemWidth = this._itemWidth;
            if (this._itemHeight < 0) {
                var item = void 0;
                if (0 < items.length) {
                    item = items[0];
                }
                else {
                    item = initItem(newItem(data), oldItemIndexStart, data);
                    container.addChild(item);
                    oldItemIndexEnd += 1;
                    oldItemCount += 1;
                }
                itemHeight = Math.max(1, item.height);
                if (isNumber(item.getWidth())) {
                    itemWidth = Math.max(1, item.width);
                }
                this._itemHeight = itemHeight;
                this._itemWidth = itemWidth;
            }
            var contentPadding = content.padding;
            var contentPaddingTop = contentPadding.getTop();
            var contentPaddingBottom = contentPadding.getBottom();
            var contentPaddingLeft = contentPadding.getLeft();
            var contentPaddingRight = contentPadding.getRight();
            var contentWidthAvailable = Math.max(0, content.width - contentPaddingLeft - contentPaddingRight);
            var multiplicity = 0 < itemWidth ? Math.max(1, Math.floor(contentWidthAvailable / itemWidth)) : 1;
            this._multiplicity = multiplicity;
            var y = content !== container ? container.transform.position.y : contentPaddingTop;
            var newHeight = Math.ceil(dataSize / multiplicity) * itemHeight;
            var newContentHeight = Math.max(height, contentPaddingTop + newHeight + contentPaddingBottom);
            var newContentY = Math.max(height - newContentHeight, content.position.y);
            var newItemIndexLowerBound = Math.floor(((0 - (newContentY + y)) * multiplicity) / itemHeight);
            var newItemIndexUpperBound = Math.floor(((height - (newContentY + y)) * multiplicity) / itemHeight);
            var newItemIndexStart = newItemIndexLowerBound - multiplicity;
            if (newItemIndexStart % 2 !== 0) {
                newItemIndexStart -= 1;
            }
            var newItemIndexEnd = newItemIndexUpperBound + multiplicity + multiplicity;
            if (newItemIndexEnd % 2 !== 0) {
                newItemIndexEnd += 1;
            }
            var newItemCount = newItemIndexEnd - newItemIndexStart;
            if (newItemCount < oldItemCount) {
                newItemCount = oldItemCount;
                newItemIndexEnd = newItemIndexStart + newItemCount;
            }
            if (oldItemCount < newItemCount) {
                for (var i = oldItemCount; i < newItemCount; ++i) {
                    var oldItemIndex = oldItemIndexStart + i;
                    var item = initItem(newItem(data), oldItemIndex, data);
                    container.addChild(item);
                }
                oldItemCount = newItemCount;
                oldItemIndexEnd = oldItemIndexStart + oldItemCount;
            }
            else if (newItemCount < oldItemCount) {
                for (var i = oldItemCount - 1; newItemCount <= i; --i) {
                    container.removeChild(items[i]);
                }
                oldItemCount = newItemCount;
                oldItemIndexEnd = oldItemIndexStart + oldItemCount;
            }
            this._itemIndexStart = newItemIndexStart;
            this._itemIndexEnd = newItemIndexEnd;
            var itemIndexStartDelta = newItemIndexStart - oldItemIndexStart;
            var itemIndexStartDeltaAbs = Math.abs(itemIndexStartDelta);
            var itemsLength = items.length;
            if (0 < itemIndexStartDeltaAbs && itemIndexStartDeltaAbs < itemsLength) {
                var work = this._workItems;
                if (0 < itemIndexStartDelta) {
                    for (var i = 0; i < itemIndexStartDeltaAbs; ++i) {
                        var item = items[i];
                        this.reset(item);
                        work.push(item);
                    }
                    for (var i = itemIndexStartDeltaAbs; i < itemsLength; ++i) {
                        items[i - itemIndexStartDeltaAbs] = items[i];
                    }
                    for (var i = 0; i < itemIndexStartDeltaAbs; ++i) {
                        items[itemsLength - itemIndexStartDeltaAbs + i] = work[i];
                    }
                }
                else {
                    for (var i = 0; i < itemIndexStartDeltaAbs; ++i) {
                        var item = items[itemsLength - itemIndexStartDeltaAbs + i];
                        this.reset(item);
                        work.push(item);
                    }
                    for (var i = itemsLength - itemIndexStartDeltaAbs - 1; 0 <= i; --i) {
                        items[i + itemIndexStartDeltaAbs] = items[i];
                    }
                    for (var i = 0; i < itemIndexStartDeltaAbs; ++i) {
                        items[i] = work[i];
                    }
                }
                work.length = 0;
            }
            var itemOffsetX = 0;
            var itemOffsetY = 0;
            if (content === container) {
                itemOffsetX = contentPaddingLeft;
                itemOffsetY = contentPaddingTop;
            }
            mapped.each(function (datum, index) {
                var item = items[index - newItemIndexStart];
                var ix = index % multiplicity;
                var iy = Math.floor(index / multiplicity);
                item.position.set(itemOffsetX + ix * itemWidth, itemOffsetY + iy * itemHeight);
                _this.set(item, datum, index, forcibly);
            }, newItemIndexStart, newItemIndexStart + itemsLength);
            for (var i = 0; newItemIndexStart + i < 0 && i < itemsLength; ++i) {
                var item = items[i];
                var index = newItemIndexStart + i;
                var ix = index % multiplicity;
                var iy = Math.floor(index / multiplicity);
                item.position.set(itemOffsetX + ix * itemWidth, itemOffsetY + iy * itemHeight);
                this.unset(item);
            }
            for (var i = itemsLength - 1; dataSize <= newItemIndexStart + i && 0 <= i; --i) {
                var item = items[i];
                var index = newItemIndexStart + i;
                var ix = index % multiplicity;
                var iy = Math.floor(index / multiplicity);
                item.position.set(itemOffsetX + ix * itemWidth, itemOffsetY + iy * itemHeight);
                this.unset(item);
            }
            this.lock();
            content.position.y = newContentY;
            content.height = newContentHeight;
            if (content !== container) {
                container.height = newHeight;
            }
            this.unlock(false);
        };
        DItemUpdater.prototype.set = function (item, value, index, forcibly) {
            item.set(value, index, forcibly);
        };
        DItemUpdater.prototype.unset = function (item) {
            item.unset();
        };
        DItemUpdater.prototype.reset = function (item) {
            item.blur(true);
            var cells = item.children;
            for (var i = 0, imax = cells.length; i < imax; ++i) {
                var cell = cells[i];
                if (cell instanceof DBase) {
                    var state = cell.state;
                    state.lock();
                    state.isPressed = false;
                    state.isHovered = false;
                    state.unlock();
                }
            }
            item.state.isHovered = false;
            return item;
        };
        DItemUpdater.prototype.moveFocus = function (e, target, moveVertically, moveHorizontally) {
            if (!(moveVertically || moveHorizontally)) {
                return false;
            }
            var isUp = moveVertically && UtilKeyboardEvent.isArrowUpKey(e);
            var isDown = moveVertically && UtilKeyboardEvent.isArrowDownKey(e);
            var isLeft = moveHorizontally && UtilKeyboardEvent.isArrowLeftKey(e);
            var isRight = moveHorizontally && UtilKeyboardEvent.isArrowRightKey(e);
            if (!(isUp || isDown || isLeft || isRight)) {
                return false;
            }
            if (!target.state.isActionable) {
                return false;
            }
            var layer = DApplications.getLayer(target);
            if (layer == null) {
                return false;
            }
            var focusController = layer.getFocusController();
            var focused = focusController.get();
            if (focused == null) {
                return false;
            }
            var container = this._container;
            if (focused.parent !== container) {
                return false;
            }
            var item = focused;
            var index = item.index;
            if (index == null) {
                return false;
            }
            var multiplicity = this._multiplicity;
            var data = this._data;
            var mapped = this.toMapped(data);
            var dataSize = mapped.size();
            var newIndex = index;
            if (isLeft || isRight) {
                if (isLeft) {
                    if (0 <= newIndex - 1) {
                        newIndex -= 1;
                    }
                }
                else {
                    if (newIndex + 1 < dataSize) {
                        newIndex += 1;
                    }
                }
            }
            if (isUp || isDown) {
                if (isUp) {
                    if (0 <= newIndex - multiplicity) {
                        newIndex -= multiplicity;
                    }
                }
                else {
                    if (newIndex + multiplicity < dataSize) {
                        newIndex += multiplicity;
                    }
                }
            }
            if (newIndex === index) {
                return false;
            }
            var items = container.children;
            var itemIndex = items.indexOf(item);
            if (itemIndex < 0) {
                return false;
            }
            var newItemIndex = itemIndex + (newIndex - index);
            if (newItemIndex < 0 || items.length <= newItemIndex) {
                return false;
            }
            var newItem = items[newItemIndex];
            focusController.focus(newItem);
            return true;
        };
        return DItemUpdater;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DListItemUpdater = /** @class */ (function (_super) {
        __extends(DListItemUpdater, _super);
        function DListItemUpdater() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DListItemUpdater.prototype.toMapped = function (data) {
            return data.mapped;
        };
        DListItemUpdater.prototype.newItem = function (data) {
            return new DListItem(data);
        };
        return DListItemUpdater;
    }(DItemUpdater));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogSelectListItemUpdater = /** @class */ (function (_super) {
        __extends(DDialogSelectListItemUpdater, _super);
        function DDialogSelectListItemUpdater() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DDialogSelectListItemUpdater.prototype.newItem = function (data) {
            return new DDialogSelectListItem(data);
        };
        return DDialogSelectListItemUpdater;
    }(DListItemUpdater));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DListDataMappedImpl = /** @class */ (function () {
        function DListDataMappedImpl(parent) {
            this._parent = parent;
        }
        DListDataMappedImpl.prototype.size = function () {
            var parent = this._parent;
            return parent.before.length + parent.items.length + parent.after.length;
        };
        DListDataMappedImpl.prototype.each = function (iteratee, from, to) {
            var parent = this._parent;
            var index0 = this.each_(iteratee, parent.before, 0, from, to);
            if (index0 < 0) {
                return;
            }
            var index1 = this.each_(iteratee, parent.items, index0, from, to);
            if (index1 < 0) {
                return;
            }
            this.each_(iteratee, parent.after, index1, from, to);
        };
        DListDataMappedImpl.prototype.each_ = function (iteratee, items, start, from, to) {
            var end = start + items.length;
            var ifrom = from != null ? Math.max(start, from) : start;
            var ito = to != null ? Math.min(end, to) : end;
            for (var i = ifrom; i < ito; ++i) {
                if (iteratee(items[i - start], i) === false) {
                    return -1;
                }
            }
            return ito;
        };
        return DListDataMappedImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DListDataSelectionMultiple = /** @class */ (function (_super) {
        __extends(DListDataSelectionMultiple, _super);
        function DListDataSelectionMultiple(parent, accessor, options) {
            var _this = _super.call(this) || this;
            _this._parent = parent;
            _this._accessor = accessor;
            _this._items = new Set();
            // Events
            var on = options === null || options === void 0 ? void 0 : options.on;
            if (on) {
                for (var name_1 in on) {
                    var handler = on[name_1];
                    if (handler) {
                        _this.on(name_1, handler);
                    }
                }
            }
            return _this;
        }
        Object.defineProperty(DListDataSelectionMultiple.prototype, "type", {
            get: function () {
                return DListDataSelectionType.MULTIPLE;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DListDataSelectionMultiple.prototype, "first", {
            get: function () {
                return this.get(0);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DListDataSelectionMultiple.prototype, "last", {
            get: function () {
                return this.get(this.size() - 1);
            },
            enumerable: false,
            configurable: true
        });
        DListDataSelectionMultiple.prototype.get = function (index) {
            var items = this._items;
            if (0 <= index && index < items.size) {
                var counter_1 = 0;
                var result_1 = null;
                items.forEach(function (item) {
                    if (counter_1 === index) {
                        result_1 = item;
                    }
                    counter_1 += 1;
                });
                return result_1;
            }
            return null;
        };
        DListDataSelectionMultiple.prototype.add = function (target) {
            var items = this._items;
            if (!items.has(target)) {
                items.add(target);
                this.onChange();
                return true;
            }
            return false;
        };
        DListDataSelectionMultiple.prototype.remove = function (target) {
            var items = this._items;
            if (items.has(target)) {
                items.delete(target);
                this.onChange();
                return true;
            }
            return false;
        };
        DListDataSelectionMultiple.prototype.toggle = function (target) {
            var items = this._items;
            if (items.has(target)) {
                items.delete(target);
            }
            else {
                items.add(target);
            }
            this.onChange();
            return true;
        };
        DListDataSelectionMultiple.prototype.clear = function () {
            var items = this._items;
            if (0 < items.size) {
                items.clear();
                this.onChange();
            }
        };
        DListDataSelectionMultiple.prototype.clearAndAdd = function (target) {
            var items = this._items;
            var size = items.size;
            if (size === 1) {
                if (items.has(target)) {
                    return false;
                }
                else {
                    items.clear();
                    items.add(target);
                    this.onChange();
                    return true;
                }
            }
            else {
                items.clear();
                items.add(target);
                this.onChange();
                return true;
            }
        };
        DListDataSelectionMultiple.prototype.clearAndAddAll = function (targets) {
            var isDirty = false;
            var newNodes = new Set();
            var oldNodes = this._items;
            for (var i = 0, imax = targets.length; i < imax; ++i) {
                var target = targets[i];
                if (!oldNodes.has(target)) {
                    isDirty = true;
                }
                newNodes.add(target);
            }
            if (!isDirty) {
                oldNodes.forEach(function (oldItem) {
                    if (!newNodes.has(oldItem)) {
                        isDirty = true;
                    }
                });
            }
            if (isDirty) {
                this._items = newNodes;
                this.onChange();
            }
            return isDirty;
        };
        DListDataSelectionMultiple.prototype.contains = function (target) {
            return this._items.has(target);
        };
        DListDataSelectionMultiple.prototype.size = function () {
            return this._items.size;
        };
        DListDataSelectionMultiple.prototype.isEmpty = function () {
            return this.size() <= 0;
        };
        DListDataSelectionMultiple.prototype.each = function (iteratee) {
            var isCanceled = false;
            this._items.forEach(function (item) {
                if (!isCanceled) {
                    if (iteratee(item) === false) {
                        isCanceled = true;
                    }
                }
            });
        };
        DListDataSelectionMultiple.prototype.toArray = function () {
            var result = [];
            this._items.forEach(function (item) {
                result.push(item);
            });
            return result;
        };
        DListDataSelectionMultiple.prototype.onChange = function () {
            this._parent.update();
            this.emit("change", this);
        };
        DListDataSelectionMultiple.prototype.toItemIdMap = function (items, toId, result) {
            for (var i = 0, imax = items.length; i < imax; ++i) {
                var item = items[i];
                result.set(toId(item), item);
            }
        };
        DListDataSelectionMultiple.prototype.toItemSet = function (items, result) {
            for (var i = 0, imax = items.length; i < imax; ++i) {
                result.add(items[i]);
            }
        };
        DListDataSelectionMultiple.prototype.onItemChange = function (before, items, after) {
            var oldItems = this._items;
            var newItems = new Set();
            var toId = this._accessor.toId;
            if (toId) {
                var newItemIdMap_1 = new Map();
                this.toItemIdMap(before, toId, newItemIdMap_1);
                this.toItemIdMap(items, toId, newItemIdMap_1);
                this.toItemIdMap(after, toId, newItemIdMap_1);
                oldItems.forEach(function (oldItem) {
                    var oldItemId = toId(oldItem);
                    var newItem = newItemIdMap_1.get(oldItemId);
                    if (newItem != null) {
                        newItems.add(newItem);
                    }
                });
                this._items = newItems;
                this.onChange();
            }
            else {
                var newItemSet_1 = new Set();
                this.toItemSet(before, newItemSet_1);
                this.toItemSet(items, newItemSet_1);
                this.toItemSet(after, newItemSet_1);
                oldItems.forEach(function (oldItem) {
                    if (newItemSet_1.has(oldItem)) {
                        newItems.add(oldItem);
                    }
                });
                if (oldItems.size !== newItems.size) {
                    this._items = newItems;
                    this.onChange();
                }
            }
        };
        DListDataSelectionMultiple.prototype.newItems = function (items, existing, result) {
            for (var i = 0, imax = items.length; i < imax; ++i) {
                var item = items[i];
                if (existing.has(item)) {
                    result.add(item);
                }
            }
            return result;
        };
        return DListDataSelectionMultiple;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DListDataSelectionNone = /** @class */ (function (_super) {
        __extends(DListDataSelectionNone, _super);
        function DListDataSelectionNone(parent, accessor, options) {
            var _this = _super.call(this) || this;
            _this._parent = parent;
            // Events
            var on = options === null || options === void 0 ? void 0 : options.on;
            if (on) {
                for (var name_1 in on) {
                    var handler = on[name_1];
                    if (handler) {
                        _this.on(name_1, handler);
                    }
                }
            }
            return _this;
        }
        Object.defineProperty(DListDataSelectionNone.prototype, "type", {
            get: function () {
                return DListDataSelectionType.NONE;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DListDataSelectionNone.prototype, "first", {
            get: function () {
                return null;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DListDataSelectionNone.prototype, "last", {
            get: function () {
                return null;
            },
            enumerable: false,
            configurable: true
        });
        DListDataSelectionNone.prototype.get = function (index) {
            return null;
        };
        DListDataSelectionNone.prototype.add = function (target) {
            return false;
        };
        DListDataSelectionNone.prototype.remove = function (target) {
            return false;
        };
        DListDataSelectionNone.prototype.toggle = function (target) {
            return false;
        };
        DListDataSelectionNone.prototype.clear = function () {
            // DO NOTHING
        };
        DListDataSelectionNone.prototype.clearAndAdd = function (target) {
            return false;
        };
        DListDataSelectionNone.prototype.clearAndAddAll = function (targets) {
            return false;
        };
        DListDataSelectionNone.prototype.contains = function (target) {
            return false;
        };
        DListDataSelectionNone.prototype.size = function () {
            return 0;
        };
        DListDataSelectionNone.prototype.isEmpty = function () {
            return true;
        };
        DListDataSelectionNone.prototype.each = function (iteratee) {
            // DO NOTHING
        };
        DListDataSelectionNone.prototype.toArray = function () {
            return [];
        };
        DListDataSelectionNone.prototype.onChange = function () {
            this._parent.update();
            this.emit("change", this);
        };
        DListDataSelectionNone.prototype.onItemChange = function (before, items, after) {
            // DO NOTHING
        };
        return DListDataSelectionNone;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DListDataSelectionSingle = /** @class */ (function (_super) {
        __extends(DListDataSelectionSingle, _super);
        function DListDataSelectionSingle(parent, accessor, options) {
            var _this = _super.call(this) || this;
            _this._parent = parent;
            _this._accessor = accessor;
            _this._item = null;
            // Events
            var on = options === null || options === void 0 ? void 0 : options.on;
            if (on) {
                for (var name_1 in on) {
                    var handler = on[name_1];
                    if (handler) {
                        _this.on(name_1, handler);
                    }
                }
            }
            return _this;
        }
        Object.defineProperty(DListDataSelectionSingle.prototype, "type", {
            get: function () {
                return DListDataSelectionType.SINGLE;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DListDataSelectionSingle.prototype, "first", {
            get: function () {
                return this._item;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DListDataSelectionSingle.prototype, "last", {
            get: function () {
                return this.get(this.size() - 1);
            },
            enumerable: false,
            configurable: true
        });
        DListDataSelectionSingle.prototype.get = function (index) {
            if (0 === index) {
                return this._item;
            }
            return null;
        };
        DListDataSelectionSingle.prototype.add = function (target) {
            if (this._item !== target) {
                this._item = target;
                this.onChange();
                return true;
            }
            return false;
        };
        DListDataSelectionSingle.prototype.remove = function (target) {
            if (this._item === target) {
                this._item = null;
                this.onChange();
                return true;
            }
            return false;
        };
        DListDataSelectionSingle.prototype.toggle = function (target) {
            if (this._item === target) {
                this._item = null;
            }
            else {
                this._item = target;
            }
            this.onChange();
            return true;
        };
        DListDataSelectionSingle.prototype.clear = function () {
            if (this._item != null) {
                this._item = null;
                this.onChange();
            }
        };
        DListDataSelectionSingle.prototype.clearAndAdd = function (target) {
            if (this._item !== target) {
                this._item = target;
                this.onChange();
                return true;
            }
            return false;
        };
        DListDataSelectionSingle.prototype.clearAndAddAll = function (targets) {
            var targetsLength = targets.length;
            if (0 < targetsLength) {
                var last = targets[targetsLength - 1];
                if (this._item !== last) {
                    this._item = last;
                    this.onChange();
                    return true;
                }
            }
            else {
                if (this._item != null) {
                    this._item = null;
                    this.onChange();
                    return true;
                }
            }
            return false;
        };
        DListDataSelectionSingle.prototype.contains = function (target) {
            return this._item === target;
        };
        DListDataSelectionSingle.prototype.size = function () {
            return this._item != null ? 1 : 0;
        };
        DListDataSelectionSingle.prototype.isEmpty = function () {
            return this.size() <= 0;
        };
        DListDataSelectionSingle.prototype.each = function (iteratee) {
            var item = this._item;
            if (item != null) {
                iteratee(item);
            }
        };
        DListDataSelectionSingle.prototype.toArray = function () {
            var item = this._item;
            if (item != null) {
                return [item];
            }
            return [];
        };
        DListDataSelectionSingle.prototype.onChange = function () {
            this._parent.update();
            this.emit("change", this);
        };
        DListDataSelectionSingle.prototype.findById = function (id, toId, items) {
            for (var i = 0, imax = items.length; i < imax; ++i) {
                var item = items[i];
                var itemId = toId(item);
                if (id === itemId) {
                    return item;
                }
            }
            return null;
        };
        DListDataSelectionSingle.prototype.find = function (target, items) {
            for (var i = 0, imax = items.length; i < imax; ++i) {
                var item = items[i];
                if (target === item) {
                    return item;
                }
            }
            return null;
        };
        DListDataSelectionSingle.prototype.onItemChange = function (before, items, after) {
            var oldItem = this._item;
            if (oldItem == null) {
                return;
            }
            var newItem = null;
            var toId = this._accessor.toId;
            if (toId) {
                var oldItemId = toId(oldItem);
                newItem =
                    this.findById(oldItemId, toId, before) ||
                        this.findById(oldItemId, toId, items) ||
                        this.findById(oldItemId, toId, after);
            }
            else {
                newItem =
                    this.find(oldItem, before) ||
                        this.find(oldItem, items) ||
                        this.find(oldItem, after);
            }
            if (oldItem !== newItem) {
                this._item = newItem;
                this.onChange();
            }
        };
        return DListDataSelectionSingle;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var toImage$1 = function (value) {
        return value.image;
    };
    var toTitle$1 = function (value) {
        return value.title;
    };
    var toLinkUrl = function (value) {
        return value.url;
    };
    var DListItemAccessorImpl = /** @class */ (function () {
        function DListItemAccessorImpl(options) {
            this.toLabel = (options === null || options === void 0 ? void 0 : options.toLabel) || toLabel$1;
            this.toTitle = (options === null || options === void 0 ? void 0 : options.toTitle) || toTitle$1;
            this.toImage = (options === null || options === void 0 ? void 0 : options.toImage) || toImage$1;
            this.toId = options === null || options === void 0 ? void 0 : options.toId;
            this.link = this.toLink(options);
        }
        DListItemAccessorImpl.prototype.toLink = function (options) {
            if (options) {
                var link = options.link;
                if (link) {
                    var toUrl = link.toUrl;
                    var target = link.target;
                    var checker = link.checker;
                    if (toUrl !== undefined || target !== undefined || checker !== undefined) {
                        return {
                            toUrl: toUrl || toLinkUrl,
                            target: target,
                            checker: checker
                        };
                    }
                }
            }
            return undefined;
        };
        return DListItemAccessorImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DListDataImpl = /** @class */ (function () {
        function DListDataImpl(parent, options) {
            this._parent = parent;
            if (options) {
                this._before = options.before || [];
                this._items = options.items || [];
                this._after = options.after || [];
            }
            else {
                this._before = [];
                this._items = [];
                this._after = [];
            }
            var accessor = new DListItemAccessorImpl(options);
            this._accessor = accessor;
            this._selection = this.toSelection(accessor, options);
            this._mapped = new DListDataMappedImpl(this);
        }
        DListDataImpl.prototype.toSelection = function (accessor, options) {
            var selection = options === null || options === void 0 ? void 0 : options.selection;
            switch (selection === null || selection === void 0 ? void 0 : selection.type) {
                case DListDataSelectionType.NONE:
                case "NONE":
                    return new DListDataSelectionNone(this, accessor, selection);
                case DListDataSelectionType.MULTIPLE:
                case "MULTIPLE":
                    return new DListDataSelectionMultiple(this, accessor, selection);
                default:
                    return new DListDataSelectionSingle(this, accessor, selection);
            }
        };
        Object.defineProperty(DListDataImpl.prototype, "before", {
            get: function () {
                return this._before;
            },
            set: function (before) {
                this._before = before;
                this._selection.onItemChange(before, this._items, this._after);
                this.update();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DListDataImpl.prototype, "items", {
            get: function () {
                return this._items;
            },
            set: function (items) {
                this._items = items;
                this._selection.onItemChange(this._before, items, this._after);
                this.update();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DListDataImpl.prototype, "after", {
            get: function () {
                return this._after;
            },
            set: function (after) {
                this._after = after;
                this._selection.onItemChange(this._before, this._items, after);
                this.update();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DListDataImpl.prototype, "mapped", {
            get: function () {
                return this._mapped;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DListDataImpl.prototype, "accessor", {
            get: function () {
                return this._accessor;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DListDataImpl.prototype, "selection", {
            get: function () {
                return this._selection;
            },
            enumerable: false,
            configurable: true
        });
        DListDataImpl.prototype.update = function (forcibly) {
            this._parent.update(forcibly);
        };
        DListDataImpl.prototype.size = function () {
            return this._items.length;
        };
        DListDataImpl.prototype.clear = function () {
            var items = this._items;
            if (0 < items.length) {
                items.length = 0;
                this.onChange();
                return true;
            }
            return false;
        };
        DListDataImpl.prototype.clearAndAdd = function (item) {
            var items = this._items;
            if (items.length === 1) {
                var first = items[0];
                if (first === item) {
                    return false;
                }
                else {
                    items[0] = item;
                    this.onChange();
                    return true;
                }
            }
            else {
                items.length = 0;
                items.push(item);
                this.onChange();
                return true;
            }
        };
        DListDataImpl.prototype.clearAndAddAll = function (newItems) {
            var isChanged = false;
            var items = this._items;
            if (0 < items.length) {
                items.length = 0;
                isChanged = true;
            }
            if (0 < newItems.length) {
                for (var i = 0, imax = newItems.length; i < imax; ++i) {
                    items.push(newItems[i]);
                }
                isChanged = true;
            }
            if (isChanged) {
                this.onChange();
                return true;
            }
            return false;
        };
        DListDataImpl.prototype.add = function (item, index) {
            var items = this._items;
            if (index == null) {
                items.push(item);
                this.onChange();
                return true;
            }
            else if (0 <= index && index < items.length) {
                items.splice(index, 0, item);
                this.onChange();
                return true;
            }
            return false;
        };
        DListDataImpl.prototype.addAll = function (newItems, index) {
            if (0 < newItems.length) {
                var items = this._items;
                var itemsLength = items.length;
                if (index == null) {
                    for (var i = 0, imax = newItems.length; i < imax; ++i) {
                        items.push(newItems[i]);
                    }
                    this.onChange();
                    return true;
                }
                else if (0 <= index && index < itemsLength) {
                    for (var i = 0, imax = newItems.length; i < imax; ++i) {
                        items.splice(index + i, 0, newItems[i]);
                    }
                    this.onChange();
                    return true;
                }
            }
            return false;
        };
        DListDataImpl.prototype.get = function (index) {
            var items = this._items;
            if (0 <= index && index < items.length) {
                return items[index];
            }
            return null;
        };
        DListDataImpl.prototype.set = function (index, item) {
            var items = this._items;
            if (0 <= index && index < items.length) {
                var result = items[index];
                items[index] = item;
                this.onChange();
                return result;
            }
            return null;
        };
        DListDataImpl.prototype.remove = function (index) {
            var items = this._items;
            if (0 <= index && index < items.length) {
                var result = items.splice(index, 1)[0];
                this.onChange();
                return result;
            }
            return null;
        };
        DListDataImpl.prototype.each = function (iteratee, from, to) {
            var items = this._items;
            var size = items.length;
            var ifrom = from != null ? Math.max(0, from) : 0;
            var ito = to != null ? Math.min(size, to) : size;
            for (var i = ifrom; i < ito; ++i) {
                if (iteratee(items[i], i) === false) {
                    break;
                }
            }
        };
        DListDataImpl.prototype.onChange = function () {
            this.update();
        };
        return DListDataImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DContent = /** @class */ (function (_super) {
        __extends(DContent, _super);
        function DContent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DContent.prototype.initReflowable = function () {
            // DO NOTHING
        };
        DContent.prototype.getType = function () {
            return "DContent";
        };
        return DContent;
    }(DBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DScrollBar = /** @class */ (function (_super) {
        __extends(DScrollBar, _super);
        function DScrollBar(options) {
            var _a, _b;
            var _this = _super.call(this, options) || this;
            _this._start = 0;
            _this._end = 1;
            _this.visible = false;
            _this._touchedAt = -1;
            _this._isTouched = false;
            _this._fadeOutTimeoutId = null;
            _this._fadeOutDelay = (_b = (_a = options === null || options === void 0 ? void 0 : options.fadeOut) === null || _a === void 0 ? void 0 : _a.delay) !== null && _b !== void 0 ? _b : _this.theme.getFadeOutDelay();
            _this._isSilent = true;
            _this._onFadeOutTimeoutBound = function () {
                _this.onFadeOutTimeout();
            };
            var thumb = _this.newThumb(options === null || options === void 0 ? void 0 : options.thumb);
            thumb.on("statechange", function (newState, oldState) {
                _this.onThumbStateChange(newState, oldState);
            });
            _this._thumb = thumb;
            _this.addChild(thumb);
            return _this;
        }
        Object.defineProperty(DScrollBar.prototype, "thumb", {
            get: function () {
                return this._thumb;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DScrollBar.prototype, "start", {
            get: function () {
                return this._start;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DScrollBar.prototype, "end", {
            get: function () {
                return this._end;
            },
            enumerable: false,
            configurable: true
        });
        DScrollBar.prototype.set = function (start, end, size, silently) {
            if (size < 1) {
                start = 0;
                end = 1;
            }
            else {
                start = Math.max(0, Math.min(1, start / size));
                end = Math.max(start, Math.min(1, end / size));
            }
            if (this._start !== start || this._end !== end) {
                this._start = start;
                this._end = end;
                this.onChange(silently);
            }
        };
        DScrollBar.prototype.onChange = function (silently) {
            this.updateThumb(this.width, this.height);
            if (silently) {
                this._isSilent = true;
            }
            if (!this._isTouched) {
                this._isTouched = true;
                DApplications.update(this);
            }
        };
        DScrollBar.prototype.touch = function (silently) {
            this.onChange(silently);
        };
        DScrollBar.prototype.isRegionVisible = function () {
            return 0 < this._start || this._end < 1;
        };
        DScrollBar.prototype.render = function (renderer) {
            if (this._isTouched) {
                this._isTouched = false;
                if (!this._isSilent && this.isRegionVisible()) {
                    var fadeOutDelay = this._fadeOutDelay;
                    if (0 <= fadeOutDelay) {
                        this._touchedAt = Date.now();
                        if (this._fadeOutTimeoutId == null) {
                            this._fadeOutTimeoutId = window.setTimeout(this._onFadeOutTimeoutBound, fadeOutDelay);
                        }
                    }
                    if (!this.visible) {
                        this.visible = true;
                        this.updateTransform();
                    }
                }
                else {
                    if (this._fadeOutDelay < 0 && this.visible) {
                        this.visible = false;
                    }
                }
            }
            if (this._isSilent) {
                this._isSilent = false;
            }
            _super.prototype.render.call(this, renderer);
        };
        DScrollBar.prototype.onResize = function (newWidth, newHeight, oldWidth, oldHeight) {
            _super.prototype.onResize.call(this, newWidth, newHeight, oldWidth, oldHeight);
            this.updateThumb(newWidth, newHeight);
        };
        DScrollBar.prototype.onFadeOutTimeout = function () {
            this._fadeOutTimeoutId = null;
            var fadeOutDelay = this._fadeOutDelay;
            var onTouchTimeoutBound = this._onFadeOutTimeoutBound;
            var state = this.state;
            if (state.isGesturing || state.onHovered || state.isHovered || state.isPressed) {
                this._fadeOutTimeoutId = window.setTimeout(onTouchTimeoutBound, fadeOutDelay);
                return;
            }
            var thumbState = this._thumb.state;
            if (thumbState.isGesturing || thumbState.isHovered || thumbState.isPressed) {
                this._fadeOutTimeoutId = window.setTimeout(onTouchTimeoutBound, fadeOutDelay);
                return;
            }
            var now = Date.now();
            var remainingTime = fadeOutDelay - (now - this._touchedAt);
            if (0 < remainingTime) {
                this._fadeOutTimeoutId = window.setTimeout(onTouchTimeoutBound, remainingTime);
                return;
            }
            if (this.visible) {
                this.visible = false;
                DApplications.update(this);
            }
        };
        DScrollBar.prototype.onThumbStateChange = function (newState, oldState) {
            if (!newState.isGesturing && !newState.isHovered && !newState.isPressed) {
                if (oldState.isGesturing || oldState.isHovered || oldState.isPressed) {
                    this._touchedAt = Date.now();
                }
            }
        };
        DScrollBar.prototype.onStateChange = function (newState, oldState) {
            _super.prototype.onStateChange.call(this, newState, oldState);
            if (!newState.isGesturing && !newState.isHovered && !newState.isPressed) {
                if (oldState.isGesturing || oldState.isHovered || oldState.isPressed) {
                    this._touchedAt = Date.now();
                }
            }
        };
        DScrollBar.prototype.getType = function () {
            return "DScrollBar";
        };
        return DScrollBar;
    }(DBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DScrollBarThumb = /** @class */ (function (_super) {
        __extends(DScrollBarThumb, _super);
        function DScrollBarThumb() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DScrollBarThumb.prototype.init = function (options) {
            var _this = this;
            _super.prototype.init.call(this, options);
            var position = new pixi_js.Point();
            this._gestureUtil = new UtilGesture({
                bind: this,
                on: {
                    start: function () {
                        position.copyFrom(_this.position);
                    },
                    move: function (target, dx, dy) {
                        position.set(position.x + dx, position.y + dy);
                        _this.onGestureMove(position.x, position.y);
                    }
                }
            });
        };
        DScrollBarThumb.prototype.getMinimumLength = function () {
            return this.theme.getThumbMinimumLength();
        };
        DScrollBarThumb.prototype.getType = function () {
            return "DScrollBarThumb";
        };
        return DScrollBarThumb;
    }(DBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DScrollBarThumbReflowableHorizontal = /** @class */ (function (_super) {
        __extends(DScrollBarThumbReflowableHorizontal, _super);
        function DScrollBarThumbReflowableHorizontal(base) {
            var _this = _super.call(this) || this;
            base.snippet.add(_this, true);
            base.reflowable.add(_this);
            return _this;
        }
        DScrollBarThumbReflowableHorizontal.prototype.onReflow = function (base, width, height) {
            this.clear();
            var state = base.state;
            var border = base.border;
            var borderColor = border.getColor(state);
            if (borderColor != null) {
                var borderAlpha = border.getAlpha(state);
                var borderWidth = border.getWidth(state);
                var borderAlign = border.getAlign(state);
                this.beginFill(borderColor, borderAlpha);
                this.lineStyle(0, 0, 0, 0);
                this.drawRect(0, borderAlign * (height - borderWidth), width, borderWidth);
                this.endFill();
                this.visible = true;
            }
            else {
                this.visible = false;
            }
        };
        return DScrollBarThumbReflowableHorizontal;
    }(pixi_js.Graphics));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DScrollBarThumbHorizontal = /** @class */ (function (_super) {
        __extends(DScrollBarThumbHorizontal, _super);
        function DScrollBarThumbHorizontal() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DScrollBarThumbHorizontal.prototype.onGestureMove = function (dx, dy) {
            this.emit("regionmove", dx, this);
        };
        DScrollBarThumbHorizontal.prototype.initReflowable = function () {
            new DScrollBarThumbReflowableHorizontal(this);
        };
        return DScrollBarThumbHorizontal;
    }(DScrollBarThumb));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DScrollBarHorizontal = /** @class */ (function (_super) {
        __extends(DScrollBarHorizontal, _super);
        function DScrollBarHorizontal(options) {
            var _this = _super.call(this, options) || this;
            _this._thumb.on("regionmove", function (x) {
                _this.onThumbRegionMove(x);
            });
            return _this;
        }
        DScrollBarHorizontal.prototype.onThumbRegionMove = function (x) {
            var width = this.width;
            if (0 < width) {
                var size = this._end - this._start;
                var newStart = Math.min(1 - size, Math.max(0, x / width));
                if (this._start !== newStart) {
                    this.emit("regionmove", newStart, this);
                }
            }
        };
        DScrollBarHorizontal.prototype.onDownThis = function (e) {
            _super.prototype.onDownThis.call(this, e);
            var width = this.width;
            if (0 < width) {
                var size = this._end - this._start;
                var position = e.data.getLocalPosition(this);
                var newStart = Math.min(1 - size, Math.max(0, position.x / width - size * 0.5));
                if (this._start !== newStart) {
                    this.emit("regionmove", newStart, this);
                }
            }
        };
        DScrollBarHorizontal.prototype.newThumb = function (options) {
            return new DScrollBarThumbHorizontal(options);
        };
        DScrollBarHorizontal.prototype.updateThumb = function (width, height) {
            var thumb = this._thumb;
            var thumbMinimumLength = Math.min(width * 0.5, thumb.getMinimumLength());
            var space = width - thumbMinimumLength;
            var barStart = space * this._start;
            var barLength = space * this._end + thumbMinimumLength - barStart;
            thumb.position.set(barStart, 0);
            thumb.resize(barLength, height);
        };
        return DScrollBarHorizontal;
    }(DScrollBar));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DScrollBarThumbReflowableVertical = /** @class */ (function (_super) {
        __extends(DScrollBarThumbReflowableVertical, _super);
        function DScrollBarThumbReflowableVertical(base) {
            var _this = _super.call(this) || this;
            base.snippet.add(_this, true);
            base.reflowable.add(_this);
            return _this;
        }
        DScrollBarThumbReflowableVertical.prototype.onReflow = function (base, width, height) {
            this.clear();
            var state = base.state;
            var border = base.border;
            var borderColor = border.getColor(state);
            if (borderColor != null) {
                var borderAlpha = border.getAlpha(state);
                var borderWidth = border.getWidth(state);
                var borderAlign = border.getAlign(state);
                this.beginFill(borderColor, borderAlpha);
                this.lineStyle(0, 0, 0, 0);
                this.drawRect(borderAlign * (width - borderWidth), 0, borderWidth, height);
                this.endFill();
                this.visible = true;
            }
            else {
                this.visible = false;
            }
        };
        return DScrollBarThumbReflowableVertical;
    }(pixi_js.Graphics));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DScrollBarThumbVertical = /** @class */ (function (_super) {
        __extends(DScrollBarThumbVertical, _super);
        function DScrollBarThumbVertical() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DScrollBarThumbVertical.prototype.onGestureMove = function (dx, dy) {
            this.emit("regionmove", dy, this);
        };
        DScrollBarThumbVertical.prototype.initReflowable = function () {
            new DScrollBarThumbReflowableVertical(this);
        };
        return DScrollBarThumbVertical;
    }(DScrollBarThumb));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DScrollBarVertical = /** @class */ (function (_super) {
        __extends(DScrollBarVertical, _super);
        function DScrollBarVertical(options) {
            var _this = _super.call(this, options) || this;
            _this._thumb.on("regionmove", function (y) {
                _this.onThumbRegionMove(y);
            });
            return _this;
        }
        DScrollBarVertical.prototype.onThumbRegionMove = function (y) {
            var height = this.height;
            if (0 < height) {
                var size = this._end - this._start;
                var newStart = Math.min(1 - size, Math.max(0, y / height));
                if (this._start !== newStart) {
                    this.emit("regionmove", newStart, this);
                }
            }
        };
        DScrollBarVertical.prototype.onDownThis = function (e) {
            _super.prototype.onDownThis.call(this, e);
            var height = this.height;
            if (0 < height) {
                var size = this._end - this._start;
                var position = e.data.getLocalPosition(this);
                var newStart = Math.min(1 - size, Math.max(0, position.y / height - size * 0.5));
                if (this._start !== newStart) {
                    this.emit("regionmove", newStart, this);
                }
            }
        };
        DScrollBarVertical.prototype.newThumb = function (options) {
            return new DScrollBarThumbVertical(options);
        };
        DScrollBarVertical.prototype.updateThumb = function (width, height) {
            var thumb = this._thumb;
            var thumbMinimumLength = Math.min(height * 0.5, thumb.getMinimumLength());
            var space = height - thumbMinimumLength;
            var barStart = space * this._start;
            var barLength = space * this._end + thumbMinimumLength - barStart;
            thumb.position.set(0, barStart);
            thumb.resize(width, barLength);
            thumb.updateTransform();
        };
        return DScrollBarVertical;
    }(DScrollBar));

    var DPaneScrollBar = /** @class */ (function () {
        function DPaneScrollBar(parent, options, onUpdate) {
            this._parent = parent;
            this._onUpdate = onUpdate;
            this._isLocked = 0;
            this._isCalled = false;
            this.vertical = new DScrollBarVertical(options === null || options === void 0 ? void 0 : options.vertical);
            this.horizontal = new DScrollBarHorizontal(options === null || options === void 0 ? void 0 : options.horizontal);
        }
        DPaneScrollBar.prototype.lock = function () {
            this._isLocked += 1;
            if (this._isLocked === 1) {
                this._isCalled = false;
                this._isCalledSilently = undefined;
            }
        };
        DPaneScrollBar.prototype.unlock = function (callIfNeeded) {
            this._isLocked -= 1;
            if (this._isLocked === 0) {
                if (callIfNeeded && this._isCalled) {
                    this.update(this._isCalledSilently);
                }
                this._isCalled = false;
                this._isCalledSilently = undefined;
            }
        };
        DPaneScrollBar.prototype.update = function (silently) {
            if (0 < this._isLocked) {
                this._isCalled = true;
                if (silently != null) {
                    this._isCalledSilently || (this._isCalledSilently = silently);
                }
                return;
            }
            var parent = this._parent;
            var width = parent.width;
            var height = parent.height;
            var content = parent.content;
            var x = -content.x;
            var y = -content.y;
            var vertical = this.vertical;
            var verticalWidth = vertical.width;
            var verticalOffsetStart = this.getOffsetVerticalStart(verticalWidth);
            var verticalOffsetEnd = this.getOffsetVerticalEnd(verticalWidth);
            vertical.set(y, y + height, content.height, silently);
            vertical.position.set(width - verticalWidth, verticalOffsetStart);
            vertical.height = height - verticalOffsetStart - verticalOffsetEnd;
            var horizontal = this.horizontal;
            var horizontalHeight = horizontal.height;
            var horizontalOffsetStart = this.getOffsetHorizontalStart(horizontalHeight);
            var horizontalOffsetEnd = this.getOffsetHorizontalEnd(horizontalHeight);
            horizontal.set(x, x + width, content.width, silently);
            horizontal.position.set(horizontalOffsetStart, height - horizontalHeight);
            horizontal.width = width - horizontalOffsetStart - horizontalOffsetEnd;
            this._onUpdate(vertical.isRegionVisible() || horizontal.isRegionVisible());
        };
        DPaneScrollBar.prototype.touch = function (silently) {
            this.vertical.touch(silently);
            this.horizontal.touch(silently);
        };
        DPaneScrollBar.prototype.getOffsetHorizontalStart = function (size) {
            return size * 0.5;
        };
        DPaneScrollBar.prototype.getOffsetHorizontalEnd = function (size) {
            return size * 0.5;
        };
        DPaneScrollBar.prototype.getOffsetVerticalStart = function (size) {
            return size * 0.5;
        };
        DPaneScrollBar.prototype.getOffsetVerticalEnd = function (size) {
            return size * 0.5;
        };
        return DPaneScrollBar;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    // Class
    var DPane = /** @class */ (function (_super) {
        __extends(DPane, _super);
        function DPane(options) {
            var _a;
            var _this = _super.call(this, options) || this;
            // Mask
            var theme = _this.theme;
            if ((_a = options === null || options === void 0 ? void 0 : options.mask) !== null && _a !== void 0 ? _a : theme.isOverflowMaskEnabled()) {
                _this.mask = _this.getOverflowMask();
            }
            // Content
            _this.addChild(_this.content);
            // Scroll bar
            var scrollbar = _this.scrollbar;
            _this.addChild(scrollbar.vertical);
            _this.addChild(scrollbar.horizontal);
            scrollbar.update();
            // Gesture
            _this.initGesture(theme, options);
            return _this;
        }
        DPane.prototype.initGesture = function (theme, options) {
            var _this = this;
            var _a, _b;
            // Edge does not fire the wheel event when scrolling using the 2-fingure scroll gesture on a touchpad.
            // Instead, it fires touch events. This is why the gesture is enabled regardless of the `UtilPointerEvent.touchable`.
            // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/7134034/
            var mode = toEnum((_b = (_a = options === null || options === void 0 ? void 0 : options.gesture) === null || _a === void 0 ? void 0 : _a.mode) !== null && _b !== void 0 ? _b : theme.getGestureMode(), UtilGestureMode);
            if (mode === UtilGestureMode.ON || mode === UtilGestureMode.TOUCH) {
                var position_1 = new pixi_js.Point();
                var content_1 = this.content;
                this._gestureUtil = new UtilGesture({
                    bind: this,
                    touch: mode === UtilGestureMode.TOUCH,
                    on: {
                        start: function () {
                            position_1.copyFrom(content_1.position);
                        },
                        move: function (target, dx, dy) {
                            position_1.set(position_1.x + dx, position_1.y + dy);
                            content_1.position.set(_this.toContentX(content_1, position_1.x), _this.toContentY(content_1, position_1.y));
                        }
                    }
                });
            }
        };
        Object.defineProperty(DPane.prototype, "scrollbar", {
            get: function () {
                var _a;
                var result = this._scrollbar;
                if (result == null) {
                    result = this.newScrollBar((_a = this._options) === null || _a === void 0 ? void 0 : _a.scrollbar);
                    this.initScrollBar(result);
                    this._scrollbar = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DPane.prototype.newScrollBar = function (options) {
            var _this = this;
            return new DPaneScrollBar(this, options, function (isRegionVisible) {
                _this.onScrollBarUpdate(isRegionVisible);
            });
        };
        DPane.prototype.onScrollBarUpdate = function (isRegionVisible) {
            // DO NOTHING
        };
        DPane.prototype.initScrollBar = function (scrollbar) {
            var _this = this;
            scrollbar.vertical.on("regionmove", function (start) {
                _this.onScrollBarMoveY(start);
            });
            scrollbar.horizontal.on("regionmove", function (start) {
                _this.onScrollBarMoveX(start);
            });
        };
        DPane.prototype.onScrollBarMoveX = function (start) {
            var gestureUtil = this._gestureUtil;
            if (gestureUtil != null) {
                gestureUtil.stop(this);
            }
            var content = this.content;
            content.x = -content.width * start;
        };
        DPane.prototype.onScrollBarMoveY = function (start) {
            var gestureUtil = this._gestureUtil;
            if (gestureUtil != null) {
                gestureUtil.stop(this);
            }
            var content = this.content;
            content.y = -content.height * start;
        };
        DPane.prototype.onOver = function (e) {
            _super.prototype.onOver.call(this, e);
            this.scrollbar.touch();
        };
        DPane.prototype.getType = function () {
            return "DPane";
        };
        Object.defineProperty(DPane.prototype, "content", {
            get: function () {
                var result = this._content;
                if (result == null) {
                    result = this.toContent(this._options);
                    this.initContent(result);
                    this._content = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DPane.prototype.toContent = function (options) {
            var content = options === null || options === void 0 ? void 0 : options.content;
            if (content) {
                if (content instanceof DBase) {
                    return content;
                }
                else {
                    return this.newContent(content);
                }
            }
            return this.newContent();
        };
        DPane.prototype.newContent = function (options) {
            return new DContent(options);
        };
        DPane.prototype.initContent = function (content) {
            var _this = this;
            content.on("move", function () {
                _this.onContentChange();
            });
            content.on("resize", function () {
                _this.onContentChange();
            });
        };
        DPane.prototype.getOverflowMask = function () {
            var result = this._overflowMask;
            if (result === undefined) {
                result = this.newOverflowMask();
                this._overflowMask = result;
            }
            return result;
        };
        DPane.prototype.newOverflowMask = function () {
            var result = new DBaseOverflowMask(this);
            this.reflowable.add(result);
            this.toDirty();
            return result;
        };
        DPane.prototype.onWheel = function (e, deltas, global) {
            var content = this.content;
            var x = this.getWheelContentX(content, deltas.deltaX * deltas.lowest);
            var y = this.getWheelContentY(content, deltas.deltaY * deltas.lowest);
            if (content.x !== x || content.y !== y) {
                var gestureUtil = this._gestureUtil;
                if (gestureUtil != null) {
                    gestureUtil.stop(this);
                }
                content.position.set(x, y);
                return true;
            }
            return false;
        };
        DPane.prototype.getWheelContentX = function (content, delta) {
            if (0 < delta || delta < 0) {
                var speed = this.theme.getWheelSpeed();
                return this.toContentX(content, content.x - delta * speed);
            }
            return content.x;
        };
        DPane.prototype.getWheelContentY = function (content, delta) {
            if (0 < delta || delta < 0) {
                var speed = this.theme.getWheelSpeed();
                return this.toContentY(content, content.y + delta * speed);
            }
            return content.y;
        };
        DPane.prototype.toContentX = function (content, x) {
            return Math.min(0, Math.max(this.width - content.width, x));
        };
        DPane.prototype.toContentY = function (content, y) {
            return Math.min(0, Math.max(this.height - content.height, y));
        };
        DPane.prototype.isRefitable = function (target) {
            return _super.prototype.isRefitable.call(this, target) && !(target instanceof DScrollBar);
        };
        DPane.prototype.onResize = function (newWidth, newHeight, oldWidth, oldHeight) {
            var scrollbar = this.scrollbar;
            scrollbar.lock();
            _super.prototype.onResize.call(this, newWidth, newHeight, oldWidth, oldHeight);
            scrollbar.update();
            scrollbar.unlock(true);
        };
        DPane.prototype.onContentChange = function () {
            this.scrollbar.update();
        };
        DPane.prototype.getFocusedChildClippingRect = function (focused, contentX, contentY, contentWidth, contentHeight, width, height, result) {
            result.x = 0;
            result.y = 0;
            result.width = width;
            result.height = height;
            return result;
        };
        DPane.prototype.onChildFocus = function (focused) {
            var point = DPane.WORK_POINT || new pixi_js.Point();
            DPane.WORK_POINT = point;
            // Content rectangle
            var content = this.content;
            var contentX = content.x;
            var contentY = content.y;
            var contentWidth = content.width;
            var contentHeight = content.height;
            point.set(0, 0);
            focused.toGlobal(point, point, false);
            content.toLocal(point, undefined, point, false);
            var x0 = contentX + Math.min(contentWidth, Math.max(0, point.x));
            var y0 = contentY + Math.min(contentHeight, Math.max(0, point.y));
            point.set(focused.width, focused.height);
            focused.toGlobal(point, point, true);
            content.toLocal(point, undefined, point, true);
            var x1 = contentX + Math.min(contentWidth, Math.max(0, point.x));
            var y1 = contentY + Math.min(contentHeight, Math.max(0, point.y));
            var width = this.width;
            var height = this.height;
            var clippingRect = DPane.WORK_RECTANGLE || new pixi_js.Rectangle();
            DPane.WORK_RECTANGLE = clippingRect;
            this.getFocusedChildClippingRect(focused, contentX, contentY, contentWidth, contentHeight, width, height, clippingRect);
            var clippingRectX = clippingRect.x;
            var clippingRectY = clippingRect.y;
            var clippingRectX0 = clippingRectX;
            var clippingRectY0 = clippingRectY;
            var clippingRectX1 = clippingRectX + clippingRect.width;
            var clippingRectY1 = clippingRectY + clippingRect.height;
            var newX = null;
            if (x0 < clippingRectX0) {
                if (x1 <= clippingRectX1) {
                    newX = contentX + Math.min(clippingRectX0 - x0, clippingRectX1 - x1);
                    newX = Math.max(width - contentWidth, Math.min(0, newX));
                }
            }
            else if (clippingRectX1 < x1) {
                newX = contentX - Math.min(x0 - clippingRectX0, x1 - clippingRectX1);
                newX = Math.max(width - contentWidth, Math.min(0, newX));
            }
            var newY = null;
            if (y0 < clippingRectY0) {
                if (y1 <= clippingRectY1) {
                    newY = contentY + Math.min(clippingRectY0 - y0, clippingRectY1 - y1);
                    newY = Math.max(height - contentHeight, Math.min(0, newY));
                }
            }
            else if (clippingRectY1 < y1) {
                newY = contentY - Math.min(y0 - clippingRectY0, y1 - clippingRectY1);
                newY = Math.max(height - contentHeight, Math.min(0, newY));
            }
            var contentPosition = content.position;
            if (newX != null) {
                if (newY != null) {
                    contentPosition.set(newX, newY);
                }
                else {
                    contentPosition.x = newX;
                }
            }
            else {
                if (newY != null) {
                    contentPosition.y = newY;
                }
            }
            _super.prototype.onChildFocus.call(this, focused);
        };
        DPane.prototype.destroy = function () {
            // Overflow mask
            var overflowMask = this._overflowMask;
            if (overflowMask != null) {
                this._overflowMask = null;
                overflowMask.destroy();
            }
            this.mask = null;
            _super.prototype.destroy.call(this);
        };
        return DPane;
    }(DBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DList = /** @class */ (function (_super) {
        __extends(DList, _super);
        function DList(options) {
            var _this = _super.call(this, options) || this;
            _this.update();
            return _this;
        }
        Object.defineProperty(DList.prototype, "updater", {
            get: function () {
                var result = this._updater;
                if (result == null) {
                    result = this.newUpdater(this.data, this.content, this._options);
                    this._updater = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DList.prototype.newUpdater = function (data, content, options) {
            return new DListItemUpdater(data, content, content, options === null || options === void 0 ? void 0 : options.updater);
        };
        Object.defineProperty(DList.prototype, "data", {
            get: function () {
                var result = this._data;
                if (result == null) {
                    result = this.toData(this._options);
                    this._data = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DList.prototype.toData = function (options) {
            var data = options && (options.data || options.items);
            var selection = options === null || options === void 0 ? void 0 : options.selection;
            if (data == null) {
                if (selection) {
                    return new DListDataImpl(this, {
                        selection: selection
                    });
                }
                else {
                    return new DListDataImpl(this);
                }
            }
            else if (isArray(data)) {
                if (selection) {
                    return new DListDataImpl(this, {
                        items: data,
                        selection: selection
                    });
                }
                else {
                    return new DListDataImpl(this, {
                        items: data
                    });
                }
            }
            else if ("each" in data) {
                return data;
            }
            else {
                if (selection) {
                    if (data.selection === undefined) {
                        data.selection = selection;
                    }
                    return new DListDataImpl(this, data);
                }
                else {
                    return new DListDataImpl(this, data);
                }
            }
        };
        DList.prototype.onContentChange = function () {
            _super.prototype.onContentChange.call(this);
            this.update();
        };
        DList.prototype.onResize = function (newWidth, newHeight, oldWidth, oldHeight) {
            var updater = this.updater;
            updater.lock();
            _super.prototype.onResize.call(this, newWidth, newHeight, oldWidth, oldHeight);
            updater.update();
            updater.unlock(true);
        };
        Object.defineProperty(DList.prototype, "selection", {
            get: function () {
                return this.data.selection;
            },
            enumerable: false,
            configurable: true
        });
        DList.prototype.lock = function () {
            this.updater.lock();
        };
        DList.prototype.unlock = function (callIfNeeded) {
            this.updater.unlock(callIfNeeded);
        };
        /**
         * Updates items. If the `forcibly` is true, some dirty checkings for
         * avoiding unnecessary state changes are skipped.
         *
         * @param forcibly true to update forcibly
         */
        DList.prototype.update = function (forcibly) {
            this.updater.update(forcibly);
        };
        DList.prototype.onKeyDown = function (e) {
            this.updater.moveFocus(e, this, true, true);
            return _super.prototype.onKeyDown.call(this, e);
        };
        DList.prototype.getType = function () {
            return "DList";
        };
        return DList;
    }(DPane));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogSelectList = /** @class */ (function (_super) {
        __extends(DDialogSelectList, _super);
        function DDialogSelectList() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DDialogSelectList.prototype.newUpdater = function (data, content, options) {
            return new DDialogSelectListItemUpdater(data, content, content, options === null || options === void 0 ? void 0 : options.updater);
        };
        DDialogSelectList.prototype.getType = function () {
            return "DDialogSelectList";
        };
        return DDialogSelectList;
    }(DList));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogSelectSearhImpl = /** @class */ (function (_super) {
        __extends(DDialogSelectSearhImpl, _super);
        function DDialogSelectSearhImpl(search) {
            var _this = _super.call(this) || this;
            _this._search =
                search !== null && search !== void 0 ? search : (function (word, categoryId) { return Promise.resolve([]); });
            _this._id = 0;
            _this._idCompleted = 0;
            return _this;
        }
        DDialogSelectSearhImpl.prototype.create = function (args) {
            var _this = this;
            var id = ++this._id;
            var search = this._search;
            (args.length <= 1 ? search(args[0]) : search(args[0], args[1])).then(function (searchResult) {
                if (_this._id === id) {
                    _this._idCompleted = id;
                    _this.emit("success", _this, searchResult);
                    _this.emit("change", _this);
                }
            }, function () {
                if (_this._id === id) {
                    _this._idCompleted = id;
                    _this.emit("fail", _this);
                    _this.emit("change", _this);
                }
            });
            this.emit("change", this);
        };
        DDialogSelectSearhImpl.prototype.isDone = function () {
            return this._id === this._idCompleted;
        };
        return DDialogSelectSearhImpl;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DInputSearch = /** @class */ (function (_super) {
        __extends(DInputSearch, _super);
        function DInputSearch() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DInputSearch.prototype.getType = function () {
            return "DInputSearch";
        };
        return DInputSearch;
    }(DInputText));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DNote = /** @class */ (function (_super) {
        __extends(DNote, _super);
        function DNote() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DNote.prototype.getType = function () {
            return "DNote";
        };
        return DNote;
    }(DImageBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DNoteSmall = /** @class */ (function (_super) {
        __extends(DNoteSmall, _super);
        function DNoteSmall() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DNoteSmall.prototype.getType = function () {
            return "DNoteSmall";
        };
        return DNoteSmall;
    }(DNote));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DNoteSmallError = /** @class */ (function (_super) {
        __extends(DNoteSmallError, _super);
        function DNoteSmallError() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DNoteSmallError.prototype.getType = function () {
            return "DNoteSmallError";
        };
        return DNoteSmallError;
    }(DNoteSmall));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DNoteSmallNoItemsFound = /** @class */ (function (_super) {
        __extends(DNoteSmallNoItemsFound, _super);
        function DNoteSmallNoItemsFound() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DNoteSmallNoItemsFound.prototype.getType = function () {
            return "DNoteSmallNoItemsFound";
        };
        return DNoteSmallNoItemsFound;
    }(DNoteSmall));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DNoteSmallSearching = /** @class */ (function (_super) {
        __extends(DNoteSmallSearching, _super);
        function DNoteSmallSearching() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DNoteSmallSearching.prototype.getType = function () {
            return "DNoteSmallSearching";
        };
        return DNoteSmallSearching;
    }(DNoteSmall));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogSelect = /** @class */ (function (_super) {
        __extends(DDialogSelect, _super);
        function DDialogSelect(options) {
            var _a, _b;
            var _this = _super.call(this, options) || this;
            // Value
            _this._value = null;
            // Categories
            var categories = (_b = (_a = options === null || options === void 0 ? void 0 : options.category) === null || _a === void 0 ? void 0 : _a.items) !== null && _b !== void 0 ? _b : [];
            _this._categories = categories;
            if (0 < categories.length) {
                _this.onCategoriesChange(categories);
            }
            // Controller binding
            var transition = new UtilTransition();
            var search = _this.search;
            search.on("success", function (e, results) {
                if (0 < results.length) {
                    transition.hide();
                }
                else {
                    transition.show(_this.noteNoItemsFound);
                }
                _this.onSearched(results);
            });
            search.on("fail", function () {
                transition.show(_this.noteError);
                _this.onSearched([]);
            });
            search.on("change", function () {
                if (!search.isDone()) {
                    var noteSearching = _this.noteSearching;
                    if (noteSearching) {
                        transition.show(noteSearching);
                    }
                }
            });
            return _this;
        }
        DDialogSelect.prototype.newContentChildren = function (theme, options) {
            var result = _super.prototype.newContentChildren.call(this, theme, options);
            result.push(this.inputLayout, this.list, this.buttonDismiss);
            return result;
        };
        Object.defineProperty(DDialogSelect.prototype, "inputLayout", {
            get: function () {
                var _a;
                return ((_a = this._inputLayout) !== null && _a !== void 0 ? _a : (this._inputLayout = this.newInputLayout()));
            },
            enumerable: false,
            configurable: true
        });
        DDialogSelect.prototype.newInputLayout = function () {
            return new DLayoutHorizontal({
                width: "padding",
                height: "auto",
                children: [this.selectCategory, this.input]
            });
        };
        DDialogSelect.prototype.newSpace = function () {
            return new DLayoutSpace({
                width: this.toInputMargin(this.theme, this._options)
            });
        };
        Object.defineProperty(DDialogSelect.prototype, "selectCategory", {
            get: function () {
                var _a;
                return ((_a = this._selectCategory) !== null && _a !== void 0 ? _a : (this._selectCategory = this.newSelectCategory()));
            },
            enumerable: false,
            configurable: true
        });
        DDialogSelect.prototype.newSelectCategory = function () {
            var _this = this;
            var result = new DSelect(this.toSelectCategoryOptions(this.theme, this._options));
            result.on("change", function (value) {
                _this.onSelectCategoryChange(value);
            });
            return result;
        };
        DDialogSelect.prototype.toSelectCategoryOptions = function (theme, options) {
            var result = (options === null || options === void 0 ? void 0 : options.category) || {};
            if (result.width === undefined && result.weight === undefined) {
                result.width = 140;
            }
            if (result.visible === undefined) {
                result.visible = false;
            }
            return result;
        };
        DDialogSelect.prototype.onSelectCategoryChange = function (categoryId) {
            this.search.create([this.input.value, categoryId]);
        };
        Object.defineProperty(DDialogSelect.prototype, "input", {
            get: function () {
                var _a;
                return ((_a = this._input) !== null && _a !== void 0 ? _a : (this._input = this.newInput()));
            },
            enumerable: false,
            configurable: true
        });
        DDialogSelect.prototype.newInput = function () {
            var _this = this;
            var result = new DInputSearch(this.toInputOptions(this.theme, this._options));
            result.on("input", function (value) {
                _this.onInputInput(value);
            });
            return result;
        };
        DDialogSelect.prototype.toInputOptions = function (theme, options) {
            var result = (options === null || options === void 0 ? void 0 : options.input) || {};
            if (result.width === undefined && result.weight === undefined) {
                result.weight = 1;
            }
            return result;
        };
        DDialogSelect.prototype.toInputMargin = function (theme, options) {
            var _a, _b;
            return (_b = (_a = options === null || options === void 0 ? void 0 : options.input) === null || _a === void 0 ? void 0 : _a.margin) !== null && _b !== void 0 ? _b : theme.getInputMargin();
        };
        DDialogSelect.prototype.onInputInput = function (value) {
            if (0 < this._categories.length) {
                this.search.create([value, this.selectCategory.value]);
            }
            else {
                this.search.create([value]);
            }
        };
        Object.defineProperty(DDialogSelect.prototype, "list", {
            get: function () {
                var _a;
                return ((_a = this._list) !== null && _a !== void 0 ? _a : (this._list = this.newList()));
            },
            enumerable: false,
            configurable: true
        });
        DDialogSelect.prototype.newList = function () {
            var _this = this;
            var result = new DDialogSelectList(this.toListOptions(this.theme, this._options));
            result.selection.on("change", function (selection) {
                _this.onListSelectionChange(selection);
            });
            return result;
        };
        DDialogSelect.prototype.onListSelectionChange = function (selection) {
            var selected = selection.first;
            if (selected == null) {
                return;
            }
            this._value = selected;
            this.onOk(selected);
        };
        DDialogSelect.prototype.toListOptions = function (theme, options) {
            var result = (options === null || options === void 0 ? void 0 : options.list) || {};
            if (result.width === undefined) {
                result.width = "padding";
            }
            return result;
        };
        Object.defineProperty(DDialogSelect.prototype, "noteError", {
            get: function () {
                var _a;
                return ((_a = this._noteError) !== null && _a !== void 0 ? _a : (this._noteError = this.newNoteError()));
            },
            enumerable: false,
            configurable: true
        });
        DDialogSelect.prototype.newNoteError = function () {
            var _a, _b;
            var error = (_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.note) === null || _b === void 0 ? void 0 : _b.error;
            if (error !== null) {
                return new DNoteSmallError(this.toNoteOptions(this.list, error));
            }
            return null;
        };
        Object.defineProperty(DDialogSelect.prototype, "noteNoItemsFound", {
            get: function () {
                var _a;
                return ((_a = this._noteNoItemsFound) !== null && _a !== void 0 ? _a : (this._noteNoItemsFound = this.newNoteNoItemsFound()));
            },
            enumerable: false,
            configurable: true
        });
        DDialogSelect.prototype.newNoteNoItemsFound = function () {
            var _a, _b;
            var noItemsFound = (_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.note) === null || _b === void 0 ? void 0 : _b.noItemsFound;
            if (noItemsFound !== null) {
                return new DNoteSmallNoItemsFound(this.toNoteOptions(this.list, noItemsFound));
            }
            return null;
        };
        Object.defineProperty(DDialogSelect.prototype, "noteSearching", {
            get: function () {
                var _a;
                return ((_a = this._noteSearching) !== null && _a !== void 0 ? _a : (this._noteSearching = this.newNoteSearching()));
            },
            enumerable: false,
            configurable: true
        });
        DDialogSelect.prototype.newNoteSearching = function () {
            var _a, _b;
            var searching = (_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.note) === null || _b === void 0 ? void 0 : _b.searching;
            // Because the `searching` note is disabled by default,
            // if options.searching is missing, i.e., if its value is undefined,
            // this method returns null. This is why `!=` is used here instead of `!==`.
            if (searching != null) {
                return new DNoteSmallSearching(this.toNoteOptions(this.list, searching));
            }
            return null;
        };
        DDialogSelect.prototype.toNoteOptions = function (parent, options) {
            if (options != null) {
                if (options.parent == null) {
                    options.parent = parent;
                }
                if (options.visible == null) {
                    options.visible = false;
                }
                return options;
            }
            return {
                parent: parent,
                visible: false
            };
        };
        Object.defineProperty(DDialogSelect.prototype, "search", {
            get: function () {
                var _a;
                return ((_a = this._search) !== null && _a !== void 0 ? _a : (this._search = this.newSearch()));
            },
            enumerable: false,
            configurable: true
        });
        DDialogSelect.prototype.newSearch = function () {
            var options = this._options;
            if (options) {
                var controller = options.controller;
                if (controller) {
                    var search = controller.search;
                    if ("create" in search) {
                        return search;
                    }
                    else {
                        return new DDialogSelectSearhImpl(search);
                    }
                }
            }
            return new DDialogSelectSearhImpl();
        };
        Object.defineProperty(DDialogSelect.prototype, "buttonDismiss", {
            get: function () {
                var result = this._buttonDismiss;
                if (result === undefined) {
                    result = this.newButtonDismiss();
                    this._buttonDismiss = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DDialogSelect.prototype.newButtonDismiss = function () {
            var _this = this;
            var options = this.toButtonDismissOptions(this._options);
            if (options.enabled === true) {
                var result = new DButton(options);
                result.on("active", function () {
                    _this._value = null;
                    _this.onOk(null);
                });
                return result;
            }
            return null;
        };
        DDialogSelect.prototype.toButtonDismissOptions = function (options) {
            var theme = this.theme;
            if (options != null) {
                var dismiss = options.dismiss;
                if (dismiss != null) {
                    if (dismiss.enabled === undefined) {
                        dismiss.enabled = theme.isDismissable();
                    }
                    if (dismiss.weight === undefined && dismiss.width === undefined) {
                        dismiss.width = "padding";
                    }
                    var text = dismiss.text;
                    if (text === undefined) {
                        dismiss.text = {
                            value: theme.getDismissLabel()
                        };
                    }
                    else if (text.value === undefined) {
                        text.value = theme.getDismissLabel();
                    }
                    return dismiss;
                }
            }
            return {
                width: "padding",
                enabled: theme.isDismissable(),
                text: {
                    value: theme.getDismissLabel()
                }
            };
        };
        Object.defineProperty(DDialogSelect.prototype, "value", {
            get: function () {
                return this._value;
            },
            enumerable: false,
            configurable: true
        });
        DDialogSelect.prototype.onSearched = function (results) {
            this.list.data.items = results;
        };
        DDialogSelect.prototype.getResolvedValue = function () {
            return this._value;
        };
        DDialogSelect.prototype.getType = function () {
            return "DDialogSelect";
        };
        DDialogSelect.prototype.onOpen = function () {
            _super.prototype.onOpen.call(this);
            this.list.selection.clear();
            if (0 < this._categories.length) {
                this.search.create([this.input.value, this.selectCategory.value]);
            }
            else {
                this.search.create([this.input.value]);
            }
        };
        Object.defineProperty(DDialogSelect.prototype, "categories", {
            get: function () {
                return this._categories;
            },
            set: function (categories) {
                this._categories = categories;
                this.onCategoriesChange(categories);
            },
            enumerable: false,
            configurable: true
        });
        DDialogSelect.prototype.onCategoriesChange = function (categories) {
            var _a, _b, _c, _d, _e;
            var selectCategory = this.selectCategory;
            if (0 < categories.length) {
                var items = [];
                var theme = this.theme;
                var options = (_c = (_b = (_a = this.options) === null || _a === void 0 ? void 0 : _a.category) === null || _b === void 0 ? void 0 : _b.dismiss) !== null && _c !== void 0 ? _c : {};
                if ((_d = options.enable) !== null && _d !== void 0 ? _d : theme.isCategoryDismissable()) {
                    items.push({
                        value: null,
                        text: {
                            value: (_e = options.label) !== null && _e !== void 0 ? _e : theme.getCategoryDismissLabel()
                        }
                    });
                }
                for (var i = 0, imax = categories.length; i < imax; ++i) {
                    var category = categories[i];
                    items.push({
                        value: category.id,
                        text: {
                            value: category.label
                        }
                    });
                }
                selectCategory.menu = new DMenu({
                    fit: true,
                    items: items
                });
                selectCategory.show();
            }
            else {
                selectCategory.hide();
            }
        };
        DDialogSelect.prototype.onOk = function (value) {
            this.emit("select", value, this);
            _super.prototype.onOk.call(this, value);
        };
        DDialogSelect.prototype.destroy = function () {
            var input = this._input;
            if (input) {
                input.destroy();
            }
            var noteError = this._noteError;
            if (noteError) {
                noteError.destroy();
            }
            var noteNoItemsFound = this._noteNoItemsFound;
            if (noteNoItemsFound) {
                noteNoItemsFound === null || noteNoItemsFound === void 0 ? void 0 : noteNoItemsFound.destroy();
            }
            var noteSearching = this._noteSearching;
            if (noteSearching) {
                noteSearching === null || noteSearching === void 0 ? void 0 : noteSearching.destroy();
            }
            var list = this._list;
            if (list) {
                list.destroy();
            }
            _super.prototype.destroy.call(this);
        };
        return DDialogSelect;
    }(DDialogLayered));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var defaultGetter$1 = function (dialog) {
        // Assumes the dialog.value is VALUE.
        return dialog.value;
    };
    var defaultSetter$1 = function () {
        // DO NOTHING
    };
    var DButtonSelect = /** @class */ (function (_super) {
        __extends(DButtonSelect, _super);
        function DButtonSelect(options) {
            var _a, _b;
            var _this = _super.call(this, options) || this;
            _this._dialogGetter = (_a = options === null || options === void 0 ? void 0 : options.getter) !== null && _a !== void 0 ? _a : defaultGetter$1;
            _this._dialogSetter = (_b = options === null || options === void 0 ? void 0 : options.setter) !== null && _b !== void 0 ? _b : defaultSetter$1;
            return _this;
        }
        DButtonSelect.prototype.onActivate = function (e) {
            var _this = this;
            var _a;
            _super.prototype.onActivate.call(this, e);
            var dialog = this.dialog;
            var oldValue = (_a = this.text.computed) !== null && _a !== void 0 ? _a : null;
            this._dialogSetter(dialog, oldValue);
            dialog.open(this).then(function () {
                var newValue = _this._dialogGetter(dialog);
                if (newValue !== oldValue) {
                    _this.text = newValue;
                    _this.emit("change", newValue, oldValue, _this);
                }
            });
        };
        Object.defineProperty(DButtonSelect.prototype, "dialog", {
            get: function () {
                var _a;
                var dialog = this._dialog;
                if (dialog == null) {
                    var options = (_a = this._options) === null || _a === void 0 ? void 0 : _a.dialog;
                    if (options && "open" in options) {
                        dialog = options;
                    }
                    else {
                        // Assumes DIALOG === DDialogSelect<DIALOG_VALUE, DIALOG_CATEGORY_ID>.
                        dialog = new DDialogSelect(options);
                    }
                    this._dialog = dialog;
                }
                return dialog;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DButtonSelect.prototype, "value", {
            get: function () {
                var _a;
                return (_a = this.text.computed) !== null && _a !== void 0 ? _a : null;
            },
            set: function (value) {
                this.text = value;
            },
            enumerable: false,
            configurable: true
        });
        DButtonSelect.prototype.getType = function () {
            return "DButtonSelect";
        };
        return DButtonSelect;
    }(DButton));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DButtonTime = /** @class */ (function (_super) {
        __extends(DButtonTime, _super);
        function DButtonTime() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DButtonTime.prototype.onActivate = function (e) {
            var _this = this;
            var _a, _b;
            _super.prototype.onActivate.call(this, e);
            var value = (_b = (_a = this.text.computed) === null || _a === void 0 ? void 0 : _a.getTime()) !== null && _b !== void 0 ? _b : Date.now();
            var dialog = this.dialog;
            dialog.current = new Date(value);
            dialog.new = new Date(value);
            dialog.open(this).then(function () {
                _this.onValueChange(dialog.new, dialog.current);
            });
        };
        DButtonTime.prototype.onValueChange = function (newValue, oldValue) {
            this.text = new Date(newValue.getTime());
            this.emit("change", newValue, oldValue, this);
        };
        DButtonTime.prototype.getDatetimeMask = function () {
            var _a, _b;
            var result = this._datetimeMask;
            if (result == null) {
                result = DPickerTimes.toMask((_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.dialog) === null || _b === void 0 ? void 0 : _b.picker);
                this._datetimeMask = result;
            }
            return result;
        };
        Object.defineProperty(DButtonTime.prototype, "dialog", {
            get: function () {
                var _a;
                var dialog = this._dialog;
                if (dialog == null) {
                    var options = (_a = this._options) === null || _a === void 0 ? void 0 : _a.dialog;
                    if (options) {
                        dialog = this.newDialog(options);
                    }
                    else {
                        if (DButtonTime.DIALOG == null) {
                            DButtonTime.DIALOG = this.newDialog({
                                mode: "MENU",
                                sticky: true
                            });
                        }
                        dialog = DButtonTime.DIALOG;
                    }
                    this._dialog = dialog;
                }
                return dialog;
            },
            enumerable: false,
            configurable: true
        });
        DButtonTime.prototype.newDialog = function (options) {
            return new DDialogTime(options);
        };
        Object.defineProperty(DButtonTime.prototype, "value", {
            get: function () {
                var _a;
                return (_a = this.text.computed) !== null && _a !== void 0 ? _a : new Date();
            },
            set: function (value) {
                var computed = this.text.computed;
                if (computed === undefined || computed.getTime() !== value.getTime()) {
                    this.text = value;
                }
            },
            enumerable: false,
            configurable: true
        });
        DButtonTime.prototype.getType = function () {
            return "DButtonTime";
        };
        return DButtonTime;
    }(DButton));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DButtonUndo = /** @class */ (function (_super) {
        __extends(DButtonUndo, _super);
        function DButtonUndo(options) {
            var _this = _super.call(this, options) || this;
            var state = _this.state;
            var commandController = DControllers.getCommandController();
            state.isDisabled = !commandController.isUndoable();
            commandController.on("change", function () {
                state.isDisabled = !commandController.isUndoable();
            });
            return _this;
        }
        DButtonUndo.prototype.onActivate = function (e) {
            _super.prototype.onActivate.call(this, e);
            DControllers.getCommandController().undo();
        };
        return DButtonUndo;
    }(DButton));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartAxisPosition = {
        TOP: 0,
        BOTTOM: 1,
        LEFT: 2,
        RIGHT: 3
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartAxisBaseBar = /** @class */ (function () {
        function DChartAxisBaseBar(parser) {
            this._parser = parser;
            this._index = 0;
        }
        Object.defineProperty(DChartAxisBaseBar.prototype, "shape", {
            get: function () {
                var result = this._shape;
                if (result == null) {
                    result = this.newShape();
                    this._shape = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DChartAxisBaseBar.prototype.newShape = function () {
            var _a;
            var parser = this._parser;
            var bar = parser.bar;
            var result = new EShapeBar();
            result.points.position = this.newShapePosition();
            result.points.style = (_a = bar.style) !== null && _a !== void 0 ? _a : EShapePointsStyle.NONE;
            result.stroke.copy(bar.stroke);
            result.text.copy(parser.label);
            return result;
        };
        DChartAxisBaseBar.prototype.newShapePosition = function () {
            switch (this._parser.position) {
                case DChartAxisPosition.LEFT:
                case DChartAxisPosition.RIGHT:
                    return EShapeBarPosition.TOP;
                default:
                    return EShapeBarPosition.LEFT;
            }
        };
        DChartAxisBaseBar.prototype.bind = function (container, index) {
            this._container = container;
            this._index = index;
            this.shape.attach(container.container);
        };
        DChartAxisBaseBar.prototype.unbind = function () {
            var shape = this._shape;
            if (shape != null) {
                shape.detach();
            }
            this._index = 0;
            this._container = undefined;
        };
        DChartAxisBaseBar.prototype.update = function () {
            var container = this._container;
            var index = this._index;
            var shape = this._shape;
            if (shape != null && container != null) {
                var parser = this._parser;
                var plotArea = container.plotArea;
                var plotAreaBounds = plotArea.getAxisBounds(parser.position);
                var plotAreaX = plotAreaBounds.x;
                var plotAreaY = plotAreaBounds.y;
                var plotAreaWidth = plotAreaBounds.width;
                var plotAreaHeight = plotAreaBounds.height;
                var offset = parser.padding * index;
                shape.lock(EShapeLockPart.UPLOADED);
                var position = shape.transform.position;
                var size = shape.size;
                switch (parser.position) {
                    case DChartAxisPosition.TOP:
                        position.set(plotAreaX + plotAreaWidth * 0.5, plotAreaY - offset);
                        size.set(plotAreaWidth, 0);
                        break;
                    case DChartAxisPosition.BOTTOM:
                        position.set(plotAreaX + plotAreaWidth * 0.5, plotAreaY + plotAreaHeight + offset);
                        size.set(plotAreaWidth, 0);
                        break;
                    case DChartAxisPosition.LEFT:
                        position.set(plotAreaX - offset, plotAreaY + plotAreaHeight * 0.5);
                        size.set(0, plotAreaHeight);
                        break;
                    case DChartAxisPosition.RIGHT:
                        position.set(plotAreaX + plotAreaWidth + offset, plotAreaY + plotAreaHeight * 0.5);
                        size.set(0, plotAreaHeight);
                        break;
                }
                shape.unlock(EShapeLockPart.UPLOADED, true);
                return true;
            }
            return false;
        };
        DChartAxisBaseBar.prototype.destroy = function () {
            var shape = this._shape;
            if (shape != null) {
                this._shape = undefined;
                shape.destroy();
            }
            this._index = 0;
            this._container = undefined;
        };
        return DChartAxisBaseBar;
    }());

    var DChartAxisBaseGuideContainer = /** @class */ (function () {
        function DChartAxisBaseGuideContainer(axis) {
            this._axis = axis;
            this._index = 0;
            this._list = [];
        }
        DChartAxisBaseGuideContainer.prototype.add = function (guide) {
            this._list.push(guide);
            var container = this._container;
            var index = this._index;
            if (container != null) {
                guide.bind(container, index, this._axis);
            }
            return this;
        };
        DChartAxisBaseGuideContainer.prototype.get = function (index) {
            var list = this._list;
            if (0 <= index && index < list.length) {
                return list[index];
            }
            return null;
        };
        DChartAxisBaseGuideContainer.prototype.indexOf = function (guide) {
            return this._list.indexOf(guide);
        };
        DChartAxisBaseGuideContainer.prototype.clear = function () {
            var list = this._list;
            for (var i = 0, imax = list.length; i < imax; ++i) {
                list[i].destroy();
            }
            list.length = 0;
            return this;
        };
        DChartAxisBaseGuideContainer.prototype.size = function () {
            return this._list.length;
        };
        DChartAxisBaseGuideContainer.prototype.bind = function (container, index) {
            this._container = container;
            this._index = index;
            var axis = this._axis;
            var list = this._list;
            for (var i = 0, imax = list.length; i < imax; ++i) {
                list[i].bind(container, index, axis);
            }
        };
        DChartAxisBaseGuideContainer.prototype.unbind = function () {
            var list = this._list;
            for (var i = 0, imax = list.length; i < imax; ++i) {
                list[i].unbind();
            }
            this._index = 0;
            this._container = undefined;
        };
        DChartAxisBaseGuideContainer.prototype.update = function () {
            var isUpdated = false;
            var list = this._list;
            for (var i = 0, imax = list.length; i < imax; ++i) {
                if (list[i].update()) {
                    isUpdated = true;
                }
            }
            return isUpdated;
        };
        DChartAxisBaseGuideContainer.prototype.destroy = function () {
            var list = this._list;
            for (var i = 0, imax = list.length; i < imax; ++i) {
                list[i].destroy();
            }
            list.length = 0;
            this._index = 0;
            this._container = undefined;
        };
        return DChartAxisBaseGuideContainer;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartAxisTickPosition = {
        INSIDE: 0,
        OUTSIDE: 1
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartAxisBaseOptionParser = /** @class */ (function () {
        function DChartAxisBaseOptionParser(theme, options) {
            var _a, _b;
            this.coordinate = (_a = options === null || options === void 0 ? void 0 : options.coordinate) !== null && _a !== void 0 ? _a : 0;
            this.position = this.toPosition(theme, options);
            this.tick = this.toTick(theme, options);
            this.label = this.toLabel(theme, options);
            this.padding = (_b = options === null || options === void 0 ? void 0 : options.padding) !== null && _b !== void 0 ? _b : theme.getPadding();
            this.bar = this.toBar(theme, options);
            this.guide = this.toGuide(theme, options);
        }
        DChartAxisBaseOptionParser.prototype.toPosition = function (theme, options) {
            var position = options === null || options === void 0 ? void 0 : options.position;
            if (isString(position)) {
                return DChartAxisPosition[position];
            }
            else if (position != null) {
                return position;
            }
            return theme.getPosition();
        };
        DChartAxisBaseOptionParser.prototype.toGuide = function (theme, options) {
            var _a, _b;
            return {
                list: (_b = (_a = options === null || options === void 0 ? void 0 : options.guide) === null || _a === void 0 ? void 0 : _a.list) !== null && _b !== void 0 ? _b : []
            };
        };
        DChartAxisBaseOptionParser.prototype.toBar = function (theme, options) {
            var _a;
            return {
                style: (_a = options === null || options === void 0 ? void 0 : options.style) !== null && _a !== void 0 ? _a : theme.getStyle(),
                stroke: this.toBarStroke(theme, options === null || options === void 0 ? void 0 : options.stroke)
            };
        };
        DChartAxisBaseOptionParser.prototype.toTick = function (theme, options) {
            var _a;
            var tick = options === null || options === void 0 ? void 0 : options.tick;
            return {
                enable: (_a = tick === null || tick === void 0 ? void 0 : tick.enable) !== null && _a !== void 0 ? _a : theme.getTickEnable(),
                major: this.toTickMajor(theme, tick),
                minor: this.toTickMinor(theme, tick)
            };
        };
        DChartAxisBaseOptionParser.prototype.toTickMajor = function (theme, options) {
            var _a, _b, _c, _d, _e, _f, _g, _h;
            var major = options === null || options === void 0 ? void 0 : options.major;
            var position = (_b = (_a = major === null || major === void 0 ? void 0 : major.position) !== null && _a !== void 0 ? _a : options === null || options === void 0 ? void 0 : options.position) !== null && _b !== void 0 ? _b : theme.getMajorTickPosition();
            var optionsStyle = options === null || options === void 0 ? void 0 : options.style;
            var style = EShapePointsStyles.from((_d = (_c = major === null || major === void 0 ? void 0 : major.style) !== null && _c !== void 0 ? _c : optionsStyle) !== null && _d !== void 0 ? _d : theme.getMajorTickStyle());
            var optionsStroke = options === null || options === void 0 ? void 0 : options.stroke;
            var stroke = this.toTickMajorStroke(theme, major === null || major === void 0 ? void 0 : major.stroke, optionsStroke);
            var count = (_e = major === null || major === void 0 ? void 0 : major.count) !== null && _e !== void 0 ? _e : theme.getMajorTickCount();
            var capacity = (_f = major === null || major === void 0 ? void 0 : major.capacity) !== null && _f !== void 0 ? _f : theme.getMajorTickCapacity(count);
            return {
                count: count,
                capacity: capacity,
                step: (_g = major === null || major === void 0 ? void 0 : major.step) !== null && _g !== void 0 ? _g : theme.getMajorTickStep(),
                size: (_h = major === null || major === void 0 ? void 0 : major.size) !== null && _h !== void 0 ? _h : theme.getMajorTickSize(),
                position: this.toTickPosition(position),
                style: style,
                stroke: stroke,
                text: this.toTickMajorText(theme, major === null || major === void 0 ? void 0 : major.text),
                formatter: this.toTickMajorFormatter(theme, major),
                gridline: this.toTickMajorGridline(theme, major === null || major === void 0 ? void 0 : major.gridline, optionsStyle, optionsStroke)
            };
        };
        DChartAxisBaseOptionParser.prototype.toTickMajorGridline = function (theme, options, optionsStyle, optionsStroke) {
            var _a, _b, _c;
            var style = EShapePointsStyles.from((_b = (_a = options === null || options === void 0 ? void 0 : options.style) !== null && _a !== void 0 ? _a : optionsStyle) !== null && _b !== void 0 ? _b : theme.getMajorTickGridlineStyle());
            return {
                enable: (_c = options === null || options === void 0 ? void 0 : options.enable) !== null && _c !== void 0 ? _c : theme.getMajorTickGridlineEnable(),
                style: style,
                stroke: this.toTickMajorGridlineStroke(theme, options === null || options === void 0 ? void 0 : options.stroke, optionsStroke)
            };
        };
        DChartAxisBaseOptionParser.prototype.toTickPosition = function (tickPosition) {
            var position = this.position;
            if (tickPosition === DChartAxisTickPosition.OUTSIDE || tickPosition === "OUTSIDE") {
                switch (position) {
                    case DChartAxisPosition.TOP:
                        return EShapeBarPosition.BOTTOM;
                    case DChartAxisPosition.BOTTOM:
                        return EShapeBarPosition.TOP;
                    case DChartAxisPosition.LEFT:
                        return EShapeBarPosition.RIGHT;
                    case DChartAxisPosition.RIGHT:
                        return EShapeBarPosition.LEFT;
                    default:
                        return EShapeBarPosition.TOP;
                }
            }
            else {
                switch (position) {
                    case DChartAxisPosition.TOP:
                        return EShapeBarPosition.TOP;
                    case DChartAxisPosition.BOTTOM:
                        return EShapeBarPosition.BOTTOM;
                    case DChartAxisPosition.LEFT:
                        return EShapeBarPosition.LEFT;
                    case DChartAxisPosition.RIGHT:
                        return EShapeBarPosition.RIGHT;
                    default:
                        return EShapeBarPosition.TOP;
                }
            }
        };
        DChartAxisBaseOptionParser.prototype.toTickMinor = function (theme, options) {
            var _a, _b, _c, _d, _e, _f, _g;
            var minor = options === null || options === void 0 ? void 0 : options.minor;
            var position = (_b = (_a = minor === null || minor === void 0 ? void 0 : minor.position) !== null && _a !== void 0 ? _a : options === null || options === void 0 ? void 0 : options.position) !== null && _b !== void 0 ? _b : theme.getMinorTickPosition();
            var style = EShapePointsStyles.from((_d = (_c = minor === null || minor === void 0 ? void 0 : minor.style) !== null && _c !== void 0 ? _c : options === null || options === void 0 ? void 0 : options.style) !== null && _d !== void 0 ? _d : theme.getMinorTickStyle());
            return {
                count: (_e = minor === null || minor === void 0 ? void 0 : minor.count) !== null && _e !== void 0 ? _e : theme.getMinorTickCount(),
                step: (_f = minor === null || minor === void 0 ? void 0 : minor.step) !== null && _f !== void 0 ? _f : theme.getMinorTickStep(),
                size: (_g = minor === null || minor === void 0 ? void 0 : minor.size) !== null && _g !== void 0 ? _g : theme.getMinorTickSize(),
                position: this.toTickPosition(position),
                style: style,
                stroke: this.toTickMinorStroke(theme, minor === null || minor === void 0 ? void 0 : minor.stroke, options === null || options === void 0 ? void 0 : options.stroke),
                text: this.toTickMinorText(theme, minor === null || minor === void 0 ? void 0 : minor.text),
                formatter: this.toTickMinorFormatter(theme, minor)
            };
        };
        DChartAxisBaseOptionParser.prototype.toBarStroke = function (theme, options) {
            return this.toStroke(options, undefined, theme.getStrokeEnable(), theme.getStrokeColor(), theme.getStrokeAlpha(), theme.getStrokeWidth(), theme.getStrokeAlign(), theme.getStrokeSide(), theme.getStrokeStyle());
        };
        DChartAxisBaseOptionParser.prototype.toTickMajorStroke = function (theme, optionsA, optionsB) {
            return this.toStroke(optionsA, optionsB, theme.getMajorTickStrokeEnable(), theme.getMajorTickStrokeColor(), theme.getMajorTickStrokeAlpha(), theme.getMajorTickStrokeWidth(), theme.getMajorTickStrokeAlign(), theme.getMajorTickStrokeSide(), theme.getMajorTickStrokeStyle());
        };
        DChartAxisBaseOptionParser.prototype.toTickMajorGridlineStroke = function (theme, optionsA, optionsB) {
            return this.toStroke(optionsA, optionsB, theme.getMajorTickGridlineStrokeEnable(), theme.getMajorTickGridlineStrokeColor(), theme.getMajorTickGridlineStrokeAlpha(), theme.getMajorTickGridlineStrokeWidth(), theme.getMajorTickGridlineStrokeAlign(), theme.getMajorTickGridlineStrokeSide(), theme.getMajorTickGridlineStrokeStyle());
        };
        DChartAxisBaseOptionParser.prototype.toTickMinorStroke = function (theme, optionsA, optionsB) {
            return this.toStroke(optionsA, optionsB, theme.getMinorTickStrokeEnable(), theme.getMinorTickStrokeColor(), theme.getMinorTickStrokeAlpha(), theme.getMinorTickStrokeWidth(), theme.getMinorTickStrokeAlign(), theme.getMinorTickStrokeSide(), theme.getMinorTickStrokeStyle());
        };
        DChartAxisBaseOptionParser.prototype.toStroke = function (optionsA, optionsB, enable, color, alpha, width, align, side, style) {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3;
            if (optionsA) {
                if (optionsB) {
                    return {
                        enable: (_b = (_a = optionsA.enable) !== null && _a !== void 0 ? _a : optionsB.enable) !== null && _b !== void 0 ? _b : enable,
                        color: (_d = (_c = optionsA.color) !== null && _c !== void 0 ? _c : optionsB.color) !== null && _d !== void 0 ? _d : color,
                        alpha: (_f = (_e = optionsA.alpha) !== null && _e !== void 0 ? _e : optionsB.alpha) !== null && _f !== void 0 ? _f : alpha,
                        width: (_h = (_g = optionsA.width) !== null && _g !== void 0 ? _g : optionsB.width) !== null && _h !== void 0 ? _h : width,
                        align: (_k = (_j = optionsA.align) !== null && _j !== void 0 ? _j : optionsB.align) !== null && _k !== void 0 ? _k : align,
                        side: (_m = (_l = optionsA.side) !== null && _l !== void 0 ? _l : optionsB.side) !== null && _m !== void 0 ? _m : side,
                        style: this.toStrokeStyle((_p = (_o = optionsA.style) !== null && _o !== void 0 ? _o : optionsB.style) !== null && _p !== void 0 ? _p : style)
                    };
                }
                else {
                    return {
                        enable: (_q = optionsA.enable) !== null && _q !== void 0 ? _q : enable,
                        color: (_r = optionsA.color) !== null && _r !== void 0 ? _r : color,
                        alpha: (_s = optionsA.alpha) !== null && _s !== void 0 ? _s : alpha,
                        width: (_t = optionsA.width) !== null && _t !== void 0 ? _t : width,
                        align: (_u = optionsA.align) !== null && _u !== void 0 ? _u : align,
                        side: (_v = optionsA.side) !== null && _v !== void 0 ? _v : side,
                        style: this.toStrokeStyle((_w = optionsA.style) !== null && _w !== void 0 ? _w : style)
                    };
                }
            }
            else if (optionsB) {
                return {
                    enable: (_x = optionsB.enable) !== null && _x !== void 0 ? _x : enable,
                    color: (_y = optionsB.color) !== null && _y !== void 0 ? _y : color,
                    alpha: (_z = optionsB.alpha) !== null && _z !== void 0 ? _z : alpha,
                    width: (_0 = optionsB.width) !== null && _0 !== void 0 ? _0 : width,
                    align: (_1 = optionsB.align) !== null && _1 !== void 0 ? _1 : align,
                    side: (_2 = optionsB.side) !== null && _2 !== void 0 ? _2 : side,
                    style: this.toStrokeStyle((_3 = optionsB.style) !== null && _3 !== void 0 ? _3 : style)
                };
            }
            else {
                return {
                    enable: enable,
                    color: color,
                    alpha: alpha,
                    width: width,
                    align: align,
                    side: side,
                    style: style
                };
            }
        };
        DChartAxisBaseOptionParser.prototype.toStrokeStyle = function (target) {
            if (isString(target)) {
                return EShapeStrokeStyle[target];
            }
            else if (isArray(target)) {
                var result = EShapeStrokeStyle.NONE;
                for (var i = 0, imax = target.length; i < imax; ++i) {
                    result |= EShapeStrokeStyle[target[i]];
                }
                return result;
            }
            return target;
        };
        DChartAxisBaseOptionParser.prototype.toTickMajorFormatter = function (theme, options) {
            var text = options === null || options === void 0 ? void 0 : options.text;
            if (text) {
                var format_1 = text.format;
                if (format_1 === null) {
                    return undefined;
                }
                else if (format_1 != null) {
                    return NumberFormatters.create(format_1);
                }
                else {
                    var formatter = text.formatter;
                    if (formatter) {
                        return {
                            format: formatter
                        };
                    }
                }
            }
            var format = theme.getMajorTickTextFormat();
            if (format != null) {
                return NumberFormatters.create(format);
            }
            return undefined;
        };
        DChartAxisBaseOptionParser.prototype.toTickMajorText = function (theme, options) {
            options = options || {};
            return {
                format: options.format,
                color: this.toTickMajorTextColor(theme, options.color),
                alpha: options.alpha,
                family: options.family,
                size: options.size,
                weight: toEnum(options.weight, EShapeTextWeight),
                align: this.toTickMajorTextAlign(theme, options.align),
                offset: this.toTickMajorTextOffset(theme, options.offset),
                style: toEnum(options.style, EShapeTextStyle),
                outline: this.toTickMajorTextOutline(theme, options.outline),
                spacing: this.toTickMajorTextSpacing(theme, options.spacing),
                direction: this.toTickMajorTextDirection(theme, options.direction),
                padding: this.toTickMajorTextPadding(theme, options.padding),
                clipping: options.clipping
            };
        };
        DChartAxisBaseOptionParser.prototype.toTickMajorTextOutline = function (theme, options) {
            if (options) {
                return {
                    enable: options.enable,
                    color: options.color,
                    alpha: options.alpha,
                    width: options.width
                };
            }
        };
        DChartAxisBaseOptionParser.prototype.toTickMajorTextAlign = function (theme, options) {
            var _a, _b;
            var position = this.position;
            return {
                horizontal: (_a = options === null || options === void 0 ? void 0 : options.horizontal) !== null && _a !== void 0 ? _a : theme.getMajorTickTextAlignHorizontal(position),
                vertical: (_b = options === null || options === void 0 ? void 0 : options.vertical) !== null && _b !== void 0 ? _b : theme.getMajorTickTextAlignVertical(position)
            };
        };
        DChartAxisBaseOptionParser.prototype.toTickMajorTextOffset = function (theme, options) {
            if (options) {
                return {
                    horizontal: options.horizontal,
                    vertical: options.vertical
                };
            }
        };
        DChartAxisBaseOptionParser.prototype.toTickMajorTextSpacing = function (theme, options) {
            if (options) {
                return {
                    horizontal: options.horizontal,
                    vertical: options.vertical
                };
            }
        };
        DChartAxisBaseOptionParser.prototype.toTickMajorTextPadding = function (theme, options) {
            var _a, _b;
            return {
                horizontal: (_a = options === null || options === void 0 ? void 0 : options.horizontal) !== null && _a !== void 0 ? _a : theme.getMajorTickTextPaddingHorizontal(),
                vertical: (_b = options === null || options === void 0 ? void 0 : options.vertical) !== null && _b !== void 0 ? _b : theme.getMajorTickTextPaddingVertical()
            };
        };
        DChartAxisBaseOptionParser.prototype.toTickMajorTextDirection = function (theme, options) {
            return toEnum(options !== null && options !== void 0 ? options : theme.getMajorTickTextDirection(), EShapeTextDirection);
        };
        DChartAxisBaseOptionParser.prototype.toTickMajorTextColor = function (theme, options) {
            return options !== null && options !== void 0 ? options : theme.getMajorTickTextColor();
        };
        DChartAxisBaseOptionParser.prototype.toTickMinorFormatter = function (theme, options) {
            var text = options === null || options === void 0 ? void 0 : options.text;
            if (text) {
                var format_2 = text.format;
                if (format_2 === null) {
                    return undefined;
                }
                else if (format_2 != null) {
                    return NumberFormatters.create(format_2);
                }
                else {
                    var formatter = text.formatter;
                    if (formatter) {
                        return {
                            format: formatter
                        };
                    }
                }
            }
            var format = theme.getMinorTickTextFormat();
            if (format != null) {
                return NumberFormatters.create(format);
            }
            return undefined;
        };
        DChartAxisBaseOptionParser.prototype.toTickMinorText = function (theme, options) {
            options = options || {};
            return {
                format: options.format,
                color: this.toTickMinorTextColor(theme, options.color),
                alpha: options.alpha,
                family: options.family,
                size: options.size,
                weight: toEnum(options.weight, EShapeTextWeight),
                align: this.toTickMinorTextAlign(theme, options.align),
                offset: this.toTickMinorTextOffset(theme, options.offset),
                style: toEnum(options.style, EShapeTextStyle),
                outline: this.toTickMinorTextOutline(theme, options.outline),
                spacing: this.toTickMinorTextSpacing(theme, options.spacing),
                direction: this.toTickMinorTextDirection(theme, options.direction),
                padding: this.toTickMinorTextPadding(theme, options.padding),
                clipping: options.clipping
            };
        };
        DChartAxisBaseOptionParser.prototype.toTickMinorTextOutline = function (theme, options) {
            if (options) {
                return {
                    enable: options.enable,
                    color: options.color,
                    alpha: options.alpha,
                    width: options.width
                };
            }
        };
        DChartAxisBaseOptionParser.prototype.toTickMinorTextAlign = function (theme, options) {
            var _a, _b;
            var position = this.position;
            return {
                horizontal: (_a = options === null || options === void 0 ? void 0 : options.horizontal) !== null && _a !== void 0 ? _a : theme.getMinorTickTextAlignHorizontal(position),
                vertical: (_b = options === null || options === void 0 ? void 0 : options.vertical) !== null && _b !== void 0 ? _b : theme.getMinorTickTextAlignVertical(position)
            };
        };
        DChartAxisBaseOptionParser.prototype.toTickMinorTextOffset = function (theme, options) {
            if (options) {
                return {
                    horizontal: options.horizontal,
                    vertical: options.vertical
                };
            }
        };
        DChartAxisBaseOptionParser.prototype.toTickMinorTextSpacing = function (theme, options) {
            if (options) {
                return {
                    horizontal: options.horizontal,
                    vertical: options.vertical
                };
            }
        };
        DChartAxisBaseOptionParser.prototype.toTickMinorTextPadding = function (theme, options) {
            var _a, _b;
            return {
                horizontal: (_a = options === null || options === void 0 ? void 0 : options.horizontal) !== null && _a !== void 0 ? _a : theme.getMinorTickTextPaddingHorizontal(),
                vertical: (_b = options === null || options === void 0 ? void 0 : options.vertical) !== null && _b !== void 0 ? _b : theme.getMinorTickTextPaddingVertical()
            };
        };
        DChartAxisBaseOptionParser.prototype.toTickMinorTextDirection = function (theme, options) {
            return toEnum(options !== null && options !== void 0 ? options : theme.getMinorTickTextDirection(), EShapeTextDirection);
        };
        DChartAxisBaseOptionParser.prototype.toTickMinorTextColor = function (theme, options) {
            return options !== null && options !== void 0 ? options : theme.getMinorTickTextColor();
        };
        DChartAxisBaseOptionParser.prototype.toLabel = function (theme, options) {
            var label = options === null || options === void 0 ? void 0 : options.label;
            if (label) {
                return {
                    value: label.value,
                    color: this.toLabelColor(theme, label.color),
                    alpha: label.alpha,
                    family: label.family,
                    size: label.size,
                    weight: toEnum(label.weight, EShapeTextWeight),
                    align: this.toLabelAlign(theme, label.align),
                    offset: this.toLabelOffset(theme, label.offset),
                    style: toEnum(label.style, EShapeTextStyle),
                    outline: this.toLabelOutline(theme, label.outline),
                    spacing: this.toLabelSpacing(theme, label.spacing),
                    direction: this.toLabelDirection(theme, label.direction),
                    padding: this.toLabelPadding(theme, label.padding),
                    clipping: label.clipping
                };
            }
        };
        DChartAxisBaseOptionParser.prototype.toLabelOutline = function (theme, options) {
            if (options) {
                return {
                    enable: options.enable,
                    color: options.color,
                    alpha: options.alpha,
                    width: options.width
                };
            }
        };
        DChartAxisBaseOptionParser.prototype.toLabelAlign = function (theme, options) {
            var _a, _b;
            var position = this.position;
            return {
                horizontal: (_a = options === null || options === void 0 ? void 0 : options.horizontal) !== null && _a !== void 0 ? _a : theme.getLabelAlignHorizontal(position),
                vertical: (_b = options === null || options === void 0 ? void 0 : options.vertical) !== null && _b !== void 0 ? _b : theme.getLabelAlignVertical(position)
            };
        };
        DChartAxisBaseOptionParser.prototype.toLabelOffset = function (theme, options) {
            if (options) {
                return {
                    horizontal: options.horizontal,
                    vertical: options.vertical
                };
            }
        };
        DChartAxisBaseOptionParser.prototype.toLabelSpacing = function (theme, options) {
            if (options) {
                return {
                    horizontal: options.horizontal,
                    vertical: options.vertical
                };
            }
        };
        DChartAxisBaseOptionParser.prototype.toLabelPadding = function (theme, options) {
            var _a, _b;
            return {
                horizontal: (_a = options === null || options === void 0 ? void 0 : options.horizontal) !== null && _a !== void 0 ? _a : theme.getLabelPaddingHorizontal(),
                vertical: (_b = options === null || options === void 0 ? void 0 : options.vertical) !== null && _b !== void 0 ? _b : theme.getLabelPaddingVertical()
            };
        };
        DChartAxisBaseOptionParser.prototype.toLabelDirection = function (theme, options) {
            return toEnum(options !== null && options !== void 0 ? options : theme.getLabelDirection(), EShapeTextDirection);
        };
        DChartAxisBaseOptionParser.prototype.toLabelColor = function (theme, options) {
            return options !== null && options !== void 0 ? options : theme.getLabelColor();
        };
        return DChartAxisBaseOptionParser;
    }());

    var DChartAxisBaseTickMajorGridline = /** @class */ (function () {
        function DChartAxisBaseTickMajorGridline(parser) {
            this._parser = parser;
            this._index = 0;
        }
        Object.defineProperty(DChartAxisBaseTickMajorGridline.prototype, "shapes", {
            get: function () {
                var _a;
                return ((_a = this._shapes) !== null && _a !== void 0 ? _a : (this._shapes = this.newShapes()));
            },
            enumerable: false,
            configurable: true
        });
        DChartAxisBaseTickMajorGridline.prototype.newShapes = function () {
            var _a;
            var result = [];
            var tick = this._parser.tick;
            var major = tick.major;
            var gridline = major.gridline;
            if (tick.enable && gridline.enable) {
                var capacity = major.capacity;
                var style = (_a = gridline.style) !== null && _a !== void 0 ? _a : EShapePointsStyle.NONE;
                var position = this.newShapePosition();
                for (var i = 0; i < capacity; ++i) {
                    var shape = new EShapeBar();
                    shape.points.position = position;
                    shape.points.style = style;
                    shape.stroke.copy(gridline.stroke);
                    result.push(shape);
                }
            }
            return result;
        };
        DChartAxisBaseTickMajorGridline.prototype.newShapePosition = function () {
            switch (this._parser.position) {
                case DChartAxisPosition.LEFT:
                case DChartAxisPosition.RIGHT:
                    return EShapeBarPosition.LEFT;
                default:
                    return EShapeBarPosition.TOP;
            }
        };
        DChartAxisBaseTickMajorGridline.prototype.bind = function (container, index) {
            this._container = container;
            this._index = index;
            var shapes = this.shapes;
            var containerContainer = container.container;
            for (var i = 0, imax = shapes.length; i < imax; ++i) {
                shapes[i].attach(containerContainer);
            }
        };
        DChartAxisBaseTickMajorGridline.prototype.unbind = function () {
            var shapes = this._shapes;
            if (shapes != null) {
                for (var i = 0, imax = shapes.length; i < imax; ++i) {
                    shapes[i].detach();
                }
            }
            this._index = 0;
            this._container = undefined;
        };
        DChartAxisBaseTickMajorGridline.prototype.destroy = function () {
            var shapes = this._shapes;
            if (shapes != null) {
                for (var i = 0, imax = shapes.length; i < imax; ++i) {
                    shapes[i].destroy();
                }
                shapes.length = 0;
                this._shapes = undefined;
            }
            this._index = 0;
            this._container = undefined;
        };
        return DChartAxisBaseTickMajorGridline;
    }());

    var DChartAxisBaseTickMajor = /** @class */ (function () {
        function DChartAxisBaseTickMajor(parser) {
            this._parser = parser;
            this._index = 0;
            this._gridline = new DChartAxisBaseTickMajorGridline(parser);
        }
        Object.defineProperty(DChartAxisBaseTickMajor.prototype, "shapes", {
            get: function () {
                var _a;
                return ((_a = this._shapes) !== null && _a !== void 0 ? _a : (this._shapes = this.newShapes()));
            },
            enumerable: false,
            configurable: true
        });
        DChartAxisBaseTickMajor.prototype.newShapes = function () {
            var _a;
            var result = [];
            var tick = this._parser.tick;
            if (tick.enable) {
                var major = tick.major;
                var capacity = major.capacity;
                var size = major.size;
                var position = major.position;
                var style = (_a = major.style) !== null && _a !== void 0 ? _a : EShapePointsStyle.NONE;
                for (var i = 0; i < capacity; ++i) {
                    var shape = new EShapeBar();
                    shape.points.position = position;
                    shape.points.size = size;
                    shape.points.style = style;
                    shape.stroke.copy(major.stroke);
                    shape.text.copy(major.text);
                    shape.size.set(0, 0);
                    result.push(shape);
                }
            }
            return result;
        };
        Object.defineProperty(DChartAxisBaseTickMajor.prototype, "gridline", {
            get: function () {
                return this._gridline;
            },
            enumerable: false,
            configurable: true
        });
        DChartAxisBaseTickMajor.prototype.bind = function (container, index) {
            this._container = container;
            this._index = index;
            // Gridline
            this._gridline.bind(container, index);
            // Ticks
            var shapes = this.shapes;
            var containerContainer = container.container;
            for (var i = 0, imax = shapes.length; i < imax; ++i) {
                shapes[i].attach(containerContainer);
            }
        };
        DChartAxisBaseTickMajor.prototype.unbind = function () {
            var shapes = this._shapes;
            if (shapes != null) {
                for (var i = 0, imax = shapes.length; i < imax; ++i) {
                    shapes[i].detach();
                }
            }
            this._gridline.unbind();
            this._index = 0;
            this._container = undefined;
        };
        DChartAxisBaseTickMajor.prototype.destroy = function () {
            var shapes = this._shapes;
            if (shapes != null) {
                for (var i = 0, imax = shapes.length; i < imax; ++i) {
                    shapes[i].destroy();
                }
                shapes.length = 0;
                this._shapes = undefined;
            }
            this._gridline.destroy();
            this._index = 0;
            this._container = undefined;
        };
        return DChartAxisBaseTickMajor;
    }());

    var DChartAxisBaseTickMinor = /** @class */ (function () {
        function DChartAxisBaseTickMinor(parser) {
            this._parser = parser;
            this._index = 0;
        }
        Object.defineProperty(DChartAxisBaseTickMinor.prototype, "shapes", {
            get: function () {
                var _a;
                return ((_a = this._shapes) !== null && _a !== void 0 ? _a : (this._shapes = this.newShapes()));
            },
            enumerable: false,
            configurable: true
        });
        DChartAxisBaseTickMinor.prototype.newShapes = function () {
            var _a;
            var result = [];
            var tick = this._parser.tick;
            if (tick.enable) {
                var minor = tick.minor;
                var count = minor.count;
                var size = minor.size;
                var position = minor.position;
                var style = (_a = minor.style) !== null && _a !== void 0 ? _a : EShapePointsStyle.NONE;
                var major = tick.major;
                for (var i = 0, imax = (major.capacity + 1) * count; i < imax; ++i) {
                    var shape = new EShapeBar();
                    shape.points.position = position;
                    shape.points.size = size;
                    shape.points.style = style;
                    shape.stroke.copy(minor.stroke);
                    shape.text.copy(minor.text);
                    shape.size.set(0, 0);
                    result.push(shape);
                }
            }
            return result;
        };
        DChartAxisBaseTickMinor.prototype.bind = function (container, index) {
            this._container = container;
            this._index = index;
            var shapes = this.shapes;
            var containerContainer = container.container;
            for (var i = 0, imax = shapes.length; i < imax; ++i) {
                shapes[i].attach(containerContainer);
            }
        };
        DChartAxisBaseTickMinor.prototype.unbind = function () {
            var shapes = this._shapes;
            if (shapes != null) {
                for (var i = 0, imax = shapes.length; i < imax; ++i) {
                    shapes[i].detach();
                }
            }
            this._index = 0;
            this._container = undefined;
        };
        DChartAxisBaseTickMinor.prototype.destroy = function () {
            var shapes = this._shapes;
            if (shapes != null) {
                for (var i = 0, imax = shapes.length; i < imax; ++i) {
                    shapes[i].destroy();
                }
                shapes.length = 0;
                this._shapes = undefined;
            }
            this._index = 0;
            this._container = undefined;
        };
        return DChartAxisBaseTickMinor;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartRegionImpl = /** @class */ (function () {
        function DChartRegionImpl(from, to) {
            this.from = from;
            this.to = to;
        }
        DChartRegionImpl.prototype.set = function (from, to) {
            if (from != null) {
                this.from = from;
            }
            if (to != null) {
                this.to = to;
            }
            return this;
        };
        DChartRegionImpl.prototype.add = function (from, to) {
            if (!isNaN$1(from)) {
                this.from = isNaN$1(this.from) ? from : Math.min(this.from, from);
            }
            if (!isNaN$1(to)) {
                this.to = isNaN$1(this.to) ? to : Math.max(this.to, to);
            }
            return this;
        };
        DChartRegionImpl.prototype.clear = function () {
            this.from = NaN;
            this.to = NaN;
            return this;
        };
        return DChartRegionImpl;
    }());

    var DChartAxisBaseTickContainer = /** @class */ (function () {
        function DChartAxisBaseTickContainer(parser, options) {
            this._parser = parser;
            this._index = 0;
            this._major = this.newMajor(parser, options);
            this._minor = this.newMinor(parser, options);
            this._majorTicks = [];
            this._minorTicks = [];
            this._work = new DChartRegionImpl(0, 0);
        }
        Object.defineProperty(DChartAxisBaseTickContainer.prototype, "major", {
            get: function () {
                return this._major;
            },
            enumerable: false,
            configurable: true
        });
        DChartAxisBaseTickContainer.prototype.newMajor = function (parser, options) {
            return new DChartAxisBaseTickMajor(parser);
        };
        Object.defineProperty(DChartAxisBaseTickContainer.prototype, "minor", {
            get: function () {
                return this._minor;
            },
            enumerable: false,
            configurable: true
        });
        DChartAxisBaseTickContainer.prototype.newMinor = function (parser, options) {
            return new DChartAxisBaseTickMinor(parser);
        };
        DChartAxisBaseTickContainer.prototype.bind = function (container, index) {
            this._container = container;
            this._index = index;
            this._major.bind(container, index);
            this._minor.bind(container, index);
        };
        DChartAxisBaseTickContainer.prototype.unbind = function () {
            this._minor.unbind();
            this._major.unbind();
            this._index = 0;
            this._container = undefined;
        };
        DChartAxisBaseTickContainer.prototype.update = function () {
            var parser = this._parser;
            var container = this._container;
            var majorShapes = this._major.shapes;
            var minorShapes = this._minor.shapes;
            if (parser.tick.enable && container != null && majorShapes && minorShapes) {
                var plotArea = container.plotArea;
                var plotAreaBounds = plotArea.getAxisBounds(parser.position);
                var plotAreaX = plotAreaBounds.x;
                var plotAreaY = plotAreaBounds.y;
                var plotAreaWidth = plotAreaBounds.width;
                var plotAreaHeight = plotAreaBounds.height;
                var transform = plotArea.container.transform.localTransform;
                var gridlineShapes = this._major.gridline.shapes;
                var offset = parser.padding * this._index;
                var work = this._work;
                var coordinate = void 0;
                switch (parser.position) {
                    case DChartAxisPosition.TOP:
                        coordinate = plotArea.coordinate.x.get(parser.coordinate);
                        if (coordinate) {
                            var domain = this.getDomain(plotArea, coordinate, work);
                            var domainFrom = domain.from;
                            var domainTo = domain.to;
                            var domainVisible = this.getDomainVisible(plotArea, coordinate, work);
                            var domainVisibleFrom = domainVisible.from;
                            var domainVisibleTo = domainVisible.to;
                            return this.updateX(domainFrom, domainTo, domainVisibleFrom, domainVisibleTo, coordinate, majorShapes, minorShapes, gridlineShapes, plotAreaY - offset, transform, plotAreaY, plotAreaHeight);
                        }
                        break;
                    case DChartAxisPosition.BOTTOM:
                        coordinate = plotArea.coordinate.x.get(parser.coordinate);
                        if (coordinate) {
                            var domain = this.getDomain(plotArea, coordinate, work);
                            var domainFrom = domain.from;
                            var domainTo = domain.to;
                            var domainVisible = this.getDomainVisible(plotArea, coordinate, work);
                            var domainVisibleFrom = domainVisible.from;
                            var domainVisibleTo = domainVisible.to;
                            return this.updateX(domainFrom, domainTo, domainVisibleFrom, domainVisibleTo, coordinate, majorShapes, minorShapes, gridlineShapes, plotAreaY + plotAreaHeight + offset, transform, plotAreaY, plotAreaHeight);
                        }
                        break;
                    case DChartAxisPosition.LEFT:
                        coordinate = plotArea.coordinate.y.get(parser.coordinate);
                        if (coordinate) {
                            var range = this.getRange(plotArea, coordinate, work);
                            var rangeFrom = range.from;
                            var rangeTo = range.to;
                            var rangeVisible = this.getRangeVisible(plotArea, coordinate, work);
                            var rangeVisibleFrom = rangeVisible.from;
                            var rangeVisibleTo = rangeVisible.to;
                            return this.updateY(rangeFrom, rangeTo, rangeVisibleFrom, rangeVisibleTo, coordinate, majorShapes, minorShapes, gridlineShapes, plotAreaX - offset, transform, plotAreaX, plotAreaWidth);
                        }
                        break;
                    case DChartAxisPosition.RIGHT:
                        coordinate = plotArea.coordinate.y.get(parser.coordinate);
                        if (coordinate) {
                            var range = this.getRange(plotArea, coordinate, work);
                            var rangeFrom = range.from;
                            var rangeTo = range.to;
                            var rangeVisible = this.getRangeVisible(plotArea, coordinate, work);
                            var rangeVisibleFrom = rangeVisible.from;
                            var rangeVisibleTo = rangeVisible.to;
                            return this.updateY(rangeFrom, rangeTo, rangeVisibleFrom, rangeVisibleTo, coordinate, majorShapes, minorShapes, gridlineShapes, plotAreaX + plotAreaWidth + offset, transform, plotAreaX, plotAreaWidth);
                        }
                        break;
                }
            }
            return false;
        };
        DChartAxisBaseTickContainer.prototype.getDomain = function (plotArea, coordinate, result) {
            var bounds = plotArea.getContainerBounds();
            var transform = coordinate.transform;
            return result.set(coordinate.unmap(transform.unmap(bounds.x)), coordinate.unmap(transform.unmap(bounds.x + bounds.width)));
        };
        DChartAxisBaseTickContainer.prototype.getDomainVisible = function (plotArea, coordinate, result) {
            return result;
        };
        DChartAxisBaseTickContainer.prototype.getRange = function (plotArea, coordinate, result) {
            var bounds = plotArea.getContainerBounds();
            var transform = coordinate.transform;
            return result.set(coordinate.unmap(transform.unmap(bounds.y)), coordinate.unmap(transform.unmap(bounds.y + bounds.height)));
        };
        DChartAxisBaseTickContainer.prototype.getRangeVisible = function (plotArea, coordinate, result) {
            return result;
        };
        DChartAxisBaseTickContainer.prototype.updateX = function (domainFrom, domainTo, domainVisibleFrom, domainVisibleTo, coordinate, majorShapes, minorShapes, gridlineShapes, shapePositionY, transform, plotAreaY, plotAreaHeight) {
            var tick = this._parser.tick;
            var majorTick = tick.major;
            var majorCount = majorTick.count;
            var majorCapacity = majorTick.capacity;
            var majorStep = majorTick.step;
            var majorFormatter = majorTick.formatter;
            var minorTick = tick.minor;
            var minorCountPerMajor = minorTick.count;
            var minorCount = (majorCapacity + 1) * minorCountPerMajor;
            var minorStep = minorTick.step;
            var minorFormatter = minorTick.formatter;
            var majorTicks = this._majorTicks;
            var minorTicks = this._minorTicks;
            this.newTicks(coordinate, domainFrom, domainTo, domainVisibleFrom, domainVisibleTo, majorCount, majorCapacity, majorStep, minorCountPerMajor, minorCount, minorStep, majorTicks, minorTicks);
            var a = transform.a;
            var tx = transform.tx;
            for (var i = 0; i < majorCapacity; ++i) {
                var majorShape = majorShapes[i];
                var imajorTick = i * 3;
                var majorTickPosition = majorTicks[imajorTick + 0];
                if (!isNaN(majorTickPosition)) {
                    var majorTickProjectedPosition = majorTicks[imajorTick + 1];
                    var majotTickPositionX = a * majorTickProjectedPosition + tx;
                    var majorTickStep = majorTicks[imajorTick + 2];
                    this.showMajor(majorShape, majotTickPositionX, shapePositionY, majorFormatter === null || majorFormatter === void 0 ? void 0 : majorFormatter.format(majorTickPosition, majorTickStep));
                    if (i < gridlineShapes.length) {
                        this.showMajorGridline(gridlineShapes[i], majorTickPosition, majotTickPositionX, plotAreaY + plotAreaHeight * 0.5, 0, plotAreaHeight);
                    }
                }
                else {
                    this.hideMajor(majorShape);
                    if (i < gridlineShapes.length) {
                        this.hideMajorGridline(gridlineShapes[i]);
                    }
                }
            }
            for (var i = 0; i < minorCount; ++i) {
                var minorShape = minorShapes[i];
                var iminorTick = i * 3;
                var minorTickPosition = minorTicks[iminorTick + 0];
                if (!isNaN(minorTickPosition)) {
                    var minorTickProjectedPosition = minorTicks[iminorTick + 1];
                    var minorTickPositionX = a * minorTickProjectedPosition + tx;
                    var minorTickStep = minorTicks[iminorTick + 2];
                    this.showMinor(minorShape, minorTickPositionX, shapePositionY, minorFormatter === null || minorFormatter === void 0 ? void 0 : minorFormatter.format(minorTickPosition, minorTickStep));
                }
                else {
                    this.hideMinor(minorShape);
                }
            }
            return true;
        };
        DChartAxisBaseTickContainer.prototype.updateY = function (rangeFrom, rangeTo, rangeVisibleFrom, rangeVisibleTo, coordinate, majorShapes, minorShapes, gridlineShapes, shapePositionX, transform, plotAreaX, plotAreaWidth) {
            var tick = this._parser.tick;
            var majorTick = tick.major;
            var majorCount = majorTick.count;
            var majorCapacity = majorTick.capacity;
            var majorStep = majorTick.step;
            var majorFormatter = majorTick.formatter;
            var minorTick = tick.minor;
            var minorCountPerMajor = minorTick.count;
            var minorCount = (majorCapacity + 1) * minorCountPerMajor;
            var minorStep = minorTick.step;
            var minorFormatter = minorTick.formatter;
            var majorTicks = this._majorTicks;
            var minorTicks = this._minorTicks;
            this.newTicks(coordinate, rangeFrom, rangeTo, rangeVisibleFrom, rangeVisibleTo, majorCount, majorCapacity, majorStep, minorCountPerMajor, minorCount, minorStep, majorTicks, minorTicks);
            var d = transform.d;
            var ty = transform.ty;
            for (var i = 0; i < majorCapacity; ++i) {
                var majorShape = majorShapes[i];
                var imajorTick = i * 3;
                var majorTickPosition = majorTicks[imajorTick + 0];
                if (!isNaN(majorTickPosition)) {
                    var majorTickProjectedPosition = majorTicks[imajorTick + 1];
                    var majotTickPositionY = d * majorTickProjectedPosition + ty;
                    var majorTickStep = majorTicks[imajorTick + 2];
                    this.showMajor(majorShape, shapePositionX, majotTickPositionY, majorFormatter === null || majorFormatter === void 0 ? void 0 : majorFormatter.format(majorTickPosition, majorTickStep));
                    if (i < gridlineShapes.length) {
                        this.showMajorGridline(gridlineShapes[i], majorTickPosition, plotAreaX + plotAreaWidth * 0.5, majotTickPositionY, plotAreaWidth, 0);
                    }
                }
                else {
                    this.hideMajor(majorShape);
                    if (i < gridlineShapes.length) {
                        this.hideMajorGridline(gridlineShapes[i]);
                    }
                }
            }
            for (var i = 0; i < minorCount; ++i) {
                var minorShape = minorShapes[i];
                var iminorTick = i * 3;
                var minorTickPosition = minorTicks[iminorTick + 0];
                if (!isNaN(minorTickPosition)) {
                    var minorTickProjectedPosition = minorTicks[iminorTick + 1];
                    var minorTickPositionY = d * minorTickProjectedPosition + ty;
                    var minorTickStep = minorTicks[iminorTick + 2];
                    this.showMinor(minorShape, shapePositionX, minorTickPositionY, minorFormatter === null || minorFormatter === void 0 ? void 0 : minorFormatter.format(minorTickPosition, minorTickStep));
                }
                else {
                    this.hideMinor(minorShape);
                }
            }
            return true;
        };
        DChartAxisBaseTickContainer.prototype.showMajor = function (shape, x, y, text) {
            shape.lock(EShapeLockPart.UPLOADED);
            shape.visible = true;
            shape.transform.position.set(x, y);
            shape.text.value = text != null ? text : "";
            shape.unlock(EShapeLockPart.UPLOADED, true);
        };
        DChartAxisBaseTickContainer.prototype.showMajorGridline = function (shape, value, x, y, sx, sy) {
            shape.lock(EShapeLockPart.UPLOADED);
            shape.visible = true;
            shape.transform.position.set(x, y);
            shape.size.set(sx, sy);
            shape.unlock(EShapeLockPart.UPLOADED, true);
        };
        DChartAxisBaseTickContainer.prototype.hideMajor = function (shape) {
            shape.visible = false;
        };
        DChartAxisBaseTickContainer.prototype.hideMajorGridline = function (shape) {
            shape.visible = false;
        };
        DChartAxisBaseTickContainer.prototype.showMinor = function (shape, x, y, text) {
            shape.lock(EShapeLockPart.UPLOADED);
            shape.visible = true;
            shape.transform.position.set(x, y);
            shape.text.value = text != null ? text : "";
            shape.unlock(EShapeLockPart.UPLOADED, true);
        };
        DChartAxisBaseTickContainer.prototype.hideMinor = function (shape) {
            shape.visible = false;
        };
        DChartAxisBaseTickContainer.prototype.newTicks = function (coordinate, domainFrom, domainTo, domainVisibleFrom, domainVisibleTo, majorCount, majorCapacity, majorStep, minorCountPerMajor, minorCount, minorStep, majorResult, minorResult) {
            coordinate.ticks(domainFrom, domainTo, domainVisibleFrom, domainVisibleTo, majorCount, majorCapacity, majorStep, minorCountPerMajor, minorCount, minorStep, majorResult, minorResult);
        };
        DChartAxisBaseTickContainer.prototype.destroy = function () {
            this._major.destroy();
            this._minor.destroy();
            this._index = 0;
            this._container = undefined;
        };
        return DChartAxisBaseTickContainer;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartAxisBase = /** @class */ (function () {
        function DChartAxisBase(options) {
            var theme = this.toTheme(options);
            this._theme = theme;
            var parser = this.newParser(theme, options);
            this._parser = parser;
            this._index = 0;
            this._bar = this.newBar(parser, theme, options);
            this._tick = this.newTick(parser, theme, options);
            this._guide = this.newGuide(parser, theme, options);
        }
        DChartAxisBase.prototype.newParser = function (theme, options) {
            return new DChartAxisBaseOptionParser(theme, options);
        };
        Object.defineProperty(DChartAxisBase.prototype, "position", {
            get: function () {
                return this._parser.position;
            },
            set: function (position) {
                this._parser.position = position;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartAxisBase.prototype, "coordinate", {
            get: function () {
                return this._parser.coordinate;
            },
            set: function (coordinate) {
                this._parser.coordinate = coordinate;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartAxisBase.prototype, "padding", {
            get: function () {
                return this._parser.padding;
            },
            set: function (padding) {
                this._parser.padding = padding;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartAxisBase.prototype, "bar", {
            get: function () {
                return this._bar;
            },
            enumerable: false,
            configurable: true
        });
        DChartAxisBase.prototype.newBar = function (parser, theme, options) {
            return new DChartAxisBaseBar(parser);
        };
        Object.defineProperty(DChartAxisBase.prototype, "tick", {
            get: function () {
                return this._tick;
            },
            enumerable: false,
            configurable: true
        });
        DChartAxisBase.prototype.newTick = function (parser, theme, options) {
            return new DChartAxisBaseTickContainer(parser);
        };
        Object.defineProperty(DChartAxisBase.prototype, "guide", {
            get: function () {
                return this._guide;
            },
            enumerable: false,
            configurable: true
        });
        DChartAxisBase.prototype.newGuide = function (parser, theme, options) {
            var result = new DChartAxisBaseGuideContainer(this);
            var list = parser.guide.list;
            for (var i = 0, imax = list.length; i < imax; ++i) {
                result.add(list[i]);
            }
            return result;
        };
        DChartAxisBase.prototype.bind = function (container, index) {
            this._container = container;
            this._index = index;
            this._bar.bind(container, index);
            this._tick.bind(container, index);
            this._guide.bind(container, index);
        };
        DChartAxisBase.prototype.unbind = function () {
            this._guide.unbind();
            this._tick.unbind();
            this._bar.unbind();
            this._index = 0;
            this._container = undefined;
        };
        DChartAxisBase.prototype.update = function () {
            var isBarUpdated = this._bar.update();
            var isTicksUpdated = this._tick.update();
            var isGuideUpdated = this._guide.update();
            if (isBarUpdated || isTicksUpdated || isGuideUpdated) {
                var container = this._container;
                if (container) {
                    DApplications.update(container.plotArea);
                }
            }
        };
        DChartAxisBase.prototype.onRender = function () {
            this._bar.update();
            this._tick.update();
            this._guide.update();
        };
        DChartAxisBase.prototype.destroy = function () {
            this._bar.destroy();
            this._tick.destroy();
            this._guide.destroy();
            this._container = undefined;
        };
        DChartAxisBase.prototype.toTheme = function (options) {
            var _a;
            return (_a = options === null || options === void 0 ? void 0 : options.theme) !== null && _a !== void 0 ? _a : this.getThemeDefault();
        };
        DChartAxisBase.prototype.getThemeDefault = function () {
            return DThemes.getInstance().get(this.getType());
        };
        DChartAxisBase.prototype.getType = function () {
            return "DChartAxisBase";
        };
        return DChartAxisBase;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartAxisContainerImpl = /** @class */ (function () {
        function DChartAxisContainerImpl(plotArea, container, options) {
            this._plotArea = plotArea;
            this._container = container;
            this._list = new Map();
        }
        Object.defineProperty(DChartAxisContainerImpl.prototype, "container", {
            get: function () {
                return this._container;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartAxisContainerImpl.prototype, "plotArea", {
            get: function () {
                return this._plotArea;
            },
            enumerable: false,
            configurable: true
        });
        DChartAxisContainerImpl.prototype.add = function (axis) {
            var list = this._list;
            var axes = list.get(axis.position);
            if (axes == null) {
                axes = [];
                list.set(axis.position, axes);
            }
            axes.push(axis);
            axis.bind(this, axes.length - 1);
        };
        DChartAxisContainerImpl.prototype.get = function (position, index) {
            var list = this._list;
            var axes = list.get(toEnum(position, DChartAxisPosition));
            if (axes) {
                if (0 <= index && index < axes.length) {
                    return axes[index];
                }
            }
            return null;
        };
        DChartAxisContainerImpl.prototype.indexOf = function (axis) {
            var list = this._list;
            var axes = list.get(axis.position);
            if (axes) {
                return axes.indexOf(axis);
            }
            return -1;
        };
        DChartAxisContainerImpl.prototype.clear = function (position) {
            var list = this._list;
            var axes = list.get(toEnum(position, DChartAxisPosition));
            if (axes) {
                for (var i = 0, imax = axes.length; i < imax; ++i) {
                    axes[i].destroy();
                }
                axes.length = 0;
            }
            return this;
        };
        DChartAxisContainerImpl.prototype.size = function (position) {
            var list = this._list;
            var axes = list.get(toEnum(position, DChartAxisPosition));
            if (axes) {
                return axes.length;
            }
            return 0;
        };
        DChartAxisContainerImpl.prototype.update = function () {
            this._list.forEach(function (axes) {
                for (var i = 0, imax = axes.length; i < imax; ++i) {
                    axes[i].update();
                }
            });
        };
        DChartAxisContainerImpl.prototype.onRender = function () {
            this._list.forEach(function (axes) {
                for (var i = 0, imax = axes.length; i < imax; ++i) {
                    axes[i].onRender();
                }
            });
        };
        DChartAxisContainerImpl.prototype.destroy = function () {
            this._list.forEach(function (axes) {
                for (var i = 0, imax = axes.length; i < imax; ++i) {
                    axes[i].destroy();
                }
                axes.length = 0;
            });
        };
        return DChartAxisContainerImpl;
    }());

    var DChartAxisGuideSimpleShapeImpl = /** @class */ (function () {
        function DChartAxisGuideSimpleShapeImpl(options) {
            this._options = options;
        }
        Object.defineProperty(DChartAxisGuideSimpleShapeImpl.prototype, "bar", {
            get: function () {
                var result = this._bar;
                if (result === undefined) {
                    result = this.newBar();
                    this._bar = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DChartAxisGuideSimpleShapeImpl.prototype.newBar = function () {
            var _a, _b;
            var bar = (_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.bar) !== null && _b !== void 0 ? _b : {};
            if (bar.enable !== false) {
                var result = new EShapeBar();
                result.stroke.copy(this.toStrokeOptions(bar.stroke, EShapeStrokeStyle.DASHED));
                result.text.copy(this.toTextOptions(bar.text));
                return result;
            }
            return null;
        };
        DChartAxisGuideSimpleShapeImpl.prototype.toStrokeOptions = function (options, style) {
            var _a;
            options = options || {};
            return {
                enable: options.enable,
                color: options.color,
                alpha: options.alpha,
                width: options.width,
                align: options.align,
                side: toEnum(options.side, EShapeStrokeSide),
                style: toEnum((_a = options.style) !== null && _a !== void 0 ? _a : style, EShapeStrokeStyle)
            };
        };
        DChartAxisGuideSimpleShapeImpl.prototype.toTextOptions = function (options) {
            options = options || {};
            return {
                value: options.value,
                color: options.color,
                alpha: options.alpha,
                family: options.family,
                size: options.size,
                weight: toEnum(options.weight, EShapeTextWeight),
                align: this.toTextAlignOptions(options.align),
                offset: options.offset,
                style: toEnum(options.style, EShapeTextStyle),
                outline: options.outline,
                spacing: options.spacing,
                direction: toEnum(options.direction, EShapeTextDirection),
                padding: options.padding,
                clipping: options.clipping,
                fitting: options.fitting
            };
        };
        DChartAxisGuideSimpleShapeImpl.prototype.toTextAlignOptions = function (options) {
            options = options || {};
            return {
                horizontal: toEnum(options === null || options === void 0 ? void 0 : options.horizontal, EShapeTextAlignHorizontal),
                vertical: toEnum(options === null || options === void 0 ? void 0 : options.vertical, EShapeTextAlignVertical)
            };
        };
        DChartAxisGuideSimpleShapeImpl.prototype.toBarPosition = function (axis) {
            switch (axis.position) {
                case DChartAxisPosition.LEFT:
                case DChartAxisPosition.RIGHT:
                    return EShapeBarPosition.LEFT;
                default:
                    return EShapeBarPosition.TOP;
            }
        };
        Object.defineProperty(DChartAxisGuideSimpleShapeImpl.prototype, "label", {
            get: function () {
                var result = this._label;
                if (result === undefined) {
                    result = this.newLabel();
                    this._label = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DChartAxisGuideSimpleShapeImpl.prototype.newLabel = function () {
            var _a, _b, _c, _d;
            var label = (_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.label) !== null && _b !== void 0 ? _b : {};
            if (label.enable === true) {
                var result = new EShapeRectangleRounded();
                result.stroke.copy(this.toStrokeOptions(label.stroke));
                result.fill.copy(label.fill);
                result.text.copy(this.toTextOptions(label.text));
                result.size.set((_c = label.width) !== null && _c !== void 0 ? _c : 50, (_d = label.height) !== null && _d !== void 0 ? _d : 30);
                return result;
            }
            return null;
        };
        Object.defineProperty(DChartAxisGuideSimpleShapeImpl.prototype, "labelMargin", {
            get: function () {
                var result = this._labelMargin;
                if (result == null) {
                    result = this.newLabelMargin();
                    this._labelMargin = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DChartAxisGuideSimpleShapeImpl.prototype.newLabelMargin = function () {
            var options = this._options;
            if (options != null) {
                var label = options.label;
                if (label != null) {
                    var result = label.margin;
                    if (result != null) {
                        return result;
                    }
                }
            }
            return 10;
        };
        Object.defineProperty(DChartAxisGuideSimpleShapeImpl.prototype, "tick", {
            get: function () {
                var result = this._tick;
                if (result === undefined) {
                    result = this.newTick();
                    this._tick = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DChartAxisGuideSimpleShapeImpl.prototype.newTick = function () {
            var _a, _b, _c;
            var tick = (_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.tick) !== null && _b !== void 0 ? _b : {};
            if (tick.enable === true) {
                var result = new EShapeBar();
                result.stroke.copy(this.toStrokeOptions(tick.stroke));
                result.text.copy(this.toTextOptions(tick.text));
                var size = (_c = tick.size) !== null && _c !== void 0 ? _c : 5;
                result.size.set(size, size);
                return result;
            }
            return null;
        };
        Object.defineProperty(DChartAxisGuideSimpleShapeImpl.prototype, "tickMargin", {
            get: function () {
                var result = this._tickMargin;
                if (result == null) {
                    result = this.newTickMargin();
                    this._tickMargin = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DChartAxisGuideSimpleShapeImpl.prototype.newTickMargin = function () {
            var options = this._options;
            if (options != null) {
                var tick = options.tick;
                if (tick != null) {
                    var result = tick.margin;
                    if (result != null) {
                        return result;
                    }
                }
            }
            return 0;
        };
        DChartAxisGuideSimpleShapeImpl.prototype.toTickPosition = function (axis) {
            switch (axis.position) {
                case DChartAxisPosition.LEFT:
                case DChartAxisPosition.RIGHT:
                    return EShapeBarPosition.LEFT;
                default:
                    return EShapeBarPosition.TOP;
            }
        };
        DChartAxisGuideSimpleShapeImpl.prototype.bind = function (container, index, axis) {
            var bar = this.bar;
            if (bar != null) {
                bar.points.position = this.toBarPosition(axis);
                bar.attach(container.container);
            }
            var label = this.label;
            if (label != null) {
                label.attach(container.container);
            }
            var tick = this.tick;
            if (tick != null) {
                tick.points.position = this.toTickPosition(axis);
                tick.attach(container.container);
            }
        };
        DChartAxisGuideSimpleShapeImpl.prototype.unbind = function () {
            var bar = this._bar;
            if (bar != null) {
                bar.detach();
            }
            var label = this._label;
            if (label != null) {
                label.detach();
            }
            var tick = this._tick;
            if (tick != null) {
                tick.detach();
            }
        };
        DChartAxisGuideSimpleShapeImpl.prototype.update = function (position, x, y, visible, width, height, offset) {
            var bar = this._bar;
            if (bar != null) {
                bar.lock(EShapeLockPart.UPLOADED);
                switch (position) {
                    case DChartAxisPosition.TOP:
                        bar.transform.position.set(x, y);
                        bar.size.set(0, height);
                        bar.visible = visible;
                        break;
                    case DChartAxisPosition.BOTTOM:
                        bar.transform.position.set(x, y);
                        bar.size.set(0, height);
                        bar.visible = visible;
                        break;
                    case DChartAxisPosition.LEFT:
                        bar.transform.position.set(x, y);
                        bar.size.set(width, 0);
                        bar.visible = visible;
                        break;
                    case DChartAxisPosition.RIGHT:
                        bar.transform.position.set(x, y);
                        bar.size.set(width, 0);
                        bar.visible = visible;
                        break;
                }
                bar.unlock(EShapeLockPart.UPLOADED, true);
            }
            var label = this._label;
            if (label != null) {
                var m = this.labelMargin;
                var s = label.size;
                var ox = offset + s.x * 0.5 + m;
                var oy = offset + s.y * 0.5 + m;
                label.lock(EShapeLockPart.UPLOADED);
                switch (position) {
                    case DChartAxisPosition.TOP:
                        label.transform.position.set(x, -oy);
                        label.visible = visible;
                        break;
                    case DChartAxisPosition.BOTTOM:
                        label.transform.position.set(x, height + oy);
                        label.visible = visible;
                        break;
                    case DChartAxisPosition.LEFT:
                        label.transform.position.set(-ox, y);
                        label.visible = visible;
                        break;
                    case DChartAxisPosition.RIGHT:
                        label.transform.position.set(width + ox, y);
                        label.visible = visible;
                        break;
                }
                label.unlock(EShapeLockPart.UPLOADED, true);
            }
            var tick = this._tick;
            if (tick != null) {
                var m = this.tickMargin;
                var s = tick.size;
                var ox = offset + s.x * 0.5 + m;
                var oy = offset + s.y * 0.5 + m;
                tick.lock(EShapeLockPart.UPLOADED);
                switch (position) {
                    case DChartAxisPosition.TOP:
                        tick.transform.position.set(x, -oy);
                        tick.visible = visible;
                        break;
                    case DChartAxisPosition.BOTTOM:
                        tick.transform.position.set(x, height + oy);
                        tick.visible = visible;
                        break;
                    case DChartAxisPosition.LEFT:
                        tick.transform.position.set(-ox, y);
                        tick.visible = visible;
                        break;
                    case DChartAxisPosition.RIGHT:
                        tick.transform.position.set(width + ox, y);
                        tick.visible = visible;
                        break;
                }
                tick.unlock(EShapeLockPart.UPLOADED, true);
            }
            return true;
        };
        DChartAxisGuideSimpleShapeImpl.prototype.destroy = function () {
            var bar = this._bar;
            if (bar != null) {
                bar.destroy();
            }
            var label = this._label;
            if (label != null) {
                label.destroy();
            }
            var tick = this._tick;
            if (tick != null) {
                tick.destroy();
            }
        };
        return DChartAxisGuideSimpleShapeImpl;
    }());

    var DChartAxisGuideSimple = /** @class */ (function () {
        function DChartAxisGuideSimple(options) {
            var _a, _b;
            this._options = options;
            this._index = 0;
            if (options != null) {
                this._position = (_a = options.position) !== null && _a !== void 0 ? _a : 0;
                this._fixed = (_b = options.fixed) !== null && _b !== void 0 ? _b : false;
            }
            else {
                this._position = 0;
                this._fixed = false;
            }
            this._isShown = true;
        }
        Object.defineProperty(DChartAxisGuideSimple.prototype, "shape", {
            get: function () {
                var result = this._shape;
                if (result == null) {
                    result = this.newShape();
                    this._shape = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DChartAxisGuideSimple.prototype.newShape = function () {
            return new DChartAxisGuideSimpleShapeImpl(this._options);
        };
        Object.defineProperty(DChartAxisGuideSimple.prototype, "position", {
            get: function () {
                return this._position;
            },
            set: function (position) {
                this._position = position;
            },
            enumerable: false,
            configurable: true
        });
        DChartAxisGuideSimple.prototype.show = function () {
            this._isShown = true;
            return this;
        };
        DChartAxisGuideSimple.prototype.isShown = function () {
            return this._isShown;
        };
        DChartAxisGuideSimple.prototype.hide = function () {
            this._isShown = false;
            return this;
        };
        DChartAxisGuideSimple.prototype.isHidden = function () {
            return !this._isShown;
        };
        DChartAxisGuideSimple.prototype.bind = function (container, index, axis) {
            this._container = container;
            this._index = index;
            this._axis = axis;
            this.shape.bind(container, index, axis);
        };
        DChartAxisGuideSimple.prototype.unbind = function () {
            var shape = this._shape;
            if (shape != null) {
                shape.unbind();
            }
            this._axis = undefined;
            this._index = 0;
            this._container = undefined;
        };
        DChartAxisGuideSimple.prototype.update = function () {
            var container = this._container;
            var index = this._index;
            var shape = this._shape;
            var axis = this._axis;
            if (shape != null && container != null && axis != null) {
                var plotArea = container.plotArea;
                var plotAreaBounds = plotArea.getAxisBounds(axis.position);
                var plotAreaX = plotAreaBounds.x;
                var plotAreaY = plotAreaBounds.y;
                var plotAreaWidth = plotAreaBounds.width;
                var plotAreaHeight = plotAreaBounds.height;
                var offset = axis.padding * index;
                switch (axis.position) {
                    case DChartAxisPosition.TOP:
                    case DChartAxisPosition.BOTTOM:
                        var x = this.getPositionX(axis, plotArea, plotAreaX);
                        shape.update(axis.position, x, plotAreaY + plotAreaHeight * 0.5, this._isShown && plotAreaX <= x && x <= plotAreaX + plotAreaWidth, plotAreaWidth, plotAreaHeight, offset);
                        break;
                    case DChartAxisPosition.LEFT:
                    case DChartAxisPosition.RIGHT:
                        var y = this.getPositionY(axis, plotArea, plotAreaY);
                        shape.update(axis.position, plotAreaX + plotAreaWidth * 0.5, y, this._isShown && plotAreaY <= y && y <= plotAreaY + plotAreaHeight, plotAreaWidth, plotAreaHeight, offset);
                        break;
                }
                return true;
            }
            return false;
        };
        DChartAxisGuideSimple.prototype.getPositionX = function (axis, plotArea, plotAreaX) {
            var _a, _b;
            if (this._fixed) {
                var work = ((_a = DChartAxisGuideSimple.WORK_REGION) !== null && _a !== void 0 ? _a : (DChartAxisGuideSimple.WORK_REGION = new DChartRegionImpl(0, 0)));
                plotArea.getPixelDomain(work);
                return work.from + this._position * (work.to - work.from);
            }
            else {
                var coordinateX = plotArea.coordinate.x.get(axis.coordinate);
                if (coordinateX) {
                    var work = ((_b = DChartAxisGuideSimple.WORK_POINT) !== null && _b !== void 0 ? _b : (DChartAxisGuideSimple.WORK_POINT = new pixi_js.Point()));
                    work.set(coordinateX.transform.map(coordinateX.map(this._position)), 0);
                    plotArea.container.transform.localTransform.apply(work, work);
                    return work.x;
                }
                else {
                    return plotAreaX - 100;
                }
            }
        };
        DChartAxisGuideSimple.prototype.getPositionY = function (axis, plotArea, plotAreaY) {
            var _a, _b;
            if (this._fixed) {
                var work = ((_a = DChartAxisGuideSimple.WORK_REGION) !== null && _a !== void 0 ? _a : (DChartAxisGuideSimple.WORK_REGION = new DChartRegionImpl(0, 0)));
                plotArea.getPixelRange(work);
                return work.to + (1 - this._position) * (work.from - work.to);
            }
            else {
                var coordinateY = plotArea.coordinate.y.get(axis.coordinate);
                if (coordinateY) {
                    var work = ((_b = DChartAxisGuideSimple.WORK_POINT) !== null && _b !== void 0 ? _b : (DChartAxisGuideSimple.WORK_POINT = new pixi_js.Point()));
                    work.set(0, coordinateY.transform.map(coordinateY.map(this._position)));
                    plotArea.container.transform.localTransform.apply(work, work);
                    return work.y;
                }
                else {
                    return plotAreaY - 100;
                }
            }
        };
        DChartAxisGuideSimple.prototype.destroy = function () {
            var shape = this._shape;
            if (shape != null) {
                shape.destroy();
            }
            this._index = 0;
            this._container = undefined;
        };
        return DChartAxisGuideSimple;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * An X axis.
     */
    var DChartAxisX = /** @class */ (function (_super) {
        __extends(DChartAxisX, _super);
        function DChartAxisX() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DChartAxisX.prototype.getType = function () {
            return "DChartAxisX";
        };
        return DChartAxisX;
    }(DChartAxisBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * An X axis for datetimes.
     */
    var DChartAxisXDatetime = /** @class */ (function (_super) {
        __extends(DChartAxisXDatetime, _super);
        function DChartAxisXDatetime() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DChartAxisXDatetime.prototype.getType = function () {
            return "DChartAxisXDatetime";
        };
        return DChartAxisXDatetime;
    }(DChartAxisX));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * An Y axis.
     */
    var DChartAxisY = /** @class */ (function (_super) {
        __extends(DChartAxisY, _super);
        function DChartAxisY() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DChartAxisY.prototype.getType = function () {
            return "DChartAxisY";
        };
        return DChartAxisY;
    }(DChartAxisBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DCHART_COLOR_SET_1 = [0x10b7e3, 0xfe5420, 0xf0c312, 0x1c5d71];
    var DCHART_COLOR_SET_2 = [
        DCHART_COLOR_SET_1[0],
        UtilRgb.brighten(DCHART_COLOR_SET_1[0], 0.4),
        DCHART_COLOR_SET_1[1],
        UtilRgb.brighten(DCHART_COLOR_SET_1[1], 0.4),
        DCHART_COLOR_SET_1[2],
        UtilRgb.brighten(DCHART_COLOR_SET_1[2], 0.4),
        DCHART_COLOR_SET_1[3],
        UtilRgb.brighten(DCHART_COLOR_SET_1[3], 0.4)
    ];
    var DChartColorSet1 = function (index) {
        return DCHART_COLOR_SET_1[index % DCHART_COLOR_SET_1.length];
    };
    var DChartColorSet2 = function (index) {
        return DCHART_COLOR_SET_2[index % DCHART_COLOR_SET_2.length];
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartCoordinateDirection = {
        X: 0,
        Y: 1
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartCoordinateTransformImpl = /** @class */ (function () {
        function DChartCoordinateTransformImpl(options) {
            this._theme = this.toTheme(options);
            this._id = 0;
            this._isTranslationEnabled = options === null || options === void 0 ? void 0 : options.translation;
            this._translate = 0;
            this._isScalingEnabled = options === null || options === void 0 ? void 0 : options.scaling;
            this._scale = 1;
            this._itranslate = 0;
            this._iscale = 1;
        }
        Object.defineProperty(DChartCoordinateTransformImpl.prototype, "id", {
            get: function () {
                return this._id;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartCoordinateTransformImpl.prototype, "translate", {
            get: function () {
                return this._translate;
            },
            set: function (translate) {
                this.set(translate);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartCoordinateTransformImpl.prototype, "scale", {
            get: function () {
                return this._scale;
            },
            set: function (scale) {
                this.set(undefined, scale);
            },
            enumerable: false,
            configurable: true
        });
        DChartCoordinateTransformImpl.prototype.bind = function (container, direction) {
            this.set(0, direction === DChartCoordinateDirection.X ? +1 : -1);
        };
        DChartCoordinateTransformImpl.prototype.unbind = function () {
            // DO NOTHING
        };
        DChartCoordinateTransformImpl.prototype.set = function (translate, scale) {
            var isChanged = false;
            if (translate != null &&
                this._isTranslationEnabled !== false &&
                this._translate !== translate) {
                isChanged = true;
                this._translate = translate;
            }
            if (scale != null && this._isScalingEnabled !== false && this._scale !== scale) {
                isChanged = true;
                this._scale = scale;
            }
            if (isChanged) {
                this._id += 1;
                this._iscale = this._theme.isZero(this._scale) ? 0 : 1 / this._scale;
                this._itranslate = -this._translate * this._iscale;
            }
        };
        DChartCoordinateTransformImpl.prototype.blend = function (ratio, mark) {
            var ratioi = 1 - ratio;
            var newTranslate = mark.newTranslate * ratio + mark.oldTranslate * ratioi;
            var newScale = mark.newScale * ratio + mark.oldScale * ratioi;
            this.set(newTranslate, newScale);
        };
        DChartCoordinateTransformImpl.prototype.map = function (value) {
            return this._translate + this._scale * value;
        };
        DChartCoordinateTransformImpl.prototype.mapAll = function (values, ifrom, iend, stride, offset) {
            var translate = this._translate;
            var scale = this._scale;
            for (var i = ifrom + offset; i < iend; i += stride) {
                values[i] = translate + scale * values[i];
            }
        };
        DChartCoordinateTransformImpl.prototype.unmap = function (value) {
            return this._itranslate + this._iscale * value;
        };
        DChartCoordinateTransformImpl.prototype.unmapAll = function (values, ifrom, iend, stride, offset) {
            var itranslate = this._itranslate;
            var iscale = this._iscale;
            for (var i = ifrom + offset; i < iend; i += stride) {
                values[i] = itranslate + iscale * values[i];
            }
        };
        DChartCoordinateTransformImpl.prototype.toTheme = function (options) {
            return (options && options.theme) || this.getThemeDefault();
        };
        DChartCoordinateTransformImpl.prototype.getThemeDefault = function () {
            return DThemes.getInstance().get(this.getType());
        };
        DChartCoordinateTransformImpl.prototype.getType = function () {
            return "DChartCoordinateTransform";
        };
        return DChartCoordinateTransformImpl;
    }());

    var DChartCoordinateTransformMarkImpl = /** @class */ (function () {
        function DChartCoordinateTransformMarkImpl() {
            this.oldTranslate = 0;
            this.oldScale = 1;
            this.newTranslate = 0;
            this.newScale = 1;
        }
        DChartCoordinateTransformMarkImpl.prototype.set = function (translate, scale) {
            if (translate != null) {
                this.newTranslate = translate;
            }
            if (scale != null) {
                this.newScale = scale;
            }
        };
        return DChartCoordinateTransformMarkImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartCoordinateBase = /** @class */ (function () {
        function DChartCoordinateBase(options) {
            this._id = 0;
            this._direction = DChartCoordinateDirection.X;
            this._theme = this.toTheme(options);
            this._transform = this.newTransform(options === null || options === void 0 ? void 0 : options.transform);
            this._tick = this.newTick(options === null || options === void 0 ? void 0 : options.tick);
            this._work = this.newRegion();
            this._mark = this.newMark();
            this._from = options === null || options === void 0 ? void 0 : options.from;
            this._to = options === null || options === void 0 ? void 0 : options.to;
        }
        DChartCoordinateBase.prototype.newTransform = function (options) {
            return new DChartCoordinateTransformImpl(options);
        };
        DChartCoordinateBase.prototype.newRegion = function () {
            return new DChartRegionImpl(NaN, NaN);
        };
        DChartCoordinateBase.prototype.newMark = function () {
            return new DChartCoordinateTransformMarkImpl();
        };
        Object.defineProperty(DChartCoordinateBase.prototype, "from", {
            get: function () {
                return this._from;
            },
            set: function (from) {
                this._from = from;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartCoordinateBase.prototype, "to", {
            get: function () {
                return this._to;
            },
            set: function (to) {
                this._to = to;
            },
            enumerable: false,
            configurable: true
        });
        DChartCoordinateBase.prototype.bind = function (container, direction) {
            this._container = container;
            this._direction = direction;
            this._transform.bind(container, direction);
        };
        DChartCoordinateBase.prototype.unbind = function () {
            this._container = undefined;
            this._transform.unbind();
        };
        DChartCoordinateBase.prototype.fit = function (from, to) {
            this.doFit(from, to, this._transform);
        };
        DChartCoordinateBase.prototype.mark = function (from, to) {
            var mark = this._mark;
            var transform = this._transform;
            mark.oldTranslate = transform.translate;
            mark.oldScale = transform.scale;
            this.doFit(from, to, mark);
        };
        DChartCoordinateBase.prototype.blend = function (ratio) {
            this._transform.blend(ratio, this._mark);
        };
        DChartCoordinateBase.prototype.doFit = function (from, to, result) {
            var container = this._container;
            if (container) {
                var plotArea = container.container.plotArea;
                var work = this._work;
                switch (this._direction) {
                    case DChartCoordinateDirection.X:
                        this.getPixelDomain(plotArea, work);
                        this.doFit_(work.from, work.to, this.toFitDomain(from, to, plotArea, work), result);
                        break;
                    case DChartCoordinateDirection.Y:
                        this.getPixelRange(plotArea, work);
                        this.doFit_(work.from, work.to, this.toFitRange(from, to, plotArea, work), result);
                        break;
                }
            }
        };
        DChartCoordinateBase.prototype.getPixelDomain = function (plotArea, result) {
            return plotArea.getPixelDomain(result);
        };
        DChartCoordinateBase.prototype.getPixelRange = function (plotArea, result) {
            return plotArea.getPixelRange(result);
        };
        DChartCoordinateBase.prototype.toFitDomain = function (from, to, plotArea, result) {
            if (from == null) {
                from = this._from;
            }
            if (to == null) {
                to = this._to;
            }
            if (from != null && to != null) {
                result.set(from, to);
            }
            else {
                plotArea.series.getDomain(this, result);
                result.set(from, to);
            }
            return result;
        };
        DChartCoordinateBase.prototype.toFitRange = function (from, to, plotArea, result) {
            if (from == null) {
                from = this._from;
            }
            if (to == null) {
                to = this._to;
            }
            if (from != null && to != null) {
                result.set(from, to);
            }
            else {
                plotArea.series.getRange(this, result);
                result.set(from, to);
            }
            return result;
        };
        DChartCoordinateBase.prototype.doFit_ = function (pixelFrom, pixelTo, region, result) {
            var regionFrom = region.from;
            var regionTo = region.to;
            if (!(isNaN$1(regionFrom) || isNaN$1(regionTo))) {
                // Scale
                var newScale = 1;
                var regionFromMapped = this.map(regionFrom);
                var regionToMapped = this.map(regionTo);
                var regionSizeMapped = regionToMapped - regionFromMapped;
                if (!this._theme.isZero(regionSizeMapped)) {
                    var pixelSize = pixelTo - pixelFrom;
                    newScale = pixelSize / regionSizeMapped;
                }
                else {
                    newScale = pixelTo < pixelFrom ? -1 : 1;
                }
                // Translation
                var newTranslation = pixelFrom - regionFromMapped * newScale;
                // Done
                result.set(newTranslation, newScale);
            }
        };
        Object.defineProperty(DChartCoordinateBase.prototype, "id", {
            get: function () {
                return this._id;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartCoordinateBase.prototype, "transform", {
            get: function () {
                return this._transform;
            },
            enumerable: false,
            configurable: true
        });
        DChartCoordinateBase.prototype.map = function (value) {
            return value;
        };
        DChartCoordinateBase.prototype.mapAll = function (values, ifrom, iend, stride, offset) {
            // DO NOTHING
        };
        DChartCoordinateBase.prototype.unmap = function (value) {
            return value;
        };
        DChartCoordinateBase.prototype.unmapAll = function (values, ifrom, iend, stride, offset) {
            // DO NOTHING
        };
        DChartCoordinateBase.prototype.ticks = function (domainFrom, domainTo, domainVisibleFrom, domainVisibleTo, majorCount, majorCapacity, majorStep, minorCountPerMajor, minorCount, minorStep, majorResult, minorResult) {
            this._tick.calculate(domainFrom, domainTo, domainVisibleFrom, domainVisibleTo, majorCount, majorCapacity, majorStep, minorCountPerMajor, minorCount, minorStep, majorResult, minorResult, this);
        };
        DChartCoordinateBase.prototype.toTheme = function (options) {
            var _a;
            return (_a = options === null || options === void 0 ? void 0 : options.theme) !== null && _a !== void 0 ? _a : this.getThemeDefault();
        };
        DChartCoordinateBase.prototype.getThemeDefault = function () {
            return DThemes.getInstance().get(this.getType());
        };
        DChartCoordinateBase.prototype.getType = function () {
            return "DChartCoordinate";
        };
        return DChartCoordinateBase;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartCoordinateContainerSubImpl = /** @class */ (function () {
        function DChartCoordinateContainerSubImpl(container, direction) {
            this._container = container;
            this._direction = direction;
            this._list = [];
        }
        Object.defineProperty(DChartCoordinateContainerSubImpl.prototype, "container", {
            get: function () {
                return this._container;
            },
            enumerable: false,
            configurable: true
        });
        DChartCoordinateContainerSubImpl.prototype.add = function (coordinate, index) {
            var list = this._list;
            if (index == null) {
                list.push(coordinate);
            }
            else if (0 <= index && index < list.length) {
                list.splice(index, 0, coordinate);
            }
            else {
                list.push(coordinate);
            }
            coordinate.bind(this, this._direction);
            return this;
        };
        DChartCoordinateContainerSubImpl.prototype.get = function (index) {
            var list = this._list;
            if (0 <= index && index < list.length) {
                return list[index];
            }
            return null;
        };
        DChartCoordinateContainerSubImpl.prototype.indexOf = function (coordinate) {
            return this._list.indexOf(coordinate);
        };
        DChartCoordinateContainerSubImpl.prototype.remove = function (coordinateOrIndex) {
            var list = this._list;
            if (isNumber(coordinateOrIndex)) {
                var index = coordinateOrIndex;
                if (0 <= index && index < list.length) {
                    var removed = list.splice(index, 1)[0];
                    removed.unbind();
                    return removed;
                }
            }
            else {
                var coordinate = coordinateOrIndex;
                var index = list.indexOf(coordinate);
                if (0 <= index) {
                    list.splice(index, 1);
                    coordinate.unbind();
                    return coordinate;
                }
            }
            return null;
        };
        DChartCoordinateContainerSubImpl.prototype.clear = function () {
            var list = this._list;
            for (var i = 0, imax = list.length; i < imax; ++i) {
                list[i].unbind();
            }
            list.length = 0;
            return this;
        };
        DChartCoordinateContainerSubImpl.prototype.destroy = function () {
            return this.clear();
        };
        DChartCoordinateContainerSubImpl.prototype.size = function () {
            return this._list.length;
        };
        DChartCoordinateContainerSubImpl.prototype.fit = function (from, to) {
            var list = this._list;
            for (var i = 0, imax = list.length; i < imax; ++i) {
                list[i].fit(from, to);
            }
            return this;
        };
        DChartCoordinateContainerSubImpl.prototype.mark = function (from, to) {
            var list = this._list;
            for (var i = 0, imax = list.length; i < imax; ++i) {
                list[i].mark(from, to);
            }
            return this;
        };
        DChartCoordinateContainerSubImpl.prototype.blend = function (ratio) {
            var list = this._list;
            for (var i = 0, imax = list.length; i < imax; ++i) {
                list[i].blend(ratio);
            }
            return this;
        };
        return DChartCoordinateContainerSubImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartCoordinateContainerImpl = /** @class */ (function () {
        function DChartCoordinateContainerImpl(plotArea, options) {
            this._plotArea = plotArea;
            var x = new DChartCoordinateContainerSubImpl(this, DChartCoordinateDirection.X);
            this._x = x;
            var y = new DChartCoordinateContainerSubImpl(this, DChartCoordinateDirection.Y);
            this._y = y;
            if (options) {
                var cxs = options.x;
                if (cxs) {
                    if (isArray(cxs)) {
                        for (var i = 0, imax = cxs.length; i < imax; ++i) {
                            x.add(cxs[i]);
                        }
                    }
                    else {
                        x.add(cxs);
                    }
                }
                var cys = options.y;
                if (cys) {
                    if (isArray(cys)) {
                        for (var i = 0, imax = cys.length; i < imax; ++i) {
                            y.add(cys[i]);
                        }
                    }
                    else {
                        y.add(cys);
                    }
                }
            }
        }
        Object.defineProperty(DChartCoordinateContainerImpl.prototype, "x", {
            get: function () {
                return this._x;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartCoordinateContainerImpl.prototype, "y", {
            get: function () {
                return this._y;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartCoordinateContainerImpl.prototype, "plotArea", {
            get: function () {
                return this._plotArea;
            },
            enumerable: false,
            configurable: true
        });
        DChartCoordinateContainerImpl.prototype.fit = function (domainFrom, domainTo, rangeFrom, rangeTo) {
            this._x.fit(domainFrom, domainTo);
            this._y.fit(rangeFrom, rangeTo);
            return this;
        };
        DChartCoordinateContainerImpl.prototype.mark = function (domainFrom, domainTo, rangeFrom, rangeTo) {
            this._x.mark(domainFrom, domainTo);
            this._y.mark(rangeFrom, rangeTo);
            return this;
        };
        DChartCoordinateContainerImpl.prototype.blend = function (ratio) {
            this._x.blend(ratio);
            this._y.blend(ratio);
            return this;
        };
        return DChartCoordinateContainerImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartCoordinateLinearTick = /** @class */ (function () {
        function DChartCoordinateLinearTick(options) {
            this._theme = this.toTheme(options);
        }
        DChartCoordinateLinearTick.prototype.toMajorStep = function (domainMin, domainMax, majorCount, majorStep) {
            if (majorStep == null) {
                if (0 < majorCount) {
                    return this._theme.toStep(domainMin, domainMax, majorCount);
                }
                return -1;
            }
            else if (isNumber(majorStep)) {
                return majorStep;
            }
            else {
                return majorStep(domainMin, domainMax, majorCount);
            }
        };
        DChartCoordinateLinearTick.prototype.toMinorStep = function (majorStep, minorCount, minorStep) {
            if (minorStep == null) {
                if (0 <= majorStep) {
                    return this.calcStepMinor(majorStep, minorCount);
                }
                return -1;
            }
            else if (isNumber(minorStep)) {
                return minorStep;
            }
            else {
                return minorStep(majorStep, minorCount);
            }
        };
        DChartCoordinateLinearTick.prototype.calcStepMinor = function (majorStep, minorCount) {
            return majorStep / (minorCount + 1);
        };
        DChartCoordinateLinearTick.prototype.calcTickMinorPositions = function (step, count, majorPosition, rangeMin, rangeMax, iresult, result) {
            for (var i = 0; i < count; i += 1) {
                var minorPosition = majorPosition + (i + 1) * step;
                if (rangeMin <= minorPosition && minorPosition <= rangeMax) {
                    result[iresult++] = minorPosition;
                }
            }
        };
        DChartCoordinateLinearTick.prototype.calculate = function (domainFrom, domainTo, domainVisibleFrom, domainVisibleTo, majorCount, majorCapacity, majorStep, minorCountPerMajor, minorCount, minorStep, majorResult, minorResult, coordinate) {
            if (majorCount <= 0) {
                return;
            }
            var transform = coordinate.transform;
            var domainMin = Math.min(domainFrom, domainTo);
            var domainMax = Math.max(domainFrom, domainTo);
            var domainVisibleMin = Math.min(domainVisibleFrom, domainVisibleTo);
            var domainVisibleMax = Math.max(domainVisibleFrom, domainVisibleTo);
            var domainVisibleMinMapped = coordinate.map(domainVisibleMin);
            var domainVisibleMaxMapped = coordinate.map(domainVisibleMax);
            var from0 = Math.min(domainVisibleMinMapped, domainVisibleMaxMapped);
            var to0 = Math.max(domainVisibleMinMapped, domainVisibleMaxMapped);
            var domainMinMapped = coordinate.map(domainMin);
            var domainMaxMapped = coordinate.map(domainMax);
            var from1 = Math.min(domainMinMapped, domainMaxMapped);
            var to1 = Math.max(domainMinMapped, domainMaxMapped);
            var from = Math.max(from0, from1);
            var to = Math.min(to0, to1);
            var imajor = 0;
            var iminor = 0;
            var majorStepMapped = this.toMajorStep(domainMinMapped, domainMaxMapped, majorCount, majorStep);
            if (majorStepMapped <= 0) {
                if (from <= domainMinMapped && domainMinMapped <= to) {
                    majorResult[0] = domainMin;
                    majorResult[1] = transform.map(domainMinMapped);
                    majorResult[2] = 0;
                    imajor += 1;
                }
            }
            else {
                // Major tick start position
                var idomainStartMapped = Math.floor(domainMinMapped / majorStepMapped) - 1;
                var idomainEndMapped = Math.ceil(domainMaxMapped / majorStepMapped) + 1;
                // Major / minor tick positions
                var minorStepMapped = this.toMinorStep(majorStepMapped, minorCountPerMajor, minorStep);
                for (var i = idomainStartMapped; i <= idomainEndMapped; ++i) {
                    var majorPositionMapped = i * majorStepMapped;
                    if (imajor < majorCapacity) {
                        if (from <= majorPositionMapped && majorPositionMapped <= to) {
                            var imajorResult = imajor * 3;
                            majorResult[imajorResult + 0] = coordinate.unmap(majorPositionMapped);
                            majorResult[imajorResult + 1] = transform.map(majorPositionMapped);
                            majorResult[imajorResult + 2] = majorStepMapped;
                            imajor += 1;
                        }
                    }
                    for (var j = 0; j < minorCountPerMajor; j += 1) {
                        if (iminor < minorCount) {
                            var minorPositionMapped = majorPositionMapped + (j + 1) * minorStepMapped;
                            if (from <= minorPositionMapped && minorPositionMapped <= to) {
                                var iminorResult = iminor * 3;
                                minorResult[iminorResult + 0] = coordinate.unmap(minorPositionMapped);
                                minorResult[iminorResult + 1] = transform.map(minorPositionMapped);
                                minorResult[iminorResult + 2] = minorStepMapped;
                                iminor += 1;
                            }
                        }
                    }
                }
            }
            for (var i = imajor; i < majorCapacity; ++i) {
                var imajorResult = i * 3;
                majorResult[imajorResult + 0] = NaN;
                majorResult[imajorResult + 1] = NaN;
                majorResult[imajorResult + 2] = NaN;
            }
            for (var i = iminor; i < minorCount; ++i) {
                var iminorResult = i * 3;
                minorResult[iminorResult + 0] = NaN;
                minorResult[iminorResult + 1] = NaN;
                minorResult[iminorResult + 2] = NaN;
            }
        };
        DChartCoordinateLinearTick.prototype.toTheme = function (options) {
            var _a;
            return (_a = options === null || options === void 0 ? void 0 : options.theme) !== null && _a !== void 0 ? _a : this.getThemeDefault();
        };
        DChartCoordinateLinearTick.prototype.getThemeDefault = function () {
            return DThemes.getInstance().get(this.getType());
        };
        DChartCoordinateLinearTick.prototype.getType = function () {
            return "DChartCoordinateTick";
        };
        return DChartCoordinateLinearTick;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartCoordinateLinear = /** @class */ (function (_super) {
        __extends(DChartCoordinateLinear, _super);
        function DChartCoordinateLinear() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DChartCoordinateLinear.prototype.newTick = function (options) {
            return new DChartCoordinateLinearTick(options);
        };
        return DChartCoordinateLinear;
    }(DChartCoordinateBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartCoordinateLogTick = /** @class */ (function () {
        function DChartCoordinateLogTick(options) {
            this._theme = this.toTheme(options);
        }
        DChartCoordinateLogTick.prototype.toMajorStep = function (domainMin, domainMax, majorCount, majorStep) {
            if (majorStep == null) {
                if (0 < majorCount) {
                    return this._theme.toStep(domainMin, domainMax, majorCount);
                }
                return -1;
            }
            else if (isNumber(majorStep)) {
                return majorStep;
            }
            else {
                return majorStep(domainMin, domainMax, majorCount);
            }
        };
        DChartCoordinateLogTick.prototype.toMinorStep = function (majorStep, minorCount, minorStep) {
            if (minorStep == null) {
                if (0 <= majorStep) {
                    return this.calcStepMinor(majorStep, minorCount);
                }
                return -1;
            }
            else if (isNumber(minorStep)) {
                return minorStep;
            }
            else {
                return minorStep(majorStep, minorCount);
            }
        };
        DChartCoordinateLogTick.prototype.calcStepMinor = function (majorStep, minorCount) {
            return majorStep / (minorCount + 1);
        };
        DChartCoordinateLogTick.prototype.calcTickMinorPositions = function (step, count, majorPosition, rangeMin, rangeMax, iresult, result) {
            for (var i = 0; i < count; i += 1) {
                var minorPosition = majorPosition + (i + 1) * step;
                if (rangeMin <= minorPosition && minorPosition <= rangeMax) {
                    result[iresult++] = minorPosition;
                }
            }
        };
        DChartCoordinateLogTick.prototype.calculate = function (domainFrom, domainTo, domainVisibleFrom, domainVisibleTo, majorCount, majorCapacity, majorStep, minorCountPerMajor, minorCount, minorStep, majorResult, minorResult, coordinate) {
            if (majorCount <= 0) {
                return;
            }
            var transform = coordinate.transform;
            var domainMin = Math.min(domainFrom, domainTo);
            var domainMax = Math.max(domainFrom, domainTo);
            var domainVisibleMin = Math.min(domainVisibleFrom, domainVisibleTo);
            var domainVisibleMax = Math.max(domainVisibleFrom, domainVisibleTo);
            var domainVisibleMinMapped = coordinate.map(domainVisibleMin);
            var domainVisibleMaxMapped = coordinate.map(domainVisibleMax);
            var from0 = Math.min(domainVisibleMinMapped, domainVisibleMaxMapped);
            var to0 = Math.max(domainVisibleMinMapped, domainVisibleMaxMapped);
            var domainMinMapped = coordinate.map(domainMin);
            var domainMaxMapped = coordinate.map(domainMax);
            var from1 = Math.min(domainMinMapped, domainMaxMapped);
            var to1 = Math.max(domainMinMapped, domainMaxMapped);
            var from = Math.max(from0, from1);
            var to = Math.min(to0, to1);
            var imajor = 0;
            var iminor = 0;
            var majorStepMapped = this.toMajorStep(domainMinMapped, domainMaxMapped, majorCount, majorStep);
            if (majorStepMapped <= 0) {
                if (from <= domainMinMapped && domainMinMapped <= to) {
                    majorResult[0] = domainMin;
                    majorResult[1] = transform.map(domainMinMapped);
                    majorResult[2] = 0;
                    imajor += 1;
                }
            }
            else {
                // Major tick start position
                var idomainStartMapped = Math.floor(domainMinMapped / majorStepMapped) - 1;
                var idomainEndMapped = Math.ceil(domainMaxMapped / majorStepMapped) + 1;
                // Major / minor tick positions
                var minorStepMapped = this.toMinorStep(majorStepMapped, minorCountPerMajor, minorStep);
                for (var i = idomainStartMapped; i <= idomainEndMapped; ++i) {
                    var majorPositionMapped = i * majorStepMapped;
                    if (imajor < majorCapacity) {
                        if (from <= majorPositionMapped && majorPositionMapped <= to) {
                            var imajorResult = imajor * 3;
                            majorResult[imajorResult + 0] = coordinate.unmap(majorPositionMapped);
                            majorResult[imajorResult + 1] = transform.map(majorPositionMapped);
                            majorResult[imajorResult + 2] = coordinate.unmap(majorPositionMapped - 1);
                            imajor += 1;
                        }
                    }
                    for (var j = 0; j < minorCountPerMajor; j += 1) {
                        if (iminor < minorCount) {
                            var minorPositionMapped = majorPositionMapped + (j + 1) * minorStepMapped;
                            if (from <= minorPositionMapped && minorPositionMapped <= to) {
                                var iminorResult = iminor * 3;
                                minorResult[iminorResult + 0] = coordinate.unmap(minorPositionMapped);
                                minorResult[iminorResult + 1] = transform.map(minorPositionMapped);
                                minorResult[iminorResult + 2] = coordinate.unmap(minorPositionMapped - 1);
                                iminor += 1;
                            }
                        }
                    }
                }
            }
            for (var i = imajor; i < majorCapacity; ++i) {
                var imajorResult = i * 3;
                majorResult[imajorResult + 0] = NaN;
                majorResult[imajorResult + 1] = NaN;
                majorResult[imajorResult + 2] = NaN;
            }
            for (var i = iminor; i < minorCount; ++i) {
                var iminorResult = i * 3;
                minorResult[iminorResult + 0] = NaN;
                minorResult[iminorResult + 1] = NaN;
                minorResult[iminorResult + 2] = NaN;
            }
        };
        DChartCoordinateLogTick.prototype.toTheme = function (options) {
            var _a;
            return (_a = options === null || options === void 0 ? void 0 : options.theme) !== null && _a !== void 0 ? _a : this.getThemeDefault();
        };
        DChartCoordinateLogTick.prototype.getThemeDefault = function () {
            return DThemes.getInstance().get(this.getType());
        };
        DChartCoordinateLogTick.prototype.getType = function () {
            return "DChartCoordinateTick";
        };
        return DChartCoordinateLogTick;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartCoordinateLog = /** @class */ (function (_super) {
        __extends(DChartCoordinateLog, _super);
        function DChartCoordinateLog() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DChartCoordinateLog.prototype.newTick = function (options) {
            return new DChartCoordinateLogTick(options);
        };
        DChartCoordinateLog.prototype.map = function (value) {
            return Math.log(Math.max(0, value)) / Math.LN10;
        };
        DChartCoordinateLog.prototype.mapAll = function (values, ifrom, iend, stride, offset) {
            var factor = 1 / Math.LN10;
            for (var i = ifrom + offset; i < iend; i += stride) {
                var value = values[i];
                values[i] = Math.log(Math.max(0, value)) * factor;
            }
        };
        DChartCoordinateLog.prototype.unmap = function (value) {
            return Math.pow(10, value);
        };
        DChartCoordinateLog.prototype.unmapAll = function (values, ifrom, iend, stride, offset) {
            for (var i = ifrom + offset; i < iend; i += stride) {
                values[i] = Math.pow(10, values[i]);
            }
        };
        return DChartCoordinateLog;
    }(DChartCoordinateBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartLegendItem = /** @class */ (function (_super) {
        __extends(DChartLegendItem, _super);
        function DChartLegendItem() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DChartLegendItem.prototype.getType = function () {
            return "DChartLegendItem";
        };
        return DChartLegendItem;
    }(DBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartLegend = /** @class */ (function (_super) {
        __extends(DChartLegend, _super);
        function DChartLegend() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DChartLegend.prototype.getType = function () {
            return "DChartLegend";
        };
        return DChartLegend;
    }(DBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartOverview = /** @class */ (function (_super) {
        __extends(DChartOverview, _super);
        function DChartOverview() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DChartOverview.prototype.getType = function () {
            return "DChartOverview";
        };
        return DChartOverview;
    }(DBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartPlotAreaBase = /** @class */ (function (_super) {
        __extends(DChartPlotAreaBase, _super);
        function DChartPlotAreaBase(chart, options) {
            var _this = _super.call(this, options) || this;
            _this._isContainerBoundsDirty = true;
            _this._containerBounds = new pixi_js.Rectangle();
            _this._workPoint = new pixi_js.Point();
            _this._pixelBounds = new pixi_js.Rectangle();
            _this._chart = chart;
            _this._blendStartTime = 0;
            _this._blendDuration = 1000;
            _this._blendTimeout = null;
            _this._onBlendBound = function () {
                _this.onBlend();
            };
            _this._isViewDirty = true;
            _this._view = _this.newView(options);
            return _this;
        }
        DChartPlotAreaBase.prototype.onResize = function (newWidth, newHeight, oldWidth, oldHeight) {
            this._isViewDirty = true;
            this._isContainerBoundsDirty = true;
            _super.prototype.onResize.call(this, newWidth, newHeight, oldWidth, oldHeight);
        };
        Object.defineProperty(DChartPlotAreaBase.prototype, "chart", {
            get: function () {
                return this._chart;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartPlotAreaBase.prototype, "view", {
            get: function () {
                return this._view;
            },
            enumerable: false,
            configurable: true
        });
        DChartPlotAreaBase.prototype.onWheel = function (e, deltas, global) {
            var vresult = this._view.onWheel(e, deltas, global);
            var sresult = _super.prototype.onWheel.call(this, e, deltas, global);
            return vresult || sresult;
        };
        DChartPlotAreaBase.prototype.onDblClick = function (e, interactionManager) {
            var vresult = this._view.onDblClick(e, interactionManager);
            var sresult = _super.prototype.onDblClick.call(this, e, interactionManager);
            return vresult || sresult;
        };
        DChartPlotAreaBase.prototype.onDown = function (e) {
            this._view.onDown(e);
            _super.prototype.onDown.call(this, e);
        };
        DChartPlotAreaBase.prototype.render = function (renderer) {
            if (this._isViewDirty) {
                this._isViewDirty = false;
                this.onViewDirty();
            }
            _super.prototype.render.call(this, renderer);
        };
        DChartPlotAreaBase.prototype.getPixelDomain = function (result) {
            var padding = this.padding;
            return result.set(padding.getLeft(), this.width - padding.getRight());
        };
        DChartPlotAreaBase.prototype.getPixelRange = function (result) {
            var padding = this.padding;
            return result.set(this.height - padding.getBottom(), padding.getTop());
        };
        DChartPlotAreaBase.prototype.getPixelBounds = function () {
            var result = this._pixelBounds;
            result.x = 0;
            result.y = 0;
            result.width = this.width;
            result.height = this.height;
            return result;
        };
        DChartPlotAreaBase.prototype.getAxisBounds = function (position) {
            return this.getPixelBounds();
        };
        DChartPlotAreaBase.prototype.getSelectionBoundsX = function () {
            return this.getPixelBounds();
        };
        DChartPlotAreaBase.prototype.getSelectionBoundsY = function () {
            return this.getPixelBounds();
        };
        DChartPlotAreaBase.prototype.getContainerBounds = function () {
            var result = this._containerBounds;
            if (this._isContainerBoundsDirty) {
                this._isContainerBoundsDirty = false;
                var container = this.container;
                container.updateTransform();
                var transform = container.transform.localTransform;
                var work = this._workPoint;
                work.set(0, 0);
                transform.applyInverse(work, work);
                result.x = work.x;
                result.y = work.y;
                work.set(this.width, this.height);
                transform.applyInverse(work, work);
                result.width = work.x - result.x;
                result.height = work.y - result.y;
            }
            return result;
        };
        DChartPlotAreaBase.prototype.getType = function () {
            return "DChartPlotArea";
        };
        return DChartPlotAreaBase;
    }(DBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartPlotAreaContainer = /** @class */ (function (_super) {
        __extends(DChartPlotAreaContainer, _super);
        function DChartPlotAreaContainer(onChange) {
            var _this = _super.call(this) || this;
            var transform = _this.transform;
            _this._position = new DBasePoint(transform.position, onChange);
            _this._scale = new DBasePoint(transform.scale, onChange);
            _this._workRect = new pixi_js.Rectangle();
            return _this;
        }
        Object.defineProperty(DChartPlotAreaContainer.prototype, "position", {
            // @ts-ignore
            get: function () {
                return this._position;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartPlotAreaContainer.prototype, "scale", {
            // @ts-ignore
            get: function () {
                return this._scale;
            },
            enumerable: false,
            configurable: true
        });
        DChartPlotAreaContainer.prototype.getBounds = function (skipUpdate, rect) {
            this._lastBoundsID = -1;
            return _super.prototype.getBounds.call(this, skipUpdate, rect);
        };
        DChartPlotAreaContainer.prototype.calculateBounds = function () {
            var bounds = this._bounds;
            var work = this._work;
            var rect = this._workRect;
            var worldTransform = this.transform.worldTransform;
            var xmin = 0;
            var xmax = 0;
            var ymin = 0;
            var ymax = 0;
            var children = this.children;
            if (0 < children.length) {
                var isFirst = true;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    var child = children[i];
                    if (child.visible) {
                        child.getBoundsInternal(false, rect);
                        if (isFirst) {
                            isFirst = false;
                            xmin = rect.x;
                            ymin = rect.y;
                            xmax = rect.x + rect.width;
                            ymax = rect.y + rect.height;
                        }
                        else {
                            xmin = Math.min(xmin, rect.x);
                            ymin = Math.min(ymin, rect.y);
                            xmax = Math.max(xmax, rect.x + rect.width);
                            ymax = Math.max(ymax, rect.y + rect.height);
                        }
                    }
                }
            }
            bounds.clear();
            work.set(xmin, ymin);
            worldTransform.apply(work, work);
            bounds.addPoint(work);
            work.set(xmax, ymax);
            worldTransform.apply(work, work);
            bounds.addPoint(work);
        };
        return DChartPlotAreaContainer;
    }(EShapeContainer));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartSeriesHitResult = /** @class */ (function () {
        function DChartSeriesHitResult() {
            this.shape = null;
            this.x = 0;
            this.y = 0;
            this.p0x = 0;
            this.p0y = 0;
            this.p1x = 0;
            this.p1y = 0;
            this.index = 0;
            this.t = 0;
            this.distance = 0;
        }
        DChartSeriesHitResult.prototype.copyFrom = function (other) {
            this.shape = other.shape;
            this.x = other.x;
            this.y = other.y;
            this.p0x = other.p0x;
            this.p0y = other.p0y;
            this.p1x = other.p1x;
            this.p1y = other.p1y;
            this.index = other.index;
            this.t = other.t;
            this.distance = other.distance;
            return this;
        };
        return DChartSeriesHitResult;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartSeriesFillComputedImpl = /** @class */ (function () {
        function DChartSeriesFillComputedImpl(enable, color, alpha) {
            this.enable = enable;
            this.color = color;
            this.alpha = alpha;
        }
        DChartSeriesFillComputedImpl.from = function (base, index, fill) {
            var _a, _b, _c;
            return new DChartSeriesFillComputedImpl((_a = fill === null || fill === void 0 ? void 0 : fill.enable) !== null && _a !== void 0 ? _a : base.enable(index), (_b = fill === null || fill === void 0 ? void 0 : fill.color) !== null && _b !== void 0 ? _b : base.color(index), (_c = fill === null || fill === void 0 ? void 0 : fill.alpha) !== null && _c !== void 0 ? _c : base.alpha(index));
        };
        return DChartSeriesFillComputedImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartSeriesScalars = /** @class */ (function () {
        function DChartSeriesScalars() {
        }
        DChartSeriesScalars.from = function (value, def) {
            if (isArray(value)) {
                return function (index) { return value[index % value.length]; };
            }
            else if (isFunction(value)) {
                return value;
            }
            else if (value != null) {
                return function () { return value; };
            }
            else if (isArray(def)) {
                return function (index) { return def[index % def.length]; };
            }
            else if (isFunction(def)) {
                return def;
            }
            else {
                return function () { return def; };
            }
        };
        return DChartSeriesScalars;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartSeriesFillImpl = /** @class */ (function () {
        function DChartSeriesFillImpl(options) {
            this.enable = DChartSeriesScalars.from(options === null || options === void 0 ? void 0 : options.enable, true);
            this.color = DChartSeriesScalars.from(options === null || options === void 0 ? void 0 : options.color, DChartColorSet2);
            this.alpha = DChartSeriesScalars.from(options === null || options === void 0 ? void 0 : options.alpha, EShapeDefaults.FILL_ALPHA);
        }
        return DChartSeriesFillImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartSeriesPaddingComputedImpl = /** @class */ (function () {
        function DChartSeriesPaddingComputedImpl(outer, inner) {
            this.outer = outer;
            this.inner = inner;
        }
        DChartSeriesPaddingComputedImpl.from = function (base, index, point) {
            var _a, _b;
            return new DChartSeriesPaddingComputedImpl((_a = point === null || point === void 0 ? void 0 : point.outer) !== null && _a !== void 0 ? _a : base.outer(index), (_b = point === null || point === void 0 ? void 0 : point.inner) !== null && _b !== void 0 ? _b : base.inner(index));
        };
        return DChartSeriesPaddingComputedImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartSeriesPaddingImpl = /** @class */ (function () {
        function DChartSeriesPaddingImpl(options) {
            this.outer = DChartSeriesScalars.from(options === null || options === void 0 ? void 0 : options.outer, 0.2);
            this.inner = DChartSeriesScalars.from(options === null || options === void 0 ? void 0 : options.inner, 0.1);
        }
        return DChartSeriesPaddingImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartSeriesPointComputedImpl = /** @class */ (function () {
        function DChartSeriesPointComputedImpl(x, y) {
            this.x = x;
            this.y = y;
        }
        DChartSeriesPointComputedImpl.from = function (base, index, point, x, y) {
            var _a, _b;
            return new DChartSeriesPointComputedImpl((_a = point === null || point === void 0 ? void 0 : point.x) !== null && _a !== void 0 ? _a : (base.x != null ? base.x(index) : x), (_b = point === null || point === void 0 ? void 0 : point.y) !== null && _b !== void 0 ? _b : (base.y != null ? base.y(index) : y));
        };
        return DChartSeriesPointComputedImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartSeriesPointImpl = /** @class */ (function () {
        function DChartSeriesPointImpl(options) {
            if (options) {
                if (options.x != null) {
                    this.x = DChartSeriesScalars.from(options.x, 0);
                }
                if (options.y != null) {
                    this.y = DChartSeriesScalars.from(options.y, 0);
                }
            }
        }
        return DChartSeriesPointImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartSeriesStrokeComputedImpl = /** @class */ (function () {
        function DChartSeriesStrokeComputedImpl(enable, color, alpha, width, align, side, style) {
            this.enable = enable;
            this.color = color;
            this.alpha = alpha;
            this.width = width;
            this.align = align;
            this.side = side;
            this.style = style;
        }
        DChartSeriesStrokeComputedImpl.from = function (base, index, stroke) {
            var _a, _b, _c, _d, _e, _f, _g;
            return new DChartSeriesStrokeComputedImpl((_a = stroke === null || stroke === void 0 ? void 0 : stroke.enable) !== null && _a !== void 0 ? _a : base.enable(index), (_b = stroke === null || stroke === void 0 ? void 0 : stroke.color) !== null && _b !== void 0 ? _b : base.color(index), (_c = stroke === null || stroke === void 0 ? void 0 : stroke.alpha) !== null && _c !== void 0 ? _c : base.alpha(index), (_d = stroke === null || stroke === void 0 ? void 0 : stroke.width) !== null && _d !== void 0 ? _d : base.width(index), (_e = stroke === null || stroke === void 0 ? void 0 : stroke.align) !== null && _e !== void 0 ? _e : base.align(index), (_f = stroke === null || stroke === void 0 ? void 0 : stroke.side) !== null && _f !== void 0 ? _f : base.side(index), (_g = stroke === null || stroke === void 0 ? void 0 : stroke.style) !== null && _g !== void 0 ? _g : base.style(index));
        };
        return DChartSeriesStrokeComputedImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartSeriesStrokeImpl = /** @class */ (function () {
        function DChartSeriesStrokeImpl(options) {
            this.enable = DChartSeriesScalars.from(options === null || options === void 0 ? void 0 : options.enable, true);
            this.color = DChartSeriesScalars.from(options === null || options === void 0 ? void 0 : options.color, DChartColorSet2);
            this.alpha = DChartSeriesScalars.from(options === null || options === void 0 ? void 0 : options.alpha, EShapeDefaults.STROKE_ALPHA);
            this.width = DChartSeriesScalars.from(options === null || options === void 0 ? void 0 : options.width, EShapeDefaults.STROKE_WIDTH);
            this.align = DChartSeriesScalars.from(options === null || options === void 0 ? void 0 : options.width, EShapeDefaults.STROKE_ALIGN);
            this.side = DChartSeriesScalars.from(options === null || options === void 0 ? void 0 : options.side, EShapeStrokeSide.ALL);
            this.style = DChartSeriesScalars.from(options === null || options === void 0 ? void 0 : options.style, EShapeStrokeStyle.NON_SCALING);
        }
        return DChartSeriesStrokeImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartSeriesContainerImpl = /** @class */ (function () {
        function DChartSeriesContainerImpl(plotArea, options) {
            this._plotArea = plotArea;
            this._domain = new DChartRegionImpl(NaN, NaN);
            this._range = new DChartRegionImpl(NaN, NaN);
            this._selection = null;
            this._fill = new DChartSeriesFillImpl(options === null || options === void 0 ? void 0 : options.fill);
            this._stroke = new DChartSeriesStrokeImpl(options === null || options === void 0 ? void 0 : options.stroke);
            this._size = new DChartSeriesPointImpl(options === null || options === void 0 ? void 0 : options.size);
            this._offset = new DChartSeriesPointImpl(options === null || options === void 0 ? void 0 : options.offset);
            this._padding = new DChartSeriesPaddingImpl(options === null || options === void 0 ? void 0 : options.padding);
            this._list = [];
        }
        DChartSeriesContainerImpl.prototype.newFill = function (index, options) {
            return DChartSeriesFillComputedImpl.from(this._fill, index, options);
        };
        DChartSeriesContainerImpl.prototype.newStroke = function (index, options) {
            return DChartSeriesStrokeComputedImpl.from(this._stroke, index, options);
        };
        DChartSeriesContainerImpl.prototype.newSize = function (index, options, x, y) {
            return DChartSeriesPointComputedImpl.from(this._size, index, options, x, y);
        };
        DChartSeriesContainerImpl.prototype.newOffset = function (index, options, x, y) {
            return DChartSeriesPointComputedImpl.from(this._offset, index, options, x, y);
        };
        DChartSeriesContainerImpl.prototype.newPadding = function (index, options) {
            return DChartSeriesPaddingComputedImpl.from(this._padding, index, options);
        };
        Object.defineProperty(DChartSeriesContainerImpl.prototype, "plotArea", {
            get: function () {
                return this._plotArea;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartSeriesContainerImpl.prototype, "selection", {
            get: function () {
                return this._selection;
            },
            set: function (selection) {
                this._selection = selection;
            },
            enumerable: false,
            configurable: true
        });
        DChartSeriesContainerImpl.prototype.update = function () {
            var list = this._list;
            for (var i = 0, imax = list.length; i < imax; ++i) {
                list[i].update();
            }
            var selection = this._selection;
            if (selection) {
                selection.update();
            }
        };
        DChartSeriesContainerImpl.prototype.onRender = function () {
            var list = this._list;
            for (var i = 0, imax = list.length; i < imax; ++i) {
                list[i].onRender();
            }
            var selection = this._selection;
            if (selection) {
                selection.onRender();
            }
        };
        DChartSeriesContainerImpl.prototype.add = function (series) {
            var list = this._list;
            series.bind(this, list.length);
            list.push(series);
        };
        DChartSeriesContainerImpl.prototype.get = function (index) {
            var list = this._list;
            if (0 <= index && index < list.length) {
                return list[index];
            }
            return null;
        };
        DChartSeriesContainerImpl.prototype.indexOf = function (series) {
            return this._list.indexOf(series);
        };
        DChartSeriesContainerImpl.prototype.clear = function () {
            var list = this._list;
            for (var i = 0, imax = list.length; i < imax; ++i) {
                list[i].destroy();
            }
            list.length = 0;
            return this;
        };
        DChartSeriesContainerImpl.prototype.size = function () {
            return this._list.length;
        };
        DChartSeriesContainerImpl.prototype.destroy = function () {
            this.clear();
            var selection = this._selection;
            if (selection) {
                selection.unbind();
            }
        };
        DChartSeriesContainerImpl.prototype.getDomain = function (coordinate, result) {
            result.clear();
            var list = this._list;
            for (var i = 0, imax = list.length; i < imax; ++i) {
                var series = list[i];
                if (series.coordinate.x === coordinate) {
                    var domain = series.domain;
                    result.add(domain.from, domain.to);
                }
            }
            return result;
        };
        DChartSeriesContainerImpl.prototype.getRange = function (coordinate, result) {
            result.clear();
            var list = this._list;
            for (var i = 0, imax = list.length; i < imax; ++i) {
                var series = list[i];
                if (series.coordinate.y === coordinate) {
                    var range = series.range;
                    result.add(range.from, range.to);
                }
            }
            return result;
        };
        Object.defineProperty(DChartSeriesContainerImpl.prototype, "domain", {
            get: function () {
                var result = this._domain;
                result.clear();
                var list = this._list;
                for (var i = 0, imax = list.length; i < imax; ++i) {
                    var domain = list[i].domain;
                    result.add(domain.from, domain.to);
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartSeriesContainerImpl.prototype, "range", {
            get: function () {
                var result = this._range;
                result.clear();
                var list = this._list;
                for (var i = 0, imax = list.length; i < imax; ++i) {
                    var range = list[i].range;
                    result.add(range.from, range.to);
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DChartSeriesContainerImpl.prototype.hitTest = function (x, y) {
            var list = this._list;
            for (var i = list.length - 1; 0 <= i; --i) {
                var series = list[i];
                if (series.hitTest(x, y)) {
                    return series;
                }
            }
            return null;
        };
        DChartSeriesContainerImpl.prototype.calcHitPoint = function (x, y, result) {
            var tmp1 = result;
            var tmp2 = DChartSeriesContainerImpl.WORK_CALCHITPOINT;
            var list = this._list;
            var closest = null;
            tmp2.distance = +Infinity;
            for (var i = list.length - 1; 0 <= i; --i) {
                var series = list[i];
                if (series.calcHitPoint(x, y, tmp1)) {
                    if (tmp1.distance < tmp2.distance) {
                        closest = series;
                        var tmp = tmp1;
                        tmp1 = tmp2;
                        tmp2 = tmp;
                    }
                }
            }
            if (closest && tmp2 !== result) {
                result.copyFrom(tmp2);
            }
            return closest;
        };
        DChartSeriesContainerImpl.WORK_CALCHITPOINT = new DChartSeriesHitResult();
        return DChartSeriesContainerImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartPlotAreaOnefold = /** @class */ (function (_super) {
        __extends(DChartPlotAreaOnefold, _super);
        function DChartPlotAreaOnefold(chart, options) {
            var _a;
            var _this = _super.call(this, chart, options) || this;
            // Container
            var container = new DChartPlotAreaContainer(function () {
                _this._isViewDirty = true;
                _this._isContainerBoundsDirty = true;
                DApplications.update(_this);
            });
            _this._container = container;
            _this.addChild(container);
            // Overflow mask
            var mask = (_a = options === null || options === void 0 ? void 0 : options.mask) !== null && _a !== void 0 ? _a : _this.theme.isOverflowMaskEnabled();
            if (mask) {
                container.mask = _this.getOverflowMask();
            }
            // View
            _this._isViewDirty = true;
            _this._view = new DViewImpl(_this, function () { return container; }, options === null || options === void 0 ? void 0 : options.view);
            // Coordinate
            _this._coordinate = new DChartCoordinateContainerImpl(_this, options === null || options === void 0 ? void 0 : options.coordinate);
            // Series
            var seriesOptions = options === null || options === void 0 ? void 0 : options.series;
            var series = new DChartSeriesContainerImpl(_this, seriesOptions);
            _this._series = series;
            // Axis
            var axisOptions = options === null || options === void 0 ? void 0 : options.axis;
            var axis = new DChartAxisContainerImpl(_this, new EShapeContainer(), axisOptions);
            _this._axis = axis;
            _this.addChild(axis.container);
            // Add series
            _this.addSeries(series, seriesOptions === null || seriesOptions === void 0 ? void 0 : seriesOptions.list);
            // Add axes
            _this.addAxes(axis, axisOptions === null || axisOptions === void 0 ? void 0 : axisOptions.list);
            // Selection
            var selection = seriesOptions === null || seriesOptions === void 0 ? void 0 : seriesOptions.selection;
            if (selection != null) {
                series.selection = selection;
                selection.bind(series);
            }
            return _this;
        }
        DChartPlotAreaOnefold.prototype.getOverflowMask = function () {
            if (this._overflowMask == null) {
                this._overflowMask = new DBaseOverflowMask(this);
                this.reflowable.add(this._overflowMask);
                this.toDirty();
            }
            return this._overflowMask;
        };
        DChartPlotAreaOnefold.prototype.addSeries = function (series, list) {
            if (list != null) {
                var listLength = list.length;
                if (0 < listLength) {
                    for (var i = 0; i < listLength; ++i) {
                        series.add(list[i]);
                    }
                    series.update();
                }
            }
        };
        DChartPlotAreaOnefold.prototype.addAxes = function (axis, list) {
            if (list != null) {
                for (var i = 0, imax = list.length; i < imax; ++i) {
                    axis.add(list[i]);
                }
            }
        };
        Object.defineProperty(DChartPlotAreaOnefold.prototype, "coordinate", {
            get: function () {
                return this._coordinate;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartPlotAreaOnefold.prototype, "series", {
            get: function () {
                return this._series;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartPlotAreaOnefold.prototype, "container", {
            get: function () {
                return this._container;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartPlotAreaOnefold.prototype, "axis", {
            get: function () {
                return this._axis;
            },
            enumerable: false,
            configurable: true
        });
        DChartPlotAreaOnefold.prototype.newView = function (options) {
            var _this = this;
            return new DViewImpl(this, function () { return _this._container; }, options === null || options === void 0 ? void 0 : options.view);
        };
        DChartPlotAreaOnefold.prototype.onViewDirty = function () {
            this._coordinate.fit();
            this._axis.onRender();
            this._series.onRender();
        };
        DChartPlotAreaOnefold.prototype.fit = function (duration, domainFrom, domainTo, rangeFrom, rangeTo) {
            var coordinate = this._coordinate;
            var axis = this._axis;
            var series = this._series;
            if (duration != null && duration <= 0) {
                coordinate.fit(domainFrom, domainTo, rangeFrom, rangeTo);
                axis.update();
                series.update();
            }
            else {
                this._blendDuration = duration != null ? duration : 200;
                this._blendStartTime = Date.now();
                coordinate.mark(domainFrom, domainTo, rangeFrom, rangeTo);
                var blendTimeout = this._blendTimeout;
                if (blendTimeout != null) {
                    window.clearTimeout(blendTimeout);
                }
                this._blendTimeout = window.setTimeout(this._onBlendBound, 0);
            }
            return this;
        };
        DChartPlotAreaOnefold.prototype.onBlend = function () {
            var now = Date.now();
            var ratio = (now - this._blendStartTime) / this._blendDuration;
            if (ratio < 1) {
                this._blendTimeout = window.setTimeout(this._onBlendBound, 0);
            }
            else {
                this._blendTimeout = null;
                ratio = 1;
            }
            this._coordinate.blend(DAnimationTimings.ELASTIC(ratio));
            this._axis.update();
            this._series.update();
        };
        DChartPlotAreaOnefold.prototype.destroy = function () {
            this._container.destroy();
            this._series.destroy();
            this._axis.destroy();
        };
        return DChartPlotAreaOnefold;
    }(DChartPlotAreaBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartPlotAreaTwofoldAxisContainer = /** @class */ (function () {
        function DChartPlotAreaTwofoldAxisContainer(plotArea, container, primary, secondary) {
            this._plotArea = plotArea;
            this._container = container;
            this._list = new Map();
            this._primary = primary;
            this._secondary = secondary;
        }
        Object.defineProperty(DChartPlotAreaTwofoldAxisContainer.prototype, "container", {
            get: function () {
                return this._container;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartPlotAreaTwofoldAxisContainer.prototype, "plotArea", {
            get: function () {
                return this._plotArea;
            },
            enumerable: false,
            configurable: true
        });
        DChartPlotAreaTwofoldAxisContainer.prototype.add = function (axis) {
            var list = this._list;
            var axes = list.get(axis.position);
            if (axes == null) {
                axes = [];
                list.set(axis.position, axes);
            }
            axes.push(axis);
            axis.bind(this, axes.length - 1);
        };
        DChartPlotAreaTwofoldAxisContainer.prototype.get = function (position, index) {
            var primary = this._primary;
            var primarySize = primary.size(position);
            if (0 <= index && index < primarySize) {
                return primary.get(position, index);
            }
            var secondary = this._secondary;
            var secondarySize = secondary.size(position);
            if (primarySize <= index && index < primarySize + secondarySize) {
                return secondary.get(position, index - primarySize);
            }
            var list = this._list;
            var axes = list.get(toEnum(position, DChartAxisPosition));
            if (axes) {
                if (primarySize + secondarySize <= index &&
                    index < primarySize + secondarySize + axes.length) {
                    return axes[index - primarySize - secondarySize];
                }
            }
            return null;
        };
        DChartPlotAreaTwofoldAxisContainer.prototype.indexOf = function (axis) {
            var primary = this._primary;
            var result = primary.indexOf(axis);
            if (0 <= result) {
                return result;
            }
            var secondary = this._secondary;
            result = secondary.indexOf(axis);
            if (0 <= result) {
                return primary.size(axis.position) + result;
            }
            var list = this._list;
            var axes = list.get(axis.position);
            if (axes) {
                return primary.size(axis.position) + secondary.size(axis.position) + axes.indexOf(axis);
            }
            return -1;
        };
        DChartPlotAreaTwofoldAxisContainer.prototype.clear = function (position) {
            this._primary.clear(position);
            this._secondary.clear(position);
            var list = this._list;
            var axes = list.get(toEnum(position, DChartAxisPosition));
            if (axes) {
                for (var i = 0, imax = axes.length; i < imax; ++i) {
                    axes[i].destroy();
                }
                axes.length = 0;
            }
            return this;
        };
        DChartPlotAreaTwofoldAxisContainer.prototype.size = function (position) {
            var list = this._list;
            var axes = list.get(toEnum(position, DChartAxisPosition));
            return (this._primary.size(position) +
                this._secondary.size(position) +
                (axes != null ? axes.length : 0));
        };
        DChartPlotAreaTwofoldAxisContainer.prototype.update = function () {
            this._primary.update();
            this._secondary.update();
            this._list.forEach(function (axes) {
                for (var i = 0, imax = axes.length; i < imax; ++i) {
                    axes[i].update();
                }
            });
        };
        DChartPlotAreaTwofoldAxisContainer.prototype.onRender = function () {
            this._primary.onRender();
            this._secondary.onRender();
            this._list.forEach(function (axes) {
                for (var i = 0, imax = axes.length; i < imax; ++i) {
                    axes[i].onRender();
                }
            });
        };
        DChartPlotAreaTwofoldAxisContainer.prototype.destroy = function () {
            this._primary.destroy();
            this._secondary.destroy();
            this._list.forEach(function (axes) {
                for (var i = 0, imax = axes.length; i < imax; ++i) {
                    axes[i].destroy();
                }
                axes.length = 0;
            });
        };
        return DChartPlotAreaTwofoldAxisContainer;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartPlotAreaTwofoldCoorinateContainerSub = /** @class */ (function () {
        function DChartPlotAreaTwofoldCoorinateContainerSub(container, primary, secondary) {
            this._container = container;
            this._primary = primary;
            this._secondary = secondary;
        }
        Object.defineProperty(DChartPlotAreaTwofoldCoorinateContainerSub.prototype, "container", {
            get: function () {
                return this._container;
            },
            enumerable: false,
            configurable: true
        });
        DChartPlotAreaTwofoldCoorinateContainerSub.prototype.add = function (coordinate, index) {
            if (index != null) {
                var primary = this._primary;
                var primarySize = primary.size();
                if (index < primarySize) {
                    if (0 <= index) {
                        primary.add(coordinate, index);
                    }
                }
                else {
                    this._secondary.add(coordinate, index - primarySize);
                }
                return this;
            }
            else {
                this._secondary.add(coordinate);
            }
            return this;
        };
        DChartPlotAreaTwofoldCoorinateContainerSub.prototype.get = function (index) {
            var primary = this._primary;
            var primarySize = primary.size();
            if (0 <= index && index < primarySize) {
                return primary.get(index);
            }
            var secondary = this._secondary;
            var secondarySize = secondary.size();
            if (primarySize <= index && index < primarySize + secondarySize) {
                return secondary.get(index - primarySize);
            }
            return null;
        };
        DChartPlotAreaTwofoldCoorinateContainerSub.prototype.indexOf = function (coordinate) {
            var primary = this._primary;
            var result = primary.indexOf(coordinate);
            if (0 <= result) {
                return result;
            }
            result = this._secondary.indexOf(coordinate);
            if (0 <= result) {
                return primary.size() + result;
            }
            return -1;
        };
        DChartPlotAreaTwofoldCoorinateContainerSub.prototype.remove = function (coordinateOrIndex) {
            if (isNumber(coordinateOrIndex)) {
                var index = coordinateOrIndex;
                var primary = this._primary;
                var primarySize = primary.size();
                if (0 <= index && index < primarySize) {
                    return primary.remove(index);
                }
                var secondary = this._secondary;
                var secondarySize = secondary.size();
                if (primarySize <= index && index < primarySize + secondarySize) {
                    return secondary.remove(index - primarySize);
                }
            }
            else {
                var coordinate = coordinateOrIndex;
                var result = this._primary.remove(coordinate);
                if (result != null) {
                    return result;
                }
                result = this._secondary.remove(coordinate);
                if (result != null) {
                    return result;
                }
            }
            return null;
        };
        DChartPlotAreaTwofoldCoorinateContainerSub.prototype.clear = function () {
            this._primary.clear();
            this._secondary.clear();
            return this;
        };
        DChartPlotAreaTwofoldCoorinateContainerSub.prototype.destroy = function () {
            return this.clear();
        };
        DChartPlotAreaTwofoldCoorinateContainerSub.prototype.size = function () {
            return this._primary.size() + this._secondary.size();
        };
        DChartPlotAreaTwofoldCoorinateContainerSub.prototype.fit = function (from, to) {
            this._primary.fit(from, to);
            this._secondary.fit(from, to);
            return this;
        };
        DChartPlotAreaTwofoldCoorinateContainerSub.prototype.mark = function (from, to) {
            this._primary.mark(from, to);
            this._secondary.mark(from, to);
            return this;
        };
        DChartPlotAreaTwofoldCoorinateContainerSub.prototype.blend = function (ratio) {
            this._primary.blend(ratio);
            this._secondary.blend(ratio);
            return this;
        };
        return DChartPlotAreaTwofoldCoorinateContainerSub;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartPlotAreaTwofoldCoorinateContainer = /** @class */ (function () {
        function DChartPlotAreaTwofoldCoorinateContainer(plotArea, primary, secondary) {
            this._plotArea = plotArea;
            this._primary = primary;
            this._secondary = secondary;
            this._x = new DChartPlotAreaTwofoldCoorinateContainerSub(this, primary.x, secondary.x);
            this._y = new DChartPlotAreaTwofoldCoorinateContainerSub(this, primary.y, secondary.y);
        }
        Object.defineProperty(DChartPlotAreaTwofoldCoorinateContainer.prototype, "x", {
            get: function () {
                return this._x;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartPlotAreaTwofoldCoorinateContainer.prototype, "y", {
            get: function () {
                return this._y;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartPlotAreaTwofoldCoorinateContainer.prototype, "plotArea", {
            get: function () {
                return this._plotArea;
            },
            enumerable: false,
            configurable: true
        });
        DChartPlotAreaTwofoldCoorinateContainer.prototype.fit = function (domainFrom, domainTo, rangeFrom, rangeTo) {
            this._x.fit(domainFrom, domainTo);
            this._y.fit(rangeFrom, rangeTo);
            return this;
        };
        DChartPlotAreaTwofoldCoorinateContainer.prototype.mark = function (domainFrom, domainTo, rangeFrom, rangeTo) {
            this._x.mark(domainFrom, domainTo);
            this._y.mark(rangeFrom, rangeTo);
            return this;
        };
        DChartPlotAreaTwofoldCoorinateContainer.prototype.blend = function (ratio) {
            this._x.blend(ratio);
            this._y.blend(ratio);
            return this;
        };
        return DChartPlotAreaTwofoldCoorinateContainer;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartPlotAreaTwofoldOverflowMaskPrimary = /** @class */ (function (_super) {
        __extends(DChartPlotAreaTwofoldOverflowMaskPrimary, _super);
        function DChartPlotAreaTwofoldOverflowMaskPrimary() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DChartPlotAreaTwofoldOverflowMaskPrimary.prototype.onReflow = function (base, width, height) {
            if (this._isInitialized && this._width === width && this._height === height) {
                return;
            }
            this._isInitialized = true;
            this._width = width;
            this._height = height;
            var hh = height * 0.5;
            this.clear();
            this.beginFill(0xffffff, 1);
            this.drawRect(0, 0, width, hh);
            this.endFill();
        };
        return DChartPlotAreaTwofoldOverflowMaskPrimary;
    }(DBaseOverflowMaskSimple));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartPlotAreaTwofoldOverflowMaskSecondary = /** @class */ (function (_super) {
        __extends(DChartPlotAreaTwofoldOverflowMaskSecondary, _super);
        function DChartPlotAreaTwofoldOverflowMaskSecondary() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DChartPlotAreaTwofoldOverflowMaskSecondary.prototype.onReflow = function (base, width, height) {
            if (this._isInitialized && this._width === width && this._height === height) {
                return;
            }
            this._isInitialized = true;
            this._width = width;
            this._height = height;
            var hh = height * 0.5;
            this.clear();
            this.beginFill(0xffffff, 1);
            this.drawRect(0, hh, width, hh);
            this.endFill();
        };
        return DChartPlotAreaTwofoldOverflowMaskSecondary;
    }(DBaseOverflowMaskSimple));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartPlotAreaTwofoldSeriesContainer = /** @class */ (function () {
        function DChartPlotAreaTwofoldSeriesContainer(plotArea, primary, secondary) {
            this._plotArea = plotArea;
            this._primary = primary;
            this._secondary = secondary;
            this._domain = new DChartRegionImpl(NaN, NaN);
            this._range = new DChartRegionImpl(NaN, NaN);
        }
        DChartPlotAreaTwofoldSeriesContainer.prototype.newFill = function (index, options) {
            return this._secondary.newFill(index, options);
        };
        DChartPlotAreaTwofoldSeriesContainer.prototype.newStroke = function (index, options) {
            return this._secondary.newStroke(index, options);
        };
        DChartPlotAreaTwofoldSeriesContainer.prototype.newSize = function (index, options, x, y) {
            return this._secondary.newSize(index, options, x, y);
        };
        DChartPlotAreaTwofoldSeriesContainer.prototype.newOffset = function (index, options, x, y) {
            return this._secondary.newOffset(index, options, x, y);
        };
        DChartPlotAreaTwofoldSeriesContainer.prototype.newPadding = function (index, options) {
            return this._secondary.newPadding(index, options);
        };
        Object.defineProperty(DChartPlotAreaTwofoldSeriesContainer.prototype, "plotArea", {
            get: function () {
                return this._plotArea;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartPlotAreaTwofoldSeriesContainer.prototype, "selection", {
            get: function () {
                return this._secondary.selection;
            },
            enumerable: false,
            configurable: true
        });
        DChartPlotAreaTwofoldSeriesContainer.prototype.update = function () {
            this._primary.update();
            this._secondary.update();
            var selection = this._secondary.selection;
            if (selection) {
                selection.update();
            }
        };
        DChartPlotAreaTwofoldSeriesContainer.prototype.onRender = function () {
            this._primary.onRender();
            this._secondary.onRender();
            var selection = this._secondary.selection;
            if (selection) {
                selection.onRender();
            }
        };
        DChartPlotAreaTwofoldSeriesContainer.prototype.add = function (series) {
            this._secondary.add(series);
        };
        DChartPlotAreaTwofoldSeriesContainer.prototype.get = function (index) {
            var primary = this._primary;
            var primarySize = primary.size();
            if (0 <= index && index < primarySize) {
                return primary.get(index);
            }
            var secondary = this._secondary;
            var secondarySize = secondary.size();
            if (primarySize <= index && index < primarySize + secondarySize) {
                return secondary.get(index - primarySize);
            }
            return null;
        };
        DChartPlotAreaTwofoldSeriesContainer.prototype.indexOf = function (series) {
            var primary = this._primary;
            var result = primary.indexOf(series);
            if (0 <= result) {
                return result;
            }
            result = this._secondary.indexOf(series);
            if (0 <= result) {
                return primary.size() + result;
            }
            return -1;
        };
        DChartPlotAreaTwofoldSeriesContainer.prototype.clear = function () {
            this._primary.clear();
            this._secondary.clear();
            return this;
        };
        DChartPlotAreaTwofoldSeriesContainer.prototype.size = function () {
            return this._primary.size() + this._secondary.size();
        };
        DChartPlotAreaTwofoldSeriesContainer.prototype.destroy = function () {
            this.clear();
            var selection = this._secondary.selection;
            if (selection) {
                selection.unbind();
            }
        };
        DChartPlotAreaTwofoldSeriesContainer.prototype.getDomain = function (coordinate, result) {
            this._primary.getDomain(coordinate, result);
            var from = result.from;
            var to = result.to;
            this._secondary.getDomain(coordinate, result);
            result.add(from, to);
            return result;
        };
        DChartPlotAreaTwofoldSeriesContainer.prototype.getRange = function (coordinate, result) {
            result.clear();
            this._primary.getRange(coordinate, result);
            var from = result.from;
            var to = result.to;
            this._secondary.getRange(coordinate, result);
            result.add(from, to);
            return result;
        };
        Object.defineProperty(DChartPlotAreaTwofoldSeriesContainer.prototype, "domain", {
            get: function () {
                var result = this._domain;
                result.clear();
                var pdomain = this._primary.domain;
                result.add(pdomain.from, pdomain.to);
                var sdomain = this._secondary.domain;
                result.add(sdomain.from, sdomain.to);
                return result;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartPlotAreaTwofoldSeriesContainer.prototype, "range", {
            get: function () {
                var result = this._domain;
                result.clear();
                var prange = this._primary.range;
                result.add(prange.from, prange.to);
                var srange = this._secondary.range;
                result.add(srange.from, srange.to);
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DChartPlotAreaTwofoldSeriesContainer.prototype.hitTest = function (x, y) {
            var result = this._secondary.hitTest(x, y);
            if (result != null) {
                return result;
            }
            return this._primary.hitTest(x, y);
        };
        DChartPlotAreaTwofoldSeriesContainer.prototype.calcHitPoint = function (x, y, result) {
            var _a;
            var result1 = result;
            var result2 = ((_a = DChartPlotAreaTwofoldSeriesContainer.WORK_CALCHITPOINT) !== null && _a !== void 0 ? _a : (DChartPlotAreaTwofoldSeriesContainer.WORK_CALCHITPOINT = new DChartSeriesHitResult()));
            var series2 = this._secondary.calcHitPoint(x, y, result2);
            var series1 = this._primary.calcHitPoint(x, y, result1);
            if (series1 != null) {
                if (series2 != null) {
                    if (result1.distance <= result2.distance) {
                        return series1;
                    }
                    else {
                        result1.copyFrom(result2);
                        return series2;
                    }
                }
                else {
                    return series1;
                }
            }
            else {
                if (series2 != null) {
                    result1.copyFrom(result2);
                    return series2;
                }
                else {
                    return null;
                }
            }
        };
        return DChartPlotAreaTwofoldSeriesContainer;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartPlotAreaTwofoldSubBase = /** @class */ (function () {
        function DChartPlotAreaTwofoldSubBase(plotArea, onContainerChange, mask, margin, axisShapeContainer, options) {
            this._isContainerBoundsDirty = true;
            this._containerBounds = new pixi_js.Rectangle();
            this._workPoint = new pixi_js.Point();
            this._margin = margin;
            this._plotArea = plotArea;
            // Container
            var container = new DChartPlotAreaContainer(onContainerChange);
            this._container = container;
            // Coordinate
            this._coordinate = new DChartCoordinateContainerImpl(this, options === null || options === void 0 ? void 0 : options.coordinate);
            // Overflow mask
            if (mask) {
                container.mask = this.getOverflowMask();
            }
            // Series
            this._series = new DChartSeriesContainerImpl(this, options === null || options === void 0 ? void 0 : options.series);
            // Axis
            this._axis = new DChartAxisContainerImpl(this, axisShapeContainer, options === null || options === void 0 ? void 0 : options.axis);
        }
        Object.defineProperty(DChartPlotAreaTwofoldSubBase.prototype, "plotArea", {
            get: function () {
                return this._plotArea;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartPlotAreaTwofoldSubBase.prototype, "chart", {
            get: function () {
                return this._plotArea.chart;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartPlotAreaTwofoldSubBase.prototype, "container", {
            get: function () {
                return this._container;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartPlotAreaTwofoldSubBase.prototype, "series", {
            get: function () {
                return this._series;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartPlotAreaTwofoldSubBase.prototype, "coordinate", {
            get: function () {
                return this._coordinate;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartPlotAreaTwofoldSubBase.prototype, "axis", {
            get: function () {
                return this._axis;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartPlotAreaTwofoldSubBase.prototype, "state", {
            get: function () {
                return this._plotArea.state;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartPlotAreaTwofoldSubBase.prototype, "view", {
            get: function () {
                return this._plotArea.view;
            },
            enumerable: false,
            configurable: true
        });
        // eslint-disable-next-line @typescript-eslint/ban-types
        DChartPlotAreaTwofoldSubBase.prototype.on = function (name, callback, context) {
            this._plotArea.on(name, callback, context);
            return this;
        };
        // eslint-disable-next-line @typescript-eslint/ban-types
        DChartPlotAreaTwofoldSubBase.prototype.off = function (name, callback, context) {
            this._plotArea.off(name, callback, context);
            return this;
        };
        DChartPlotAreaTwofoldSubBase.prototype.getPixelDomain = function (result) {
            var plotArea = this._plotArea;
            var padding = plotArea.padding;
            var width = plotArea.width;
            return result.set(padding.getLeft(), width - padding.getRight());
        };
        DChartPlotAreaTwofoldSubBase.prototype.getAxisBounds = function (position) {
            return this.getPixelBounds();
        };
        DChartPlotAreaTwofoldSubBase.prototype.getSelectionBoundsX = function () {
            return this.getPixelBounds();
        };
        DChartPlotAreaTwofoldSubBase.prototype.getSelectionBoundsY = function () {
            return this.getPixelBounds();
        };
        DChartPlotAreaTwofoldSubBase.prototype.toBoundsDirty = function () {
            this._isContainerBoundsDirty = true;
        };
        DChartPlotAreaTwofoldSubBase.prototype.toLocal = function (position, from, result, skipUpdate) {
            return this._plotArea.toLocal(position, from, result, skipUpdate);
        };
        DChartPlotAreaTwofoldSubBase.prototype.destroy = function () {
            this._container.destroy();
            this._series.destroy();
            this._axis.destroy();
        };
        return DChartPlotAreaTwofoldSubBase;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartPlotAreaTwofoldSubPrimary = /** @class */ (function (_super) {
        __extends(DChartPlotAreaTwofoldSubPrimary, _super);
        function DChartPlotAreaTwofoldSubPrimary() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DChartPlotAreaTwofoldSubPrimary.prototype.getOverflowMask = function () {
            if (this._overflowMask == null) {
                var plotArea = this._plotArea;
                this._overflowMask = new DChartPlotAreaTwofoldOverflowMaskPrimary(plotArea);
                plotArea.reflowable.add(this._overflowMask);
                plotArea.toDirty();
            }
            return this._overflowMask;
        };
        DChartPlotAreaTwofoldSubPrimary.prototype.getPixelRange = function (result) {
            var plotArea = this._plotArea;
            var padding = plotArea.padding;
            var paddingTop = padding.getTop();
            var height = plotArea.height;
            return result.set((height - this._margin) * 0.5, paddingTop);
        };
        DChartPlotAreaTwofoldSubPrimary.prototype.getPixelBounds = function () {
            var result = this._plotArea.getPixelBounds();
            result.height *= 0.5;
            return result;
        };
        DChartPlotAreaTwofoldSubPrimary.prototype.getContainerBounds = function () {
            var result = this._containerBounds;
            if (this._isContainerBoundsDirty) {
                this._isContainerBoundsDirty = false;
                var bounds = this._plotArea.getContainerBounds();
                result.width = bounds.width;
                result.height = bounds.height * 0.5;
                result.x = bounds.x;
                result.y = bounds.y;
            }
            return result;
        };
        return DChartPlotAreaTwofoldSubPrimary;
    }(DChartPlotAreaTwofoldSubBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartPlotAreaTwofoldSubSecondary = /** @class */ (function (_super) {
        __extends(DChartPlotAreaTwofoldSubSecondary, _super);
        function DChartPlotAreaTwofoldSubSecondary() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DChartPlotAreaTwofoldSubSecondary.prototype.getOverflowMask = function () {
            if (this._overflowMask == null) {
                var plotArea = this._plotArea;
                this._overflowMask = new DChartPlotAreaTwofoldOverflowMaskSecondary(plotArea);
                plotArea.reflowable.add(this._overflowMask);
                plotArea.toDirty();
            }
            return this._overflowMask;
        };
        DChartPlotAreaTwofoldSubSecondary.prototype.getPixelRange = function (result) {
            var plotArea = this._plotArea;
            var padding = plotArea.padding;
            var paddingBottom = padding.getBottom();
            var height = plotArea.height;
            return result.set(height - paddingBottom, (height + this._margin) * 0.5);
        };
        DChartPlotAreaTwofoldSubSecondary.prototype.getPixelBounds = function () {
            var result = this._plotArea.getPixelBounds();
            result.height *= 0.5;
            result.y = result.height;
            return result;
        };
        DChartPlotAreaTwofoldSubSecondary.prototype.getContainerBounds = function () {
            var result = this._containerBounds;
            if (this._isContainerBoundsDirty) {
                this._isContainerBoundsDirty = false;
                var bounds = this._plotArea.getContainerBounds();
                result.width = bounds.width;
                result.height = bounds.height * 0.5;
                result.x = bounds.x;
                result.y = bounds.y + result.height;
            }
            return result;
        };
        return DChartPlotAreaTwofoldSubSecondary;
    }(DChartPlotAreaTwofoldSubBase));

    var DChartPlotAreaTwofoldViewTargetPoint = /** @class */ (function () {
        function DChartPlotAreaTwofoldViewTargetPoint(primary, secondary) {
            this._primary = primary;
            this._secondary = secondary;
        }
        Object.defineProperty(DChartPlotAreaTwofoldViewTargetPoint.prototype, "x", {
            get: function () {
                return this._secondary.x;
            },
            set: function (x) {
                this._primary.x = x;
                this._secondary.x = x;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartPlotAreaTwofoldViewTargetPoint.prototype, "y", {
            get: function () {
                return this._secondary.y;
            },
            set: function (y) {
                this._primary.y = y;
                this._secondary.y = y;
            },
            enumerable: false,
            configurable: true
        });
        DChartPlotAreaTwofoldViewTargetPoint.prototype.set = function (x, y) {
            this._primary.set(x, y);
            this._secondary.set(x, y);
            return this;
        };
        return DChartPlotAreaTwofoldViewTargetPoint;
    }());
    var DChartPlotAreaTwofoldViewTarget = /** @class */ (function () {
        function DChartPlotAreaTwofoldViewTarget(primary, secondary) {
            this._primary = primary;
            this._secondary = secondary;
            this._scale = new DChartPlotAreaTwofoldViewTargetPoint(primary.scale, secondary.scale);
            this._position = new DChartPlotAreaTwofoldViewTargetPoint(primary.position, secondary.position);
        }
        Object.defineProperty(DChartPlotAreaTwofoldViewTarget.prototype, "scale", {
            get: function () {
                return this._scale;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartPlotAreaTwofoldViewTarget.prototype, "position", {
            get: function () {
                return this._position;
            },
            enumerable: false,
            configurable: true
        });
        DChartPlotAreaTwofoldViewTarget.prototype.getLocalBounds = function (rect) {
            this._primary.getLocalBounds(rect);
            var x1 = rect.x;
            var y1 = rect.y;
            var w1 = rect.width;
            var h1 = rect.height;
            this._secondary.getLocalBounds(rect);
            var x2 = rect.x;
            var y2 = rect.y;
            var w2 = rect.width;
            var h2 = rect.height;
            var x3 = Math.min(x1, x2);
            var y3 = Math.min(y1, y2);
            var x4 = Math.max(x1 + w1, x2 + w2);
            var y4 = Math.max(y1 + h1, y2 + h2);
            rect.x = x3;
            rect.y = y3;
            rect.width = x4 - x3;
            rect.height = y4 - y3;
            return rect;
        };
        return DChartPlotAreaTwofoldViewTarget;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartPlotAreaTwofold = /** @class */ (function (_super) {
        __extends(DChartPlotAreaTwofold, _super);
        function DChartPlotAreaTwofold(chart, options) {
            var _a, _b, _c, _d, _e, _f, _g;
            var _this = _super.call(this, chart, options) || this;
            // Margin
            var theme = _this.theme;
            var margin = (_a = options === null || options === void 0 ? void 0 : options.margin) !== null && _a !== void 0 ? _a : theme.getMargin();
            _this._margin = margin;
            // Primary
            var axisShapeContainer = new EShapeContainer();
            var onContainerChangeBound = function () {
                _this.onContainerChange();
            };
            var mask = (_b = options === null || options === void 0 ? void 0 : options.mask) !== null && _b !== void 0 ? _b : theme.isOverflowMaskEnabled();
            var primaryOptions = options === null || options === void 0 ? void 0 : options.primary;
            var primary = new DChartPlotAreaTwofoldSubPrimary(_this, onContainerChangeBound, mask, margin, axisShapeContainer, primaryOptions);
            _this._primary = primary;
            // Secondary
            var secondaryOptions = options === null || options === void 0 ? void 0 : options.secondary;
            var secondary = new DChartPlotAreaTwofoldSubSecondary(_this, onContainerChangeBound, mask, margin, axisShapeContainer, secondaryOptions);
            _this._secondary = secondary;
            // Container
            _this.addChild(primary.container);
            _this.addChild(secondary.container);
            // Coordinate
            _this._coordinate = new DChartPlotAreaTwofoldCoorinateContainer(_this, primary.coordinate, secondary.coordinate);
            // Series
            var primarySeries = primary.series;
            var secondarySeries = secondary.series;
            var series = new DChartPlotAreaTwofoldSeriesContainer(_this, primarySeries, secondarySeries);
            _this._series = series;
            // Axis
            var primaryAxis = primary.axis;
            var secondaryAxis = secondary.axis;
            _this.addChild(axisShapeContainer);
            var axis = new DChartPlotAreaTwofoldAxisContainer(_this, axisShapeContainer, primaryAxis, secondaryAxis);
            _this._axis = axis;
            // Add Series
            _this.addSeries(primarySeries, (_c = primaryOptions === null || primaryOptions === void 0 ? void 0 : primaryOptions.series) === null || _c === void 0 ? void 0 : _c.list);
            _this.addSeries(secondarySeries, (_d = secondaryOptions === null || secondaryOptions === void 0 ? void 0 : secondaryOptions.series) === null || _d === void 0 ? void 0 : _d.list);
            // Add Axes
            _this.addAxes(primaryAxis, (_e = primaryOptions === null || primaryOptions === void 0 ? void 0 : primaryOptions.axis) === null || _e === void 0 ? void 0 : _e.list);
            _this.addAxes(secondaryAxis, (_f = secondaryOptions === null || secondaryOptions === void 0 ? void 0 : secondaryOptions.axis) === null || _f === void 0 ? void 0 : _f.list);
            _this.addAxes(axis, (_g = options === null || options === void 0 ? void 0 : options.axis) === null || _g === void 0 ? void 0 : _g.list);
            // Selection
            var selection = options === null || options === void 0 ? void 0 : options.selection;
            if (selection != null) {
                primarySeries.selection = selection;
                secondarySeries.selection = selection;
                selection.bind(series);
            }
            return _this;
        }
        DChartPlotAreaTwofold.prototype.onResize = function (newWidth, newHeight, oldWidth, oldHeight) {
            this._primary.toBoundsDirty();
            this._secondary.toBoundsDirty();
            _super.prototype.onResize.call(this, newWidth, newHeight, oldWidth, oldHeight);
        };
        DChartPlotAreaTwofold.prototype.addSeries = function (series, list) {
            if (list != null) {
                var listLength = list.length;
                if (0 < listLength) {
                    for (var i = 0; i < listLength; ++i) {
                        series.add(list[i]);
                    }
                    series.update();
                }
            }
        };
        DChartPlotAreaTwofold.prototype.addAxes = function (axis, list) {
            if (list != null) {
                for (var i = 0, imax = list.length; i < imax; ++i) {
                    axis.add(list[i]);
                }
            }
        };
        Object.defineProperty(DChartPlotAreaTwofold.prototype, "primary", {
            get: function () {
                return this._primary;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartPlotAreaTwofold.prototype, "secondary", {
            get: function () {
                return this._secondary;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartPlotAreaTwofold.prototype, "container", {
            get: function () {
                return this.secondary.container;
            },
            enumerable: false,
            configurable: true
        });
        DChartPlotAreaTwofold.prototype.onContainerChange = function () {
            this._isViewDirty = true;
            this._isContainerBoundsDirty = true;
            this._primary.toBoundsDirty();
            this._secondary.toBoundsDirty();
            DApplications.update(this);
        };
        Object.defineProperty(DChartPlotAreaTwofold.prototype, "coordinate", {
            get: function () {
                return this._coordinate;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartPlotAreaTwofold.prototype, "series", {
            get: function () {
                return this._series;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartPlotAreaTwofold.prototype, "axis", {
            get: function () {
                return this._axis;
            },
            enumerable: false,
            configurable: true
        });
        DChartPlotAreaTwofold.prototype.newView = function (options) {
            var _this = this;
            var viewTarget;
            var toViewTarget = function () {
                return (viewTarget !== null && viewTarget !== void 0 ? viewTarget : (viewTarget = new DChartPlotAreaTwofoldViewTarget(_this._primary.container, _this._secondary.container)));
            };
            return new DViewImpl(this, toViewTarget, options === null || options === void 0 ? void 0 : options.view);
        };
        DChartPlotAreaTwofold.prototype.onViewDirty = function () {
            this._coordinate.fit();
            this._axis.onRender();
            this._series.onRender();
        };
        DChartPlotAreaTwofold.prototype.fit = function (duration, domainFrom, domainTo, rangeFrom, rangeTo) {
            if (duration != null && duration <= 0) {
                var primary = this.primary;
                primary.coordinate.fit(domainFrom, domainTo, rangeFrom, rangeTo);
                primary.axis.update();
                primary.series.update();
                var secondary = this.secondary;
                secondary.coordinate.fit(domainFrom, domainTo, rangeFrom, rangeTo);
                secondary.axis.update();
                secondary.series.update();
            }
            else {
                this._blendDuration = duration != null ? duration : 200;
                this._blendStartTime = Date.now();
                this.primary.coordinate.mark(domainFrom, domainTo, rangeFrom, rangeTo);
                this.secondary.coordinate.mark(domainFrom, domainTo, rangeFrom, rangeTo);
                var blendTimeout = this._blendTimeout;
                if (blendTimeout != null) {
                    window.clearTimeout(blendTimeout);
                }
                this._blendTimeout = window.setTimeout(this._onBlendBound, 0);
            }
            return this;
        };
        DChartPlotAreaTwofold.prototype.onBlend = function () {
            var now = Date.now();
            var ratio = (now - this._blendStartTime) / this._blendDuration;
            if (ratio < 1) {
                this._blendTimeout = window.setTimeout(this._onBlendBound, 0);
            }
            else {
                this._blendTimeout = null;
                ratio = 1;
            }
            var t = DAnimationTimings.ELASTIC(ratio);
            var primary = this.primary;
            primary.coordinate.blend(t);
            primary.axis.update();
            primary.series.update();
            var secondary = this.secondary;
            secondary.coordinate.blend(t);
            secondary.axis.update();
            secondary.series.update();
        };
        DChartPlotAreaTwofold.prototype.destroy = function () {
            var _a, _b;
            (_a = this._primary) === null || _a === void 0 ? void 0 : _a.destroy();
            (_b = this._secondary) === null || _b === void 0 ? void 0 : _b.destroy();
            this._axis.destroy();
        };
        return DChartPlotAreaTwofold;
    }(DChartPlotAreaBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartRegionImplObservable = /** @class */ (function () {
        function DChartRegionImplObservable(from, to, onChange) {
            this._from = from;
            this._to = to;
            this._onChange = onChange;
        }
        Object.defineProperty(DChartRegionImplObservable.prototype, "from", {
            get: function () {
                return this._from;
            },
            set: function (from) {
                this.set(from, undefined);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartRegionImplObservable.prototype, "to", {
            get: function () {
                return this._to;
            },
            set: function (to) {
                this.set(undefined, to);
            },
            enumerable: false,
            configurable: true
        });
        DChartRegionImplObservable.prototype.set = function (from, to) {
            var isChanged = false;
            if (from != null && this._from !== from) {
                if (!isNaN$1(this._from) || !isNaN$1(from)) {
                    this._from = from;
                    isChanged = true;
                }
            }
            if (to != null && this._to !== to) {
                if (!isNaN$1(this._to) || !isNaN$1(to)) {
                    this._to = to;
                    isChanged = true;
                }
            }
            if (isChanged) {
                this._onChange();
            }
            return this;
        };
        DChartRegionImplObservable.prototype.add = function (from, to) {
            var newFrom;
            if (!isNaN$1(from)) {
                newFrom = isNaN$1(this.from) ? from : Math.min(this.from, from);
            }
            var newTo;
            if (!isNaN$1(to)) {
                newTo = isNaN$1(this.to) ? to : Math.max(this.to, to);
            }
            return this.set(newFrom, newTo);
        };
        DChartRegionImplObservable.prototype.clear = function () {
            return this.set(NaN, NaN);
        };
        return DChartRegionImplObservable;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartSelectionContainerImpl = /** @class */ (function () {
        function DChartSelectionContainerImpl(x, y) {
            this._x = x;
            this._y = y;
        }
        Object.defineProperty(DChartSelectionContainerImpl.prototype, "x", {
            get: function () {
                return this._x;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartSelectionContainerImpl.prototype, "y", {
            get: function () {
                return this._y;
            },
            enumerable: false,
            configurable: true
        });
        DChartSelectionContainerImpl.prototype.bind = function (container) {
            this._x.bind(container);
            this._y.bind(container);
        };
        DChartSelectionContainerImpl.prototype.unbind = function () {
            this._x.unbind();
            this._y.unbind();
        };
        DChartSelectionContainerImpl.prototype.set = function (container, position, mappedPosition, series) {
            this._x.set(container, position, mappedPosition, series);
            this._y.set(container, position, mappedPosition, series);
        };
        DChartSelectionContainerImpl.prototype.unset = function () {
            this._x.unset();
            this._y.unset();
        };
        DChartSelectionContainerImpl.prototype.update = function (container, position, mappedPosition, series) {
            var isXUpdated = this._x.update(container, position, mappedPosition, series);
            var isYUpdated = this._y.update(container, position, mappedPosition, series);
            return isXUpdated || isYUpdated;
        };
        return DChartSelectionContainerImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartSelectionShapeBase = /** @class */ (function () {
        function DChartSelectionShapeBase(options) {
            var _a, _b, _c;
            var theme = this.toTheme(options);
            this._theme = theme;
            var state = new DBaseStateSetImpl().add((_a = options === null || options === void 0 ? void 0 : options.state) !== null && _a !== void 0 ? _a : DBaseState.HOVERED);
            this._state = state;
            this._isEnabled = (_b = options === null || options === void 0 ? void 0 : options.enable) !== null && _b !== void 0 ? _b : theme.isEnabled(state);
            if (options != null) {
                var shape = options.shape;
                if (shape != null) {
                    if (isFunction(shape)) {
                        this._newShape = shape;
                    }
                    else {
                        this._shape = shape;
                    }
                }
            }
            this._style = (_c = options === null || options === void 0 ? void 0 : options.style) !== null && _c !== void 0 ? _c : this.setStyle;
        }
        DChartSelectionShapeBase.prototype.bind = function (container) {
            if (this._isEnabled) {
                var shape = this._shape;
                if (shape == null) {
                    var state = this._state;
                    var newShape = this._newShape;
                    if (newShape != null) {
                        shape = newShape(state);
                    }
                    else {
                        shape = this.newShape(state, this._theme);
                    }
                }
                this._shape = shape;
                shape.attach(container.plotArea.axis.container);
                shape.visible = false;
            }
        };
        DChartSelectionShapeBase.prototype.unbind = function () {
            var shape = this._shape;
            if (shape) {
                shape.detach();
            }
        };
        DChartSelectionShapeBase.prototype.newShape = function (state, theme) {
            return theme.newShape(state);
        };
        DChartSelectionShapeBase.prototype.set = function (container, position, mappedPosition, series) {
            this.update(container, position, mappedPosition, series);
            var shape = this._shape;
            if (shape != null) {
                this._style(shape, series);
            }
        };
        DChartSelectionShapeBase.prototype.setStyle = function (shape, series) {
            // DO NOTHING
        };
        DChartSelectionShapeBase.prototype.unset = function () {
            var shape = this._shape;
            if (shape) {
                shape.visible = false;
            }
        };
        DChartSelectionShapeBase.prototype.toTheme = function (options) {
            var theme = options === null || options === void 0 ? void 0 : options.theme;
            if (isString(theme)) {
                return this.getTheme(theme);
            }
            else if (theme != null) {
                return theme;
            }
            else {
                return this.getTheme(this.getType());
            }
        };
        DChartSelectionShapeBase.prototype.getTheme = function (type) {
            return DThemes.getInstance().get(type);
        };
        return DChartSelectionShapeBase;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartSelectionGridlineX = /** @class */ (function (_super) {
        __extends(DChartSelectionGridlineX, _super);
        function DChartSelectionGridlineX() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DChartSelectionGridlineX.prototype.update = function (container, position, mappedPosition, series) {
            var shape = this._shape;
            if (shape) {
                var mappedX = mappedPosition.x;
                var bounds = container.plotArea.getSelectionBoundsX();
                shape.transform.position.set(mappedX, bounds.y + bounds.height * 0.5);
                shape.size.set(0, bounds.height);
                var hw = shape.stroke.width * 0.5;
                shape.visible = bounds.x <= mappedX + hw && mappedX - hw <= bounds.x + bounds.width;
                return true;
            }
            return false;
        };
        DChartSelectionGridlineX.prototype.getType = function () {
            return "DChartSelectionGridlineX";
        };
        return DChartSelectionGridlineX;
    }(DChartSelectionShapeBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartSelectionGridlineY = /** @class */ (function (_super) {
        __extends(DChartSelectionGridlineY, _super);
        function DChartSelectionGridlineY() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DChartSelectionGridlineY.prototype.update = function (container, position, mappedPosition, series) {
            var shape = this._shape;
            if (shape) {
                var mappedY = mappedPosition.y;
                var bounds = container.plotArea.getSelectionBoundsY();
                shape.transform.position.set(bounds.x + bounds.width * 0.5, mappedY);
                shape.size.set(bounds.width, 0);
                var hw = shape.stroke.width * 0.5;
                shape.visible = bounds.y <= mappedY + hw && mappedY - hw <= bounds.y + bounds.height;
                return true;
            }
            return false;
        };
        DChartSelectionGridlineY.prototype.getType = function () {
            return "DChartSelectionGridlineY";
        };
        return DChartSelectionGridlineY;
    }(DChartSelectionShapeBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartSelectionMarker = /** @class */ (function (_super) {
        __extends(DChartSelectionMarker, _super);
        function DChartSelectionMarker() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DChartSelectionMarker.prototype.update = function (container, position, mappedPosition, series) {
            var shape = this._shape;
            if (shape) {
                shape.transform.position.copyFrom(mappedPosition);
                shape.visible = this.isVisible(container, position, mappedPosition, series);
                return true;
            }
            return false;
        };
        DChartSelectionMarker.prototype.isVisible = function (container, position, mappedPosition, series) {
            container = (series === null || series === void 0 ? void 0 : series.container) || container;
            var x = mappedPosition.x;
            var y = mappedPosition.y;
            var bounds = container.plotArea.getPixelBounds();
            return (bounds.x <= x &&
                x <= bounds.x + bounds.width &&
                bounds.y <= y &&
                y <= bounds.y + bounds.height);
        };
        DChartSelectionMarker.prototype.getType = function () {
            return "DChartSelectionMarker";
        };
        return DChartSelectionMarker;
    }(DChartSelectionShapeBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartSelectionPoint = {
        PREVIOUS: 0,
        NEXT: 1,
        CLOSER: 2,
        INTERSECTION: 3
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartSelectionSubImpl = /** @class */ (function (_super) {
        __extends(DChartSelectionSubImpl, _super);
        function DChartSelectionSubImpl(options) {
            var _a, _b, _c;
            var _this = _super.call(this) || this;
            _this._container = null;
            _this._series = null;
            _this._isEnabled = (_a = options.enable) !== null && _a !== void 0 ? _a : true;
            _this._isVisible = false;
            var gridline = options.gridline;
            if (gridline != null) {
                _this._gridline = new DChartSelectionContainerImpl(new DChartSelectionGridlineX(gridline.x), new DChartSelectionGridlineY(gridline.y));
            }
            else {
                _this._gridline = new DChartSelectionContainerImpl(new DChartSelectionGridlineX(), new DChartSelectionGridlineY());
            }
            _this._marker = new DChartSelectionMarker(options.marker);
            _this._state = (_b = options.state) !== null && _b !== void 0 ? _b : DBaseState.HOVERED;
            _this._coordinateX = null;
            _this._coordinateY = null;
            _this._position = new pixi_js.Point();
            _this._point = (_c = options.point) !== null && _c !== void 0 ? _c : DChartSelectionPoint.CLOSER;
            _this._work = new pixi_js.Point();
            // Events
            var on = options.on;
            if (on) {
                for (var name_1 in on) {
                    var handler = on[name_1];
                    if (handler) {
                        _this.on(name_1, handler);
                    }
                }
            }
            return _this;
        }
        DChartSelectionSubImpl.prototype.bind = function (container) {
            if (this._isEnabled) {
                this._container = container;
                this._gridline.bind(container);
                this._marker.bind(container);
            }
        };
        DChartSelectionSubImpl.prototype.unbind = function () {
            this._marker.unbind();
            this._gridline.unbind();
            this._container = null;
            this._coordinateX = null;
            this._coordinateY = null;
        };
        Object.defineProperty(DChartSelectionSubImpl.prototype, "visible", {
            get: function () {
                return this._isVisible;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartSelectionSubImpl.prototype, "series", {
            get: function () {
                return this._series;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartSelectionSubImpl.prototype, "position", {
            get: function () {
                return this._position;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartSelectionSubImpl.prototype, "gridline", {
            get: function () {
                return this._gridline;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartSelectionSubImpl.prototype, "marker", {
            get: function () {
                return this._marker;
            },
            enumerable: false,
            configurable: true
        });
        DChartSelectionSubImpl.prototype.set = function (series, result) {
            if (isNumber(series)) {
                this.set1(series, result);
            }
            else {
                this.set2(series, result);
            }
        };
        DChartSelectionSubImpl.prototype.set1 = function (x, y) {
            var container = this._container;
            if (container == null) {
                return;
            }
            var work = this._work;
            work.set(x, y);
            var plotArea = container.plotArea;
            plotArea.container.toLocal(work, undefined, work, true);
            var coordinate = plotArea.coordinate;
            var coordinateX = coordinate.x.get(0);
            var coordinateY = coordinate.y.get(0);
            var newPositionX = work.x;
            var newPositionY = work.y;
            if (coordinateX && coordinateY) {
                newPositionX = coordinateX.unmap(coordinateX.transform.unmap(newPositionX));
                newPositionY = coordinateY.unmap(coordinateY.transform.unmap(newPositionY));
            }
            else {
                coordinateX = null;
                coordinateY = null;
            }
            var oldSeries = this._series;
            var position = this._position;
            if (this._isVisible &&
                oldSeries == null &&
                newPositionX === position.x &&
                newPositionY === position.y) {
                return;
            }
            this._isVisible = true;
            position.set(newPositionX, newPositionY);
            this._coordinateX = coordinateX;
            this._coordinateY = coordinateY;
            plotArea.container.localTransform.apply(work, work);
            this._gridline.set(container, position, work, null);
            this._marker.set(container, position, work, null);
            if (oldSeries != null) {
                var state = this._state;
                if (oldSeries) {
                    oldSeries.state.remove(state);
                }
                this._series = null;
            }
            this.emit("change", this);
            DApplications.update(plotArea);
        };
        DChartSelectionSubImpl.prototype.set2 = function (series, result) {
            var container = this._container;
            if (container == null) {
                return;
            }
            var work = this._work;
            var x = result.x;
            var y = result.y;
            switch (this._point) {
                case DChartSelectionPoint.PREVIOUS:
                    x = result.p0x;
                    y = result.p0y;
                    break;
                case DChartSelectionPoint.NEXT:
                    x = result.p1x;
                    y = result.p1y;
                    break;
                case DChartSelectionPoint.CLOSER:
                    if (Math.abs(result.p0x - result.x) < Math.abs(result.p1x - result.x)) {
                        x = result.p0x;
                        y = result.p0y;
                    }
                    else {
                        x = result.p1x;
                        y = result.p1y;
                    }
            }
            work.set(x, y);
            var plotArea = container.plotArea;
            plotArea.container.localTransform.apply(work, work);
            var coordinateX = series.coordinate.x;
            var coordinateY = series.coordinate.y;
            var newPositionX = x;
            var newPositionY = y;
            if (coordinateX && coordinateY) {
                newPositionX = coordinateX.unmap(coordinateX.transform.unmap(newPositionX));
                newPositionY = coordinateY.unmap(coordinateY.transform.unmap(newPositionY));
            }
            else {
                coordinateX = null;
                coordinateY = null;
            }
            var oldSeries = this._series;
            var position = this._position;
            if (this._isVisible &&
                oldSeries === series &&
                newPositionX === position.x &&
                newPositionY === position.y) {
                return;
            }
            this._isVisible = true;
            position.set(newPositionX, newPositionY);
            this._coordinateX = coordinateX;
            this._coordinateY = coordinateY;
            this._gridline.set(container, position, work, series);
            this._marker.set(container, position, work, series);
            if (oldSeries !== series) {
                var state = this._state;
                if (oldSeries) {
                    oldSeries.state.remove(state);
                }
                this._series = series;
                series.state.add(state);
            }
            this.emit("change", this);
            DApplications.update(plotArea);
        };
        DChartSelectionSubImpl.prototype.unset = function () {
            var container = this._container;
            if (container == null) {
                return;
            }
            var oldSeries = this._series;
            if (!this._isVisible && oldSeries == null) {
                return;
            }
            this._isVisible = false;
            this._coordinateX = null;
            this._coordinateY = null;
            this._gridline.unset();
            this._marker.unset();
            if (oldSeries != null) {
                this._series = null;
                oldSeries.state.remove(this._state);
            }
            this.emit("change", this);
            DApplications.update(container.plotArea);
        };
        DChartSelectionSubImpl.prototype.update = function () {
            var container = this._container;
            if (container == null) {
                return false;
            }
            if (!this._isVisible) {
                return false;
            }
            var position = this._position;
            var work = this._work;
            var coordinateX = this._coordinateX;
            var coordinateY = this._coordinateY;
            if (coordinateX && coordinateY) {
                work.set(coordinateX.transform.map(coordinateX.map(position.x)), coordinateY.transform.map(coordinateY.map(position.y)));
            }
            else {
                work.copyFrom(position);
            }
            container.plotArea.container.localTransform.apply(work, work);
            var series = this._series;
            var isGridlineUpdated = this._gridline.update(container, position, work, series);
            var isMarkerUpdated = this._marker.update(container, position, work, series);
            return isGridlineUpdated || isMarkerUpdated;
        };
        return DChartSelectionSubImpl;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartSelectionSimple = /** @class */ (function (_super) {
        __extends(DChartSelectionSimple, _super);
        function DChartSelectionSimple(options) {
            var _a;
            var _this = _super.call(this) || this;
            _this._container = null;
            var point = toEnum((_a = options === null || options === void 0 ? void 0 : options.point) !== null && _a !== void 0 ? _a : DChartSelectionPoint.CLOSER, DChartSelectionPoint);
            _this._selected = _this.newSelected(point, options === null || options === void 0 ? void 0 : options.selected);
            _this._hovered = _this.newHovered(point, options === null || options === void 0 ? void 0 : options.hovered);
            _this._dismiss = _this.toDismiss(options);
            // Events
            var on = options === null || options === void 0 ? void 0 : options.on;
            if (on != null) {
                for (var name_1 in on) {
                    var handler = on[name_1];
                    if (handler) {
                        _this.on(name_1, handler);
                    }
                }
            }
            _this._onMoveBound = function (e) {
                _this.onMove(e);
            };
            _this._onTapBound = function (target, e) {
                _this.onTap(e);
            };
            _this._onLongPressBound = function (target, e) {
                _this.onLongPress(e);
            };
            return _this;
        }
        DChartSelectionSimple.prototype.toDismiss = function (options) {
            var _a;
            if (options != null) {
                var dismiss = options.dismiss;
                if (dismiss != null) {
                    return {
                        enable: (_a = dismiss.enable) !== null && _a !== void 0 ? _a : true,
                        tap: this.toDismissTap(dismiss.tap),
                        longPress: this.toDismissLongPress(dismiss.longPress),
                        noSeries: this.toDismissNoSeries(dismiss.noSeries)
                    };
                }
            }
            return {
                enable: true,
                tap: this.toDismissTap(),
                longPress: this.toDismissLongPress(),
                noSeries: this.toDismissNoSeries()
            };
        };
        DChartSelectionSimple.prototype.toDismissTap = function (options) {
            var _a, _b;
            return {
                enable: (_a = options === null || options === void 0 ? void 0 : options.enable) !== null && _a !== void 0 ? _a : true,
                modifier: toEnum((_b = options === null || options === void 0 ? void 0 : options.modifier) !== null && _b !== void 0 ? _b : UtilGestureModifier.NOT_NONE, UtilGestureModifier)
            };
        };
        DChartSelectionSimple.prototype.toDismissLongPress = function (options) {
            var _a;
            return {
                enable: (_a = options === null || options === void 0 ? void 0 : options.enable) !== null && _a !== void 0 ? _a : true
            };
        };
        DChartSelectionSimple.prototype.toDismissNoSeries = function (options) {
            var _a;
            return {
                enable: (_a = options === null || options === void 0 ? void 0 : options.enable) !== null && _a !== void 0 ? _a : true
            };
        };
        DChartSelectionSimple.prototype.newSelected = function (point, options) {
            return new DChartSelectionSubImpl(this.toSelectedOptions(point, options));
        };
        DChartSelectionSimple.prototype.newHovered = function (point, options) {
            return new DChartSelectionSubImpl(this.toHoveredOptions(point, options));
        };
        DChartSelectionSimple.prototype.toSelectedOptions = function (point, options) {
            return this.toSubOptions(point, options, DBaseState.ACTIVE);
        };
        DChartSelectionSimple.prototype.toHoveredOptions = function (point, options) {
            return this.toSubOptions(point, options, DBaseState.HOVERED);
        };
        DChartSelectionSimple.prototype.toSubOptions = function (point, options, state) {
            var _a, _b, _c, _d, _e, _f, _g;
            options = options || {};
            if (options.point == null) {
                options.point = point;
            }
            if (options.state == null) {
                options.state = state;
            }
            var gridline = ((_a = options.gridline) !== null && _a !== void 0 ? _a : (options.gridline = {}));
            var gridlineX = ((_b = gridline.x) !== null && _b !== void 0 ? _b : (gridline.x = {}));
            if (gridlineX.state == null) {
                gridlineX.state = state;
            }
            var gridlineY = ((_c = gridline.y) !== null && _c !== void 0 ? _c : (gridline.y = {}));
            if (gridlineY.state == null) {
                gridlineY.state = state;
            }
            var marker = ((_d = options.marker) !== null && _d !== void 0 ? _d : (options.marker = {}));
            if (marker.state == null) {
                marker.state = state;
            }
            var label = ((_e = options.label) !== null && _e !== void 0 ? _e : (options.label = {}));
            var labelX = ((_f = label.x) !== null && _f !== void 0 ? _f : (label.x = {}));
            if (labelX.state == null) {
                labelX.state = state;
            }
            var labelY = ((_g = label.y) !== null && _g !== void 0 ? _g : (label.y = {}));
            if (labelY.state == null) {
                labelY.state = state;
            }
            return options;
        };
        DChartSelectionSimple.prototype.onTap = function (e) {
            var container = this._container;
            if (container == null) {
                return;
            }
            var dismiss = this._dismiss;
            var selected = this._selected;
            if (dismiss.enable &&
                dismiss.tap.enable &&
                UtilGestureModifiers.match(e, dismiss.tap.modifier)) {
                selected.unset();
            }
            else {
                var result = DChartSelectionSimple.WORK_SELECT;
                var global_1 = e.data.global;
                var series = container.calcHitPoint(global_1.x, global_1.y, result);
                if (series != null) {
                    selected.set(series, result);
                }
                else {
                    if (dismiss.enable && dismiss.noSeries.enable) {
                        selected.unset();
                    }
                    else {
                        selected.set(global_1.x, global_1.y);
                    }
                }
            }
        };
        DChartSelectionSimple.prototype.onLongPress = function (e) {
            var container = this._container;
            if (container == null) {
                return;
            }
            var dismiss = this._dismiss;
            if (dismiss.enable && dismiss.longPress.enable) {
                this._selected.unset();
            }
        };
        DChartSelectionSimple.prototype.onMove = function (e) {
            var container = this._container;
            if (container == null) {
                return;
            }
            var plotArea = container.plotArea;
            if (plotArea.state.isGesturing) {
                return;
            }
            var hovered = this._hovered;
            if (e.target === container.plotArea) {
                var result = DChartSelectionSimple.WORK_SELECT;
                var global_2 = e.data.global;
                var series = container.calcHitPoint(global_2.x, global_2.y, result);
                if (series != null) {
                    hovered.set(series, result);
                }
                else {
                    hovered.unset();
                }
            }
            else {
                hovered.unset();
            }
        };
        DChartSelectionSimple.prototype.bind = function (container) {
            this._container = container;
            this._selected.bind(container);
            this._hovered.bind(container);
            var plotArea = container.plotArea;
            var plotAreaView = plotArea.view;
            plotArea.on(UtilPointerEvent.move, this._onMoveBound);
            plotAreaView.on("gesturetap", this._onTapBound);
            plotAreaView.on("gesturelongpress", this._onLongPressBound);
        };
        DChartSelectionSimple.prototype.unbind = function () {
            var container = this._container;
            this._container = null;
            if (container != null) {
                var plotArea = container.plotArea;
                var plotAreaView = plotArea.view;
                plotArea.off(UtilPointerEvent.move, this._onMoveBound);
                plotAreaView.off("gesturetap", this._onTapBound);
                plotAreaView.off("gesturelongpress", this._onLongPressBound);
            }
            this._selected.unbind();
            this._hovered.unbind();
        };
        Object.defineProperty(DChartSelectionSimple.prototype, "selected", {
            get: function () {
                return this._selected;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartSelectionSimple.prototype, "hovered", {
            get: function () {
                return this._hovered;
            },
            enumerable: false,
            configurable: true
        });
        DChartSelectionSimple.prototype.update = function () {
            var isSelectedUpdated = this._selected.update();
            var isHoveredUpdated = this._hovered.update();
            if (isSelectedUpdated || isHoveredUpdated) {
                var container = this._container;
                if (container != null) {
                    DApplications.update(container.plotArea);
                }
            }
        };
        DChartSelectionSimple.prototype.onRender = function () {
            this._selected.update();
            this._hovered.update();
        };
        DChartSelectionSimple.WORK_SELECT = new DChartSeriesHitResult();
        return DChartSelectionSimple;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartSeriesBaseCoordinateContainer = /** @class */ (function () {
        function DChartSeriesBaseCoordinateContainer(parent, options) {
            var _a, _b;
            this._parent = parent;
            this._coordinateIndexX = (_a = options === null || options === void 0 ? void 0 : options.x) !== null && _a !== void 0 ? _a : 0;
            this._coordinateIndexY = (_b = options === null || options === void 0 ? void 0 : options.y) !== null && _b !== void 0 ? _b : 0;
            this._coordinateIdUpdatedX = NaN;
            this._coordinateIdUpdatedY = NaN;
            this._coordinateTransformIdUpdatedX = NaN;
            this._coordinateTransformIdUpdatedY = NaN;
        }
        Object.defineProperty(DChartSeriesBaseCoordinateContainer.prototype, "x", {
            get: function () {
                var container = this._parent.container;
                if (container) {
                    return container.plotArea.coordinate.x.get(this._coordinateIndexX);
                }
                return null;
            },
            set: function (coordinate) {
                var index = this.toIndexX(coordinate);
                if (this._coordinateIndexX !== index) {
                    this._coordinateIndexX = index;
                    this._coordinateIdUpdatedX = NaN;
                    this._coordinateTransformIdUpdatedX = NaN;
                }
            },
            enumerable: false,
            configurable: true
        });
        DChartSeriesBaseCoordinateContainer.prototype.toIndexX = function (target) {
            if (isNumber(target)) {
                return target;
            }
            else if (target != null) {
                var container = this._parent.container;
                if (container) {
                    return container.plotArea.coordinate.x.indexOf(target);
                }
            }
            return -1;
        };
        Object.defineProperty(DChartSeriesBaseCoordinateContainer.prototype, "y", {
            get: function () {
                var container = this._parent.container;
                if (container) {
                    return container.plotArea.coordinate.y.get(this._coordinateIndexY);
                }
                return null;
            },
            set: function (coordinate) {
                var index = this.toIndexY(coordinate);
                if (this._coordinateIndexY !== index) {
                    this._coordinateIndexY = index;
                    this._coordinateIdUpdatedY = NaN;
                    this._coordinateTransformIdUpdatedY = NaN;
                }
            },
            enumerable: false,
            configurable: true
        });
        DChartSeriesBaseCoordinateContainer.prototype.toIndexY = function (target) {
            if (isNumber(target)) {
                return target;
            }
            else if (target != null) {
                var container = this._parent.container;
                if (container) {
                    return container.plotArea.coordinate.y.indexOf(target);
                }
            }
            return -1;
        };
        DChartSeriesBaseCoordinateContainer.prototype.isDirty = function (coordinateX, coordinateY) {
            var coordinateIdX = coordinateX.id;
            var coordinateIdY = coordinateY.id;
            var isCoordinateXChanged = coordinateIdX !== this._coordinateIdUpdatedX;
            var isCoordinateYChanged = coordinateIdY !== this._coordinateIdUpdatedY;
            this._coordinateIdUpdatedX = coordinateIdX;
            this._coordinateIdUpdatedY = coordinateIdY;
            return isCoordinateXChanged || isCoordinateYChanged;
        };
        DChartSeriesBaseCoordinateContainer.prototype.isTransformDirty = function (coordinateX, coordinateY) {
            var coordinateTransformIdX = coordinateX.transform.id;
            var coordinateTransformIdY = coordinateY.transform.id;
            var isCoordinateTransformXChanged = coordinateTransformIdX !== this._coordinateTransformIdUpdatedX;
            var isCoordinateTransformYChanged = coordinateTransformIdY !== this._coordinateTransformIdUpdatedY;
            this._coordinateTransformIdUpdatedX = coordinateTransformIdX;
            this._coordinateTransformIdUpdatedY = coordinateTransformIdY;
            return isCoordinateTransformXChanged || isCoordinateTransformYChanged;
        };
        DChartSeriesBaseCoordinateContainer.prototype.reset = function () {
            this._coordinateIdUpdatedX = NaN;
            this._coordinateIdUpdatedY = NaN;
        };
        DChartSeriesBaseCoordinateContainer.prototype.destroy = function () {
            this.reset();
        };
        return DChartSeriesBaseCoordinateContainer;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A series represents a polyline.
     */
    var DChartSeriesBase = /** @class */ (function (_super) {
        __extends(DChartSeriesBase, _super);
        function DChartSeriesBase(options) {
            var _this = _super.call(this) || this;
            _this._coordinate = new DChartSeriesBaseCoordinateContainer(_this, options === null || options === void 0 ? void 0 : options.coordinate);
            _this._index = 0;
            _this._domain = new DChartRegionImpl(NaN, NaN);
            _this._range = new DChartRegionImpl(NaN, NaN);
            _this._regionPointId = NaN;
            _this._isShown = true;
            _this._state = new DBaseStateSetImplObservable(function (newState, oldState) {
                _this.onStateChange(newState, oldState);
            });
            // Events
            var on = options === null || options === void 0 ? void 0 : options.on;
            if (on != null) {
                for (var name_1 in on) {
                    var handler = on[name_1];
                    if (handler) {
                        _this.on(name_1, handler);
                    }
                }
            }
            return _this;
        }
        DChartSeriesBase.prototype.bind = function (container, index) {
            this._container = container;
            this._coordinate.reset();
            this._index = index;
            var chart = container.plotArea.chart;
            if (chart) {
                this._state.parent = chart.state;
            }
            return this;
        };
        DChartSeriesBase.prototype.unbind = function () {
            this._container = undefined;
            return this;
        };
        Object.defineProperty(DChartSeriesBase.prototype, "domain", {
            get: function () {
                this.updateRegion();
                return this._domain;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartSeriesBase.prototype, "range", {
            get: function () {
                this.updateRegion();
                return this._range;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartSeriesBase.prototype, "container", {
            get: function () {
                return this._container || null;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartSeriesBase.prototype, "index", {
            get: function () {
                return this._index;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartSeriesBase.prototype, "coordinate", {
            get: function () {
                return this._coordinate;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartSeriesBase.prototype, "state", {
            get: function () {
                return this._state;
            },
            enumerable: false,
            configurable: true
        });
        DChartSeriesBase.prototype.show = function () {
            if (this._isShown !== true) {
                this._isShown = true;
                this.onShow();
            }
            return this;
        };
        DChartSeriesBase.prototype.onShow = function () {
            var shape = this.shape;
            if (shape != null) {
                shape.visible = true;
            }
        };
        DChartSeriesBase.prototype.isShown = function () {
            return this._isShown;
        };
        DChartSeriesBase.prototype.hide = function () {
            if (this._isShown !== false) {
                this._isShown = false;
                this.onHide();
            }
            return this;
        };
        DChartSeriesBase.prototype.onHide = function () {
            var shape = this.shape;
            if (shape != null) {
                shape.visible = false;
            }
        };
        DChartSeriesBase.prototype.isHidden = function () {
            return !this._isShown;
        };
        DChartSeriesBase.prototype.destroy = function () {
            this._container = undefined;
            this._coordinate.destroy();
            return this;
        };
        DChartSeriesBase.prototype.hitTest = function (x, y) {
            return false;
        };
        DChartSeriesBase.prototype.calcHitPoint = function (x, y, result) {
            return false;
        };
        DChartSeriesBase.prototype.onStateChange = function (newState, oldState) {
            var _a;
            this.toDirty();
            var chart = (_a = this._container) === null || _a === void 0 ? void 0 : _a.plotArea.chart;
            DApplications.update(chart);
            this.emit("statechange", newState, oldState, this);
        };
        return DChartSeriesBase;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A series represents a line of anything.
     * Data points must be sorted in ascending order on the X axis.
     */
    var DChartSeriesLineOfAny = /** @class */ (function (_super) {
        __extends(DChartSeriesLineOfAny, _super);
        function DChartSeriesLineOfAny(options) {
            var _a;
            var _this = _super.call(this, options) || this;
            _this._line = null;
            _this._options = options;
            _this._points = (_a = options === null || options === void 0 ? void 0 : options.points) !== null && _a !== void 0 ? _a : [];
            _this._pointId = 0;
            _this._pointIdUpdated = NaN;
            return _this;
        }
        DChartSeriesLineOfAny.prototype.getSizeDefault = function () {
            return 10;
        };
        DChartSeriesLineOfAny.prototype.getOffsetDefault = function () {
            return 0;
        };
        DChartSeriesLineOfAny.prototype.bind = function (container, index) {
            var line = this._line;
            if (!line) {
                line = this._line = this.newLineOfAny();
                line.visible = this._isShown;
                var options = this._options;
                this.initLine(line, options, container, index);
            }
            line.attach(container.plotArea.container, index);
            this._pointIdUpdated = NaN;
            _super.prototype.bind.call(this, container, index);
            return this;
        };
        DChartSeriesLineOfAny.prototype.initLine = function (line, options, container, index) {
            var fill = container.newFill(index, options === null || options === void 0 ? void 0 : options.fill);
            this._fill = fill;
            line.fill.copy(fill);
            var stroke = container.newStroke(index, options === null || options === void 0 ? void 0 : options.stroke);
            this._stroke = stroke;
            line.stroke.copy(stroke);
            var sizeDefault = this.getSizeDefault();
            var size = container.newSize(index, options === null || options === void 0 ? void 0 : options.size, sizeDefault, sizeDefault);
            this._size = size;
            line.points.size.set(size.x, size.y);
            var offsetDefault = this.getOffsetDefault();
            var offset = container.newOffset(index, options && options.offset, offsetDefault, offsetDefault);
            this._offset = offset;
            line.points.offset.set(offset.x, offset.y);
        };
        DChartSeriesLineOfAny.prototype.unbind = function () {
            var line = this._line;
            if (line) {
                line.detach();
            }
            _super.prototype.unbind.call(this);
            return this;
        };
        Object.defineProperty(DChartSeriesLineOfAny.prototype, "shape", {
            get: function () {
                return this._line;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartSeriesLineOfAny.prototype, "points", {
            get: function () {
                return this._points;
            },
            set: function (points) {
                this._points = points;
                this._pointId += 1;
            },
            enumerable: false,
            configurable: true
        });
        DChartSeriesLineOfAny.prototype.toDirty = function () {
            this._pointId += 1;
            return this;
        };
        DChartSeriesLineOfAny.prototype.update = function () {
            this.doUpdate(true);
            return this;
        };
        DChartSeriesLineOfAny.prototype.onRender = function () {
            this.doUpdate(false);
            return this;
        };
        DChartSeriesLineOfAny.prototype.doUpdate = function (render) {
            var line = this._line;
            if (line) {
                var coordinate = this._coordinate;
                var coordinateX = coordinate.x;
                var coordinateY = coordinate.y;
                if (coordinateX && coordinateY) {
                    var pointId = this._pointId;
                    var isPointChanged = pointId !== this._pointIdUpdated;
                    var isCoordinateChanged = coordinate.isDirty(coordinateX, coordinateY);
                    var isCoordinateTransformChanged = coordinate.isTransformDirty(coordinateX, coordinateY);
                    if (isPointChanged || isCoordinateChanged || isCoordinateTransformChanged) {
                        this._pointIdUpdated = pointId;
                        this.doUpdateLine(line, coordinateX, coordinateY);
                        if (render) {
                            DApplications.update(line);
                        }
                        return true;
                    }
                }
            }
            return false;
        };
        DChartSeriesLineOfAny.prototype.doUpdateLine = function (line, xcoordinate, ycoordinate) {
            var values = line.points.values;
            var valuesLength = values.length;
            var ivalues = 0;
            var points = this._points;
            var xmin = NaN;
            var xmax = NaN;
            var ymin = NaN;
            var ymax = NaN;
            for (var i = 0, imax = points.length; i < imax; i += 2) {
                var x = points[i];
                var y = points[i + 1];
                if (x != null && y != null) {
                    if (ivalues < valuesLength) {
                        values[ivalues] = x;
                        values[ivalues + 1] = y;
                    }
                    else {
                        values.push(x, y);
                    }
                    ivalues += 2;
                    if (xmin !== xmin) {
                        xmin = x;
                        xmax = x;
                        ymin = y;
                        ymax = y;
                    }
                    else {
                        xmin = Math.min(xmin, x);
                        xmax = Math.max(xmax, x);
                        ymin = Math.min(ymin, y);
                        ymax = Math.max(ymax, y);
                    }
                }
            }
            if (values.length !== ivalues) {
                values.length = ivalues;
            }
            xcoordinate.mapAll(values, 0, ivalues, 2, 0);
            ycoordinate.mapAll(values, 0, ivalues, 2, 1);
            xcoordinate.transform.mapAll(values, 0, ivalues, 2, 0);
            ycoordinate.transform.mapAll(values, 0, ivalues, 2, 1);
            if (xmin !== xmin) {
                xmin = 0;
                xmax = 0;
                ymin = 0;
                ymax = 0;
            }
            var region = DChartSeriesLineOfAny.WORK_REGION || {
                xmin: 0,
                xmax: 0,
                ymin: 0,
                ymax: 0
            };
            DChartSeriesLineOfAny.WORK_REGION = region;
            this.adjustLineRegion(xmin, xmax, ymin, ymax, region);
            xmin = xcoordinate.transform.map(xcoordinate.map(region.xmin));
            xmax = xcoordinate.transform.map(xcoordinate.map(region.xmax));
            ymin = ycoordinate.transform.map(ycoordinate.map(region.ymin));
            ymax = ycoordinate.transform.map(ycoordinate.map(region.ymax));
            var sx = Math.abs(xmax - xmin);
            var sy = Math.abs(ymax - ymin);
            var cx = (xmin + xmax) * 0.5;
            var cy = (ymin + ymax) * 0.5;
            for (var i = 0, imax = values.length; i < imax; i += 2) {
                values[i + 0] -= cx;
                values[i + 1] -= cy;
            }
            line.lock(EShapeLockPart.UPLOADED);
            this.applyLine(line, xcoordinate, ycoordinate, sx, sy, cx, cy, values);
            line.unlock(EShapeLockPart.UPLOADED, true);
        };
        DChartSeriesLineOfAny.prototype.adjustLineRegion = function (xmin, xmax, ymin, ymax, result) {
            result.xmin = xmin;
            result.xmax = xmax;
            result.ymin = ymin;
            result.ymax = ymax;
            return result;
        };
        DChartSeriesLineOfAny.prototype.applyLine = function (line, xcoordinate, ycoordinate, sx, sy, cx, cy, values) {
            line.points.set(values);
            line.points.toFitted(sx, sy);
            line.size.set(sx, sy);
            line.transform.position.set(cx, cy);
        };
        DChartSeriesLineOfAny.prototype.updateRegion = function () {
            var pointId = this._pointId;
            if (this._regionPointId !== pointId) {
                this._regionPointId = pointId;
                var points = this._points;
                var domain = this._domain;
                var range = this._range;
                domain.clear();
                range.clear();
                this.calcRegion(points, domain, range);
            }
        };
        DChartSeriesLineOfAny.prototype.calcRegion = function (points, domain, range) {
            for (var i = 0, imax = points.length; i < imax; i += 2) {
                var xraw = points[i];
                if (xraw != null) {
                    domain.add(xraw, xraw);
                }
                var yraw = points[i + 1];
                if (yraw != null) {
                    range.add(yraw, yraw);
                }
            }
        };
        DChartSeriesLineOfAny.prototype.destroy = function () {
            var line = this._line;
            if (line) {
                this._line = null;
                line.detach();
                line.destroy();
            }
            this._points.length = 0;
            this._pointId = 0;
            this._pointIdUpdated = NaN;
            _super.prototype.destroy.call(this);
            return this;
        };
        DChartSeriesLineOfAny.prototype.hitTest = function (x, y) {
            var line = this._line;
            if (line) {
                var local = DChartSeriesLineOfAny.WORK;
                local.set(x, y);
                line.toLocal(local, undefined, local);
                return line.contains(local.x, local.y) != null;
            }
            return false;
        };
        DChartSeriesLineOfAny.prototype.calcHitPoint = function (x, y, result) {
            var line = this._line;
            if (line) {
                var local = DChartSeriesLineOfAny.WORK;
                local.set(x, y);
                line.toLocal(local, undefined, local);
                result.shape = line;
                return line.calcHitPoint(local.x, local.y, null, this.calcHitPointTestRange, this.calcHitPointHitTester, result);
            }
            return false;
        };
        DChartSeriesLineOfAny.prototype.calcHitPointTestRange = function (x, y, ax, ay, ox, oy, threshold, values, result) {
            var to = toCeilingIndex(values, x + ax + ox, 2, 0);
            var from = 0;
            for (var i = to - 1, iv = i << 1; 0 <= i; i -= 1, iv -= 2) {
                if (values[iv] <= x - ax) {
                    from = i;
                    break;
                }
            }
            result[0] = from;
            result[1] = from !== to ? to : Math.min(values.length << 1, to + 1);
            return result;
        };
        DChartSeriesLineOfAny.prototype.calcHitPointHitTester = function (x, y, ax, ay, ox, oy, px, py, sw, ss, sa, index, threshold, result) {
            var shape = result.shape;
            if (shape.containsPointAbs(x, y, ax, ay, ox, oy, px, py, sw, ss, sa)) {
                var transform = shape.transform;
                var position = transform.position;
                var scale = transform.scale;
                result.x = result.p0x = result.p1x = position.x + scale.x * px;
                result.y = result.p0y = result.p1y = position.y + scale.y * py;
                result.t = threshold;
                result.index = index;
                var dx = x - (px + ox);
                var dy = y - (py + oy);
                result.distance = Math.sqrt(dx * dx + dy * dy);
                return true;
            }
            return false;
        };
        DChartSeriesLineOfAny.WORK = new pixi_js.Point();
        return DChartSeriesLineOfAny;
    }(DChartSeriesBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A series represents bars.
     * Data points must be sorted in ascending order on the X axis.
     */
    var DChartSeriesBar = /** @class */ (function (_super) {
        __extends(DChartSeriesBar, _super);
        function DChartSeriesBar(options) {
            var _this = _super.call(this, options) || this;
            _this._barCount = -1;
            _this._barIndex = -1;
            _this._xcoordinateId = -1;
            _this._xcoordinateTransformId = -1;
            _this._isSizeAutomatic = (options && options.size && options.size.auto) !== false;
            return _this;
        }
        DChartSeriesBar.prototype.bind = function (container, index) {
            this._barCount = -1;
            this._barIndex = -1;
            this._xcoordinateId = -1;
            this._xcoordinateTransformId = -1;
            _super.prototype.bind.call(this, container, index);
            return this;
        };
        DChartSeriesBar.prototype.initLine = function (line, options, container, index) {
            _super.prototype.initLine.call(this, line, options, container, index);
            this._padding = container.newPadding(index, options && options.padding);
        };
        DChartSeriesBar.prototype.newLineOfAny = function () {
            return new EShapeLineOfRectangles();
        };
        DChartSeriesBar.prototype.getSizeDefault = function () {
            return 1;
        };
        DChartSeriesBar.prototype.adjustLineRegion = function (xmin, xmax, ymin, ymax, result) {
            return _super.prototype.adjustLineRegion.call(this, xmin, xmax, Math.min(0, ymin), Math.max(0, ymax), result);
        };
        DChartSeriesBar.prototype.updateBarCountAndIndex = function () {
            if (this._barIndex < 0 || this._barCount < 0) {
                var barIndex = 0;
                var barCount = 0;
                var container = this._container;
                if (container) {
                    for (var i = 0, imax = container.size(); i < imax; ++i) {
                        var series = container.get(i);
                        if (series === this) {
                            barIndex = barCount;
                        }
                        if (series instanceof DChartSeriesBar) {
                            barCount += 1;
                        }
                    }
                }
                barCount = Math.max(1, barCount);
                this._barCount = barCount;
                this._barIndex = barIndex;
                return true;
            }
            return false;
        };
        DChartSeriesBar.prototype.applyLine = function (line, xcoordinate, ycoordinate, sx, sy, cx, cy, values) {
            var linePoints = line.points;
            var linePointsOffset = linePoints.offset;
            var linePointsSize = linePoints.size;
            // Offset
            var size = this._size;
            var offset = this._offset;
            var padding = this._padding;
            if (size && offset && padding) {
                var xcoordinateId = xcoordinate.id;
                var xcoordinateTransformId = xcoordinate.transform.id;
                if (this.updateBarCountAndIndex() ||
                    this._xcoordinateId !== xcoordinateId ||
                    this._xcoordinateTransformId !== xcoordinateTransformId) {
                    var barCount = this._barCount;
                    var barIndex = this._barIndex;
                    this._xcoordinateId = xcoordinateId;
                    this._xcoordinateTransformId = xcoordinateTransformId;
                    var x0 = xcoordinate.transform.map(xcoordinate.map(0));
                    var x1 = xcoordinate.transform.map(xcoordinate.map(size.x));
                    var totalBandWidth = Math.abs(x0 - x1) * (1 - padding.outer);
                    if (barCount <= 1) {
                        linePointsOffset.x = offset.x;
                        linePointsSize.x = totalBandWidth;
                    }
                    else {
                        var totalBarWidth = totalBandWidth * (1 - padding.inner);
                        var totalPaddingInner = totalBandWidth - totalBarWidth;
                        var barWidth = totalBarWidth / barCount;
                        var barPadding = totalPaddingInner / (barCount - 1);
                        var barX = barWidth * (barIndex + 0.5) + barIndex * barPadding;
                        linePointsOffset.x = offset.x + barX - totalBandWidth * 0.5;
                        linePointsSize.x = barWidth;
                    }
                }
            }
            // Sizes & Offsets
            var sizes = linePointsSize.y;
            if (!isArray(sizes)) {
                sizes = [];
            }
            var sizesLength = sizes.length;
            var offsets = linePointsOffset.y;
            if (!isArray(offsets)) {
                offsets = [];
            }
            var offsetsLength = offsets.length;
            var isize = 0;
            var y0 = ycoordinate.transform.map(ycoordinate.map(0)) - cy;
            for (var i = 0, imax = values.length; i < imax; i += 2, isize += 1) {
                var distance = values[i + 1] - y0;
                var s = Math.abs(distance);
                if (isize < sizesLength) {
                    sizes[isize] = s;
                }
                else {
                    sizes.push(s);
                }
                var o = -0.5 * distance;
                if (isize < offsetsLength) {
                    offsets[isize] = o;
                }
                else {
                    offsets.push(o);
                }
            }
            if (sizes.length !== isize) {
                sizes.length = isize;
            }
            if (offsets.length !== isize) {
                offsets.length = isize;
            }
            linePointsOffset.y = offsets;
            linePointsSize.y = sizes;
            // Others
            _super.prototype.applyLine.call(this, line, xcoordinate, ycoordinate, sx, sy, cx, cy, values);
        };
        DChartSeriesBar.prototype.calcSizeX = function (def) {
            var points = this._points;
            if (2 < points.length) {
                var pointsLength = points.length;
                var x0 = points[pointsLength - 2];
                for (var i = pointsLength - 4; 0 <= i; i -= 2) {
                    var x1 = points[i];
                    if (x0 != null && x1 != null) {
                        return Math.abs(x0 - x1);
                    }
                    else {
                        x0 = x1;
                    }
                }
            }
            return def;
        };
        DChartSeriesBar.prototype.calcRegion = function (points, domain, range) {
            _super.prototype.calcRegion.call(this, points, domain, range);
            var size = this._size;
            if (size) {
                var sx = size.x;
                if (this._isSizeAutomatic) {
                    sx = this.calcSizeX(sx);
                    size.x = sx;
                }
                var sxh = sx * 0.5;
                domain.set(domain.from - sxh, domain.to + sxh);
            }
            range.add(0, 0);
        };
        return DChartSeriesBar;
    }(DChartSeriesLineOfAny));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A series represents a line of circles.
     * Data points must be sorted in ascending order on the X axis.
     */
    var DChartSeriesLineOfCircles = /** @class */ (function (_super) {
        __extends(DChartSeriesLineOfCircles, _super);
        function DChartSeriesLineOfCircles() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DChartSeriesLineOfCircles.prototype.newLineOfAny = function () {
            return new EShapeLineOfCircles();
        };
        return DChartSeriesLineOfCircles;
    }(DChartSeriesLineOfAny));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A series represents a line of rounded rectangles.
     * Data points must be sorted in ascending order on the X axis.
     */
    var DChartSeriesLineOfRectangleRoundeds = /** @class */ (function (_super) {
        __extends(DChartSeriesLineOfRectangleRoundeds, _super);
        function DChartSeriesLineOfRectangleRoundeds() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DChartSeriesLineOfRectangleRoundeds.prototype.newLineOfAny = function () {
            return new EShapeLineOfRectangleRoundeds();
        };
        return DChartSeriesLineOfRectangleRoundeds;
    }(DChartSeriesLineOfAny));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A series represents a line of rectangles.
     * Data points must be sorted in ascending order on the X axis.
     */
    var DChartSeriesLineOfRectangles = /** @class */ (function (_super) {
        __extends(DChartSeriesLineOfRectangles, _super);
        function DChartSeriesLineOfRectangles() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DChartSeriesLineOfRectangles.prototype.newLineOfAny = function () {
            return new EShapeLineOfRectangles();
        };
        return DChartSeriesLineOfRectangles;
    }(DChartSeriesLineOfAny));

    /*
     * Copyright (C) 2020 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A series represents a line of triangles.
     * Data points must be sorted in ascending order on the X axis.
     */
    var DChartSeriesLineOfTriangles = /** @class */ (function (_super) {
        __extends(DChartSeriesLineOfTriangles, _super);
        function DChartSeriesLineOfTriangles(options) {
            var _this = _super.call(this, options) || this;
            _this._sizeId = 0;
            return _this;
        }
        DChartSeriesLineOfTriangles.prototype.newLineOfAny = function () {
            return new EShapeLineOfTriangles();
        };
        DChartSeriesLineOfTriangles.prototype.applyLine = function (line, xcoordinate, ycoordinate, sx, sy, cx, cy, values) {
            // Offset
            var size = this._size;
            var offset = this._offset;
            if (size && offset && this._sizeId !== size.y) {
                this._sizeId = size.y;
                line.points.offset.y = offset.y - size.y * 0.2;
            }
            //
            _super.prototype.applyLine.call(this, line, xcoordinate, ycoordinate, sx, sy, cx, cy, values);
        };
        return DChartSeriesLineOfTriangles;
    }(DChartSeriesLineOfAny));

    /*
     * Copyright (C) 2020 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A series represents a line of rounded triangles.
     * Data points must be sorted in ascending order on the X axis.
     */
    var DChartSeriesLineOfTriangleRoundeds = /** @class */ (function (_super) {
        __extends(DChartSeriesLineOfTriangleRoundeds, _super);
        function DChartSeriesLineOfTriangleRoundeds() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DChartSeriesLineOfTriangleRoundeds.prototype.newLineOfAny = function () {
            return new EShapeLineOfTriangleRoundeds();
        };
        return DChartSeriesLineOfTriangleRoundeds;
    }(DChartSeriesLineOfTriangles));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A series represents a polyline.
     * Data points must be sorted in ascending order on the X axis.
     */
    var DChartSeriesLine = /** @class */ (function (_super) {
        __extends(DChartSeriesLine, _super);
        function DChartSeriesLine(options) {
            var _a;
            var _this = _super.call(this, options) || this;
            _this._line = null;
            _this._options = options;
            _this._points = (_a = options === null || options === void 0 ? void 0 : options.points) !== null && _a !== void 0 ? _a : [];
            _this._pointId = 0;
            _this._pointIdUpdated = NaN;
            _this._centerX = 0;
            _this._centerY = 0;
            return _this;
        }
        DChartSeriesLine.prototype.bind = function (container, index) {
            var _a;
            var line = this._line;
            if (!line) {
                var stroke = container.newStroke(index, (_a = this._options) === null || _a === void 0 ? void 0 : _a.stroke);
                this._stroke = stroke;
                line = new EShapeLine();
                line.stroke.copy(stroke);
                line.visible = this._isShown;
                this._line = line;
            }
            line.attach(container.plotArea.container, index);
            this._pointIdUpdated = NaN;
            _super.prototype.bind.call(this, container, index);
            return this;
        };
        DChartSeriesLine.prototype.unbind = function () {
            var line = this._line;
            if (line) {
                line.detach();
            }
            _super.prototype.unbind.call(this);
            return this;
        };
        Object.defineProperty(DChartSeriesLine.prototype, "shape", {
            get: function () {
                return this._line;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartSeriesLine.prototype, "points", {
            get: function () {
                return this._points;
            },
            set: function (points) {
                this._points = points;
                this._pointId += 1;
            },
            enumerable: false,
            configurable: true
        });
        DChartSeriesLine.prototype.toDirty = function () {
            this._pointId += 1;
            return this;
        };
        DChartSeriesLine.prototype.update = function () {
            this.doUpdate(true);
            return this;
        };
        DChartSeriesLine.prototype.onRender = function () {
            this.doUpdate(false);
            return this;
        };
        DChartSeriesLine.prototype.doUpdate = function (render) {
            var line = this._line;
            if (line) {
                var coordinate = this._coordinate;
                var coordinateX = coordinate.x;
                var coordinateY = coordinate.y;
                if (coordinateX && coordinateY) {
                    var pointId = this._pointId;
                    var isPointChanged = pointId !== this._pointIdUpdated;
                    var isCoordinateChanged = coordinate.isDirty(coordinateX, coordinateY);
                    var isCoordinateTransformChanged = coordinate.isTransformDirty(coordinateX, coordinateY);
                    if (isPointChanged || isCoordinateChanged || isCoordinateTransformChanged) {
                        this._pointIdUpdated = pointId;
                        this.doUpdateLine(line, coordinateX, coordinateY, isPointChanged || isCoordinateChanged);
                        if (render) {
                            DApplications.update(line);
                        }
                        return true;
                    }
                }
            }
            return false;
        };
        DChartSeriesLine.prototype.doUpdateLine = function (line, xcoordinate, ycoordinate, isPointsDirty) {
            line.lock(EShapeLockPart.UPLOADED);
            if (isPointsDirty) {
                var values = line.points.values;
                var segments = line.points.segments;
                var valuesLength = values.length;
                var segmentsLength = segments.length;
                var ivalues = 0;
                var isegments = 0;
                var points = this._points;
                var xmin = NaN;
                var xmax = NaN;
                var ymin = NaN;
                var ymax = NaN;
                for (var i = 0, imax = points.length; i < imax; i += 2) {
                    var x = points[i];
                    var y = points[i + 1];
                    if (x != null && y != null) {
                        if (ivalues < valuesLength) {
                            values[ivalues] = x;
                            values[ivalues + 1] = y;
                        }
                        else {
                            values.push(x, y);
                        }
                        ivalues += 2;
                        if (xmin !== xmin) {
                            xmin = x;
                            xmax = x;
                            ymin = y;
                            ymax = y;
                        }
                        else {
                            xmin = Math.min(xmin, x);
                            xmax = Math.max(xmax, x);
                            ymin = Math.min(ymin, y);
                            ymax = Math.max(ymax, y);
                        }
                    }
                    else {
                        var segment = (i >> 1) - isegments;
                        if (isegments < segmentsLength) {
                            segments[isegments] = segment;
                        }
                        else {
                            segments.push(segment);
                        }
                        isegments += 1;
                    }
                }
                if (values.length !== ivalues) {
                    values.length = ivalues;
                }
                if (segments.length !== isegments) {
                    segments.length = isegments;
                }
                xcoordinate.mapAll(values, 0, ivalues, 2, 0);
                ycoordinate.mapAll(values, 0, ivalues, 2, 1);
                if (xmin !== xmin) {
                    xmin = 0;
                    xmax = 0;
                    ymin = 0;
                    ymax = 0;
                }
                xmin = xcoordinate.map(xmin);
                xmax = xcoordinate.map(xmax);
                ymin = ycoordinate.map(ymin);
                ymax = ycoordinate.map(ymax);
                var sx = Math.abs(xmax - xmin);
                var sy = Math.abs(ymax - ymin);
                var cx = (xmin + xmax) * 0.5;
                var cy = (ymin + ymax) * 0.5;
                for (var i = 0, imax = values.length; i < imax; i += 2) {
                    values[i + 0] -= cx;
                    values[i + 1] -= cy;
                }
                line.points.set(values, segments);
                line.points.toFitted(sx, sy);
                line.size.set(sx, sy);
                this._centerX = cx;
                this._centerY = cy;
            }
            line.transform.position.set(xcoordinate.transform.map(this._centerX), ycoordinate.transform.map(this._centerY));
            line.transform.scale.set(xcoordinate.transform.scale, ycoordinate.transform.scale);
            line.unlock(EShapeLockPart.UPLOADED, true);
        };
        DChartSeriesLine.prototype.updateRegion = function () {
            var pointId = this._pointId;
            if (this._regionPointId !== pointId) {
                this._regionPointId = pointId;
                var points = this._points;
                var domain = this._domain;
                var range = this._range;
                domain.clear();
                range.clear();
                if (points != null) {
                    for (var i = 0, imax = points.length; i < imax; i += 2) {
                        var xraw = points[i];
                        if (xraw != null) {
                            domain.add(xraw, xraw);
                        }
                        var yraw = points[i + 1];
                        if (yraw != null) {
                            range.add(yraw, yraw);
                        }
                    }
                }
            }
        };
        DChartSeriesLine.prototype.destroy = function () {
            var line = this._line;
            if (line) {
                this._line = null;
                line.detach();
                line.destroy();
            }
            this._points.length = 0;
            this._pointId = 0;
            this._pointIdUpdated = NaN;
            _super.prototype.destroy.call(this);
            return this;
        };
        DChartSeriesLine.prototype.hitTest = function (x, y) {
            var line = this._line;
            if (line) {
                var local = DChartSeriesLine.WORK;
                local.set(x, y);
                line.toLocal(local, undefined, local);
                return line.contains(local.x, local.y) != null;
            }
            return false;
        };
        DChartSeriesLine.prototype.calcHitPoint = function (x, y, result) {
            var line = this._line;
            if (line) {
                var local = DChartSeriesLine.WORK;
                local.set(x, y);
                line.toLocal(local, undefined, local);
                result.shape = line;
                return line.calcHitPoint(local.x, local.y, this.toThreshold, this.calcHitPointTestRange, this.calcHitPointHitTester, result);
            }
            return false;
        };
        DChartSeriesLine.prototype.toThreshold = function (strokeWidth, strokeScale) {
            return +Infinity;
        };
        DChartSeriesLine.prototype.calcHitPointTestRange = function (x, y, threshold, values, result) {
            var index = toCeilingIndex(values, x, 2, 0);
            result[0] = Math.max(0, index - 1);
            result[1] = index;
            return result;
        };
        DChartSeriesLine.prototype.calcHitPointHitTester = function (x, y, p0x, p0y, p1x, p1y, index, threshold, result) {
            if (p0x <= x && x < p1x) {
                var l = p1x - p0x;
                if (0.0001 < Math.abs(l)) {
                    var t = (x - p0x) / l;
                    var p2x = x;
                    var p2y = p0y + t * (p1y - p0y);
                    var distance = Math.abs(p2y - y);
                    if (distance < threshold) {
                        var transform = result.shape.transform;
                        var position = transform.position;
                        var px = position.x;
                        var py = position.y;
                        var scale = transform.scale;
                        var sx = scale.x;
                        var sy = scale.y;
                        result.x = px + sx * p2x;
                        result.y = py + sy * p2y;
                        result.p0x = px + sx * p0x;
                        result.p0y = py + sy * p0y;
                        result.p1x = px + sx * p1x;
                        result.p1y = py + sy * p1y;
                        result.t = t;
                        result.index = index;
                        result.distance = distance;
                        return true;
                    }
                }
            }
            return false;
        };
        DChartSeriesLine.WORK = new pixi_js.Point();
        return DChartSeriesLine;
    }(DChartSeriesBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartSeriesExpressionParametersImpl = /** @class */ (function () {
        function DChartSeriesExpressionParametersImpl(a, b, x0, y0) {
            this._id = 0;
            this._idUpdated = NaN;
            this._a = a;
            this._b = b;
            this._x0 = x0;
            this._y0 = y0;
        }
        Object.defineProperty(DChartSeriesExpressionParametersImpl.prototype, "a", {
            get: function () {
                return this._a;
            },
            set: function (a) {
                if (this._a !== a) {
                    this._id += 1;
                    this._a = a;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartSeriesExpressionParametersImpl.prototype, "b", {
            get: function () {
                return this._b;
            },
            set: function (b) {
                if (this._b !== b) {
                    this._id += 1;
                    this._b = b;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartSeriesExpressionParametersImpl.prototype, "x0", {
            get: function () {
                return this._x0;
            },
            set: function (x0) {
                if (this._x0 !== x0) {
                    this._id += 1;
                    this._x0 = x0;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartSeriesExpressionParametersImpl.prototype, "y0", {
            get: function () {
                return this._y0;
            },
            set: function (y0) {
                if (this._y0 !== y0) {
                    this._id += 1;
                    this._y0 = y0;
                }
            },
            enumerable: false,
            configurable: true
        });
        DChartSeriesExpressionParametersImpl.prototype.toDirty = function () {
            this._id += 1;
        };
        DChartSeriesExpressionParametersImpl.prototype.isDirty = function () {
            return this._id !== this._idUpdated;
        };
        DChartSeriesExpressionParametersImpl.prototype.toClean = function () {
            this._idUpdated = this._id;
        };
        DChartSeriesExpressionParametersImpl.from = function (options) {
            var _c, _d, _e, _f;
            return new DChartSeriesExpressionParametersImpl((_c = options === null || options === void 0 ? void 0 : options.a) !== null && _c !== void 0 ? _c : 1, (_d = options === null || options === void 0 ? void 0 : options.b) !== null && _d !== void 0 ? _d : 1, (_e = options === null || options === void 0 ? void 0 : options.x0) !== null && _e !== void 0 ? _e : 0, (_f = options === null || options === void 0 ? void 0 : options.y0) !== null && _f !== void 0 ? _f : 0);
        };
        return DChartSeriesExpressionParametersImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A series represents a linear equation `a (x - x0) === b (y - y0)`.
     */
    var DChartSeriesLinear = /** @class */ (function (_super) {
        __extends(DChartSeriesLinear, _super);
        function DChartSeriesLinear(options) {
            var _this = _super.call(this, options) || this;
            _this._line = null;
            _this._options = options;
            _this._parameters = DChartSeriesExpressionParametersImpl.from(options);
            return _this;
        }
        DChartSeriesLinear.prototype.bind = function (container, index) {
            var _a;
            var line = this._line;
            if (!line) {
                var stroke = container.newStroke(index, (_a = this._options) === null || _a === void 0 ? void 0 : _a.stroke);
                this._stroke = stroke;
                line = new EShapeLine();
                line.stroke.copy(stroke);
                line.visible = this._isShown;
                this._line = line;
            }
            line.attach(container.plotArea.container, index);
            _super.prototype.bind.call(this, container, index);
            return this;
        };
        DChartSeriesLinear.prototype.unbind = function () {
            var line = this._line;
            if (line) {
                line.detach();
            }
            _super.prototype.unbind.call(this);
            return this;
        };
        Object.defineProperty(DChartSeriesLinear.prototype, "shape", {
            get: function () {
                return this._line;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartSeriesLinear.prototype, "parameters", {
            get: function () {
                return this._parameters;
            },
            enumerable: false,
            configurable: true
        });
        DChartSeriesLinear.prototype.toDirty = function () {
            this._parameters.toDirty();
            return this;
        };
        DChartSeriesLinear.prototype.update = function () {
            this.doUpdate(true);
            return this;
        };
        DChartSeriesLinear.prototype.onRender = function () {
            this.doUpdate(false);
            return this;
        };
        DChartSeriesLinear.prototype.doUpdate = function (render) {
            var line = this._line;
            var container = this._container;
            if (line && container) {
                var coordinate = this._coordinate;
                var coordinateX = coordinate.x;
                var coordinateY = coordinate.y;
                if (coordinateX && coordinateY) {
                    this.doUpdateLine(line, container, coordinateX, coordinateY);
                    if (render) {
                        DApplications.update(line);
                    }
                    return true;
                }
            }
            return false;
        };
        DChartSeriesLinear.prototype.doUpdateLine = function (line, container, xcoordinate, ycoordinate) {
            var values = line.points.values;
            var segments = line.points.segments;
            var parameters = this._parameters;
            var a = parameters.a;
            var b = parameters.b;
            var x0 = parameters.x0;
            var y0 = parameters.y0;
            var aabs = Math.abs(a);
            var babs = Math.abs(b);
            var p0x = NaN;
            var p0y = NaN;
            var p1x = NaN;
            var p1y = NaN;
            var threshold = 0.00001;
            var bounds = container.plotArea.getContainerBounds();
            if (babs <= aabs) {
                var xfrom = xcoordinate.unmap(xcoordinate.transform.unmap(bounds.x));
                var xto = xcoordinate.unmap(xcoordinate.transform.unmap(bounds.x + bounds.width));
                p0x = Math.min(xfrom, xto);
                p1x = Math.max(xfrom, xto);
                var yfrom = ycoordinate.unmap(ycoordinate.transform.unmap(bounds.y));
                var yto = ycoordinate.unmap(ycoordinate.transform.unmap(bounds.y + bounds.height));
                p0y = Math.min(yfrom, yto);
                p1y = Math.max(yfrom, yto);
                if (threshold < babs) {
                    var f = b / a;
                    var xfrom1 = f * (yfrom - y0) + x0;
                    var xto1 = f * (yto - y0) + x0;
                    var p2x = Math.min(xfrom1, xto1);
                    var p3x = Math.max(xfrom1, xto1);
                    p0x = Math.max(p0x, p2x);
                    p1x = Math.min(p1x, p3x);
                    var g = 1 / f;
                    p0y = g * (p0x - x0) + b * y0;
                    p1y = g * (p1x - x0) + b * y0;
                }
                else {
                    p0x = x0;
                    p1x = x0;
                }
            }
            else {
                var yfrom = ycoordinate.unmap(ycoordinate.transform.unmap(bounds.y));
                var yto = ycoordinate.unmap(ycoordinate.transform.unmap(bounds.y + bounds.height));
                p0y = Math.min(yfrom, yto);
                p1y = Math.max(yfrom, yto);
                var xfrom = xcoordinate.unmap(xcoordinate.transform.unmap(bounds.x));
                var xto = xcoordinate.unmap(xcoordinate.transform.unmap(bounds.x + bounds.width));
                p0x = Math.min(xfrom, xto);
                p1x = Math.max(xfrom, xto);
                if (threshold < aabs) {
                    var f = a / b;
                    var yfrom1 = f * (xfrom - x0) + y0;
                    var yto1 = f * (xto - x0) + y0;
                    var p2y = Math.min(yfrom1, yto1);
                    var p3y = Math.max(yfrom1, yto1);
                    p0y = Math.max(p0y, p2y);
                    p1y = Math.min(p1y, p3y);
                    var g = 1 / f;
                    p0x = g * (p0y - y0) + a * x0;
                    p1x = g * (p1y - y0) + a * x0;
                }
                else {
                    p0y = y0;
                    p1y = y0;
                }
            }
            p0x = xcoordinate.transform.map(xcoordinate.map(p0x));
            p0y = ycoordinate.transform.map(ycoordinate.map(p0y));
            p1x = xcoordinate.transform.map(xcoordinate.map(p1x));
            p1y = ycoordinate.transform.map(ycoordinate.map(p1y));
            var cx = (p0x + p1x) * 0.5;
            var cy = (p0y + p1y) * 0.5;
            var sx = Math.abs(p1x - p0x);
            var sy = Math.abs(p1y - p0y);
            p0x -= cx;
            p0y -= cy;
            p1x -= cx;
            p1y -= cy;
            if (values.length !== 4) {
                values.length = 0;
                values.push(p0x, p0y, p1x, p1y);
            }
            else {
                values[0] = p0x;
                values[1] = p0y;
                values[2] = p1x;
                values[3] = p1y;
            }
            if (0 < segments.length) {
                segments.length = 0;
            }
            line.lock(EShapeLockPart.UPLOADED);
            line.points.set(values, segments);
            line.points.toFitted(sx, sy);
            line.size.set(sx, sy);
            line.transform.position.set(cx, cy);
            line.unlock(EShapeLockPart.UPLOADED, true);
        };
        DChartSeriesLinear.prototype.updateRegion = function () {
            // DO NOTHING
        };
        DChartSeriesLinear.prototype.destroy = function () {
            var line = this._line;
            if (line) {
                this._line = null;
                line.detach();
                line.destroy();
            }
            _super.prototype.destroy.call(this);
            return this;
        };
        DChartSeriesLinear.prototype.hitTest = function (x, y) {
            var line = this._line;
            if (line) {
                var local = DChartSeriesLinear.WORK;
                local.set(x, y);
                line.toLocal(local, undefined, local);
                return line.contains(local.x, local.y) != null;
            }
            return false;
        };
        DChartSeriesLinear.prototype.calcHitPoint = function (x, y, result) {
            var line = this._line;
            if (line) {
                var local = DChartSeriesLinear.WORK;
                local.set(x, y);
                line.toLocal(local, undefined, local);
                result.shape = line;
                return line.calcHitPoint(local.x, local.y, this.toThreshold, null, this.calcHitPointHitTester, result);
            }
            return false;
        };
        DChartSeriesLinear.prototype.toThreshold = function (strokeWidth, strokeScale) {
            return +Infinity;
        };
        DChartSeriesLinear.prototype.calcHitPointHitTester = function (x, y, p0x, p0y, p1x, p1y, index, threshold, result) {
            if (p0x <= x && x < p1x) {
                var l = p1x - p0x;
                if (0.0001 < Math.abs(l)) {
                    var t = (x - p0x) / l;
                    var p2x = x;
                    var p2y = p0y + t * (p1y - p0y);
                    var distance = Math.abs(p2y - y);
                    if (distance < threshold) {
                        var transform = result.shape.transform;
                        var position = transform.position;
                        var px = position.x;
                        var py = position.y;
                        var scale = transform.scale;
                        var sx = scale.x;
                        var sy = scale.y;
                        result.x = result.p0x = result.p1x = px + sx * p2x;
                        result.y = result.p0y = result.p1y = py + sy * p2y;
                        result.t = t;
                        result.index = index;
                        result.distance = distance;
                        return true;
                    }
                }
            }
            return false;
        };
        DChartSeriesLinear.WORK = new pixi_js.Point();
        return DChartSeriesLinear;
    }(DChartSeriesBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChart = /** @class */ (function (_super) {
        __extends(DChart, _super);
        function DChart() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DChart.prototype.init = function (options) {
            var _a;
            _super.prototype.init.call(this, options);
            // Overflow mask
            var plotArea = this.plotArea;
            var mask = (_a = options === null || options === void 0 ? void 0 : options.mask) !== null && _a !== void 0 ? _a : this.theme.isOverflowMaskEnabled();
            if (mask) {
                plotArea.axis.container.mask = this.getOverflowMask();
            }
        };
        DChart.prototype.getOverflowMask = function () {
            if (this._overflowMask == null) {
                this._overflowMask = new DBaseOverflowMask(this);
                this.reflowable.add(this._overflowMask);
                this.toDirty();
            }
            return this._overflowMask;
        };
        Object.defineProperty(DChart.prototype, "plotArea", {
            get: function () {
                var _a;
                return ((_a = this._plotArea) !== null && _a !== void 0 ? _a : (this._plotArea = this.newPlotArea()));
            },
            enumerable: false,
            configurable: true
        });
        DChart.prototype.newPlotArea = function () {
            var _a;
            var plotArea = (_a = this._options) === null || _a === void 0 ? void 0 : _a.plotArea;
            if (plotArea != null && ("primary" in plotArea || "secondary" in plotArea)) {
                var result = new DChartPlotAreaTwofold(this, plotArea);
                this.addChild(result);
                return result;
            }
            else {
                var result = new DChartPlotAreaOnefold(this, plotArea);
                this.addChild(result);
                return result;
            }
        };
        DChart.prototype.destroy = function () {
            var _a;
            if (!this._destroyed) {
                (_a = this._plotArea) === null || _a === void 0 ? void 0 : _a.destroy();
                _super.prototype.destroy.call(this);
            }
        };
        DChart.prototype.getType = function () {
            return "DChart";
        };
        return DChart;
    }(DBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DCommandCreate = /** @class */ (function (_super) {
        __extends(DCommandCreate, _super);
        function DCommandCreate() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DCommandCreate.prototype.isStorable = function () {
            return false;
        };
        DCommandCreate.prototype.isClear = function () {
            return true;
        };
        return DCommandCreate;
    }(DCommandBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DCommandSaveAs = /** @class */ (function (_super) {
        __extends(DCommandSaveAs, _super);
        function DCommandSaveAs(name) {
            var _this = _super.call(this) || this;
            _this._name = name;
            return _this;
        }
        Object.defineProperty(DCommandSaveAs.prototype, "name", {
            get: function () {
                return this._name;
            },
            enumerable: false,
            configurable: true
        });
        DCommandSaveAs.prototype.isStorable = function () {
            return false;
        };
        DCommandSaveAs.prototype.execute = function () {
            DControllers.getDocumentController().saveAs(this._name);
            return true;
        };
        return DCommandSaveAs;
    }(DCommandBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DCommandSave = /** @class */ (function (_super) {
        __extends(DCommandSave, _super);
        function DCommandSave() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DCommandSave.prototype.isStorable = function () {
            return false;
        };
        DCommandSave.prototype.execute = function () {
            DControllers.getDocumentController().save();
            return true;
        };
        return DCommandSave;
    }(DCommandBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDiagramCanvasEditorShapeImpl = /** @class */ (function (_super) {
        __extends(DDiagramCanvasEditorShapeImpl, _super);
        function DDiagramCanvasEditorShapeImpl() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return DDiagramCanvasEditorShapeImpl;
    }(DDiagramCanvasBaseShapeImpl));

    /*
     * Copyright (C) 2021 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDiagramCanvasEditorSnap = /** @class */ (function () {
        function DDiagramCanvasEditorSnap(parent, theme, options) {
            var _this = this;
            this._parent = parent;
            this._isDirty = true;
            // Controller
            var controller = options.controller;
            this._controller = controller;
            var onChangeBound = function () {
                _this.onChange();
            };
            controller.grid.on("change", onChangeBound);
            controller.target.on("change", onChangeBound);
            // Container
            var container = new EShapeContainer();
            container.visible = false;
            this._container = container;
            parent.addChildAt(container, parent.children.length - 1);
            // Grid
            this._grid = this.toGrid(theme, options.grid);
            this._gridParentWidth = parent.width;
            this._gridParentHeight = parent.height;
            this._gridParentScale = parent.scale.x;
            this._gridSize = this.newGridSize();
            // Target
            this._target = this.toTarget(theme, options.target);
        }
        DDiagramCanvasEditorSnap.prototype.toGrid = function (theme, options) {
            var _a;
            if (options != null) {
                return {
                    major: this.toGridMajor(theme, options.major),
                    minor: this.toGridMinor(theme, options.minor),
                    size: (_a = options.size) !== null && _a !== void 0 ? _a : theme.getSnapGridSize()
                };
            }
            return {
                major: this.toGridMajor(theme),
                minor: this.toGridMinor(theme),
                size: theme.getSnapGridSize()
            };
        };
        DDiagramCanvasEditorSnap.prototype.toGridMajor = function (theme, options) {
            var _a, _b, _c, _d, _e;
            if (options != null) {
                return {
                    interval: (_a = options.interval) !== null && _a !== void 0 ? _a : theme.getSnapGridMajorInterval(),
                    color: (_b = options.color) !== null && _b !== void 0 ? _b : theme.getSnapGridMajorColor(),
                    alpha: (_c = options.alpha) !== null && _c !== void 0 ? _c : theme.getSnapGridMajorAlpha(),
                    width: (_d = options.width) !== null && _d !== void 0 ? _d : theme.getSnapGridMajorWidth(),
                    style: (_e = options.style) !== null && _e !== void 0 ? _e : theme.getSnapGridMajorStyle()
                };
            }
            return {
                interval: theme.getSnapGridMajorInterval(),
                color: theme.getSnapGridMajorColor(),
                alpha: theme.getSnapGridMajorAlpha(),
                width: theme.getSnapGridMajorWidth(),
                style: theme.getSnapGridMajorStyle()
            };
        };
        DDiagramCanvasEditorSnap.prototype.toGridMinor = function (theme, options) {
            var _a, _b, _c, _d;
            if (options != null) {
                return {
                    color: (_a = options.color) !== null && _a !== void 0 ? _a : theme.getSnapGridMinorColor(),
                    alpha: (_b = options.alpha) !== null && _b !== void 0 ? _b : theme.getSnapGridMinorAlpha(),
                    width: (_c = options.width) !== null && _c !== void 0 ? _c : theme.getSnapGridMinorWidth(),
                    style: (_d = options.style) !== null && _d !== void 0 ? _d : theme.getSnapGridMinorStyle()
                };
            }
            return {
                color: theme.getSnapGridMinorColor(),
                alpha: theme.getSnapGridMinorAlpha(),
                width: theme.getSnapGridMinorWidth(),
                style: theme.getSnapGridMinorStyle()
            };
        };
        DDiagramCanvasEditorSnap.prototype.toTarget = function (theme, options) {
            var _a, _b, _c, _d;
            if (options != null) {
                return {
                    color: (_a = options.color) !== null && _a !== void 0 ? _a : theme.getSnapTargetColor(),
                    alpha: (_b = options.alpha) !== null && _b !== void 0 ? _b : theme.getSnapTargetAlpha(),
                    width: (_c = options.width) !== null && _c !== void 0 ? _c : theme.getSnapTargetWidth(),
                    style: (_d = options.style) !== null && _d !== void 0 ? _d : theme.getSnapTargetStyle()
                };
            }
            return {
                color: theme.getSnapTargetColor(),
                alpha: theme.getSnapTargetAlpha(),
                width: theme.getSnapTargetWidth(),
                style: theme.getSnapTargetStyle()
            };
        };
        DDiagramCanvasEditorSnap.prototype.onChange = function () {
            this._isDirty = true;
            DApplications.update(this._parent);
        };
        Object.defineProperty(DDiagramCanvasEditorSnap.prototype, "container", {
            get: function () {
                return this._container;
            },
            enumerable: false,
            configurable: true
        });
        DDiagramCanvasEditorSnap.prototype.serialize = function () {
            return this._controller.serialize();
        };
        DDiagramCanvasEditorSnap.prototype.onResize = function (newWidth, newHeight, oldWidth, oldHeight) {
            if (this._gridParentWidth !== newWidth || this._gridParentHeight !== newHeight) {
                this._gridParentWidth = newWidth;
                this._gridParentHeight = newHeight;
                this._isDirty = true;
                this.updateGridSize();
            }
        };
        DDiagramCanvasEditorSnap.prototype.onScale = function (newX, newY, oldX, oldY) {
            if (this._gridParentScale !== newX) {
                this._gridParentScale = newX;
                this.updateGridSize();
            }
        };
        DDiagramCanvasEditorSnap.prototype.updateGridSize = function () {
            var gridSize = this.newGridSize();
            if (this._gridSize !== gridSize) {
                this._gridSize = gridSize;
                this._isDirty = true;
            }
        };
        DDiagramCanvasEditorSnap.prototype.newGridSize = function () {
            return this._grid.size(this._controller.grid.size, this._gridParentWidth, this._gridParentHeight, this._gridParentScale);
        };
        DDiagramCanvasEditorSnap.prototype.onRender = function () {
            if (this._isDirty) {
                this._isDirty = false;
                this.updateAll();
            }
        };
        DDiagramCanvasEditorSnap.prototype.updateAll = function () {
            var container = this._container;
            var controller = this._controller;
            var isGridVisible = controller.grid.visible;
            var isTargetVisible = controller.target.visible;
            if (isGridVisible || isTargetVisible) {
                var w = this._gridParentWidth;
                var h = this._gridParentHeight;
                var wh = 0.5 * w;
                var hh = 0.5 * h;
                var TOP = EShapeBarPosition.TOP;
                var LEFT = EShapeBarPosition.LEFT;
                var shapes = container.children;
                var index = 0;
                // Grid
                if (isGridVisible) {
                    var grid = this._grid;
                    var major = grid.major;
                    var minor = grid.minor;
                    var interval = major.interval;
                    var size = this._gridSize;
                    for (var x = size, ix = 1; x < w; x += size, ix += 1, index += 1) {
                        var style = ix % interval === 0 ? major : minor;
                        this.update(container, shapes, index, x, hh, TOP, w, h, style);
                    }
                    for (var y = size, iy = 1; y < h; y += size, iy += 1, index += 1) {
                        var style = iy % interval === 0 ? major : minor;
                        this.update(container, shapes, index, wh, y, LEFT, w, h, style);
                    }
                }
                // Target
                if (isTargetVisible) {
                    var values = controller.target.values;
                    var target = this._target;
                    for (var i = 0, imax = values.length; i < imax; i += 1, index += 1) {
                        var value = values[i];
                        var position = value.position;
                        if (value.type === ESnapperTargetValueType.VERTICAL) {
                            this.update(container, shapes, index, position, hh, TOP, w, h, target);
                        }
                        else {
                            this.update(container, shapes, index, wh, position, LEFT, w, h, target);
                        }
                    }
                }
                for (var i = index, imax = shapes.length; i < imax; ++i) {
                    shapes[i].visible = false;
                }
                container.visible = true;
            }
            else {
                container.visible = false;
            }
        };
        DDiagramCanvasEditorSnap.prototype.update = function (container, shapes, index, x, y, position, w, h, style) {
            var shape = null;
            if (index < shapes.length) {
                shape = shapes[index];
                shape.lock(EShapeLockPart.UPLOADED);
                shape.points.position = position;
                shape.transform.position.set(x, y);
                shape.stroke.set(true, style.color, style.alpha, style.width, undefined, undefined, style.style);
                shape.size.set(w, h);
                shape.visible = true;
                shape.unlock(EShapeLockPart.UPLOADED, true);
            }
            else {
                shape = new EShapeBar();
                shape.lock(EShapeLockPart.UPLOADED);
                shape.points.position = position;
                shape.transform.position.set(x, y);
                shape.stroke.set(true, style.color, style.alpha, style.width, undefined, undefined, style.style);
                shape.size.set(w, h);
                shape.visible = true;
                shape.unlock(EShapeLockPart.UPLOADED, true);
                shape.attach(container);
            }
        };
        return DDiagramCanvasEditorSnap;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDiagramSerializedVersion = 1;

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDiagramCanvasEditor = /** @class */ (function (_super) {
        __extends(DDiagramCanvasEditor, _super);
        function DDiagramCanvasEditor(options) {
            var _this = _super.call(this, options) || this;
            _this._snap = _this.toSnap(_this.theme, options.snap);
            return _this;
        }
        DDiagramCanvasEditor.prototype.toSnap = function (theme, options) {
            if (options) {
                return new DDiagramCanvasEditorSnap(this, theme, options);
            }
            return null;
        };
        Object.defineProperty(DDiagramCanvasEditor.prototype, "snap", {
            get: function () {
                return this._snap;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDiagramCanvasEditor.prototype, "shape", {
            get: function () {
                var _a;
                return ((_a = this._shape) !== null && _a !== void 0 ? _a : (this._shape = this.newShape()));
            },
            enumerable: false,
            configurable: true
        });
        DDiagramCanvasEditor.prototype.newShape = function () {
            return new DDiagramCanvasEditorShapeImpl(this);
        };
        DDiagramCanvasEditor.prototype.serialize = function (id, thumbnail) {
            var _a;
            var manager = new EShapeResourceManagerSerialization();
            var items = [];
            var background = this._background;
            var backgroundColor = background.color;
            var backgroundAlpha = background.alpha;
            return {
                version: DDiagramSerializedVersion,
                id: id,
                name: this.name,
                label: this.label,
                width: this.width,
                height: this.height,
                category: this.category,
                summary: this.summary,
                description: this.description,
                background: {
                    color: isNumber(backgroundColor) ? backgroundColor : 0xffffff,
                    alpha: isNumber(backgroundAlpha) ? backgroundAlpha : 0
                },
                tile: this._tile.serialize(),
                resources: manager.resources,
                data: manager.data,
                pieces: manager.pieces,
                layers: this._layer.serialize(manager, items),
                items: items,
                snap: (_a = this._snap) === null || _a === void 0 ? void 0 : _a.serialize(),
                thumbnail: thumbnail === null || thumbnail === void 0 ? void 0 : thumbnail.serialize()
            };
        };
        DDiagramCanvasEditor.prototype.onResize = function (newWidth, newHeight, oldWidth, oldHeight) {
            var snap = this._snap;
            if (snap != null) {
                snap.onResize(newWidth, newHeight, oldWidth, oldHeight);
            }
            _super.prototype.onResize.call(this, newWidth, newHeight, oldWidth, oldHeight);
        };
        DDiagramCanvasEditor.prototype.onScale = function (newX, newY, oldX, oldY) {
            var snap = this._snap;
            if (snap != null) {
                snap.onScale(newX, newY, oldX, oldY);
            }
            _super.prototype.onScale.call(this, newX, newY, oldX, oldY);
        };
        DDiagramCanvasEditor.prototype.render = function (renderer) {
            var snap = this._snap;
            if (snap != null) {
                snap.onRender();
            }
            _super.prototype.render.call(this, renderer);
        };
        DDiagramCanvasEditor.prototype.getType = function () {
            return "DDiagramCanvasEditor";
        };
        return DDiagramCanvasEditor;
    }(DDiagramCanvasBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDiagramEditorThumbnail = /** @class */ (function () {
        function DDiagramEditorThumbnail(snapshot, theme, options) {
            this._snapshot = snapshot;
            this._isEnabled = this.toIsEnabled(theme, options);
            this._options = this.toCreateAsUrlOptions(theme, options);
        }
        DDiagramEditorThumbnail.prototype.toIsEnabled = function (theme, options) {
            var _a;
            return (_a = options === null || options === void 0 ? void 0 : options.enable) !== null && _a !== void 0 ? _a : theme.isThumbnailEnabled();
        };
        DDiagramEditorThumbnail.prototype.toSize = function (theme, options) {
            return options !== undefined ? options : theme.getThumbnailSize();
        };
        DDiagramEditorThumbnail.prototype.toCleanup = function (theme, cleanup) {
            var _a, _b;
            if (cleanup == null || cleanup === true) {
                return {
                    snap: true,
                    background: true
                };
            }
            else if (cleanup === false) {
                return {
                    snap: false,
                    background: false
                };
            }
            return {
                snap: (_a = cleanup.snap) !== null && _a !== void 0 ? _a : true,
                background: (_b = cleanup.background) !== null && _b !== void 0 ? _b : true
            };
        };
        DDiagramEditorThumbnail.prototype.toCreateAsUrlOptions = function (theme, options) {
            return {
                size: this.toSize(theme, options === null || options === void 0 ? void 0 : options.size),
                cleanup: this.toCleanup(theme, options === null || options === void 0 ? void 0 : options.cleanup)
            };
        };
        Object.defineProperty(DDiagramEditorThumbnail.prototype, "enable", {
            get: function () {
                return this._isEnabled;
            },
            set: function (enable) {
                this._isEnabled = enable;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDiagramEditorThumbnail.prototype, "size", {
            get: function () {
                return this._options.size;
            },
            set: function (size) {
                this._options.size = size;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDiagramEditorThumbnail.prototype, "cleanup", {
            get: function () {
                return this._options.cleanup;
            },
            enumerable: false,
            configurable: true
        });
        DDiagramEditorThumbnail.prototype.serialize = function () {
            if (this._isEnabled) {
                return this._snapshot.createAsUrl(this._options);
            }
        };
        return DDiagramEditorThumbnail;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDiagramEditor = /** @class */ (function (_super) {
        __extends(DDiagramEditor, _super);
        function DDiagramEditor(options) {
            var _this = _super.call(this, options) || this;
            _this._isChanged = false;
            _this._isChanged = false;
            var commands = DControllers.getCommandController();
            commands.on("dirty", function () {
                if (_this._isChanged !== true) {
                    _this._isChanged = true;
                    _this.emit("change", _this);
                }
            });
            var theme = _this.theme;
            _this._snapper = new ESnapper(_this, theme, options === null || options === void 0 ? void 0 : options.snapper);
            _this._thumbnail = new DDiagramEditorThumbnail(_this._snapshot, theme, options === null || options === void 0 ? void 0 : options.thumbnail);
            return _this;
        }
        Object.defineProperty(DDiagramEditor.prototype, "thumbnail", {
            get: function () {
                return this._thumbnail;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDiagramEditor.prototype, "snapper", {
            get: function () {
                return this._snapper;
            },
            enumerable: false,
            configurable: true
        });
        DDiagramEditor.prototype.toMode = function (options) {
            if (options === null || options === void 0 ? void 0 : options.mapping) {
                return EShapeResourceManagerDeserializationMode.EDITOR_DATA_MAPPED;
            }
            return EShapeResourceManagerDeserializationMode.EDITOR;
        };
        DDiagramEditor.prototype.newCanvas = function (serialized) {
            return new DDiagramCanvasEditor(this.toCanvasOptions(serialized));
        };
        DDiagramEditor.prototype.toCanvasOptions = function (serialized) {
            var options = this.toCanvasBaseOptions(serialized);
            // Snapper
            var snapper = this._snapper;
            var snap = options.snap;
            if (snap == null) {
                options.snap = {
                    controller: snapper
                };
            }
            else if (snap.controller == null) {
                snap.controller = snapper;
            }
            return options;
        };
        DDiagramEditor.prototype.serialize = function () {
            var canvas = this.canvas;
            var serialized = this._serialized;
            if (canvas != null && serialized != null) {
                this.emit("serializing", canvas, this);
                try {
                    var result = canvas.serialize(serialized.id, this._thumbnail);
                    this.emit("serialized", canvas, null, this);
                    return result;
                }
                catch (e) {
                    this.emit("serialized", canvas, "exception", this);
                    return null;
                }
            }
            return null;
        };
        DDiagramEditor.prototype.save = function () {
            var _this = this;
            var serialized = this.serialize();
            if (serialized != null) {
                var controller = this._controller;
                if (controller) {
                    var simple = DDiagrams.toSimple(serialized);
                    this.emit("saving", simple, this);
                    return controller.save(simple).then(function (newId) {
                        _this._isChanged = false;
                        serialized.id = newId;
                        _this._serialized = serialized;
                        _this.emit("change", _this);
                        _this.emit("saved", null, _this);
                    }, function (reason) {
                        _this.emit("saved", reason, _this);
                    });
                }
                else {
                    this.emit("saved", "no-controller", this);
                    return Promise.reject();
                }
            }
            this.emit("saved", null, this);
            return Promise.resolve();
        };
        DDiagramEditor.prototype.saveAs = function (name) {
            var _this = this;
            var serialized = this.serialize();
            if (serialized != null) {
                var controller = this._controller;
                if (controller) {
                    serialized.id = undefined;
                    serialized.name = name;
                    var simple = DDiagrams.toSimple(serialized);
                    this.emit("saving", simple, this);
                    return controller.save(simple).then(function (newId) {
                        _this._isChanged = false;
                        serialized.id = newId;
                        _this._serialized = serialized;
                        var canvas = _this.canvas;
                        if (canvas != null) {
                            canvas.name = name;
                        }
                        _this.emit("change", _this);
                        _this.emit("saved", null, _this);
                    }, function (reason) {
                        _this.emit("saved", reason, _this);
                    });
                }
                else {
                    this.emit("saved", "no-controller", this);
                    return Promise.reject("no-controller");
                }
            }
            this.emit("saved", null, this);
            return Promise.resolve();
        };
        DDiagramEditor.prototype.delete = function () {
            var _this = this;
            var serialized = this._serialized;
            if (serialized && serialized.id != null) {
                var controller = this._controller;
                if (controller) {
                    this.emit("deleting", this);
                    return controller.delete(serialized.id).then(function () {
                        var result = _this.set(null);
                        _this.emit("deleted", null, _this);
                        return result;
                    }, function (reason) {
                        _this.emit("deleted", reason, _this);
                        return Promise.reject(reason);
                    });
                }
                else {
                    this.emit("deleted", "no-controller", this);
                    return Promise.reject("no-controller");
                }
            }
            this.set(null);
            this.emit("deleted", null, this);
            return Promise.resolve(null);
        };
        DDiagramEditor.prototype.create = function (options) {
            return this.set({
                version: DDiagramSerializedVersion,
                id: undefined,
                name: options.name,
                label: options.label,
                width: options.width,
                height: options.height,
                category: options.category,
                summary: options.summary,
                description: options.description,
                background: options.background,
                resources: [],
                data: [],
                layers: [[this.theme.getBaseLayerLabel()]],
                items: [],
                snap: undefined
            });
        };
        DDiagramEditor.prototype.onSet = function (serialized, canvas) {
            _super.prototype.onSet.call(this, serialized, canvas);
            // Snap settings
            var snap = serialized.snap;
            var snapper = this._snapper;
            if (snap != null) {
                snapper.deserialize(snap);
            }
            else {
                snapper.reset();
            }
            if (this._isAmbient) {
                snapper.target.visible = false;
                snapper.grid.visible = false;
            }
            // Reset the isChanged flag
            this._isChanged = false;
            // Done
            this.emit("change", this);
        };
        DDiagramEditor.prototype.onUnset = function () {
            _super.prototype.onUnset.call(this);
            this._isChanged = false;
            this.emit("change", this);
        };
        DDiagramEditor.prototype.open = function (id) {
            var _this = this;
            var controller = this._controller;
            if (controller) {
                this.emit("opening", this);
                return controller.get(id).then(function (serialized) {
                    var result = _this.set(DDiagrams.toSerialized(serialized));
                    _this.emit("opened", null, _this);
                    return result;
                }, function (reason) {
                    _this.emit("opened", reason, _this);
                    return Promise.reject(reason);
                });
            }
            this.emit("opened", "no-controller", this);
            return Promise.reject("no-controller");
        };
        DDiagramEditor.prototype.close = function () {
            return this.set(null);
        };
        DDiagramEditor.prototype.isChanged = function () {
            return this._isChanged || this.isNew();
        };
        DDiagramEditor.prototype.isNew = function () {
            var serialized = this._serialized;
            if (serialized != null) {
                return serialized.id == null;
            }
            return false;
        };
        DDiagramEditor.prototype.getName = function () {
            var serialized = this._serialized;
            if (serialized != null) {
                return serialized.name;
            }
            return null;
        };
        DDiagramEditor.prototype.getType = function () {
            return "DDiagramEditor";
        };
        return DDiagramEditor;
    }(DDiagramBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogConfirmMessage = /** @class */ (function (_super) {
        __extends(DDialogConfirmMessage, _super);
        function DDialogConfirmMessage() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DDialogConfirmMessage.prototype.getType = function () {
            return "DDialogConfirmMessage";
        };
        return DDialogConfirmMessage;
    }(DImage));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogConfirm = /** @class */ (function (_super) {
        __extends(DDialogConfirm, _super);
        function DDialogConfirm() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DDialogConfirm.prototype.newContentChildren = function (theme, options) {
            var result = _super.prototype.newContentChildren.call(this, theme, options);
            result.push(this.message);
            return result;
        };
        DDialogConfirm.prototype.toMessage = function (theme, options) {
            var message = options === null || options === void 0 ? void 0 : options.message;
            if (message != null) {
                if (isString(message) || isFunction(message)) {
                    return this.newMessage(this.toMessageOptions(message));
                }
                else if (message instanceof DBase) {
                    return message;
                }
                else {
                    return this.newMessage(this.toMessageOptionsMerged(message, theme.getMessage()));
                }
            }
            return this.newMessage(this.toMessageOptions(theme.getMessage()));
        };
        DDialogConfirm.prototype.toMessageOptionsMerged = function (options, message) {
            var text = options.text;
            if (text == null) {
                text = {};
                options.text = text;
            }
            if (text.value === undefined) {
                text.value = message;
            }
            return options;
        };
        DDialogConfirm.prototype.toMessageOptions = function (message) {
            return {
                text: {
                    value: message
                }
            };
        };
        DDialogConfirm.prototype.newMessage = function (options) {
            return new DDialogConfirmMessage(options);
        };
        Object.defineProperty(DDialogConfirm.prototype, "message", {
            get: function () {
                var result = this._message;
                if (result == null) {
                    result = this.toMessage(this.theme, this._options);
                    this._message = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DDialogConfirm.prototype.getResolvedValue = function () {
            return undefined;
        };
        DDialogConfirm.prototype.getType = function () {
            return "DDialogConfirm";
        };
        return DDialogConfirm;
    }(DDialogLayered));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogConfirmDelete = /** @class */ (function (_super) {
        __extends(DDialogConfirmDelete, _super);
        function DDialogConfirmDelete() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DDialogConfirmDelete.prototype.getType = function () {
            return "DDialogConfirmDelete";
        };
        return DDialogConfirmDelete;
    }(DDialogConfirm));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogConfirmDiscard = /** @class */ (function (_super) {
        __extends(DDialogConfirmDiscard, _super);
        function DDialogConfirmDiscard() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DDialogConfirmDiscard.prototype.getType = function () {
            return "DDialogConfirmDiscard";
        };
        return DDialogConfirmDiscard;
    }(DDialogConfirm));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogMessage = /** @class */ (function (_super) {
        __extends(DDialogMessage, _super);
        function DDialogMessage() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DDialogMessage.prototype.getType = function () {
            return "DDialogMessage";
        };
        return DDialogMessage;
    }(DDialogConfirm));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogProcessingMessage = /** @class */ (function (_super) {
        __extends(DDialogProcessingMessage, _super);
        function DDialogProcessingMessage() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DDialogProcessingMessage.prototype.getType = function () {
            return "DDialogProcessingMessage";
        };
        return DDialogProcessingMessage;
    }(DDialogConfirmMessage));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogProcessing = /** @class */ (function (_super) {
        __extends(DDialogProcessing, _super);
        function DDialogProcessing(options) {
            var _a;
            var _this = _super.call(this, options) || this;
            _this._isDone = true;
            _this._startTime = 0;
            var theme = _this.theme;
            var delay = options === null || options === void 0 ? void 0 : options.delay;
            _this._delayDone = (_a = delay === null || delay === void 0 ? void 0 : delay.done) !== null && _a !== void 0 ? _a : theme.getDoneDelay();
            var delayClose = delay === null || delay === void 0 ? void 0 : delay.close;
            _this._delayClose = delayClose !== undefined ? delayClose : theme.getCloseDelay();
            _this._messageText = _this.message.text.value;
            return _this;
        }
        DDialogProcessing.prototype.newMessage = function (options) {
            return new DDialogProcessingMessage(options);
        };
        DDialogProcessing.prototype.onOpen = function () {
            this._isDone = false;
            this._startTime = Date.now();
            var timeoutId = this._timeoutId;
            if (timeoutId != null) {
                clearTimeout(timeoutId);
            }
            var closeTimeoutId = this._closeTimeoutId;
            if (closeTimeoutId != null) {
                clearTimeout(closeTimeoutId);
            }
            var message = this.message;
            message.text = this._messageText;
            message.state.removeAll(DBaseState.SUCCEEDED, DBaseState.FAILED);
            var footer = this._footer;
            if (footer != null) {
                footer.hide();
            }
            _super.prototype.onOpen.call(this);
        };
        DDialogProcessing.prototype.onDone = function (delay) {
            var _this = this;
            if (delay != null) {
                this._closeTimeoutId = window.setTimeout(function () {
                    _this.close();
                }, delay);
            }
            else {
                this.close();
            }
        };
        DDialogProcessing.prototype.onResolved = function (message) {
            if (message != null) {
                this.message.text = message;
            }
            this.message.state.set(DBaseState.SUCCEEDED, DBaseState.FAILED);
            var delayClose = this._delayClose;
            if (delayClose != null) {
                this.onDone(delayClose);
            }
            else {
                var footer = this._footer;
                if (footer != null) {
                    footer.show();
                }
                else {
                    this.close();
                }
            }
        };
        DDialogProcessing.prototype.onRejected = function (message) {
            if (message != null) {
                this.message.text = message;
            }
            this.message.state.set(DBaseState.FAILED, DBaseState.SUCCEEDED);
            var footer = this._footer;
            if (footer != null) {
                footer.show();
            }
            else {
                this.onDone(this._delayClose);
            }
        };
        DDialogProcessing.prototype.resolve = function (message) {
            var _this = this;
            if (!this._isDone) {
                this._isDone = true;
                var elapsedTime = Date.now() - this._startTime;
                var delay = this._delayDone - elapsedTime;
                if (0 < delay) {
                    this._timeoutId = window.setTimeout(function () {
                        _this._timeoutId = undefined;
                        _this.onResolved(message);
                    }, delay);
                }
                else {
                    this.onResolved(message);
                }
            }
        };
        DDialogProcessing.prototype.reject = function (message) {
            var _this = this;
            if (!this._isDone) {
                this._isDone = true;
                var elapsedTime = Date.now() - this._startTime;
                var delay = this._delayDone - elapsedTime;
                if (0 < delay) {
                    this._timeoutId = window.setTimeout(function () {
                        _this._timeoutId = undefined;
                        _this.onRejected(message);
                    }, delay);
                }
                else {
                    this.onRejected(message);
                }
            }
        };
        DDialogProcessing.prototype.onCloseOn = function () {
            if (this._isDone) {
                _super.prototype.onCloseOn.call(this);
            }
        };
        DDialogProcessing.prototype.getType = function () {
            return "DDialogProcessing";
        };
        return DDialogProcessing;
    }(DDialogConfirm));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogSaveAs = /** @class */ (function (_super) {
        __extends(DDialogSaveAs, _super);
        function DDialogSaveAs() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DDialogSaveAs.prototype.onOpen = function () {
            var name = DControllers.getDocumentController().getName();
            if (name != null) {
                this.input.value = name;
            }
            _super.prototype.onOpen.call(this);
        };
        DDialogSaveAs.prototype.onOk = function (value) {
            _super.prototype.onOk.call(this, value);
            var commandController = DControllers.getCommandController();
            if (isString(value)) {
                commandController.push(new DCommandSaveAs(value));
            }
            else {
                value.then(function (resolved) {
                    commandController.push(new DCommandSaveAs(resolved));
                });
            }
        };
        DDialogSaveAs.prototype.getType = function () {
            return "DDialogSaveAs";
        };
        return DDialogSaveAs;
    }(DDialogInputText));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDropdown = /** @class */ (function (_super) {
        __extends(DDropdown, _super);
        function DDropdown() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DDropdown.prototype.getType = function () {
            return "DDropdown";
        };
        return DDropdown;
    }(DDropdownBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DExpandableHeader = /** @class */ (function (_super) {
        __extends(DExpandableHeader, _super);
        function DExpandableHeader(options) {
            var _this = _super.call(this, options) || this;
            _this.on(UtilPointerEvent.down, function (e) {
                if (_this.state.isActionable) {
                    _this.onSelect(e);
                }
            });
            return _this;
        }
        DExpandableHeader.prototype.onSelect = function (e) {
            this.emit("select", this);
        };
        DExpandableHeader.prototype.onKeyDown = function (e) {
            if (UtilKeyboardEvent.isActivateKey(e)) {
                this.onKeyDownActivate(e);
            }
            return _super.prototype.onKeyDown.call(this, e);
        };
        DExpandableHeader.prototype.onKeyDownActivate = function (e) {
            if (this.state.isActionable && this.state.isFocused) {
                this.onSelect(e);
                return true;
            }
            return false;
        };
        DExpandableHeader.prototype.getType = function () {
            return "DExpandableHeader";
        };
        return DExpandableHeader;
    }(DImage));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DExpandable = /** @class */ (function (_super) {
        __extends(DExpandable, _super);
        function DExpandable() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DExpandable.prototype.init = function (options) {
            var _this = this;
            _super.prototype.init.call(this, options);
            // Header
            var theme = this.theme;
            var header = this.toHeader(theme, options);
            this._header = header;
            header.on("select", function () {
                _this.toggle();
            });
            this.addChild(header);
            // Body
            var body = this.toBody(theme, options);
            this._body = body;
            this.addChild(body);
            //
            if (this.state.isActive) {
                this.onActivated();
            }
            else {
                this.onDeactivated();
            }
        };
        DExpandable.prototype.toHeader = function (theme, options) {
            if (options && options.header) {
                if (options.header instanceof pixi_js.DisplayObject) {
                    return options.header;
                }
                else {
                    return this.newHeader(theme, options.header);
                }
            }
            return this.newHeader(theme);
        };
        DExpandable.prototype.newHeader = function (theme, options) {
            return new DExpandableHeader(options);
        };
        DExpandable.prototype.toBody = function (theme, options) {
            return options.body;
        };
        DExpandable.prototype.open = function () {
            this.state.isActive = true;
        };
        DExpandable.prototype.close = function () {
            this.state.isActive = false;
        };
        DExpandable.prototype.toggle = function () {
            this.state.isActive = !this.state.isActive;
        };
        DExpandable.prototype.onActivated = function () {
            var body = this._body;
            if (body instanceof DBase) {
                body.show();
            }
            else {
                body.visible = true;
            }
        };
        DExpandable.prototype.onDeactivated = function () {
            var body = this._body;
            if (body instanceof DBase) {
                body.hide();
            }
            else {
                body.visible = false;
            }
        };
        DExpandable.prototype.onStateChange = function (newState, oldState) {
            _super.prototype.onStateChange.call(this, newState, oldState);
            if (newState.isActive) {
                if (!oldState.isActive) {
                    this.onActivated();
                }
            }
            else {
                if (oldState.isActive) {
                    this.onDeactivated();
                }
            }
        };
        DExpandable.prototype.getType = function () {
            return "DExpandable";
        };
        return DExpandable;
    }(DLayoutVertical));

    var DIndicatorProcessingState = {
        INITIAL: 0,
        STARTED: 1,
        RESOLVED: 2,
        REJECTED: 3
    };
    var DIndicatorProcessing = /** @class */ (function () {
        function DIndicatorProcessing(parent, options) {
            var _a, _b, _c, _d, _e, _f, _g;
            this._parent = parent;
            this._state = DIndicatorProcessingState.INITIAL;
            this._startTime = 0;
            // Delay
            var theme = this.theme;
            var delay = options === null || options === void 0 ? void 0 : options.delay;
            this._delayDone = (_a = delay === null || delay === void 0 ? void 0 : delay.done) !== null && _a !== void 0 ? _a : theme.getProcessDoneDelay();
            var delayClose = delay === null || delay === void 0 ? void 0 : delay.close;
            this._delayClose = delayClose !== undefined ? delayClose : theme.getProcessCloseDelay();
            // Text
            var text = options === null || options === void 0 ? void 0 : options.text;
            this._isTextEnabled = (_b = text === null || text === void 0 ? void 0 : text.enabled) !== null && _b !== void 0 ? _b : theme.isProcessTextEnabled();
            this._textValue = (_c = text === null || text === void 0 ? void 0 : text.value) !== null && _c !== void 0 ? _c : theme.newProcessTextValue();
            // Image
            var image = options === null || options === void 0 ? void 0 : options.image;
            this._isImageEnabled = (_d = image === null || image === void 0 ? void 0 : image.enabled) !== null && _d !== void 0 ? _d : theme.isProcessImageEnabled();
            this._imageIndex = (_e = image === null || image === void 0 ? void 0 : image.index) !== null && _e !== void 0 ? _e : theme.getProcessImageIndex();
            this._imageSource = (_f = image === null || image === void 0 ? void 0 : image.source) !== null && _f !== void 0 ? _f : theme.newProcessImageSource();
            this._imageRotation = (_g = image === null || image === void 0 ? void 0 : image.rotation) !== null && _g !== void 0 ? _g : theme.newProcessImageRotation();
            // State
            this._wasReadOnly = false;
        }
        DIndicatorProcessing.prototype.start = function () {
            var state = this._state;
            if (state === DIndicatorProcessingState.INITIAL) {
                this._state = DIndicatorProcessingState.STARTED;
                this.onBegin();
            }
            else if (state === DIndicatorProcessingState.RESOLVED ||
                state === DIndicatorProcessingState.REJECTED) {
                this._state = DIndicatorProcessingState.STARTED;
                this.onEnd();
                this.onBegin();
            }
            return this;
        };
        DIndicatorProcessing.prototype.onBegin = function () {
            this._startTime = Date.now();
            var timeoutId = this._timeoutId;
            if (timeoutId != null) {
                clearTimeout(timeoutId);
            }
            var closeTimeoutId = this._closeTimeoutId;
            if (closeTimeoutId != null) {
                clearTimeout(closeTimeoutId);
            }
            var parent = this._parent;
            var state = parent.state;
            state.lock();
            state.ticker.remove(DBaseState.PROCESSING).add(DBaseState.PROCESSING, 32);
            state.removeAll(DBaseState.SUCCEEDED, DBaseState.FAILED);
            this._wasReadOnly = state.isReadOnly;
            if (!this._wasReadOnly) {
                state.add(DBaseState.READ_ONLY);
            }
            state.unlock();
            if (this._isTextEnabled) {
                this._textValueBackup = parent.text.value;
                var textValue = this._textValue;
                if (textValue !== undefined) {
                    parent.text = textValue;
                }
            }
            if (this._isImageEnabled) {
                var image = parent.image.get(this._imageIndex);
                if (image != null) {
                    this._imageSourceBackup = image.source;
                    this._imageRotationBackup = image.rotation;
                    var imageSource = this._imageSource;
                    if (imageSource !== undefined) {
                        image.source = imageSource;
                    }
                    var imageRotation = this._imageRotation;
                    if (imageRotation !== undefined) {
                        image.rotation = imageRotation;
                    }
                }
            }
        };
        DIndicatorProcessing.prototype.end = function () {
            var state = this._state;
            if (state === DIndicatorProcessingState.STARTED ||
                state === DIndicatorProcessingState.RESOLVED ||
                state === DIndicatorProcessingState.REJECTED) {
                this._state = DIndicatorProcessingState.INITIAL;
                this.onEnd();
            }
            return this;
        };
        DIndicatorProcessing.prototype.onEnd = function () {
            var timeoutId = this._timeoutId;
            if (timeoutId != null) {
                clearTimeout(timeoutId);
            }
            var closeTimeoutId = this._closeTimeoutId;
            if (closeTimeoutId != null) {
                clearTimeout(closeTimeoutId);
            }
            var parent = this._parent;
            var state = parent.state;
            state.lock();
            state.ticker.remove(DBaseState.PROCESSING);
            state.removeAll(DBaseState.SUCCEEDED, DBaseState.FAILED);
            if (!this._wasReadOnly) {
                state.remove(DBaseState.READ_ONLY);
            }
            state.unlock();
            if (this._isTextEnabled) {
                parent.text = this._textValueBackup;
            }
            if (this._isImageEnabled) {
                var image = parent.image.get(this._imageIndex);
                if (image != null) {
                    image.source = this._imageSourceBackup;
                    image.rotation = this._imageRotationBackup;
                }
            }
        };
        DIndicatorProcessing.prototype.resolve = function (message) {
            var _this = this;
            if (this._state === DIndicatorProcessingState.STARTED) {
                this._state = DIndicatorProcessingState.RESOLVED;
                var elapsedTime = Date.now() - this._startTime;
                var delay = this._delayDone - elapsedTime;
                if (0 < delay) {
                    this._timeoutId = window.setTimeout(function () {
                        _this._timeoutId = undefined;
                        _this.onResolved(message);
                    }, delay);
                }
                else {
                    this.onResolved(message);
                }
            }
        };
        DIndicatorProcessing.prototype.onResolved = function (message) {
            var parent = this._parent;
            if (this._isTextEnabled && message != null) {
                parent.text = message;
            }
            var state = parent.state;
            state.lock();
            state.ticker.remove(DBaseState.PROCESSING);
            state.add(DBaseState.SUCCEEDED);
            state.remove(DBaseState.FAILED);
            if (!this._wasReadOnly) {
                state.remove(DBaseState.READ_ONLY);
            }
            state.unlock();
            this.onDone(this._delayClose);
        };
        DIndicatorProcessing.prototype.reject = function (message) {
            var _this = this;
            if (this._state === DIndicatorProcessingState.STARTED) {
                this._state = DIndicatorProcessingState.REJECTED;
                var elapsedTime = Date.now() - this._startTime;
                var delay = this._delayDone - elapsedTime;
                if (0 < delay) {
                    this._timeoutId = window.setTimeout(function () {
                        _this._timeoutId = undefined;
                        _this.onRejected(message);
                    }, delay);
                }
                else {
                    this.onRejected(message);
                }
            }
        };
        DIndicatorProcessing.prototype.onRejected = function (message) {
            var parent = this._parent;
            if (this._isTextEnabled && message != null) {
                parent.text = message;
            }
            var state = parent.state;
            state.lock();
            state.ticker.remove(DBaseState.PROCESSING);
            state.add(DBaseState.FAILED);
            state.remove(DBaseState.SUCCEEDED);
            if (!this._wasReadOnly) {
                state.remove(DBaseState.READ_ONLY);
            }
            state.unlock();
            this.onDone(this._delayClose);
        };
        DIndicatorProcessing.prototype.onDone = function (delay) {
            var _this = this;
            if (delay != null) {
                this._closeTimeoutId = window.setTimeout(function () {
                    _this._closeTimeoutId = undefined;
                    _this.end();
                }, delay);
            }
            else {
                this.end();
            }
        };
        DIndicatorProcessing.prototype.getType = function () {
            return "DIndicatorProcessing";
        };
        Object.defineProperty(DIndicatorProcessing.prototype, "theme", {
            get: function () {
                return DThemes.get(this.getType());
            },
            enumerable: false,
            configurable: true
        });
        return DIndicatorProcessing;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DInputIntegerAndLabel = /** @class */ (function (_super) {
        __extends(DInputIntegerAndLabel, _super);
        function DInputIntegerAndLabel() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DInputIntegerAndLabel.prototype.createInput = function (options) {
            return new DInputInteger(options);
        };
        return DInputIntegerAndLabel;
    }(DInputAndLabel));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DInputTextArea = /** @class */ (function (_super) {
        __extends(DInputTextArea, _super);
        function DInputTextArea() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DInputTextArea.prototype.newUtil = function () {
            return new UtilInputTextArea(this, this.newOperation(), this.theme, this._options);
        };
        DInputTextArea.prototype.getType = function () {
            return "DInputTextArea";
        };
        return DInputTextArea;
    }(DInput));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A board for layouting elements.
     * Unlike {@link DLayoutVertical} and {@link DLayoutHorizontal},
     * this class doesn't change the position and the size of children.
     * Unlike {@link DBase} and {@link DBoard}, this class doesn't have
     * the background, the border, and the outline. And its children are
     * interactive by default.
     */
    var DLayoutBoard = /** @class */ (function (_super) {
        __extends(DLayoutBoard, _super);
        function DLayoutBoard() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DLayoutBoard.prototype.getType = function () {
            return "DLayoutBoard";
        };
        return DLayoutBoard;
    }(DBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DListItemAmbient = /** @class */ (function (_super) {
        __extends(DListItemAmbient, _super);
        function DListItemAmbient() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DListItemAmbient.prototype.getType = function () {
            return "DListItemAmbient";
        };
        return DListItemAmbient;
    }(DListItem));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMapCoordinateEPSG3857 = /** @class */ (function () {
        function DMapCoordinateEPSG3857(tileSize) {
            if (tileSize === void 0) { tileSize = 256; }
            this._tileSize = tileSize;
        }
        DMapCoordinateEPSG3857.prototype.getTileSize = function () {
            return this._tileSize;
        };
        /**
         * Converts the given (lon, lat) point in WGS84 to (x, y) in EPSG:900913.
         * The origin of the converted point (x, y) is at the middle-left corner.
         * The `meters` can be the same instance that is passed in as the `lonlat`.
         *
         * @param lonlat (lon, lat) point
         * @param meters (x, y) point in meters converted from the given lonlat.
         * @return (x, y) point in meters
         * @see https://www.maptiler.com/google-maps-coordinates-tile-bounds-projection/
         * @see https://qiita.com/MALORGIS/items/1a9114dd090e5b891bf7
         */
        DMapCoordinateEPSG3857.prototype.lonLatToMeters = function (lonlat, meters) {
            var C = DMapCoordinateEPSG3857.CIRCUMFERENCE_HALF;
            meters.x = (lonlat.x * C) / 180;
            meters.y = (Math.log(Math.tan(((90 + lonlat.y) * Math.PI) / 360)) * C) / Math.PI;
            return meters;
        };
        /**
         * The `lonlat` can be the same instance that is passed in as the `meters`.
         *
         * @param meters
         * @param lonlat
         */
        DMapCoordinateEPSG3857.prototype.metersToLonLat = function (meters, lonlat) {
            var C = DMapCoordinateEPSG3857.CIRCUMFERENCE_HALF;
            lonlat.x = (meters.x / C) * 180;
            lonlat.y = (Math.atan(Math.exp((meters.y * Math.PI) / C)) * 360) / Math.PI - 90;
            return lonlat;
        };
        /**
         * Converts pixel coordinates in given zoom level of pyramid to EPSG:900913.
         * The origin of the `pixels` is the top-left corner.
         * The `meters` can be the same instance that is passed in as the `pixels`.
         */
        DMapCoordinateEPSG3857.prototype.pixelsToMeters = function (pixels, tz, tileSize, meters) {
            var R = this.toResolution(tz, tileSize);
            var C = DMapCoordinateEPSG3857.CIRCUMFERENCE_HALF;
            meters.x = pixels.x * R - C;
            meters.y = C - pixels.y * R;
            return meters;
        };
        /**
         * Converts EPSG:900913 to pyramid pixel coordinates in given zoom level.
         * The origin of the pixels is the top-left corner.
         * The `pixels` can be the same instance that is passed in as the `meters`.
         */
        DMapCoordinateEPSG3857.prototype.metersToPixels = function (meters, tz, tileSize, pixels) {
            var R = this.toResolution(tz, tileSize);
            var C = DMapCoordinateEPSG3857.CIRCUMFERENCE_HALF;
            pixels.x = (meters.x + C) / R;
            pixels.y = (C - meters.y) / R;
            return pixels;
        };
        /**
         * Returns a tile covering region in given pixel coordinates.
         * The origin of the tile is the top-left corner.
         * The `tile` can be the same instance that is passed in as the `pixels`.
         */
        DMapCoordinateEPSG3857.prototype.pixelsToTile = function (pixels, tileSize, tile) {
            tile.x = Math.ceil(pixels.x / tileSize) - 1;
            tile.y = Math.ceil(pixels.y / tileSize) - 1;
            return tile;
        };
        /**
         * The origin of the tile is the top-left corner.
         * The `tile` can be the same instance that is passed in as the `meters`.
         */
        DMapCoordinateEPSG3857.prototype.metersToTile = function (meters, tz, tile) {
            var C = DMapCoordinateEPSG3857.CIRCUMFERENCE_HALF;
            var Z = 1 << tz;
            tile.x = Math.ceil(0.5 * (meters.x / C + 1) * Z) - 1;
            tile.y = Math.ceil(0.5 * (1 - meters.y / C) * Z) - 1;
            return tile;
        };
        DMapCoordinateEPSG3857.prototype.lonLatToTile = function (lonlat, tz, tile) {
            return this.metersToTile(this.lonLatToMeters(lonlat, tile), tz, tile);
        };
        DMapCoordinateEPSG3857.prototype.lonLatToPixels = function (lonlat, tz, tileSize, pixels) {
            return this.metersToPixels(this.lonLatToMeters(lonlat, pixels), tz, tileSize, pixels);
        };
        DMapCoordinateEPSG3857.prototype.pixelsToLonLat = function (pixels, tz, tileSize, lonlat) {
            return this.metersToLonLat(this.pixelsToMeters(pixels, tz, tileSize, lonlat), lonlat);
        };
        /**
         * The `pixels` can be the same instance that is passed in as the `tile`.
         */
        DMapCoordinateEPSG3857.prototype.tileToPixels = function (tile, tileSize, pixels) {
            pixels.x = tile.x * tileSize;
            pixels.y = tile.y * tileSize;
            return pixels;
        };
        /**
         * Returns bounds of the given tile in EPSG:900913 coordinates
         * The `meters` can be the same instance that is passed in as the `tile`.
         */
        DMapCoordinateEPSG3857.prototype.tileToMeters = function (tile, tz, meters) {
            var R = this.toResolutionMeter(tz);
            var C = DMapCoordinateEPSG3857.CIRCUMFERENCE_HALF;
            meters.x = tile.x * R + C;
            meters.y = C - tile.y * R;
            return meters;
        };
        DMapCoordinateEPSG3857.prototype.toResolutionMeter = function (tz) {
            return (2 * DMapCoordinateEPSG3857.CIRCUMFERENCE_HALF) / (1 << tz);
        };
        DMapCoordinateEPSG3857.prototype.toResolution = function (tz, tileSize) {
            return (2 * DMapCoordinateEPSG3857.CIRCUMFERENCE_HALF) / (tileSize << tz);
        };
        DMapCoordinateEPSG3857.prototype.toTileCount = function (tz) {
            return 1 << tz;
        };
        DMapCoordinateEPSG3857.prototype.toTileCode = function (tz, tx, ty) {
            return (tx << tz) + ty;
        };
        DMapCoordinateEPSG3857.CIRCUMFERENCE_HALF = Math.PI * 6378137 /* Approximate earth radius in meter */;
        return DMapCoordinateEPSG3857;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMapCoordinates = /** @class */ (function () {
        function DMapCoordinates() {
        }
        Object.defineProperty(DMapCoordinates, "DEFAULT", {
            get: function () {
                if (this._default == null) {
                    this._default = new DMapCoordinateEPSG3857();
                }
                return this._default;
            },
            enumerable: false,
            configurable: true
        });
        return DMapCoordinates;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMapTile = /** @class */ (function () {
        function DMapTile(parent, tx, ty, px, py, scale) {
            this.tx = tx;
            this.ty = ty;
            var sprite = new pixi_js.Sprite(pixi_js.Texture.EMPTY);
            sprite.parent = parent;
            sprite.position.set(px, py);
            sprite.scale.set(scale, scale);
            this._sprite = sprite;
        }
        DMapTile.prototype.load = function (url, onLoaded) {
            var texture = pixi_js.Texture.from(url, { resolution: 1 });
            this._sprite.texture = texture;
            if (texture.valid) {
                onLoaded();
            }
            else {
                texture.on("update", onLoaded);
            }
        };
        DMapTile.prototype.transform = function (px, py, scale) {
            var sprite = this._sprite;
            sprite.position.set(px, py);
            sprite.scale.set(scale, scale);
        };
        Object.defineProperty(DMapTile.prototype, "loaded", {
            get: function () {
                return this._sprite.texture.valid;
            },
            enumerable: false,
            configurable: true
        });
        DMapTile.prototype.render = function (renderer) {
            var sprite = this._sprite;
            sprite.updateTransform();
            sprite.render(renderer);
        };
        DMapTile.prototype.destroy = function () {
            var sprite = this._sprite;
            var texture = sprite.texture;
            var resource = texture.baseTexture.resource;
            var image = null;
            if (resource instanceof pixi_js.resources.BaseImageResource) {
                if (resource.source instanceof HTMLImageElement) {
                    image = resource.source;
                }
            }
            texture.destroy(true);
            sprite.destroy();
            if (image) {
                image.src = "";
            }
        };
        return DMapTile;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMapTilePlane = /** @class */ (function () {
        function DMapTilePlane(parent, builder, tz, mapping, coordinate, onLoaded) {
            var _this = this;
            this._parent = parent;
            this._builder = builder;
            this._onLoaded = onLoaded;
            this._isOnLoadedCalled = false;
            this._isOnLoadedAllowed = true;
            this._onLoadedBound = function () {
                _this.onLoaded();
            };
            this._tz = tz;
            this._lon0 = NaN;
            this._lat0 = NaN;
            this._lon1 = NaN;
            this._lat1 = NaN;
            this._tiles = new Map();
            this._renderTileBound = function (tile) {
                _this.renderTile(tile);
            };
            this._txmin = NaN;
            this._txmax = NaN;
            this._tymin = NaN;
            this._tymax = NaN;
            this._deleteTileBound = function (tile, tileCode, tiles) {
                _this.deleteTile(tile, tileCode, tiles);
            };
            this._destroyTileBound = function (tile) {
                _this.destroyTile(tile);
            };
            this._updateLoadingStateForEach = function (tile) {
                if (!tile.loaded) {
                    _this._isLoaded = false;
                }
            };
            this._tileCount = coordinate.toTileCount(tz);
            this._tileScaleRelative = 1 / this._tileCount;
            this._tileScale = mapping.scale * this._tileScaleRelative;
            this._tileSize = coordinate.getTileSize() * mapping.scale;
            this._mapping = mapping;
            this._coordinate = coordinate;
            this._isLoaded = true;
        }
        DMapTilePlane.prototype.newTile = function (tx, ty, px, py, scale) {
            return new DMapTile(this._parent, tx, ty, px, py, scale);
        };
        DMapTilePlane.prototype.renderTile = function (tile) {
            tile.render(this._renderer);
        };
        Object.defineProperty(DMapTilePlane.prototype, "tz", {
            get: function () {
                return this._tz;
            },
            enumerable: false,
            configurable: true
        });
        DMapTilePlane.prototype.render = function (renderer) {
            this._renderer = renderer;
            this._tiles.forEach(this._renderTileBound);
        };
        DMapTilePlane.prototype.move = function (lon0, lat0, lon1, lat1) {
            var oldLon0 = this._lon0;
            var oldLat0 = this._lat0;
            var oldLon1 = this._lon1;
            var oldLat1 = this._lat1;
            if (oldLon0 !== lon0 || oldLat0 !== lat0 || oldLon1 !== lon1 || oldLat1 !== lat1) {
                this._lon0 = lon0;
                this._lat0 = lat0;
                this._lon1 = lon1;
                this._lat1 = lat1;
                var tz = this._tz;
                var coordinate = this._coordinate;
                var work = DMapTilePlane.WORK;
                work.set(lon0, lat0);
                coordinate.lonLatToTile(work, tz, work);
                var tx0 = work.x;
                var ty0 = work.y;
                work.set(lon1, lat1);
                coordinate.lonLatToTile(work, tz, work);
                var tx1 = work.x;
                var ty1 = work.y;
                var tileCount = this._tileCount;
                var txmin = Math.max(0, tx0);
                var txmax = Math.min(tileCount - 1, tx1);
                var tymin = Math.max(0, ty0);
                var tymax = Math.min(tileCount - 1, ty1);
                var dtxmin = txmin - this._txmin;
                var dtxmax = txmax - this._txmax;
                var dtymin = tymin - this._tymin;
                var dtymax = tymax - this._tymax;
                var isTxMinChanged = dtxmin !== dtxmin || dtxmin < 0 || 1 < dtxmin;
                var isTxMaxChanged = dtxmax !== dtxmax || 0 < dtxmax || dtxmax < -1;
                var isTyMinChanged = dtymin !== dtymin || dtymin < 0 || 1 < dtymin;
                var isTyMaxChanged = dtymax !== dtymax || 0 < dtymax || dtymax < -1;
                if (isTxMinChanged || isTxMaxChanged || isTyMinChanged || isTyMaxChanged) {
                    if (isTxMinChanged) {
                        this._txmin = txmin;
                    }
                    else {
                        txmin = this._txmin;
                    }
                    if (isTxMaxChanged) {
                        this._txmax = txmax;
                    }
                    else {
                        txmax = this._txmax;
                    }
                    if (isTyMinChanged) {
                        this._tymin = tymin;
                    }
                    else {
                        tymin = this._tymin;
                    }
                    if (isTyMaxChanged) {
                        this._tymax = tymax;
                    }
                    else {
                        tymax = this._tymax;
                    }
                    var tiles = this._tiles;
                    tiles.forEach(this._deleteTileBound);
                    var ctx = (txmin + txmax) >> 1;
                    var cty = (tymin + tymax) >> 1;
                    var ltx = Math.max(ctx - txmin, txmax - ctx);
                    var lty = Math.max(cty - tymin, tymax - cty);
                    var lt = Math.max(ltx, lty);
                    this.toOffset(work);
                    var offsetX = work.x;
                    var offsetY = work.y;
                    this._isOnLoadedCalled = false;
                    this._isOnLoadedAllowed = false;
                    this.loadTile(tz, ctx, cty, offsetX, offsetY, work);
                    for (var it = 1; it <= lt; ++it) {
                        var txa = ctx - it;
                        if (txmin <= txa) {
                            this.loadTilesY(tz, txa, cty, it, tymin, tymax, offsetX, offsetY, work);
                        }
                        var txb = ctx + it;
                        if (txb <= txmax) {
                            this.loadTilesY(tz, txb, cty, it, tymin, tymax, offsetX, offsetY, work);
                        }
                        var tya = cty - it;
                        if (tymin <= tya) {
                            this.loadTilesX(tz, ctx, it - 1, txmin, txmax, tya, offsetX, offsetY, work);
                        }
                        var tyb = cty + it;
                        if (tyb <= tymax) {
                            this.loadTilesX(tz, ctx, it - 1, txmin, txmax, tyb, offsetX, offsetY, work);
                        }
                    }
                    this._isOnLoadedAllowed = true;
                    if (this._isOnLoadedCalled) {
                        this.onLoaded();
                    }
                }
            }
        };
        DMapTilePlane.prototype.loadTilesX = function (tz, ctx, ltx, txmin, txmax, ty, ox, oy, work) {
            this.loadTile(tz, ctx, ty, ox, oy, work);
            for (var i = 1; i <= ltx; ++i) {
                var txa = ctx - i;
                if (txmin <= txa) {
                    this.loadTile(tz, txa, ty, ox, oy, work);
                }
                var txb = ctx + i;
                if (txb <= txmax) {
                    this.loadTile(tz, txb, ty, ox, oy, work);
                }
            }
        };
        DMapTilePlane.prototype.loadTilesY = function (tz, tx, cty, lty, tymin, tymax, ox, oy, work) {
            this.loadTile(tz, tx, cty, ox, oy, work);
            for (var i = 1; i <= lty; ++i) {
                var tya = cty - i;
                if (tymin <= tya) {
                    this.loadTile(tz, tx, tya, ox, oy, work);
                }
                var tyb = cty + i;
                if (tyb <= tymax) {
                    this.loadTile(tz, tx, tyb, ox, oy, work);
                }
            }
        };
        DMapTilePlane.prototype.loadTile = function (tz, tx, ty, ox, oy, work) {
            var coordinate = this._coordinate;
            var tileCode = coordinate.toTileCode(tz, tx, ty);
            var tiles = this._tiles;
            var tile = tiles.get(tileCode);
            if (tile == null) {
                this.toTilePosition(tx, ty, ox, oy, work);
                tile = this.newTile(tx, ty, work.x, work.y, this._tileScale);
                tiles.set(tileCode, tile);
                tile.load(this._builder(tz, tx, ty), this._onLoadedBound);
                this._isLoaded = false;
            }
        };
        DMapTilePlane.prototype.toTilePosition = function (tx, ty, ox, oy, result) {
            var tileSize = this._tileSize;
            var tileScaleRelative = this._tileScaleRelative;
            result.set(tx, ty);
            this._coordinate.tileToPixels(result, tileSize, result);
            result.set(result.x * tileScaleRelative + ox, result.y * tileScaleRelative + oy);
            return result;
        };
        DMapTilePlane.prototype.toOffset = function (result) {
            var parent = this._parent;
            var mapping = this._mapping;
            var tileSize = this._tileSize;
            result.set(-mapping.x * tileSize + parent.width * 0.5, -mapping.y * tileSize + parent.height * 0.5);
            return result;
        };
        DMapTilePlane.prototype.deleteTile = function (tile, tileCode, tiles) {
            var tx = tile.tx;
            var ty = tile.ty;
            if (tx < this._txmin || this._txmax < tx || ty < this._tymin || this._tymax < ty) {
                tiles.delete(tileCode);
                tile.destroy();
            }
        };
        DMapTilePlane.prototype.destroy = function () {
            var tiles = this._tiles;
            tiles.forEach(this._destroyTileBound);
            tiles.clear();
        };
        DMapTilePlane.prototype.destroyTile = function (tile) {
            tile.destroy();
        };
        DMapTilePlane.prototype.updateLoadingState = function () {
            this._isLoaded = true;
            this._tiles.forEach(this._updateLoadingStateForEach);
        };
        DMapTilePlane.prototype.onLoaded = function () {
            if (this._isOnLoadedAllowed) {
                this._onLoaded();
            }
            else {
                this._isOnLoadedCalled = true;
            }
        };
        Object.defineProperty(DMapTilePlane.prototype, "loaded", {
            get: function () {
                if (!this._isLoaded) {
                    this.updateLoadingState();
                }
                return this._isLoaded;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DMapTilePlane.prototype, "mapping", {
            get: function () {
                return this._mapping;
            },
            set: function (mapping) {
                var _this = this;
                var coordinate = this._coordinate;
                var tileScale = mapping.scale * this._tileScaleRelative;
                var tileSize = coordinate.getTileSize() * mapping.scale;
                this._tileScale = tileScale;
                this._tileSize = tileSize;
                this._mapping = mapping;
                var work = DMapTilePlane.WORK;
                this.toOffset(work);
                var offsetX = work.x;
                var offsetY = work.y;
                this._tiles.forEach(function (tile) {
                    _this.toTilePosition(tile.tx, tile.ty, offsetX, offsetY, work);
                    tile.transform(work.x, work.y, tileScale);
                });
            },
            enumerable: false,
            configurable: true
        });
        DMapTilePlane.WORK = new pixi_js.Point();
        return DMapTilePlane;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMapTilePyramidImpl = /** @class */ (function (_super) {
        __extends(DMapTilePyramidImpl, _super);
        function DMapTilePyramidImpl(options) {
            var _this = _super.call(this) || this;
            var canvas = options.canvas;
            _this._canvas = canvas;
            _this._builder = options.builder;
            var mapping = options.mapping;
            _this._mapping = mapping;
            var coordinate = options.coordinate;
            _this._coordinate = coordinate;
            _this._mappingInternal = _this.toMapping(canvas, mapping, coordinate);
            _this._z = NaN;
            _this._tz = NaN;
            _this._minZ = options.plane.min;
            _this._maxZ = options.plane.max;
            _this._planes = [];
            _this._onLoadedBound = function () {
                _this.onLoaded();
            };
            _this._fitBound = function () {
                _this._fitBoundTimeout = undefined;
                _this.fit();
            };
            _this._fitThrottle = options.plane.throttle;
            var fitThrottledBound = function () {
                _this.fitThrottled();
            };
            _this._fitThrottledBound = fitThrottledBound;
            canvas.on("scale", fitThrottledBound);
            canvas.on("move", fitThrottledBound);
            canvas.snippet.add(_this, true);
            return _this;
        }
        Object.defineProperty(DMapTilePyramidImpl.prototype, "coordinate", {
            get: function () {
                return this._coordinate;
            },
            enumerable: false,
            configurable: true
        });
        DMapTilePyramidImpl.prototype.fitThrottled = function () {
            if (this._fitBoundTimeout == null) {
                this._fitBoundTimeout = window.setTimeout(this._fitBound, this._fitThrottle);
            }
        };
        DMapTilePyramidImpl.prototype.toMapping = function (canvas, mapping, coordinate) {
            var work = DMapTilePyramidImpl.WORK_LONLAT;
            var tileSize = coordinate.getTileSize();
            work.set(mapping.from.lon, mapping.from.lat);
            coordinate.lonLatToPixels(work, 0, tileSize, work);
            var x0 = work.x;
            var y0 = work.y;
            work.set(mapping.to.lon, mapping.to.lat);
            coordinate.lonLatToPixels(work, 0, tileSize, work);
            var x1 = work.x;
            var y1 = work.y;
            var dx = Math.abs(x1 - x0);
            var dy = Math.abs(y1 - y0);
            var dmin = 0.0000001;
            var scale = 1;
            if (dmin < dx) {
                if (dmin < dy) {
                    scale = Math.max(canvas.width / dx, canvas.height / dy);
                }
                else {
                    scale = canvas.width / dx;
                }
            }
            else {
                if (dmin < dy) {
                    scale = canvas.height / dy;
                }
            }
            return {
                scale: scale,
                x: (0.5 * (x1 + x0)) / tileSize,
                y: (0.5 * (y1 + y0)) / tileSize
            };
        };
        Object.defineProperty(DMapTilePyramidImpl.prototype, "mapping", {
            get: function () {
                return this._mapping;
            },
            set: function (mapping) {
                var oldMapping = this._mappingInternal;
                var newMapping = this.toMapping(this._canvas, mapping, this._coordinate);
                var threshold = 0.0000001;
                if (threshold < Math.abs(oldMapping.scale - newMapping.scale) ||
                    threshold < Math.abs(oldMapping.x - newMapping.x) ||
                    threshold < Math.abs(oldMapping.y - newMapping.y)) {
                    this._mappingInternal = newMapping;
                    var planes = this._planes;
                    for (var i = 0, imax = planes.length; i < imax; ++i) {
                        var plane = planes[i];
                        if (plane) {
                            plane.mapping = newMapping;
                        }
                    }
                    DApplications.update(this._canvas);
                    this._fitThrottledBound();
                }
            },
            enumerable: false,
            configurable: true
        });
        DMapTilePyramidImpl.prototype.newPlane = function (tz) {
            return new DMapTilePlane(this._canvas, this._builder, tz, this._mappingInternal, this._coordinate, this._onLoadedBound);
        };
        DMapTilePyramidImpl.prototype.render = function (renderer) {
            var tz = this._tz;
            var planes = this._planes;
            for (var i = 0; i < tz; ++i) {
                var plane = planes[i];
                if (plane != null) {
                    plane.render(renderer);
                }
            }
            for (var i = planes.length - 1; tz < i; --i) {
                var plane = planes[i];
                if (plane != null) {
                    plane.render(renderer);
                }
            }
            var planeTz = planes[tz];
            if (planeTz != null) {
                planeTz.render(renderer);
            }
        };
        DMapTilePyramidImpl.prototype.toTileZ = function (tz) {
            return Math.min(this._maxZ, Math.max(this._minZ, Math.floor(tz)));
        };
        DMapTilePyramidImpl.prototype.updateTransform = function () {
            // DO NOTHING
        };
        DMapTilePyramidImpl.prototype.toZ = function (scale) {
            return Math.log(this._mappingInternal.scale * scale) / Math.log(2);
        };
        DMapTilePyramidImpl.prototype.move = function (scale, lon0, lat0, lon1, lat1) {
            var planes = this._planes;
            var z = this.toZ(scale);
            if (this._z !== z) {
                this._z = z;
                var tz = this.toTileZ(z);
                if (this._tz !== tz) {
                    this._tz = tz;
                    var newPlane = planes[tz];
                    if (newPlane == null) {
                        newPlane = this.newPlane(tz);
                        planes[tz] = newPlane;
                    }
                }
            }
            var plane = planes[this._tz];
            if (plane != null) {
                plane.move(lon0, lat0, lon1, lat1);
            }
            return this;
        };
        DMapTilePyramidImpl.prototype.fit = function () {
            var canvas = this._canvas;
            if (canvas != null) {
                var container = canvas.parent;
                if (container != null) {
                    var scale = canvas.scale;
                    var scaleX = scale.x;
                    var scaleY = scale.y;
                    var x = canvas.x;
                    var y = canvas.y;
                    var coordinate = this._coordinate;
                    var mapping = this._mappingInternal;
                    var tileSize = coordinate.getTileSize() * mapping.scale;
                    var x0 = mapping.x * tileSize - (x / scaleX + 0.5 * canvas.width);
                    var x1 = x0 + container.width / scaleX;
                    var y0 = mapping.y * tileSize - (y / scaleY + 0.5 * canvas.height);
                    var y1 = y0 + container.height / scaleY;
                    var work = DMapTilePyramidImpl.WORK_LONLAT;
                    work.set(x0, y0);
                    coordinate.pixelsToLonLat(work, 0, tileSize, work);
                    var lon0 = work.x;
                    var lat0 = work.y;
                    work.set(x1, y1);
                    coordinate.pixelsToLonLat(work, 0, tileSize, work);
                    var lon1 = work.x;
                    var lat1 = work.y;
                    this.move(scaleX, lon0, lat0, lon1, lat1);
                }
            }
            return this;
        };
        DMapTilePyramidImpl.prototype.destroyPlanesBefore = function (tz, planes) {
            for (var i = 0; i < tz; ++i) {
                var plane = planes[i];
                if (plane) {
                    plane.destroy();
                    planes[i] = undefined;
                }
            }
        };
        DMapTilePyramidImpl.prototype.destroyPlanesAfter = function (tz, planes) {
            for (var i = tz + 1, imax = planes.length; i < imax; ++i) {
                var plane = planes[i];
                if (plane) {
                    plane.destroy();
                    planes[i] = undefined;
                }
            }
        };
        DMapTilePyramidImpl.prototype.cleanup = function () {
            var tz = this._tz;
            var planes = this._planes;
            var planeTz = planes[tz];
            if (planeTz && planeTz.loaded) {
                this.destroyPlanesBefore(tz, planes);
                this.destroyPlanesAfter(tz, planes);
                return;
            }
            for (var i = tz + 1, imax = planes.length; i < imax; ++i) {
                var plane = planes[i];
                if (plane && plane.loaded) {
                    this.destroyPlanesBefore(tz, planes);
                    this.destroyPlanesAfter(i, planes);
                    return;
                }
            }
            for (var i = tz - 1; 0 <= i; --i) {
                var plane = planes[i];
                if (plane && plane.loaded) {
                    this.destroyPlanesBefore(i, planes);
                    return;
                }
            }
        };
        DMapTilePyramidImpl.prototype.onLoaded = function () {
            this.cleanup();
            DApplications.update(this._canvas);
        };
        DMapTilePyramidImpl.prototype.destroy = function () {
            var planes = this._planes;
            for (var i = 0, imax = planes.length; i < imax; ++i) {
                var plane = planes[i];
                if (plane) {
                    plane.destroy();
                    planes[i] = undefined;
                }
            }
            var canvas = this._canvas;
            var fitThrottledBound = this._fitThrottledBound;
            canvas.off("scale", fitThrottledBound);
            canvas.off("move", fitThrottledBound);
            canvas.snippet.remove(this, true);
            return this;
        };
        DMapTilePyramidImpl.WORK_LONLAT = new pixi_js.Point();
        return DMapTilePyramidImpl;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMapTileUrlBuilderKokudo = function (tz, tx, ty) {
        if (5 <= tz) {
            return "https://cyberjapandata.gsi.go.jp/xyz/pale/".concat(tz, "/").concat(tx, "/").concat(ty, ".png");
        }
        else if (2 <= tz) {
            return "https://cyberjapandata.gsi.go.jp/xyz/std/".concat(tz, "/").concat(tx, "/").concat(ty, ".png");
        }
        else {
            return "https://cyberjapandata.gsi.go.jp/xyz/earthhillshade/".concat(tz, "/").concat(tx, "/").concat(ty, ".png");
        }
    };
    var DMapTileUrlBuilderOsm = function (tz, tx, ty) {
        return "https://".concat("abc"[(tx + ty) % 3], ".tile.openstreetmap.org/").concat(tz, "/").concat(tx, "/").concat(ty, ".png");
    };
    var DMapTileUrlBuilderOsmfj = function (tz, tx, ty) {
        return "https://j.tile.openstreetmap.jp/".concat(tz, "/").concat(tx, "/").concat(ty, ".png");
    };
    var DMapTilePyramids = /** @class */ (function () {
        function DMapTilePyramids() {
        }
        DMapTilePyramids.toPlaneOptions = function (options) {
            var _a, _b, _c;
            var plane = options.plane;
            return {
                min: (_a = plane === null || plane === void 0 ? void 0 : plane.min) !== null && _a !== void 0 ? _a : this.MIN,
                max: (_b = plane === null || plane === void 0 ? void 0 : plane.max) !== null && _b !== void 0 ? _b : this.MAX,
                throttle: (_c = plane === null || plane === void 0 ? void 0 : plane.throttle) !== null && _c !== void 0 ? _c : this.THROTTLE
            };
        };
        DMapTilePyramids.from = function (options) {
            return new DMapTilePyramidImpl({
                canvas: options.canvas,
                builder: options.builder || DMapTileUrlBuilderOsmfj,
                mapping: options.canvas.tile.mapping,
                coordinate: options.coordinate || DMapCoordinates.DEFAULT,
                plane: this.toPlaneOptions(options)
            });
        };
        DMapTilePyramids.MIN = 0;
        DMapTilePyramids.MAX = 18;
        DMapTilePyramids.THROTTLE = 333;
        return DMapTilePyramids;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuBarItem = /** @class */ (function (_super) {
        __extends(DMenuBarItem, _super);
        function DMenuBarItem() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuBarItem.prototype.toMenu = function (theme, options) {
            var menu = options === null || options === void 0 ? void 0 : options.menu;
            if (menu instanceof DMenu) {
                return menu;
            }
            else {
                return new DMenu(this.toMenuOptions(theme, menu));
            }
        };
        DMenuBarItem.prototype.newMenu = function (theme, options) {
            return new DMenu(this.toMenuOptions(theme, options));
        };
        DMenuBarItem.prototype.toMenuOptions = function (theme, options) {
            if (options) {
                if (options.fit == null) {
                    options.fit = false;
                }
                return options;
            }
            return {
                fit: false
            };
        };
        DMenuBarItem.prototype.onActivate = function (e) {
            _super.prototype.onActivate.call(this, e);
            this.open();
        };
        DMenuBarItem.prototype.open = function () {
            this.menu.open(this);
        };
        DMenuBarItem.prototype.close = function () {
            this.menu.close();
        };
        Object.defineProperty(DMenuBarItem.prototype, "menu", {
            get: function () {
                var _this = this;
                var result = this._menu;
                if (result == null) {
                    result = this.toMenu(this.theme, this._options);
                    result.on("select", function (value, item, menu) {
                        _this.onMenuSelect(value, item, menu);
                    });
                    this._menu = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DMenuBarItem.prototype.onMenuSelect = function (value, item, menu) {
            this.emit("select", value, item, this);
            var parent = this.parent;
            if (parent) {
                parent.emit("select", value, item, parent);
            }
        };
        DMenuBarItem.prototype.onKeyDown = function (e) {
            if (UtilKeyboardEvent.isArrowDownKey(e)) {
                this.onKeyDownArrowDown(e);
            }
            return _super.prototype.onKeyDown.call(this, e);
        };
        DMenuBarItem.prototype.onKeyDownArrowDown = function (e) {
            if (this.state.isActionable && this.state.isFocused) {
                this.onActivate(e);
                return true;
            }
            return false;
        };
        DMenuBarItem.prototype.getType = function () {
            return "DMenuBarItem";
        };
        return DMenuBarItem;
    }(DButton));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuBar = /** @class */ (function (_super) {
        __extends(DMenuBar, _super);
        function DMenuBar() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuBar.prototype.init = function (options) {
            _super.prototype.init.call(this, options);
            var items = options === null || options === void 0 ? void 0 : options.items;
            if (items) {
                for (var i = 0, imax = items.length; i < imax; ++i) {
                    var item = this.toItem(items[i]);
                    if (item) {
                        this.addChild(item);
                    }
                }
            }
        };
        DMenuBar.prototype.toItem = function (item) {
            if (item == null) {
                return null;
            }
            else if (item instanceof pixi_js.DisplayObject) {
                return item;
            }
            else if ("space" in item) {
                return new DLayoutSpace(item);
            }
            return new DMenuBarItem(item);
        };
        DMenuBar.prototype.onKeyDown = function (e) {
            UtilKeyboardEvent.moveFocusHorizontally(e, this);
            return _super.prototype.onKeyDown.call(this, e);
        };
        DMenuBar.prototype.getType = function () {
            return "DMenuBar";
        };
        return DMenuBar;
    }(DLayoutHorizontal));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuSidedContent = /** @class */ (function (_super) {
        __extends(DMenuSidedContent, _super);
        function DMenuSidedContent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuSidedContent.prototype.initReflowable = function () {
            // DO NOTHING
        };
        DMenuSidedContent.prototype.getType = function () {
            return "DMenuSidedContent";
        };
        return DMenuSidedContent;
    }(DLayoutHorizontal));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuSidedSelectionType = {
        NONE: 0,
        SINGLE: 1,
        SINGLE_ONCE: 2
    };
    var defaultFilter = function () { return true; };
    var DMenuSidedSelection = /** @class */ (function (_super) {
        __extends(DMenuSidedSelection, _super);
        function DMenuSidedSelection(content, options) {
            var _a, _b, _c;
            var _this = _super.call(this) || this;
            _this._content = content;
            _this._item = null;
            _this._isDirty = true;
            _this._type = toEnum((_b = (_a = options === null || options === void 0 ? void 0 : options.mode) !== null && _a !== void 0 ? _a : options === null || options === void 0 ? void 0 : options.type) !== null && _b !== void 0 ? _b : DMenuSidedSelectionType.SINGLE_ONCE, DMenuSidedSelectionType);
            _this._filter = (_c = options === null || options === void 0 ? void 0 : options.filter) !== null && _c !== void 0 ? _c : _this.getFilterDefault();
            // Events
            var on = options === null || options === void 0 ? void 0 : options.on;
            if (on) {
                for (var name_1 in on) {
                    var handler = on[name_1];
                    if (handler) {
                        _this.on(name_1, handler);
                    }
                }
            }
            return _this;
        }
        DMenuSidedSelection.prototype.first = function () {
            return this._item;
        };
        DMenuSidedSelection.prototype.toDirty = function () {
            this._isDirty = true;
        };
        DMenuSidedSelection.prototype.update = function () {
            if (this._isDirty) {
                this._isDirty = false;
                this.update_(this._content);
            }
        };
        DMenuSidedSelection.prototype.hasMenu = function (child) {
            return child && child.menu instanceof DMenu;
        };
        DMenuSidedSelection.prototype.update_ = function (root) {
            var children = root.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                var child = children[i];
                if (child instanceof DMenuItemBase) {
                    if (child.state.isActive) {
                        this.set_(child, false);
                    }
                }
                if (child instanceof pixi_js.Container) {
                    this.update_(child);
                }
                if (this.hasMenu(child)) {
                    this.update_(child.menu);
                }
            }
        };
        DMenuSidedSelection.prototype.add = function (item) {
            this.update();
            this.set_(item, true);
        };
        DMenuSidedSelection.prototype.set = function (item) {
            this.update();
            this.set_(item, true);
        };
        DMenuSidedSelection.prototype.get = function (index) {
            this.update();
            return this._item;
        };
        DMenuSidedSelection.prototype.getIndex = function (index) {
            return null;
        };
        DMenuSidedSelection.prototype.size = function () {
            return this._item ? 1 : 0;
        };
        DMenuSidedSelection.prototype.isEmpty = function () {
            return this._item == null;
        };
        DMenuSidedSelection.prototype.remove = function (item) {
            this.update();
            if (this._item === item) {
                this.set_(null, true);
            }
        };
        DMenuSidedSelection.prototype.clear = function () {
            this.update();
            this.set_(null, true);
        };
        DMenuSidedSelection.prototype.getFilterDefault = function () {
            return defaultFilter;
        };
        DMenuSidedSelection.prototype.set_ = function (item, emit) {
            var oldItem = this._item;
            var mode = this._type;
            if (mode !== DMenuSidedSelectionType.NONE && this._filter(item) && oldItem !== item) {
                this.setState(oldItem, mode, false);
                this._item = item;
                this.setState(item, mode, true);
                if (emit) {
                    this.emit("change", this);
                }
            }
        };
        DMenuSidedSelection.prototype.setState = function (item, mode, isOn) {
            if (item) {
                if (mode === DMenuSidedSelectionType.SINGLE) {
                    item.state.isActive = isOn;
                }
                else {
                    if (isOn) {
                        item.state.addAll(DBaseState.ACTIVE, DBaseState.READ_ONLY);
                    }
                    else {
                        item.state.removeAll(DBaseState.ACTIVE, DBaseState.READ_ONLY);
                    }
                }
            }
        };
        return DMenuSidedSelection;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuSided = /** @class */ (function (_super) {
        __extends(DMenuSided, _super);
        function DMenuSided(options) {
            var _a;
            var _this = _super.call(this, options) || this;
            var context = new DMenuContext(_this);
            _this._context = context;
            context.add(_this);
            var items = options === null || options === void 0 ? void 0 : options.items;
            if (items != null) {
                var sticky = (_a = options === null || options === void 0 ? void 0 : options.sticky) !== null && _a !== void 0 ? _a : false;
                _this.newItems(items, sticky);
            }
            var selection = options === null || options === void 0 ? void 0 : options.selection;
            _this._selection =
                selection instanceof DMenuSidedSelection ? selection : _this.newSelection(selection);
            return _this;
        }
        DMenuSided.prototype.newSelection = function (options) {
            return new DMenuSidedSelection(this.content, options);
        };
        DMenuSided.prototype.onHierarchyDirty = function () {
            var selection = this._selection;
            if (selection != null) {
                selection.toDirty();
            }
            _super.prototype.onHierarchyDirty.call(this);
        };
        DMenuSided.prototype.newItems = function (items, sticky) {
            DMenuSideds.newItems(this.content, items, sticky);
        };
        DMenuSided.prototype.newContent = function (options) {
            return new DMenuSidedContent(options);
        };
        Object.defineProperty(DMenuSided.prototype, "selection", {
            get: function () {
                return this._selection;
            },
            enumerable: false,
            configurable: true
        });
        DMenuSided.prototype.getContext = function () {
            return this._context;
        };
        DMenuSided.prototype.getCloseable = function () {
            return this;
        };
        DMenuSided.prototype.open = function () {
            // DO NOTHING
        };
        DMenuSided.prototype.close = function () {
            // DO NOTHING
        };
        DMenuSided.prototype.onKeyDown = function (e) {
            UtilKeyboardEvent.moveFocusVertically(e, this);
            return _super.prototype.onKeyDown.call(this, e);
        };
        DMenuSided.prototype.getType = function () {
            return "DMenuSided";
        };
        return DMenuSided;
    }(DPane));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DNoteError = /** @class */ (function (_super) {
        __extends(DNoteError, _super);
        function DNoteError() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DNoteError.prototype.getType = function () {
            return "DNoteError";
        };
        return DNoteError;
    }(DNote));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DNoteNoItemsFound = /** @class */ (function (_super) {
        __extends(DNoteNoItemsFound, _super);
        function DNoteNoItemsFound() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DNoteNoItemsFound.prototype.getType = function () {
            return "DNoteNoItemsFound";
        };
        return DNoteNoItemsFound;
    }(DNote));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DNoteSearching = /** @class */ (function (_super) {
        __extends(DNoteSearching, _super);
        function DNoteSearching() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DNoteSearching.prototype.getType = function () {
            return "DNoteSearching";
        };
        return DNoteSearching;
    }(DNote));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DNotification = /** @class */ (function (_super) {
        __extends(DNotification, _super);
        function DNotification() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return DNotification;
    }(DBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPaginationButtonLast = /** @class */ (function (_super) {
        __extends(DPaginationButtonLast, _super);
        function DPaginationButtonLast() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DPaginationButtonLast.prototype.getType = function () {
            return "DPaginationButtonLast";
        };
        return DPaginationButtonLast;
    }(DButtonAmbient));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPaginationButtonNext = /** @class */ (function (_super) {
        __extends(DPaginationButtonNext, _super);
        function DPaginationButtonNext() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DPaginationButtonNext.prototype.getType = function () {
            return "DPaginationButtonNext";
        };
        return DPaginationButtonNext;
    }(DButtonAmbient));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPaginationButtonPage = /** @class */ (function (_super) {
        __extends(DPaginationButtonPage, _super);
        function DPaginationButtonPage() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DPaginationButtonPage.prototype.getType = function () {
            return "DPaginationButtonPage";
        };
        return DPaginationButtonPage;
    }(DButtonAmbient));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPaginationButtonPrevious = /** @class */ (function (_super) {
        __extends(DPaginationButtonPrevious, _super);
        function DPaginationButtonPrevious() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DPaginationButtonPrevious.prototype.getType = function () {
            return "DPaginationButtonPrevious";
        };
        return DPaginationButtonPrevious;
    }(DButtonAmbient));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPaginationButtonTop = /** @class */ (function (_super) {
        __extends(DPaginationButtonTop, _super);
        function DPaginationButtonTop() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DPaginationButtonTop.prototype.getType = function () {
            return "DPaginationButtonTop";
        };
        return DPaginationButtonTop;
    }(DButtonAmbient));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPaginationDots = /** @class */ (function (_super) {
        __extends(DPaginationDots, _super);
        function DPaginationDots() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DPaginationDots.prototype.getType = function () {
            return "DPaginationDots";
        };
        return DPaginationDots;
    }(DImageBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPaginationPage = /** @class */ (function (_super) {
        __extends(DPaginationPage, _super);
        function DPaginationPage() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DPaginationPage.prototype.getType = function () {
            return "DPaginationPage";
        };
        return DPaginationPage;
    }(DImageBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPagination = /** @class */ (function (_super) {
        __extends(DPagination, _super);
        function DPagination(options) {
            var _a, _b, _c, _d;
            var _this = _super.call(this, options) || this;
            if (options != null) {
                _this._size = (_b = (_a = options.size) !== null && _a !== void 0 ? _a : options.total) !== null && _b !== void 0 ? _b : 10;
                _this._value = (_d = (_c = options.value) !== null && _c !== void 0 ? _c : options.selected) !== null && _d !== void 0 ? _d : 0;
            }
            else {
                _this._size = 10;
                _this._value = 0;
            }
            var buttonTop = _this.buttonTop;
            if (buttonTop != null) {
                _this.addChild(buttonTop);
            }
            var buttonPrevious = _this.buttonPrevious;
            if (buttonPrevious != null) {
                _this.addChild(buttonPrevious);
            }
            var spaceLeft = _this.spaceLeft;
            if (spaceLeft != null) {
                _this.addChild(spaceLeft);
            }
            var buttonPages0 = _this.buttonPages0;
            var buttonPages0Length = buttonPages0.length;
            _this.addChild(buttonPages0[0]);
            _this.addChild(_this.dots0);
            for (var i = 1; i < buttonPages0Length; ++i) {
                _this.addChild(buttonPages0[i]);
            }
            _this.addChild(_this.page);
            var buttonPages1 = _this.buttonPages1;
            var buttonPages1Length = buttonPages1.length;
            for (var i = 0, imax = buttonPages1Length - 1; i < imax; ++i) {
                _this.addChild(buttonPages1[i]);
            }
            _this.addChild(_this.dots1);
            _this.addChild(buttonPages1[buttonPages1Length - 1]);
            var spaceRight = _this.spaceRight;
            if (spaceRight != null) {
                _this.addChild(spaceRight);
            }
            var buttonNext = _this.buttonNext;
            if (buttonNext != null) {
                _this.addChild(buttonNext);
            }
            var buttonLast = _this.buttonLast;
            if (buttonLast != null) {
                _this.addChild(buttonLast);
            }
            return _this;
        }
        Object.defineProperty(DPagination.prototype, "value", {
            /**
             * Returns a value that is an index of a current page.
             *
             * @returns a value that is an index of a selected page.
             */
            get: function () {
                return this._value;
            },
            /**
             * Sets a value that is an index of a current page.
             *
             * @param value a value that is an index of a page
             */
            set: function (value) {
                if (0 <= value && value < this._size && this._value !== value) {
                    this._value = value;
                    this.toDirty();
                    DApplications.update(this);
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DPagination.prototype, "selected", {
            /**
             * Returns an index of the selected page.
             *
             * @returns an index of the selected page.
             * @deprecated in favor of {@link value}.
             */
            get: function () {
                return this.value;
            },
            /**
             * Selects a page.
             *
             * @param index an index of a page
             * @deprecated in favor of {@link value}.
             */
            set: function (index) {
                this.value = index;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DPagination.prototype, "size", {
            /**
             * Returns a number of total pages.
             *
             * @returns a number of total pages.
             */
            get: function () {
                return this._size;
            },
            /**
             * Sets a number of total pages.
             *
             * @param size a number of pages
             */
            set: function (size) {
                if (0 <= size && this._size !== size) {
                    this._size = size;
                    if (size === 0) {
                        this._value = -1;
                    }
                    else {
                        this._value = Math.max(0, Math.min(this._size - 1, this._value));
                    }
                    this.toDirty();
                    DApplications.update(this);
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DPagination.prototype, "total", {
            /**
             * Returns a number of total pages.
             *
             * @returns a number of total pages.
             * @deprecated in favor of {@link size}
             */
            get: function () {
                return this.size;
            },
            /**
             * Sets a number of total pages.
             *
             * @param total a number of pages
             * @deprecated in favor of {@link size}
             */
            set: function (total) {
                this.size = total;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DPagination.prototype, "dots0", {
            get: function () {
                var result = this._dots0;
                if (result == null) {
                    result = this.newDots();
                    this._dots0 = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DPagination.prototype, "dots1", {
            get: function () {
                var result = this._dots1;
                if (result == null) {
                    result = this.newDots();
                    this._dots1 = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DPagination.prototype.newDots = function () {
            return new DPaginationDots();
        };
        Object.defineProperty(DPagination.prototype, "buttonLast", {
            get: function () {
                var result = this._buttonLast;
                if (result === undefined) {
                    result = this.newButtonLast();
                    this._buttonLast = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DPagination.prototype.newButtonLast = function () {
            var _this = this;
            var _a, _b;
            var last = (_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.button) === null || _b === void 0 ? void 0 : _b.last;
            if (last !== null && last !== false && last !== undefined) {
                var result = new DPaginationButtonLast(last !== true ? last : undefined);
                result.on("active", function () {
                    _this.onButtonLastActive();
                });
                return result;
            }
            return null;
        };
        DPagination.prototype.onButtonLastActive = function () {
            this.goToLast();
        };
        /**
         * Goes to the last page.
         * Unlike {@link value}, this method emits the change event if silently is not true.
         *
         * @param silently true to suppress the change event
         * @returns true if succeeded.
         */
        DPagination.prototype.goToLast = function (silently) {
            return this.goTo(this._size - 1, silently);
        };
        /**
         * Goes to the given page.
         * Unlike {@link value}, this method emits the change event if silently is not true.
         *
         * @param index a page index
         * @param silently true to suppress the change event
         * @returns this
         */
        DPagination.prototype.goTo = function (index, silently) {
            if (0 <= index && index < this._size && this._value !== index) {
                var oldIndex = this._value;
                this._value = index;
                if (silently !== true) {
                    this.emit("change", index, oldIndex, this);
                }
                this.toDirty();
                DApplications.update(this);
                return true;
            }
            return false;
        };
        Object.defineProperty(DPagination.prototype, "buttonNext", {
            get: function () {
                var result = this._buttonNext;
                if (result === undefined) {
                    result = this.newButtonNext();
                    this._buttonNext = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DPagination.prototype.newButtonNext = function () {
            var _this = this;
            var _a, _b;
            var next = (_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.button) === null || _b === void 0 ? void 0 : _b.next;
            if (next !== null && next !== false) {
                var result = new DPaginationButtonNext(next !== true ? next : undefined);
                result.on("active", function () {
                    _this.onButtonNextActive();
                });
                return result;
            }
            return null;
        };
        DPagination.prototype.onButtonNextActive = function () {
            this.goToNext();
        };
        /**
         * Goes to the next page.
         * Unlike {@link value}, this method emits the change event if silently is not true.
         *
         * @param silently true to suppress the change event
         * @returns true if succeeded.
         */
        DPagination.prototype.goToNext = function (silently) {
            return this.goTo(this._value + 1, silently);
        };
        Object.defineProperty(DPagination.prototype, "buttonPrevious", {
            get: function () {
                var result = this._buttonPrevious;
                if (result === undefined) {
                    result = this.newButtonPrevious();
                    this._buttonPrevious = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DPagination.prototype.newButtonPrevious = function () {
            var _this = this;
            var _a, _b;
            var previous = (_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.button) === null || _b === void 0 ? void 0 : _b.previous;
            if (previous !== null && previous !== false) {
                var result = new DPaginationButtonPrevious(previous !== true ? previous : undefined);
                result.on("active", function () {
                    _this.onButtonPreviousActive();
                });
                return result;
            }
            return null;
        };
        DPagination.prototype.onButtonPreviousActive = function () {
            this.goToPrevious();
        };
        /**
         * Goes to the previous page.
         * Unlike {@link value}, this method emits the change event if silently is not true.
         *
         * @param silently true to suppress the change event
         * @returns true if succeeded.
         */
        DPagination.prototype.goToPrevious = function (silently) {
            return this.goTo(this._value - 1, silently);
        };
        Object.defineProperty(DPagination.prototype, "buttonTop", {
            get: function () {
                var result = this._buttonTop;
                if (result === undefined) {
                    result = this.newButtonTop();
                    this._buttonTop = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DPagination.prototype.newButtonTop = function () {
            var _this = this;
            var _a, _b;
            var top = (_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.button) === null || _b === void 0 ? void 0 : _b.top;
            if (top !== null && top !== false && top !== undefined) {
                var result = new DPaginationButtonTop(top !== true ? top : undefined);
                result.on("active", function () {
                    _this.onButtonTopActive();
                });
                return result;
            }
            return null;
        };
        DPagination.prototype.onButtonTopActive = function () {
            this.goToTop();
        };
        /**
         * Goes to the top page.
         * Unlike {@link value}, this method emits the change event if silently is not true.
         *
         * @param silently true to suppress the change event
         * @returns true if succeeded.
         */
        DPagination.prototype.goToTop = function (silently) {
            return this.goTo(0, silently);
        };
        DPagination.prototype.newButtonPage = function () {
            var _this = this;
            var _a, _b;
            var result = new DPaginationButtonPage((_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.button) === null || _b === void 0 ? void 0 : _b.page);
            result.on("active", function () {
                _this.onButtonPageActive(result);
            });
            return result;
        };
        Object.defineProperty(DPagination.prototype, "buttonPages0", {
            get: function () {
                var result = this._buttonPages0;
                if (result == null) {
                    result = this.newButtonPages0();
                    this._buttonPages0 = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DPagination.prototype.newButtonPages0 = function () {
            return [
                this.newButtonPage(),
                this.newButtonPage(),
                this.newButtonPage(),
                this.newButtonPage()
            ];
        };
        DPagination.prototype.allocButtonPages0 = function (size) {
            var buttonPages0 = this.buttonPages0;
            var buttonPages0Length = buttonPages0.length;
            var index = this.getChildIndex(buttonPages0[buttonPages0Length - 1]) + 1;
            for (var i = 0, imax = size - buttonPages0Length; i < imax; ++i) {
                var buttonPage = this.newButtonPage();
                this.addChildAt(buttonPage, index + i);
                buttonPages0.push(buttonPage);
            }
        };
        Object.defineProperty(DPagination.prototype, "buttonPages1", {
            get: function () {
                var result = this._buttonPages1;
                if (result == null) {
                    result = this.newButtonPages1();
                    this._buttonPages1 = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DPagination.prototype.newButtonPages1 = function () {
            return [
                this.newButtonPage(),
                this.newButtonPage(),
                this.newButtonPage(),
                this.newButtonPage()
            ];
        };
        DPagination.prototype.allocButtonPages1 = function (size) {
            var buttonPages1 = this.buttonPages1;
            var buttonPages1Length = buttonPages1.length;
            var index = this.getChildIndex(buttonPages1[0]);
            for (var i = 0, imax = size - buttonPages1Length; i < imax; ++i) {
                var buttonPage = this.newButtonPage();
                this.addChildAt(buttonPage, index);
                buttonPages1.unshift(buttonPage);
            }
        };
        Object.defineProperty(DPagination.prototype, "page", {
            get: function () {
                var result = this._page;
                if (result == null) {
                    result = this.newPage();
                    this._page = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DPagination.prototype.newPage = function () {
            var _a;
            return new DPaginationPage((_a = this._options) === null || _a === void 0 ? void 0 : _a.page);
        };
        DPagination.prototype.onButtonPageActive = function (button) {
            var text = button.text.value;
            if (isNumber(text)) {
                this.goTo(text - 1);
                if (button.state.isFocused) {
                    button.state.isHovered = false;
                    this.page.focus();
                }
            }
        };
        Object.defineProperty(DPagination.prototype, "spaceLeft", {
            get: function () {
                var result = this._spaceLeft;
                if (result === undefined) {
                    result = this.newSpaceLeft();
                    this._spaceLeft = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DPagination.prototype.newSpaceLeft = function () {
            if (this.buttonTop != null || this.buttonPrevious != null) {
                return this.newSpace();
            }
            return null;
        };
        Object.defineProperty(DPagination.prototype, "spaceRight", {
            get: function () {
                var result = this._spaceRight;
                if (result === undefined) {
                    result = this.newSpaceRight();
                    this._spaceRight = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DPagination.prototype.newSpaceRight = function () {
            if (this.buttonLast != null || this.buttonNext != null) {
                return this.newSpace();
            }
            return null;
        };
        DPagination.prototype.newSpace = function () {
            var _a, _b;
            var space = (_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.button) === null || _b === void 0 ? void 0 : _b.space;
            if (space !== null && space !== false) {
                if (space === true || space === undefined) {
                    return new DLayoutSpace({
                        weight: 1
                    });
                }
                else if (isNumber(space)) {
                    return new DLayoutSpace({
                        width: space
                    });
                }
                else {
                    return new DLayoutSpace(space);
                }
            }
            return null;
        };
        DPagination.prototype.onReflow = function () {
            this.update();
            _super.prototype.onReflow.call(this);
        };
        DPagination.prototype.update = function () {
            var size = this._size;
            var value = this._value;
            if (size <= 0) {
                this.doUpdate0(value, size);
            }
            else {
                if (this._auto.width.isOn) {
                    this.doUpdate2(value, size, 0, 0, 0, 0);
                }
                else {
                    this.doUpdate1(value, size);
                }
            }
        };
        DPagination.prototype.doUpdate0 = function (value, size) {
            var buttonTop = this.buttonTop;
            if (buttonTop != null) {
                buttonTop.state.isEnabled = false;
            }
            var buttonPrevious = this.buttonPrevious;
            if (buttonPrevious != null) {
                buttonPrevious.state.isEnabled = false;
            }
            this.hideDots(this.dots0);
            var buttonPages0 = this.buttonPages0;
            for (var i = 0, imax = buttonPages0.length; i < imax; ++i) {
                this.hidePage(buttonPages0[i]);
            }
            this.hidePage(this.page);
            var buttonPages1 = this.buttonPages1;
            for (var i = 0, imax = buttonPages1.length; i < imax; ++i) {
                this.hidePage(buttonPages1[i]);
            }
            this.hideDots(this.dots1);
            var buttonNext = this.buttonNext;
            if (buttonNext != null) {
                buttonNext.state.isEnabled = false;
            }
            var buttonLast = this.buttonLast;
            if (buttonLast) {
                buttonLast.state.isEnabled = false;
            }
        };
        DPagination.prototype.doUpdate1 = function (value, size) {
            var required = 0;
            var nrequired = 0;
            var buttonTop = this.buttonTop;
            if (buttonTop != null) {
                required += buttonTop.width;
                nrequired += 1;
            }
            var buttonPrevious = this.buttonPrevious;
            if (buttonPrevious != null) {
                required += buttonPrevious.width;
                nrequired += 1;
            }
            var spaceLeft = this.spaceLeft;
            if (spaceLeft != null) {
                if (spaceLeft.weight < 0) {
                    required += spaceLeft.width;
                }
                nrequired += 1;
            }
            var page = this.page;
            required += page.width;
            nrequired += 1;
            var spaceRight = this.spaceRight;
            if (spaceRight != null) {
                if (spaceRight.weight < 0) {
                    required += spaceRight.width;
                }
                nrequired += 1;
            }
            var buttonNext = this.buttonNext;
            if (buttonNext != null) {
                required += buttonNext.width;
                nrequired += 1;
            }
            var buttonLast = this.buttonLast;
            if (buttonLast) {
                required += buttonLast.width;
                nrequired += 1;
            }
            var marginHorizontal = this._margin.horizontal;
            if (2 <= nrequired) {
                required += (nrequired - 1) * marginHorizontal;
            }
            var padding = this.padding;
            var space = this.width - (padding.getLeft() + padding.getRight());
            if (space <= required) {
                this.doUpdate2(value, size, 4, 4, 0, 0);
            }
            else {
                var buttonPages0 = this.buttonPages0;
                var buttonPage0Width = buttonPages0[0].width;
                var nrequired0 = value;
                var required0 = nrequired0 * (buttonPage0Width + marginHorizontal);
                var buttonPages1 = this.buttonPages1;
                var buttonPage1Width = buttonPages1[0].width;
                var nrequired1 = size - (value + 1);
                var required1 = nrequired1 * (buttonPage1Width + marginHorizontal);
                if (required + required0 + required1 <= space) {
                    this.doUpdate2(value, size, 0, 0, 0, 0);
                }
                else {
                    var dots1 = this.dots1;
                    var dots1Width = dots1.width;
                    var dots0 = this.dots0;
                    var dots0Width = dots0.width;
                    var m0 = marginHorizontal + buttonPage0Width;
                    var m1 = marginHorizontal + buttonPage1Width;
                    var required0n = dots0Width + m0;
                    var required1n = dots1Width + m1;
                    var required0m = required0n + m0;
                    var required1m = required1n + m1;
                    if (required0 <= required1) {
                        if (3 <= nrequired1 && required + required0 + required1m <= space) {
                            var l = space - (required + required0 + required1m);
                            var n1 = Math.floor(l / m1);
                            this.doUpdate2(value, size, 0, 1, 0, n1);
                        }
                        else if (3 <= nrequired0 &&
                            3 <= nrequired1 &&
                            required + required0m + required1m <= space) {
                            var l = space - (required + required0m + required1m);
                            var n1 = Math.floor((l * 0.5) / m1);
                            var n0 = Math.floor((l - n1 * m1) / m0);
                            this.doUpdate2(value, size, 1, 1, n0, n1);
                        }
                        else if (2 <= nrequired1 && required + required0 + required1n <= space) {
                            this.doUpdate2(value, size, 0, 2, 0, 0);
                        }
                        else if (3 <= nrequired0 &&
                            2 <= nrequired1 &&
                            required + required0m + required1n <= space) {
                            var l = space - (required + required0m + required1n);
                            var n0 = Math.floor(l / m0);
                            this.doUpdate2(value, size, 1, 2, n0, 0);
                        }
                        else if (2 <= nrequired0 &&
                            2 <= nrequired1 &&
                            required + required0n + required1n <= space) {
                            this.doUpdate2(value, size, 2, 2, 0, 0);
                        }
                        else if (1 <= nrequired0 &&
                            1 <= nrequired1 &&
                            required + dots0Width + dots1Width <= space) {
                            this.doUpdate2(value, size, 3, 3, 0, 0);
                        }
                        else {
                            this.doUpdate2(value, size, 4, 4, 0, 0);
                        }
                    }
                    else {
                        if (3 <= nrequired0 && required + required0m + required1 <= space) {
                            var l = space - (required + required0m + required1);
                            var n0 = Math.floor(l / m0);
                            this.doUpdate2(value, size, 1, 0, n0, 0);
                        }
                        else if (3 <= nrequired0 &&
                            3 <= nrequired1 &&
                            required + required0m + required1m <= space) {
                            var l = space - (required + required0m + required1m);
                            var n0 = Math.floor((l * 0.5) / m0);
                            var n1 = Math.floor((l - n0 * m0) / m1);
                            this.doUpdate2(value, size, 1, 1, n0, n1);
                        }
                        else if (2 <= nrequired0 && required + required0n + required1 <= space) {
                            this.doUpdate2(value, size, 2, 0, 0, 0);
                        }
                        else if (2 <= nrequired0 &&
                            3 <= nrequired1 &&
                            required + required0n + required1m <= space) {
                            var l = space - (required + required0n + required1m);
                            var n1 = Math.floor(l / m1);
                            this.doUpdate2(value, size, 2, 1, 0, n1);
                        }
                        else if (2 <= nrequired0 &&
                            2 <= nrequired1 &&
                            required + required0n + required1n <= space) {
                            this.doUpdate2(value, size, 2, 2, 0, 0);
                        }
                        else if (1 <= nrequired0 &&
                            1 <= nrequired1 &&
                            required + dots0Width + dots1Width <= space) {
                            this.doUpdate2(value, size, 3, 3, 0, 0);
                        }
                        else {
                            this.doUpdate2(value, size, 4, 4, 0, 0);
                        }
                    }
                }
            }
        };
        DPagination.prototype.doUpdate2 = function (value, size, left, right, nleft1, nright1) {
            var buttonTop = this.buttonTop;
            if (buttonTop != null) {
                buttonTop.state.isEnabled = 0 < value;
            }
            var buttonPrevious = this.buttonPrevious;
            if (buttonPrevious != null) {
                buttonPrevious.state.isEnabled = 0 < value;
            }
            var buttonPages0 = this.buttonPages0;
            switch (left) {
                case 0:
                    this.hideDots(this.dots0);
                    this.allocButtonPages0(value);
                    for (var i = 0, imax = buttonPages0.length; i < imax; ++i) {
                        if (i < value) {
                            this.showPage(buttonPages0[i], i);
                        }
                        else {
                            this.hidePage(buttonPages0[i]);
                        }
                    }
                    break;
                case 1:
                    this.showDots(this.dots0, 1, value - 2 - nleft1);
                    this.allocButtonPages0(2 + nleft1);
                    this.showPage(buttonPages0[0], 0);
                    for (var i = 1, imax = buttonPages0.length - nleft1 - 1; i < imax; ++i) {
                        this.hidePage(buttonPages0[i]);
                    }
                    for (var i = 0, imax = 1 + nleft1; i < imax; ++i) {
                        this.showPage(buttonPages0[buttonPages0.length - imax + i], value - 1 - (imax - 1) + i);
                    }
                    break;
                case 2:
                    this.showDots(this.dots0, 0, value - 2);
                    for (var i = 0, imax = buttonPages0.length - 1; i < imax; ++i) {
                        this.hidePage(buttonPages0[i]);
                    }
                    this.showPage(buttonPages0[buttonPages0.length - 1], value - 1);
                    break;
                case 3:
                    this.showDots(this.dots0, 0, value - 1);
                    for (var i = 0, imax = buttonPages0.length; i < imax; ++i) {
                        this.hidePage(buttonPages0[i]);
                    }
                    break;
                case 4:
                    this.hideDots(this.dots0);
                    for (var i = 0, imax = buttonPages0.length; i < imax; ++i) {
                        this.hidePage(buttonPages0[i]);
                    }
                    break;
            }
            this.showPage(this.page, value);
            var buttonPages1 = this.buttonPages1;
            switch (right) {
                case 0:
                    this.allocButtonPages1(size - (value + 1));
                    for (var i = 0, imax = buttonPages1.length; i < imax; ++i) {
                        var j = value + 1 + i;
                        if (j < size) {
                            this.showPage(buttonPages1[i], j);
                        }
                        else {
                            this.hidePage(buttonPages1[i]);
                        }
                    }
                    this.hideDots(this.dots1);
                    break;
                case 1:
                    this.allocButtonPages1(2 + nright1);
                    for (var i = 0, imax = 1 + nright1; i < imax; ++i) {
                        this.showPage(buttonPages1[i], value + 1 + i);
                    }
                    for (var i = 1 + nright1, imax = buttonPages1.length - 1; i < imax; ++i) {
                        this.hidePage(buttonPages1[i]);
                    }
                    this.showPage(buttonPages1[buttonPages1.length - 1], size - 1);
                    this.showDots(this.dots1, value + 2 + nright1, size - 2);
                    break;
                case 2:
                    this.showPage(buttonPages1[0], value + 1);
                    for (var i = 1, imax = buttonPages1.length; i < imax; ++i) {
                        this.hidePage(buttonPages1[i]);
                    }
                    this.showDots(this.dots1, value + 2, size - 1);
                    break;
                case 3:
                    for (var i = 0, imax = buttonPages1.length; i < imax; ++i) {
                        this.hidePage(buttonPages1[i]);
                    }
                    this.showDots(this.dots1, value + 1, size - 1);
                    break;
                case 4:
                    for (var i = 0, imax = buttonPages1.length; i < imax; ++i) {
                        this.hidePage(buttonPages1[i]);
                    }
                    this.hideDots(this.dots1);
                    break;
            }
            var buttonNext = this.buttonNext;
            if (buttonNext != null) {
                buttonNext.state.isEnabled = value < size - 1;
            }
            var buttonLast = this.buttonLast;
            if (buttonLast != null) {
                buttonLast.state.isEnabled = value < size - 1;
            }
        };
        DPagination.prototype.showPage = function (button, index) {
            button.text = index + 1;
            button.show();
        };
        DPagination.prototype.hidePage = function (button) {
            button.hide();
        };
        DPagination.prototype.showDots = function (dots, from, to) {
            dots.show();
        };
        DPagination.prototype.hideDots = function (dots) {
            dots.hide();
        };
        DPagination.prototype.getType = function () {
            return "DPagination";
        };
        return DPagination;
    }(DLayoutHorizontal));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPickerDatetimeRange = /** @class */ (function (_super) {
        __extends(DPickerDatetimeRange, _super);
        function DPickerDatetimeRange() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return DPickerDatetimeRange;
    }(DBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPickerTimeRange = /** @class */ (function (_super) {
        __extends(DPickerTimeRange, _super);
        function DPickerTimeRange() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return DPickerTimeRange;
    }(DBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A multi-value selector class.
     */
    var DSelectMultiple = /** @class */ (function (_super) {
        __extends(DSelectMultiple, _super);
        function DSelectMultiple(options) {
            var _this = _super.call(this, options) || this;
            // Default values
            _this._values = [];
            var values = options === null || options === void 0 ? void 0 : options.values;
            if (values) {
                _this.values = values;
            }
            return _this;
        }
        DSelectMultiple.prototype.onMenuSelect = function (value, item, menu) {
            _super.prototype.onMenuSelect.call(this, value, item, menu);
            if (item instanceof DMenuItemCheck) {
                var oldValues = this._values;
                var newValues = [];
                var newItems = [];
                if (item.state.isActive) {
                    this.updateMenuItems(menu, oldValues, value, undefined, newValues, newItems);
                }
                else {
                    this.updateMenuItems(menu, oldValues, undefined, value, newValues, newItems);
                }
                this._values = newValues;
                this.text = newItems;
                this.onValueChange(newValues, oldValues, newItems);
            }
        };
        DSelectMultiple.prototype.onMenuReplaced = function (newMenu, oldMenu) {
            _super.prototype.onMenuReplaced.call(this, newMenu, oldMenu);
            // Update the values
            var values = this._values;
            var newValues = [];
            var newItems = [];
            this.updateMenuItems(newMenu, values, undefined, undefined, newValues, newItems);
            this._values = newValues;
            this.text = newItems;
        };
        DSelectMultiple.prototype.onValueChange = function (newValues, oldValues, items) {
            this.emit("change", newValues, oldValues, items, this);
        };
        DSelectMultiple.prototype.onMenuOpening = function (menu) {
            _super.prototype.onMenuOpening.call(this, menu);
            this.updateMenuItems(this.menu, this._values);
        };
        Object.defineProperty(DSelectMultiple.prototype, "values", {
            /**
             * Returns a selected value or null.
             */
            get: function () {
                return this._values;
            },
            /**
             * Sets to the specified value.
             */
            set: function (values) {
                var oldValues = this._values;
                if (!this.isSameValues(values, oldValues)) {
                    var newValues = [];
                    var newItems = [];
                    this.updateMenuItems(this.menu, values, undefined, undefined, newValues, newItems);
                    this._values = newValues;
                    this.text = newItems;
                }
            },
            enumerable: false,
            configurable: true
        });
        DSelectMultiple.prototype.isSameValues = function (a, b) {
            if (a.length === b.length) {
                for (var i = 0, imax = a.length; i < imax; ++i) {
                    if (b.indexOf(a[i]) < 0) {
                        return false;
                    }
                }
            }
            return false;
        };
        DSelectMultiple.prototype.updateMenuItems = function (menu, oldValues, addedValue, removedValue, newValues, newItems) {
            var children = menu.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                var child = children[i];
                if (child instanceof DMenuItemMenu) {
                    this.updateMenuItems(child.menu, oldValues, addedValue, removedValue, newValues, newItems);
                }
                else if (child instanceof DMenuItemCheck) {
                    var childValue = child.value;
                    if (removedValue !== undefined && removedValue === childValue) {
                        child.state.isActive = false;
                    }
                    else if ((addedValue !== undefined && child.value === addedValue) ||
                        0 <= oldValues.indexOf(child.value)) {
                        if (newValues) {
                            newValues.push(child.value);
                        }
                        if (newItems) {
                            newItems.push(child);
                        }
                        child.state.isActive = true;
                    }
                    else {
                        child.state.isActive = false;
                    }
                }
            }
        };
        DSelectMultiple.prototype.getType = function () {
            return "DSelectMultiple";
        };
        return DSelectMultiple;
    }(DDropdownBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DShadowImpl = /** @class */ (function (_super) {
        __extends(DShadowImpl, _super);
        function DShadowImpl(texture, width, height, offsetX, offsetY) {
            var _this = _super.call(this, texture, width, height, width, height) || this;
            _this._offsetX = offsetX;
            _this._offsetY = offsetY;
            _this._shiftX = width * 0.5;
            _this._shiftY = height * 0.5;
            _this.interactive = false;
            _this.interactiveChildren = false;
            texture.on("update", function () {
                _this.onTextureUpdate();
            });
            return _this;
        }
        DShadowImpl.prototype.onTextureUpdate = function () {
            this.emit("update", this);
        };
        DShadowImpl.prototype.onReflow = function (base, width, height) {
            var sx = this._shiftX;
            var sy = this._shiftY;
            this.x = -sx + this._offsetX;
            this.y = -sy + this._offsetY;
            this.width = sx + width + sx;
            this.height = sy + height + sy;
        };
        DShadowImpl.prototype.render = function (renderer) {
            var parent = this.parent;
            if (parent) {
                var alpha = parent.alpha;
                this.alpha = alpha * alpha * alpha;
            }
            _super.prototype.render.call(this, renderer);
        };
        return DShadowImpl;
    }(pixi_js.NineSlicePlane));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DSliderLabel = /** @class */ (function (_super) {
        __extends(DSliderLabel, _super);
        function DSliderLabel() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DSliderLabel.prototype.init = function (options) {
            var _a;
            _super.prototype.init.call(this, options);
            this._value = (_a = options === null || options === void 0 ? void 0 : options.value) !== null && _a !== void 0 ? _a : 0;
        };
        Object.defineProperty(DSliderLabel.prototype, "value", {
            get: function () {
                return this._value;
            },
            set: function (value) {
                this._value = value;
            },
            enumerable: false,
            configurable: true
        });
        DSliderLabel.prototype.getType = function () {
            return "DSliderLabel";
        };
        return DSliderLabel;
    }(DTextBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DSliderThumb = /** @class */ (function (_super) {
        __extends(DSliderThumb, _super);
        function DSliderThumb() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DSliderThumb.prototype.getType = function () {
            return "DSliderThumb";
        };
        return DSliderThumb;
    }(DButton));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DSliderValue = /** @class */ (function (_super) {
        __extends(DSliderValue, _super);
        function DSliderValue(options) {
            var _a, _b;
            var _this = _super.call(this, options) || this;
            _this._value = (_a = options === null || options === void 0 ? void 0 : options.value) !== null && _a !== void 0 ? _a : 0;
            _this._rounder = _this.toRounder(options);
            _this._delta = (_b = options === null || options === void 0 ? void 0 : options.delta) !== null && _b !== void 0 ? _b : 1;
            return _this;
        }
        DSliderValue.prototype.toRounder = function (options) {
            var _a;
            var rounder = options === null || options === void 0 ? void 0 : options.rounder;
            if (rounder) {
                return rounder;
            }
            var precision = (_a = options === null || options === void 0 ? void 0 : options.precision) !== null && _a !== void 0 ? _a : this.theme.getPrecision();
            var base = Math.pow(10, precision);
            return function (value) {
                return Math.round(value * base) / base;
            };
        };
        Object.defineProperty(DSliderValue.prototype, "value", {
            get: function () {
                return this._value;
            },
            set: function (value) {
                this._value = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DSliderValue.prototype, "rounder", {
            get: function () {
                return this._rounder;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DSliderValue.prototype, "delta", {
            get: function () {
                return this._delta;
            },
            enumerable: false,
            configurable: true
        });
        DSliderValue.prototype.getType = function () {
            return "DSliderValue";
        };
        return DSliderValue;
    }(DTextBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A slider class.
     */
    var DSlider = /** @class */ (function (_super) {
        __extends(DSlider, _super);
        function DSlider() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DSlider.prototype.init = function (options) {
            var _this = this;
            _super.prototype.init.call(this, options);
            this._ratioValue = 0;
            this._track = this.newTrack(options);
            this.addChild(this._track);
            this._trackSelected = this.newTrackSelected(options);
            this._trackSelected.state.isActive = true;
            this.addChild(this._trackSelected);
            this._thumb = this.newThumb(options);
            this.addChild(this._thumb);
            this._min = this.newLabelMin(options);
            this.addChild(this._min);
            this._max = this.newLabelMax(options);
            this.addChild(this._max);
            this._value = this.newValue(options);
            this.addChild(this._value);
            // Event listeners
            this._track.on(UtilPointerEvent.down, function (e) {
                _this._value.visible = _this.state.inEnabled;
                _this.onTrackDown(e.data.global);
            });
            this._trackSelected.on(UtilPointerEvent.down, function (e) {
                _this._value.visible = _this.state.inEnabled;
                _this.onTrackSelectedDown(e.data.global);
            });
            this._onTrackUpBound = function (e) {
                _this.onTrackUpBound(e);
                _this._value.visible = false;
            };
            this._onTrackSelectedUpBound = function (e) {
                _this.onTrackSelectedUpBound(e);
                _this._value.visible = false;
            };
            this._thumb.on(UtilPointerEvent.down, function (e) {
                _this._value.visible = true;
                _this.onThumbDown(e);
            });
            this._onThumbMoveBound = function (e) {
                _this.onThumbMove(e);
            };
            this._onThumbUpBound = function (e) {
                _this.onThumbUp(e);
                _this._value.visible = false;
            };
            //
            this.onValuesChange();
        };
        DSlider.prototype.newThumb = function (options) {
            return new DSliderThumb(options === null || options === void 0 ? void 0 : options.thumb);
        };
        DSlider.prototype.newValue = function (options) {
            return new DSliderValue(this.toValueOptions(options === null || options === void 0 ? void 0 : options.value));
        };
        DSlider.prototype.toValueOptions = function (options) {
            options = options || {};
            if (options.value == null) {
                options.value = 0;
            }
            var text = options.text || {};
            options.text = text;
            if (text.value == null) {
                text.value = options.value;
            }
            if (options.visible == null) {
                options.visible = false;
            }
            return options;
        };
        DSlider.prototype.newLabelMin = function (options) {
            return new DSliderLabel(this.toLabelMinOptions(options === null || options === void 0 ? void 0 : options.min));
        };
        DSlider.prototype.toLabelMinOptions = function (options) {
            options = options || {};
            if (options.value == null) {
                options.value = 0;
            }
            var text = options.text || {};
            options.text = text;
            if (text.value == null) {
                text.value = "".concat(options.value);
            }
            return options;
        };
        DSlider.prototype.newLabelMax = function (options) {
            return new DSliderLabel(this.toLabelMaxOptions(options === null || options === void 0 ? void 0 : options.max));
        };
        DSlider.prototype.toLabelMaxOptions = function (options) {
            options = options || {};
            if (options.value == null) {
                options.value = 1;
            }
            var text = options.text || {};
            options.text = text;
            if (text.value == null) {
                text.value = "".concat(options.value);
            }
            return options;
        };
        DSlider.prototype.getValueMargin = function () {
            return 14;
        };
        DSlider.prototype.onTrackDown = function (global) {
            if (this.state.inDisabled) {
                return;
            }
            var layer = DApplications.getLayer(this);
            if (layer) {
                var interactionManager = layer.renderer.plugins.interaction;
                this._interactionManager = interactionManager;
                var onTrackUpBound = this._onTrackUpBound;
                interactionManager.on(UtilPointerEvent.up, onTrackUpBound);
                interactionManager.on(UtilPointerEvent.upoutside, onTrackUpBound);
                interactionManager.on(UtilPointerEvent.cancel, onTrackUpBound);
            }
            this.onPick(global);
        };
        DSlider.prototype.onTrackSelectedDown = function (global) {
            if (this.state.inDisabled) {
                return;
            }
            var layer = DApplications.getLayer(this);
            if (layer) {
                var interactionManager = layer.renderer.plugins.interaction;
                this._interactionManager = interactionManager;
                var onTrackSelectedUpBound = this._onTrackSelectedUpBound;
                interactionManager.on(UtilPointerEvent.up, onTrackSelectedUpBound);
                interactionManager.on(UtilPointerEvent.upoutside, onTrackSelectedUpBound);
                interactionManager.on(UtilPointerEvent.cancel, onTrackSelectedUpBound);
            }
            this.onPick(global);
        };
        DSlider.prototype.onTrackUpBound = function (e) {
            var interactionManager = this._interactionManager;
            if (interactionManager) {
                this._interactionManager = undefined;
                var onTrackUpBound = this._onTrackUpBound;
                interactionManager.off(UtilPointerEvent.up, onTrackUpBound);
                interactionManager.off(UtilPointerEvent.upoutside, onTrackUpBound);
                interactionManager.off(UtilPointerEvent.cancel, onTrackUpBound);
            }
        };
        DSlider.prototype.onTrackSelectedUpBound = function (e) {
            var interactionManager = this._interactionManager;
            if (interactionManager) {
                this._interactionManager = undefined;
                var onTrackSelectedUpBound = this._onTrackSelectedUpBound;
                interactionManager.off(UtilPointerEvent.up, onTrackSelectedUpBound);
                interactionManager.off(UtilPointerEvent.upoutside, onTrackSelectedUpBound);
                interactionManager.off(UtilPointerEvent.cancel, onTrackSelectedUpBound);
            }
        };
        DSlider.prototype.onThumbMove = function (e) {
            if (this.state.inDisabled) {
                return;
            }
            this.onPick(e.data.global);
        };
        DSlider.prototype.onThumbDown = function (e) {
            var layer = DApplications.getLayer(this);
            if (layer) {
                var interactionManager = layer.renderer.plugins.interaction;
                this._interactionManager = interactionManager;
                var onThumbMoveBound = this._onThumbMoveBound;
                interactionManager.on(UtilPointerEvent.move, onThumbMoveBound);
                var onThumbUpBound = this._onThumbUpBound;
                interactionManager.on(UtilPointerEvent.up, onThumbUpBound);
                interactionManager.on(UtilPointerEvent.upoutside, onThumbUpBound);
                interactionManager.on(UtilPointerEvent.cancel, onThumbUpBound);
            }
        };
        DSlider.prototype.onThumbUp = function (e) {
            var interactionManager = this._interactionManager;
            if (interactionManager) {
                this._interactionManager = undefined;
                var onThumbMoveBound = this._onThumbMoveBound;
                interactionManager.off(UtilPointerEvent.move, onThumbMoveBound);
                var onThumbUpBound = this._onThumbUpBound;
                interactionManager.off(UtilPointerEvent.up, onThumbUpBound);
                interactionManager.off(UtilPointerEvent.upoutside, onThumbUpBound);
                interactionManager.off(UtilPointerEvent.cancel, onThumbUpBound);
            }
        };
        DSlider.prototype.updateValue = function () {
            var min = this._min.value;
            var max = this._max.value;
            var value = this._value;
            var newValue = value.rounder(min + this._ratioValue * (max - min));
            var oldValue = value.value;
            if (newValue !== oldValue) {
                value.value = newValue;
                value.text = value.value;
                this.emit("change", newValue, oldValue, this);
            }
        };
        DSlider.prototype.onResize = function (newWidth, newHeight, oldWidth, oldHeight) {
            _super.prototype.onResize.call(this, newWidth, newHeight, oldWidth, oldHeight);
            this.onValuesChange();
        };
        Object.defineProperty(DSlider.prototype, "value", {
            /**
             * Returns a current value.
             */
            get: function () {
                return this._value.value;
            },
            /**
             * Sets a current value.
             */
            set: function (value) {
                value = Math.max(this._min.value, Math.min(this._max.value, value));
                // Adjust if value is new
                if (this._value.value !== value) {
                    this._value.value = value;
                    this.onValuesChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DSlider.prototype, "min", {
            /**
             * Returns a minimum value.
             */
            get: function () {
                return this._min.value;
            },
            /**
             * Sets a minimum value.
             */
            set: function (newMin) {
                var min = this._min;
                newMin = Math.min(this._max.value, newMin);
                if (min.value !== newMin) {
                    var value = this._value;
                    min.text = min.value = newMin;
                    value.value = Math.max(newMin, value.value);
                    this.onValuesChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DSlider.prototype, "max", {
            /**
             * Returns a maximum value.
             */
            get: function () {
                return this._max.value;
            },
            /**
             * Sets a maximum value.
             */
            set: function (newMax) {
                var max = this._max;
                newMax = Math.max(this._min.value, newMax);
                if (max.value !== newMax) {
                    var value = this._value;
                    max.text = max.value = newMax;
                    value.value = Math.min(newMax, value.value);
                    this.onValuesChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        DSlider.prototype.getType = function () {
            return "DSlider";
        };
        return DSlider;
    }(DBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DSliderTrack = /** @class */ (function (_super) {
        __extends(DSliderTrack, _super);
        function DSliderTrack() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DSliderTrack.prototype.getType = function () {
            return "DSliderTrack";
        };
        return DSliderTrack;
    }(DButton));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DSliderTrackHorizontal = /** @class */ (function (_super) {
        __extends(DSliderTrackHorizontal, _super);
        function DSliderTrackHorizontal() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DSliderTrackHorizontal.prototype.getType = function () {
            return "DSliderTrackHorizontal";
        };
        return DSliderTrackHorizontal;
    }(DSliderTrack));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DSliderHorizontal = /** @class */ (function (_super) {
        __extends(DSliderHorizontal, _super);
        function DSliderHorizontal() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DSliderHorizontal.prototype.newTrack = function (options) {
            return new DSliderTrackHorizontal(options === null || options === void 0 ? void 0 : options.track);
        };
        DSliderHorizontal.prototype.newTrackSelected = function (options) {
            return new DSliderTrackHorizontal(options === null || options === void 0 ? void 0 : options.track);
        };
        DSliderHorizontal.prototype.toValueOptions = function (options) {
            var _this = this;
            options = _super.prototype.toValueOptions.call(this, options);
            if (options.y == null) {
                options.y = function (p, s) { return p * 0.5 - s - _this.getValueMargin(); };
            }
            return options;
        };
        DSliderHorizontal.prototype.toLabelMinOptions = function (options) {
            options = _super.prototype.toLabelMinOptions.call(this, options);
            if (options.x == null) {
                options.x = function (p, s) { return -s * 0.5; };
            }
            if (options.y == null) {
                options.y = function (p, s) { return -s; };
            }
            return options;
        };
        DSliderHorizontal.prototype.toLabelMaxOptions = function (options) {
            options = _super.prototype.toLabelMaxOptions.call(this, options);
            if (options.x == null) {
                options.x = function (p, s) { return p - s * 0.5; };
            }
            if (options.y == null) {
                options.y = function (p, s) { return -s; };
            }
            return options;
        };
        DSliderHorizontal.prototype.onPick = function (global) {
            var point = new pixi_js.Point(0, 0);
            this.toLocal(global, undefined, point);
            var x = Math.max(0, Math.min(this._track.width, point.x));
            this._ratioValue = x / this._track.width;
            this.moveThumbPosition(x);
        };
        DSliderHorizontal.prototype.onValuesChange = function () {
            var min = this._min.value;
            var max = this._max.value;
            var value = this._value.value;
            this._ratioValue = (value - min) / (max - min);
            var x = this._ratioValue * this._track.width;
            this.moveThumbPosition(x);
        };
        DSliderHorizontal.prototype.moveThumbPosition = function (x) {
            var thumb = this._thumb;
            thumb.x = x - thumb.width * 0.5;
            this._trackSelected.width = x;
            var value = this._value;
            value.x = x - value.width * 0.5;
            this.updateValue();
        };
        DSliderHorizontal.prototype.onKeyDown = function (e) {
            if (UtilKeyboardEvent.isArrowRightKey(e)) {
                this.value += this._value.delta;
            }
            else if (UtilKeyboardEvent.isArrowLeftKey(e)) {
                this.value -= this._value.delta;
            }
            return _super.prototype.onKeyDown.call(this, e);
        };
        DSliderHorizontal.prototype.getType = function () {
            return "DSliderHorizontal";
        };
        return DSliderHorizontal;
    }(DSlider));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DSliderTrackVertical = /** @class */ (function (_super) {
        __extends(DSliderTrackVertical, _super);
        function DSliderTrackVertical() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DSliderTrackVertical.prototype.getType = function () {
            return "DSliderTrackVertical";
        };
        return DSliderTrackVertical;
    }(DSliderTrack));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DSliderVertical = /** @class */ (function (_super) {
        __extends(DSliderVertical, _super);
        function DSliderVertical() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DSliderVertical.prototype.newTrack = function (options) {
            return new DSliderTrackVertical(options === null || options === void 0 ? void 0 : options.track);
        };
        DSliderVertical.prototype.newTrackSelected = function (options) {
            return new DSliderTrackVertical(options === null || options === void 0 ? void 0 : options.track);
        };
        DSliderVertical.prototype.toLabelMinOptions = function (options) {
            options = _super.prototype.toLabelMinOptions.call(this, options);
            if (options.x == null) {
                options.x = function (p, s) { return -s; };
            }
            if (options.y == null) {
                options.y = function (p, s) { return p - s * 0.5; };
            }
            var text = options.text || {};
            options.text = text;
            var textAlign = text.align || {};
            text.align = textAlign;
            if (textAlign.horizontal == null) {
                textAlign.horizontal = DAlignHorizontal.RIGHT;
            }
            return options;
        };
        DSliderVertical.prototype.toLabelMaxOptions = function (options) {
            options = _super.prototype.toLabelMaxOptions.call(this, options);
            if (options.x == null) {
                options.x = function (p, s) { return -s; };
            }
            if (options.y == null) {
                options.y = function (p, s) { return -s * 0.5; };
            }
            var text = options.text || {};
            options.text = text;
            var textAlign = text.align || {};
            text.align = textAlign;
            if (textAlign.horizontal == null) {
                textAlign.horizontal = DAlignHorizontal.RIGHT;
            }
            return options;
        };
        DSliderVertical.prototype.onPick = function (global) {
            var point = new pixi_js.Point(0, 0);
            this.toLocal(global, undefined, point);
            var height = this.height;
            var y = Math.max(0, Math.min(height, point.y));
            this._ratioValue = (height - y) / height;
            this.moveThumbPosition(y);
        };
        DSliderVertical.prototype.onValuesChange = function () {
            var min = this._min.value;
            var max = this._max.value;
            var value = this._value.value;
            this._ratioValue = (value - min) / (max - min);
            var y = this.height * (1 - this._ratioValue);
            this.moveThumbPosition(y);
        };
        DSliderVertical.prototype.moveThumbPosition = function (y) {
            var thumb = this._thumb;
            thumb.y = y - thumb.height * 0.5;
            var trackSelected = this._trackSelected;
            trackSelected.y = y;
            trackSelected.height = this.height - y;
            var value = this._value;
            value.y = y - value.height - this.getValueMargin();
            this.updateValue();
        };
        DSliderVertical.prototype.onKeyDown = function (e) {
            if (UtilKeyboardEvent.isArrowUpKey(e)) {
                this.value += this._value.delta;
            }
            else if (UtilKeyboardEvent.isArrowDownKey(e)) {
                this.value -= this._value.delta;
            }
            return _super.prototype.onKeyDown.call(this, e);
        };
        DSliderVertical.prototype.getType = function () {
            return "DSliderVertical";
        };
        return DSliderVertical;
    }(DSlider));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableBodyCells = /** @class */ (function () {
        function DTableBodyCells() {
        }
        DTableBodyCells.set = function (target, row, columnIndex, column, readOnly) {
            var _a;
            var renderable = this.toRenderable(row, columnIndex, column);
            target.renderable = renderable;
            var state = target.state;
            state.lock();
            state.isDisabled = !renderable;
            if (readOnly !== false) {
                state.isReadOnly = this.toReadOnly(row, columnIndex, column);
            }
            var columnStateModifier = (_a = column.state) === null || _a === void 0 ? void 0 : _a.modifier;
            if (columnStateModifier) {
                columnStateModifier(row, columnIndex, target.state);
            }
            state.unlock();
        };
        DTableBodyCells.toReadOnly = function (row, columnIndex, column) {
            var enable = column.editing.enable;
            if (enable === true) {
                return false;
            }
            else if (enable === false) {
                return true;
            }
            else {
                return !enable(row, columnIndex);
            }
        };
        DTableBodyCells.toRenderable = function (row, columnIndex, column) {
            var renderable = column.renderable;
            if (renderable === true) {
                return true;
            }
            else if (renderable === false) {
                return false;
            }
            else {
                return renderable(row, columnIndex);
            }
        };
        return DTableBodyCells;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableBodyCellSelectDialog = /** @class */ (function (_super) {
        __extends(DTableBodyCellSelectDialog, _super);
        function DTableBodyCellSelectDialog(columnIndex, column, onChange, options) {
            var _a;
            var _this = _super.call(this, options) || this;
            _this._rowIndex = -1;
            _this._columnIndex = columnIndex;
            _this._column = column;
            _this._onChange = onChange;
            _this._isSyncEnabled = (_a = options === null || options === void 0 ? void 0 : options.sync) !== null && _a !== void 0 ? _a : _this.theme.isSyncEnabled();
            return _this;
        }
        DTableBodyCellSelectDialog.prototype.onActivate = function (e) {
            var _this = this;
            var _a;
            _super.prototype.onActivate.call(this, e);
            var selecting = this._column.selecting;
            var dialog = selecting.dialog;
            if (dialog) {
                var oldValue_1 = (_a = this.text.computed) !== null && _a !== void 0 ? _a : null;
                selecting.setter(dialog, oldValue_1);
                dialog.open(this).then(function () {
                    var newValue = selecting.getter(dialog);
                    if (_this._isSyncEnabled) {
                        if (newValue !== oldValue_1) {
                            _this.text = newValue;
                            _this.onValueChange(newValue, oldValue_1);
                        }
                    }
                    else {
                        _this.onValueChange(newValue, null);
                    }
                });
            }
        };
        DTableBodyCellSelectDialog.prototype.onValueChange = function (newValue, oldValue) {
            var row = this._row;
            if (row !== undefined) {
                var rowIndex = this._rowIndex;
                var columnIndex = this._columnIndex;
                var column = this._column;
                column.setter(row, columnIndex, newValue);
                this.emit("change", newValue, oldValue, this);
                this._onChange(newValue, oldValue, row, rowIndex, columnIndex, column, this);
            }
        };
        Object.defineProperty(DTableBodyCellSelectDialog.prototype, "row", {
            get: function () {
                return this._row;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellSelectDialog.prototype, "rowIndex", {
            get: function () {
                return this._rowIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellSelectDialog.prototype, "columnIndex", {
            get: function () {
                return this._columnIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellSelectDialog.prototype, "column", {
            get: function () {
                return this._column;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellSelectDialog.prototype, "value", {
            get: function () {
                var _a;
                return (_a = this.text.computed) !== null && _a !== void 0 ? _a : null;
            },
            set: function (value) {
                this.text = value;
            },
            enumerable: false,
            configurable: true
        });
        DTableBodyCellSelectDialog.prototype.set = function (value, row, supplimental, rowIndex, columnIndex, forcibly) {
            this._row = row;
            this._rowIndex = rowIndex;
            if (forcibly) {
                this.text.setValue(value, true);
            }
            else {
                this.text = value;
            }
            DTableBodyCells.set(this, row, columnIndex, this._column);
        };
        DTableBodyCellSelectDialog.prototype.unset = function () {
            this._row = undefined;
            this._rowIndex = -1;
        };
        DTableBodyCellSelectDialog.prototype.getType = function () {
            return "DTableBodyCellSelectDialog";
        };
        return DTableBodyCellSelectDialog;
    }(DButton));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableBodyCellActionDialog = /** @class */ (function (_super) {
        __extends(DTableBodyCellActionDialog, _super);
        function DTableBodyCellActionDialog() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DTableBodyCellActionDialog.prototype.getType = function () {
            return "DTableBodyCellActionDialog";
        };
        return DTableBodyCellActionDialog;
    }(DTableBodyCellSelectDialog));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableBodyCellActionMenu = /** @class */ (function (_super) {
        __extends(DTableBodyCellActionMenu, _super);
        function DTableBodyCellActionMenu(columnIndex, column, onChange, options) {
            var _this = _super.call(this, options) || this;
            _this._rowIndex = -1;
            _this._columnIndex = columnIndex;
            _this._column = column;
            _this._onChange = onChange;
            return _this;
        }
        DTableBodyCellActionMenu.prototype.onMenuSelect = function (selected, item, menu) {
            var row = this._row;
            if (row !== undefined) {
                var rowIndex = this._rowIndex;
                var columnIndex = this._columnIndex;
                var column = this._column;
                column.setter(row, columnIndex, selected);
                _super.prototype.onMenuSelect.call(this, selected, item, menu);
                this._onChange(selected, null, row, rowIndex, columnIndex, column, this);
            }
        };
        DTableBodyCellActionMenu.prototype.onKeyDownArrowDown = function (e) {
            return false;
        };
        Object.defineProperty(DTableBodyCellActionMenu.prototype, "row", {
            get: function () {
                return this._row;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellActionMenu.prototype, "rowIndex", {
            get: function () {
                return this._rowIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellActionMenu.prototype, "columnIndex", {
            get: function () {
                return this._columnIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellActionMenu.prototype, "column", {
            get: function () {
                return this._column;
            },
            enumerable: false,
            configurable: true
        });
        DTableBodyCellActionMenu.prototype.set = function (value, row, supplimental, rowIndex, columnIndex, forcibly) {
            this._row = row;
            this._rowIndex = rowIndex;
            this.text = value;
            DTableBodyCells.set(this, row, columnIndex, this._column);
        };
        DTableBodyCellActionMenu.prototype.unset = function () {
            this._row = undefined;
            this._rowIndex = -1;
        };
        DTableBodyCellActionMenu.prototype.getType = function () {
            return "DTableBodyCellActionMenu";
        };
        return DTableBodyCellActionMenu;
    }(DDropdown));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableBodyCellSelectPromise = /** @class */ (function (_super) {
        __extends(DTableBodyCellSelectPromise, _super);
        function DTableBodyCellSelectPromise(columnIndex, column, onChange, options) {
            var _a;
            var _this = _super.call(this, options) || this;
            _this._rowIndex = -1;
            _this._columnIndex = columnIndex;
            _this._column = column;
            _this._onChange = onChange;
            _this._isSyncEnabled = (_a = options === null || options === void 0 ? void 0 : options.sync) !== null && _a !== void 0 ? _a : _this.theme.isSyncEnabled();
            return _this;
        }
        DTableBodyCellSelectPromise.prototype.onActivate = function (e) {
            var _this = this;
            _super.prototype.onActivate.call(this, e);
            var selecting = this._column.selecting;
            var promise = selecting.promise;
            if (promise) {
                promise().then(function (newValue) {
                    var _a;
                    if (_this._isSyncEnabled) {
                        var oldValue = (_a = _this.text.computed) !== null && _a !== void 0 ? _a : null;
                        if (newValue !== oldValue) {
                            _this.text = newValue;
                            _this.onValueChange(newValue, oldValue);
                        }
                    }
                    else {
                        _this.onValueChange(newValue, null);
                    }
                });
            }
        };
        DTableBodyCellSelectPromise.prototype.onValueChange = function (newValue, oldValue) {
            var row = this._row;
            if (row !== undefined) {
                var rowIndex = this._rowIndex;
                var columnIndex = this._columnIndex;
                var column = this._column;
                column.setter(row, columnIndex, newValue);
                this.emit("change", newValue, oldValue, this);
                this._onChange(newValue, oldValue, row, rowIndex, columnIndex, column, this);
            }
        };
        Object.defineProperty(DTableBodyCellSelectPromise.prototype, "row", {
            get: function () {
                return this._row;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellSelectPromise.prototype, "rowIndex", {
            get: function () {
                return this._rowIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellSelectPromise.prototype, "columnIndex", {
            get: function () {
                return this._columnIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellSelectPromise.prototype, "column", {
            get: function () {
                return this._column;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellSelectPromise.prototype, "value", {
            get: function () {
                var _a;
                return (_a = this.text.computed) !== null && _a !== void 0 ? _a : null;
            },
            set: function (value) {
                this.text = value;
            },
            enumerable: false,
            configurable: true
        });
        DTableBodyCellSelectPromise.prototype.set = function (value, row, supplimental, rowIndex, columnIndex, forcibly) {
            this._row = row;
            this._rowIndex = rowIndex;
            if (forcibly) {
                this.text.setValue(value, true);
            }
            else {
                this.text = value;
            }
            DTableBodyCells.set(this, row, columnIndex, this._column);
        };
        DTableBodyCellSelectPromise.prototype.unset = function () {
            this._row = undefined;
            this._rowIndex = -1;
        };
        DTableBodyCellSelectPromise.prototype.getType = function () {
            return "DTableBodyCellSelectPromise";
        };
        return DTableBodyCellSelectPromise;
    }(DButton));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableBodyCellActionPromise = /** @class */ (function (_super) {
        __extends(DTableBodyCellActionPromise, _super);
        function DTableBodyCellActionPromise() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DTableBodyCellActionPromise.prototype.getType = function () {
            return "DTableBodyCellActionPromise";
        };
        return DTableBodyCellActionPromise;
    }(DTableBodyCellSelectPromise));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableBodyCellText = /** @class */ (function (_super) {
        __extends(DTableBodyCellText, _super);
        function DTableBodyCellText(columnIndex, column, onChange, options) {
            var _this = _super.call(this, options) || this;
            _this._rowIndex = -1;
            _this._columnIndex = columnIndex;
            _this._column = column;
            _this._onChange = onChange;
            return _this;
        }
        Object.defineProperty(DTableBodyCellText.prototype, "row", {
            get: function () {
                return this._row;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellText.prototype, "rowIndex", {
            get: function () {
                return this._rowIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellText.prototype, "columnIndex", {
            get: function () {
                return this._columnIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellText.prototype, "column", {
            get: function () {
                return this._column;
            },
            enumerable: false,
            configurable: true
        });
        DTableBodyCellText.prototype.set = function (value, row, supplimental, rowIndex, columnIndex, forcibly) {
            this._row = row;
            this._rowIndex = rowIndex;
            this.text = value;
            DTableBodyCells.set(this, row, columnIndex, this._column);
        };
        DTableBodyCellText.prototype.unset = function () {
            this._row = undefined;
            this._rowIndex = -1;
        };
        DTableBodyCellText.prototype.getType = function () {
            return "DTableBodyCellText";
        };
        return DTableBodyCellText;
    }(DImageBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableBodyCellButton = /** @class */ (function (_super) {
        __extends(DTableBodyCellButton, _super);
        function DTableBodyCellButton(columnIndex, column, onChange, options) {
            var _a;
            var _this = _super.call(this, columnIndex, column, onChange, options) || this;
            _this._when = toEnum((_a = options === null || options === void 0 ? void 0 : options.when) !== null && _a !== void 0 ? _a : DButtonBaseWhen.CLICKED, DButtonBaseWhen);
            _this.on(UtilPointerEvent.tap, function (e) {
                _this.onClick(e);
            });
            return _this;
        }
        DTableBodyCellButton.prototype.onClick = function (e) {
            if (this._when === DButtonBaseWhen.CLICKED && this.state.isActionable) {
                this.activate(e);
            }
        };
        DTableBodyCellButton.prototype.onDblClick = function (e, interactionManager) {
            if (this._when === DButtonBaseWhen.DOUBLE_CLICKED && this.state.isActionable) {
                this.activate(e);
            }
            return _super.prototype.onDblClick.call(this, e, interactionManager);
        };
        DTableBodyCellButton.prototype.activate = function (e) {
            this.onActivate(e);
        };
        DTableBodyCellButton.prototype.onActivate = function (e) {
            this.emit("active", this);
            var row = this._row;
            if (row !== undefined) {
                var rowIndex = this._rowIndex;
                var columnIndex = this._columnIndex;
                var column = this._column;
                this.emit("change", null, null, this);
                this._onChange(null, null, row, rowIndex, columnIndex, column, this);
            }
        };
        DTableBodyCellButton.prototype.onActivateKeyDown = function (e) {
            if (this.state.isActionable) {
                this.state.isPressed = true;
            }
        };
        DTableBodyCellButton.prototype.onActivateKeyUp = function (e) {
            if (this.state.isActionable) {
                if (this.state.isPressed) {
                    this.onActivate(e);
                }
                this.state.isPressed = false;
            }
        };
        DTableBodyCellButton.prototype.onKeyDown = function (e) {
            if (UtilKeyboardEvent.isActivateKey(e)) {
                this.onActivateKeyDown(e);
            }
            return _super.prototype.onKeyDown.call(this, e);
        };
        DTableBodyCellButton.prototype.onKeyUp = function (e) {
            if (UtilKeyboardEvent.isActivateKey(e)) {
                this.onActivateKeyUp(e);
            }
            return _super.prototype.onKeyUp.call(this, e);
        };
        DTableBodyCellButton.prototype.getType = function () {
            return "DTableBodyCellButton";
        };
        return DTableBodyCellButton;
    }(DTableBodyCellText));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableColumnType = {
        INDEX: 0,
        TEXT: 1,
        INTEGER: 2,
        REAL: 3,
        CHECK: 4,
        CHECK_SINGLE: 5,
        COLOR: 6,
        BUTTON: 7,
        SELECT: 8,
        DATE: 9,
        DATETIME: 10,
        TIME: 11,
        ACTION: 12,
        LINK: 13,
        TREE: 14,
        TEXT_AREA: 15
    };

    /**
     * An update region when table cells get edited.
     *
     * * CELL: Edited cells (Default).
     * * ROW: Rows that edited cells belongs to.
     * * ALL: All the rows.
     */
    var DTableColumnUpdate = {
        CELL: 0,
        ROW: 1,
        ALL: 2
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableBodyCellCheck = /** @class */ (function (_super) {
        __extends(DTableBodyCellCheck, _super);
        function DTableBodyCellCheck(columnIndex, column, onChange, options) {
            var _this = _super.call(this, options) || this;
            _this._rowIndex = -1;
            _this._columnIndex = columnIndex;
            _this._column = column;
            _this._onChange = onChange;
            return _this;
        }
        DTableBodyCellCheck.prototype.onActivate = function (e) {
            _super.prototype.onActivate.call(this, e);
            this.onValueChange(true, false);
        };
        DTableBodyCellCheck.prototype.onInactivate = function (e) {
            _super.prototype.onInactivate.call(this, e);
            this.onValueChange(false, true);
        };
        DTableBodyCellCheck.prototype.onValueChange = function (newValue, oldValue) {
            var row = this._row;
            if (row !== undefined) {
                var rowIndex = this._rowIndex;
                var columnIndex = this._columnIndex;
                var column = this._column;
                column.setter(row, columnIndex, newValue);
                this.emit("change", newValue, oldValue, this);
                var onChange = this._onChange;
                onChange(newValue, oldValue, row, rowIndex, columnIndex, column, this);
                if (newValue && column.type === DTableColumnType.CHECK_SINGLE) {
                    this.onChangeSingle(rowIndex, columnIndex, column, onChange);
                }
            }
        };
        DTableBodyCellCheck.prototype.onChangeSingle = function (rowIndex, columnIndex, column, onChange) {
            var _this = this;
            var tableBodyRow = this.parent;
            if (tableBodyRow != null) {
                var tableBody = tableBodyRow.parent;
                if (tableBody != null) {
                    var isChanged_1 = false;
                    var getter_1 = column.getter;
                    var setter_1 = column.setter;
                    var data = tableBody.data;
                    data.each(function (row, index) {
                        if (rowIndex !== index && getter_1(row, columnIndex)) {
                            setter_1(row, columnIndex, false);
                            isChanged_1 = true;
                            onChange(false, true, row, index, columnIndex, column, _this);
                            return false;
                        }
                        return true;
                    });
                    if (isChanged_1 && column.update !== DTableColumnUpdate.ALL) {
                        tableBody.update(true);
                    }
                }
            }
        };
        Object.defineProperty(DTableBodyCellCheck.prototype, "row", {
            get: function () {
                return this._row;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellCheck.prototype, "rowIndex", {
            get: function () {
                return this._rowIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellCheck.prototype, "columnIndex", {
            get: function () {
                return this._columnIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellCheck.prototype, "column", {
            get: function () {
                return this._column;
            },
            enumerable: false,
            configurable: true
        });
        DTableBodyCellCheck.prototype.set = function (value, row, supplimental, rowIndex, columnIndex, forcibly) {
            this._row = row;
            this._rowIndex = rowIndex;
            this.state.isActive = !!value;
            DTableBodyCells.set(this, row, columnIndex, this._column);
        };
        DTableBodyCellCheck.prototype.unset = function () {
            this._row = undefined;
            this._rowIndex = -1;
        };
        DTableBodyCellCheck.prototype.getType = function () {
            return "DTableBodyCellCheck";
        };
        return DTableBodyCellCheck;
    }(DButtonCheck));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableBodyCellColor = /** @class */ (function (_super) {
        __extends(DTableBodyCellColor, _super);
        function DTableBodyCellColor(columnIndex, column, onChange, options) {
            var _this = _super.call(this, options) || this;
            _this._rowIndex = -1;
            _this._columnIndex = columnIndex;
            _this._column = column;
            _this._onChange = onChange;
            return _this;
        }
        DTableBodyCellColor.prototype.onValueChange = function (newValue, oldValue) {
            var row = this._row;
            if (row !== undefined) {
                var rowIndex = this._rowIndex;
                var columnIndex = this._columnIndex;
                var column = this._column;
                column.setter(row, columnIndex, newValue);
                _super.prototype.onValueChange.call(this, newValue, oldValue);
                this._onChange(newValue, oldValue, row, rowIndex, columnIndex, column, this);
            }
            else {
                _super.prototype.onValueChange.call(this, newValue, oldValue);
            }
        };
        Object.defineProperty(DTableBodyCellColor.prototype, "row", {
            get: function () {
                return this._row;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellColor.prototype, "rowIndex", {
            get: function () {
                return this._rowIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellColor.prototype, "columnIndex", {
            get: function () {
                return this._columnIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellColor.prototype, "column", {
            get: function () {
                return this._column;
            },
            enumerable: false,
            configurable: true
        });
        DTableBodyCellColor.prototype.set = function (value, row, supplimental, rowIndex, columnIndex, forcibly) {
            this._row = row;
            this._rowIndex = rowIndex;
            var cell = this.value;
            if (isNumber(value)) {
                cell.color = value;
                cell.alpha = 1;
            }
            else if (isString(value)) {
                var parsed = Number(value);
                cell.color = parsed === parsed ? parsed : 0xffffff;
                cell.alpha = 1;
            }
            else if (value != null) {
                var color = value.color;
                var alpha = value.alpha;
                cell.color = isNumber(color) ? color : 0xffffff;
                cell.alpha = isNumber(alpha) ? alpha : 1;
            }
            else {
                cell.color = 0xffffff;
                cell.alpha = 1;
            }
            DTableBodyCells.set(this, row, columnIndex, this._column);
        };
        DTableBodyCellColor.prototype.unset = function () {
            this._row = undefined;
            this._rowIndex = -1;
        };
        DTableBodyCellColor.prototype.getType = function () {
            return "DTableBodyCellColor";
        };
        return DTableBodyCellColor;
    }(DButtonColor));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableBodyCellDate = /** @class */ (function (_super) {
        __extends(DTableBodyCellDate, _super);
        function DTableBodyCellDate(columnIndex, column, onChange, options) {
            var _this = _super.call(this, options) || this;
            _this._rowIndex = -1;
            _this._columnIndex = columnIndex;
            _this._column = column;
            _this._onChange = onChange;
            return _this;
        }
        DTableBodyCellDate.prototype.onValueChange = function (newValue, oldValue) {
            var row = this._row;
            if (row !== undefined) {
                var rowIndex = this._rowIndex;
                var columnIndex = this._columnIndex;
                var column = this._column;
                column.setter(row, columnIndex, newValue);
                _super.prototype.onValueChange.call(this, newValue, oldValue);
                this._onChange(newValue, oldValue, row, rowIndex, columnIndex, column, this);
            }
            else {
                _super.prototype.onValueChange.call(this, newValue, oldValue);
            }
        };
        Object.defineProperty(DTableBodyCellDate.prototype, "row", {
            get: function () {
                return this._row;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellDate.prototype, "rowIndex", {
            get: function () {
                return this._rowIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellDate.prototype, "columnIndex", {
            get: function () {
                return this._columnIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellDate.prototype, "column", {
            get: function () {
                return this._column;
            },
            enumerable: false,
            configurable: true
        });
        DTableBodyCellDate.prototype.set = function (value, row, supplimental, rowIndex, columnIndex, forcibly) {
            this._row = row;
            this._rowIndex = rowIndex;
            if (value instanceof Date) {
                if (forcibly) {
                    this.text.setValue(value, true);
                }
                else {
                    this.text = value;
                }
            }
            else if (isNumber(value)) {
                var text = this.text;
                var computed = text.computed;
                if (computed === undefined) {
                    this.text = new Date(value);
                }
                else if (computed.getTime() !== value) {
                    computed.setTime(value);
                    text.compute(true);
                }
            }
            DTableBodyCells.set(this, row, columnIndex, this._column);
        };
        DTableBodyCellDate.prototype.unset = function () {
            this._row = undefined;
            this._rowIndex = -1;
        };
        DTableBodyCellDate.prototype.getType = function () {
            return "DTableBodyCellDate";
        };
        return DTableBodyCellDate;
    }(DButtonDate));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableBodyCellDatetime = /** @class */ (function (_super) {
        __extends(DTableBodyCellDatetime, _super);
        function DTableBodyCellDatetime(columnIndex, column, onChange, options) {
            var _this = _super.call(this, options) || this;
            _this._rowIndex = -1;
            _this._columnIndex = columnIndex;
            _this._column = column;
            _this._onChange = onChange;
            return _this;
        }
        DTableBodyCellDatetime.prototype.onValueChange = function (newValue, oldValue) {
            var row = this._row;
            if (row !== undefined) {
                var rowIndex = this._rowIndex;
                var columnIndex = this._columnIndex;
                var column = this._column;
                column.setter(row, columnIndex, newValue);
                _super.prototype.onValueChange.call(this, newValue, oldValue);
                this._onChange(newValue, oldValue, row, rowIndex, columnIndex, column, this);
            }
            else {
                _super.prototype.onValueChange.call(this, newValue, oldValue);
            }
        };
        Object.defineProperty(DTableBodyCellDatetime.prototype, "row", {
            get: function () {
                return this._row;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellDatetime.prototype, "rowIndex", {
            get: function () {
                return this._rowIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellDatetime.prototype, "columnIndex", {
            get: function () {
                return this._columnIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellDatetime.prototype, "column", {
            get: function () {
                return this._column;
            },
            enumerable: false,
            configurable: true
        });
        DTableBodyCellDatetime.prototype.set = function (value, row, supplimental, rowIndex, columnIndex, forcibly) {
            this._row = row;
            this._rowIndex = rowIndex;
            if (value instanceof Date) {
                if (forcibly) {
                    this.text.setValue(value, true);
                }
                else {
                    this.text = value;
                }
            }
            else if (isNumber(value)) {
                var text = this.text;
                var computed = text.computed;
                if (computed == null) {
                    this.text = new Date(value);
                }
                else if (computed.getTime() !== value) {
                    computed.setTime(value);
                    text.compute(true);
                }
            }
            DTableBodyCells.set(this, row, columnIndex, this._column);
        };
        DTableBodyCellDatetime.prototype.unset = function () {
            this._row = undefined;
            this._rowIndex = -1;
        };
        DTableBodyCellDatetime.prototype.getType = function () {
            return "DTableBodyCellDatetime";
        };
        return DTableBodyCellDatetime;
    }(DButtonDatetime));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableBodyCellIndex = /** @class */ (function (_super) {
        __extends(DTableBodyCellIndex, _super);
        function DTableBodyCellIndex(columnIndex, column, onChange, options) {
            var _this = _super.call(this, options) || this;
            _this._rowIndex = -1;
            _this._columnIndex = columnIndex;
            _this._column = column;
            _this._onChange = onChange;
            return _this;
        }
        Object.defineProperty(DTableBodyCellIndex.prototype, "row", {
            get: function () {
                return this._row;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellIndex.prototype, "rowIndex", {
            get: function () {
                return this._rowIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellIndex.prototype, "columnIndex", {
            get: function () {
                return this._columnIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellIndex.prototype, "column", {
            get: function () {
                return this._column;
            },
            enumerable: false,
            configurable: true
        });
        DTableBodyCellIndex.prototype.set = function (value, row, supplimental, rowIndex, columnIndex, forcibly) {
            this._row = row;
            this._rowIndex = rowIndex;
            this.text = rowIndex;
            DTableBodyCells.set(this, row, columnIndex, this._column);
        };
        DTableBodyCellIndex.prototype.unset = function () {
            this._row = undefined;
            this._rowIndex = -1;
        };
        DTableBodyCellIndex.prototype.getType = function () {
            return "DTableBodyCellIndex";
        };
        return DTableBodyCellIndex;
    }(DImageBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableBodyCellInputInteger = /** @class */ (function (_super) {
        __extends(DTableBodyCellInputInteger, _super);
        function DTableBodyCellInputInteger(columnIndex, column, onChange, options) {
            var _this = _super.call(this, options) || this;
            _this._rowIndex = -1;
            _this._columnIndex = columnIndex;
            _this._column = column;
            _this._onChange = onChange;
            return _this;
        }
        DTableBodyCellInputInteger.prototype.onValueChange = function (newValue, oldValue) {
            var row = this._row;
            if (row !== undefined) {
                var rowIndex = this._rowIndex;
                var columnIndex = this._columnIndex;
                var column = this._column;
                column.setter(row, columnIndex, newValue);
                _super.prototype.onValueChange.call(this, newValue, oldValue);
                this._onChange(newValue, oldValue, row, rowIndex, columnIndex, column, this);
            }
        };
        Object.defineProperty(DTableBodyCellInputInteger.prototype, "row", {
            get: function () {
                return this._row;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellInputInteger.prototype, "rowIndex", {
            get: function () {
                return this._rowIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellInputInteger.prototype, "columnIndex", {
            get: function () {
                return this._columnIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellInputInteger.prototype, "column", {
            get: function () {
                return this._column;
            },
            enumerable: false,
            configurable: true
        });
        DTableBodyCellInputInteger.prototype.set = function (value, row, supplimental, rowIndex, columnIndex, forcibly) {
            this._row = row;
            this._rowIndex = rowIndex;
            this.text = Number(value);
            DTableBodyCells.set(this, row, columnIndex, this._column);
        };
        DTableBodyCellInputInteger.prototype.unset = function () {
            this._row = undefined;
            this._rowIndex = -1;
        };
        DTableBodyCellInputInteger.prototype.getType = function () {
            return "DTableBodyCellInputInteger";
        };
        return DTableBodyCellInputInteger;
    }(DInputInteger));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableBodyCellInputReal = /** @class */ (function (_super) {
        __extends(DTableBodyCellInputReal, _super);
        function DTableBodyCellInputReal(columnIndex, column, onChange, options) {
            var _this = _super.call(this, options) || this;
            _this._rowIndex = -1;
            _this._columnIndex = columnIndex;
            _this._column = column;
            _this._onChange = onChange;
            return _this;
        }
        DTableBodyCellInputReal.prototype.onValueChange = function (newValue, oldValue) {
            var row = this._row;
            if (row !== undefined) {
                var rowIndex = this._rowIndex;
                var columnIndex = this._columnIndex;
                var column = this._column;
                column.setter(row, columnIndex, newValue);
                _super.prototype.onValueChange.call(this, newValue, oldValue);
                this._onChange(newValue, oldValue, row, rowIndex, columnIndex, column, this);
            }
        };
        Object.defineProperty(DTableBodyCellInputReal.prototype, "row", {
            get: function () {
                return this._row;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellInputReal.prototype, "rowIndex", {
            get: function () {
                return this._rowIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellInputReal.prototype, "columnIndex", {
            get: function () {
                return this._columnIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellInputReal.prototype, "column", {
            get: function () {
                return this._column;
            },
            enumerable: false,
            configurable: true
        });
        DTableBodyCellInputReal.prototype.set = function (value, row, supplimental, rowIndex, columnIndex, forcibly) {
            this._row = row;
            this._rowIndex = rowIndex;
            this.text = Number(value);
            DTableBodyCells.set(this, row, columnIndex, this._column);
        };
        DTableBodyCellInputReal.prototype.unset = function () {
            this._row = undefined;
            this._rowIndex = -1;
        };
        DTableBodyCellInputReal.prototype.getType = function () {
            return "DTableBodyCellInputReal";
        };
        return DTableBodyCellInputReal;
    }(DInputReal));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableBodyCellInputTextArea = /** @class */ (function (_super) {
        __extends(DTableBodyCellInputTextArea, _super);
        function DTableBodyCellInputTextArea(columnIndex, column, onChange, options) {
            var _this = _super.call(this, options) || this;
            _this._rowIndex = -1;
            _this._columnIndex = columnIndex;
            _this._column = column;
            _this._onChange = onChange;
            return _this;
        }
        DTableBodyCellInputTextArea.prototype.onValueChange = function (newValue, oldValue) {
            var row = this._row;
            if (row !== undefined) {
                var rowIndex = this._rowIndex;
                var columnIndex = this._columnIndex;
                var column = this._column;
                column.setter(row, columnIndex, newValue);
                _super.prototype.onValueChange.call(this, newValue, oldValue);
                this._onChange(newValue, oldValue, row, rowIndex, columnIndex, column, this);
            }
        };
        Object.defineProperty(DTableBodyCellInputTextArea.prototype, "row", {
            get: function () {
                return this._row;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellInputTextArea.prototype, "rowIndex", {
            get: function () {
                return this._rowIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellInputTextArea.prototype, "columnIndex", {
            get: function () {
                return this._columnIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellInputTextArea.prototype, "column", {
            get: function () {
                return this._column;
            },
            enumerable: false,
            configurable: true
        });
        DTableBodyCellInputTextArea.prototype.set = function (value, row, supplimental, rowIndex, columnIndex, forcibly) {
            this._row = row;
            this._rowIndex = rowIndex;
            this.text = String(value);
            DTableBodyCells.set(this, row, columnIndex, this._column);
        };
        DTableBodyCellInputTextArea.prototype.unset = function () {
            this._row = undefined;
            this._rowIndex = -1;
        };
        DTableBodyCellInputTextArea.prototype.getType = function () {
            return "DTableBodyCellInputTextArea";
        };
        return DTableBodyCellInputTextArea;
    }(DInputTextArea));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableBodyCellInputText = /** @class */ (function (_super) {
        __extends(DTableBodyCellInputText, _super);
        function DTableBodyCellInputText(columnIndex, column, onChange, options) {
            var _this = _super.call(this, options) || this;
            _this._rowIndex = -1;
            _this._columnIndex = columnIndex;
            _this._column = column;
            _this._onChange = onChange;
            return _this;
        }
        DTableBodyCellInputText.prototype.onValueChange = function (newValue, oldValue) {
            var row = this._row;
            if (row !== undefined) {
                var rowIndex = this._rowIndex;
                var columnIndex = this._columnIndex;
                var column = this._column;
                column.setter(row, columnIndex, newValue);
                _super.prototype.onValueChange.call(this, newValue, oldValue);
                this._onChange(newValue, oldValue, row, rowIndex, columnIndex, column, this);
            }
        };
        Object.defineProperty(DTableBodyCellInputText.prototype, "row", {
            get: function () {
                return this._row;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellInputText.prototype, "rowIndex", {
            get: function () {
                return this._rowIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellInputText.prototype, "columnIndex", {
            get: function () {
                return this._columnIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellInputText.prototype, "column", {
            get: function () {
                return this._column;
            },
            enumerable: false,
            configurable: true
        });
        DTableBodyCellInputText.prototype.set = function (value, row, supplimental, rowIndex, columnIndex, forcibly) {
            this._row = row;
            this._rowIndex = rowIndex;
            this.text = String(value);
            DTableBodyCells.set(this, row, columnIndex, this._column);
        };
        DTableBodyCellInputText.prototype.unset = function () {
            this._row = undefined;
            this._rowIndex = -1;
        };
        DTableBodyCellInputText.prototype.getType = function () {
            return "DTableBodyCellInputText";
        };
        return DTableBodyCellInputText;
    }(DInputText));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableBodyCellInputTreeInput = /** @class */ (function (_super) {
        __extends(DTableBodyCellInputTreeInput, _super);
        function DTableBodyCellInputTreeInput() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DTableBodyCellInputTreeInput.prototype.newPadding = function (theme, options, callback) {
            return new DBasePaddingAdjustable(theme, options, callback);
        };
        Object.defineProperty(DTableBodyCellInputTreeInput.prototype, "padding", {
            get: function () {
                return this._padding;
            },
            enumerable: false,
            configurable: true
        });
        DTableBodyCellInputTreeInput.prototype.getType = function () {
            return "DTableBodyCellInputTreeInput";
        };
        return DTableBodyCellInputTreeInput;
    }(DInputText));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableBodyCellInputTreeMarker = /** @class */ (function (_super) {
        __extends(DTableBodyCellInputTreeMarker, _super);
        function DTableBodyCellInputTreeMarker() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DTableBodyCellInputTreeMarker.prototype.getType = function () {
            return "DTableBodyCellInputTreeMarker";
        };
        return DTableBodyCellInputTreeMarker;
    }(DButtonBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * {@link DTable} states.
     */
    var DTableState = {
        /**
         * Start cells in rows.
         */
        START: "START",
        /**
         * End cells in rows.
         */
        END: "END",
        /**
         * Cells of frozen columns.
         */
        FROZEN: "FROZEN",
        /**
         * Cells of a right-most frozen column.
         */
        FROZEN_END: "FROZEN_END",
        /**
         * Rows with data
         */
        HAS_DATA: "HAS_DATA",
        /**
         * Header cells of sortable columns.
         */
        SORTABLE: "SORTABLE",
        /**
         * Header cells of columns sorted in the ascending order.
         */
        SORTED_ASCENDING: "SORTED_ASCENDING",
        /**
         * Header cells of columns sorted in the descending order.
         */
        SORTED_DESCENDING: "SORTED_DESCENDING",
        /**
         * Tree cells with child cells.
         */
        HAS_CHILDREN: "HAS_CHILDREN",
        /**
         * Tree cells opened.
         */
        OPENED: "OPENED",
        /**
         * Header cells of checkable columns.
         */
        CHECKABLE: "CHECKABLE",
        /**
         * Selectable row
         */
        SELECTABLE: "SELECTABLE",
        /**
         * Header or category cells hovered on their edges.
         */
        HOVERED_ON_EDGE: "HOVERED_ON_EDGE",
        /**
         * Header or category of being resized.
         */
        RESIZING: "RESIZING"
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var toBaseOptions = function (options) {
        if (options != null) {
            return {
                weight: options.weight,
                width: options.width
            };
        }
        return undefined;
    };
    var DTableBodyCellInputTree = /** @class */ (function (_super) {
        __extends(DTableBodyCellInputTree, _super);
        function DTableBodyCellInputTree(columnIndex, column, onChange, options) {
            var _this = _super.call(this, toBaseOptions(options)) || this;
            _this._rowIndex = -1;
            _this._columnIndex = columnIndex;
            _this._column = column;
            _this._onChange = onChange;
            // Input
            var input = _this.newInput(options);
            _this._input = input;
            _this.addChild(input);
            // Marker
            var marker = _this.newMarker(options);
            _this._marker = marker;
            _this.addChild(marker);
            return _this;
        }
        DTableBodyCellInputTree.prototype.newInput = function (options) {
            return new DTableBodyCellInputTreeInput(this.toInputOptions(options));
        };
        DTableBodyCellInputTree.prototype.toInputOptions = function (options) {
            var _this = this;
            return {
                weight: 1,
                text: options === null || options === void 0 ? void 0 : options.text,
                editing: options === null || options === void 0 ? void 0 : options.editing,
                when: options === null || options === void 0 ? void 0 : options.when,
                cursor: options === null || options === void 0 ? void 0 : options.cursor,
                on: {
                    change: function (newValue, oldValue) {
                        _this.onInputChange(newValue, oldValue);
                    }
                }
            };
        };
        DTableBodyCellInputTree.prototype.onInputChange = function (newValue, oldValue) {
            var row = this._row;
            if (row !== undefined) {
                var rowIndex = this._rowIndex;
                var columnIndex = this._columnIndex;
                var column = this._column;
                column.setter(row, columnIndex, newValue);
                this.emit("change", newValue, oldValue, this);
                this._onChange(newValue, oldValue, row, rowIndex, columnIndex, column, this);
            }
        };
        DTableBodyCellInputTree.prototype.newMarker = function (options) {
            var _this = this;
            return new DTableBodyCellInputTreeMarker({
                visible: false,
                on: {
                    active: function () {
                        _this.onMarkerActive();
                    }
                }
            });
        };
        DTableBodyCellInputTree.prototype.onMarkerActive = function () {
            if (this._marker.state.is(DTableState.HAS_CHILDREN)) {
                this.toggle();
            }
        };
        Object.defineProperty(DTableBodyCellInputTree.prototype, "row", {
            get: function () {
                return this._row;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellInputTree.prototype, "rowIndex", {
            get: function () {
                return this._rowIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellInputTree.prototype, "columnIndex", {
            get: function () {
                return this._columnIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellInputTree.prototype, "column", {
            get: function () {
                return this._column;
            },
            enumerable: false,
            configurable: true
        });
        DTableBodyCellInputTree.prototype.toggle = function () {
            var row = this._row;
            if (row === undefined) {
                return;
            }
            var parent = this.parent;
            if (parent == null) {
                return;
            }
            var body = parent.parent;
            if (body == null) {
                return;
            }
            var data = body.data;
            if (data && data.toggle) {
                if (data.isExpanded(row)) {
                    if (data.collapse(row)) {
                        this.emit("collapse", this);
                        data.emit("collapse", row, this);
                    }
                }
                else {
                    if (data.expand(row)) {
                        this.emit("expand", this);
                        data.emit("expand", row, this);
                    }
                }
            }
        };
        DTableBodyCellInputTree.prototype.onRowSelect = function (e, local) {
            if (local.x <= this.position.x + this._input.padding.getLeft()) {
                return true;
            }
            return false;
        };
        DTableBodyCellInputTree.prototype.set = function (value, row, supplimental, rowIndex, columnIndex, forcibly) {
            this._row = row;
            this._rowIndex = rowIndex;
            var input = this._input;
            input.visible = true;
            input.text = String(value);
            var marker = this._marker;
            if (supplimental != null) {
                var isOpened = !!(supplimental & 0x1);
                var hasChildren = !!(supplimental & 0x2);
                var level = supplimental >> 2;
                var markerState = marker.state;
                markerState.lock();
                markerState.set(DTableState.HAS_CHILDREN, hasChildren);
                markerState.set(DBaseState.DISABLED, !hasChildren);
                markerState.set(DTableState.OPENED, isOpened);
                markerState.unlock();
                var padding = this.theme.getLevelPadding(level);
                marker.width = padding;
                if (hasChildren) {
                    marker.show();
                }
                else {
                    marker.hide();
                }
                input.padding.adjLeft(padding);
            }
            else {
                marker.state.removeAll(DTableState.OPENED, DTableState.HAS_CHILDREN);
                marker.hide();
                input.padding.adjLeft(0);
            }
            DTableBodyCells.set(this._input, row, columnIndex, this._column);
        };
        DTableBodyCellInputTree.prototype.unset = function () {
            this._row = undefined;
            this._rowIndex = -1;
            this._input.visible = false;
            this._marker.hide();
        };
        DTableBodyCellInputTree.prototype.getType = function () {
            return "DTableBodyCellInputTree";
        };
        return DTableBodyCellInputTree;
    }(DBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var toLinkOptions = function (cell, options) {
        if (options) {
            return {
                url: toUrl(cell, options.url),
                target: options.target,
                checker: toChecker(cell, options.checker),
                menu: options.menu
            };
        }
        return undefined;
    };
    var toUrl = function (cell, url) {
        if (isString(url) || url == null) {
            return url;
        }
        else {
            return function () {
                var row = cell.row;
                if (row !== undefined) {
                    return url(row, cell.rowIndex, cell.columnIndex, cell);
                }
                return null;
            };
        }
    };
    var toChecker = function (cell, checker) {
        if (checker != null) {
            return function () {
                var row = cell.row;
                if (row !== undefined) {
                    return checker(row, cell.rowIndex, cell.columnIndex, cell);
                }
                return false;
            };
        }
        return undefined;
    };
    var DTableBodyCellLink = /** @class */ (function (_super) {
        __extends(DTableBodyCellLink, _super);
        function DTableBodyCellLink(columnIndex, column, onChange, options) {
            var _a;
            return _super.call(this, columnIndex, column, onChange, DLinks.toStateOptions((_a = options === null || options === void 0 ? void 0 : options.link) === null || _a === void 0 ? void 0 : _a.target, options)) || this;
        }
        DTableBodyCellLink.prototype.onClick = function (e) {
            if (!this.link.onClick(this, e)) {
                _super.prototype.onClick.call(this, e);
            }
        };
        Object.defineProperty(DTableBodyCellLink.prototype, "link", {
            get: function () {
                var _a;
                var result = this._link;
                if (result == null) {
                    result = new DLink(toLinkOptions(this, (_a = this._options) === null || _a === void 0 ? void 0 : _a.link));
                    this._link = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DTableBodyCellLink.prototype.getType = function () {
            return "DTableBodyCellLink";
        };
        DTableBodyCellLink.prototype.onActivate = function (e) {
            _super.prototype.onActivate.call(this, e);
            this.link.open(e);
        };
        DTableBodyCellLink.prototype.open = function (inNewWindow) {
            this.link.open(inNewWindow);
        };
        return DTableBodyCellLink;
    }(DTableBodyCellButton));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableBodyCellSelectMenu = /** @class */ (function (_super) {
        __extends(DTableBodyCellSelectMenu, _super);
        function DTableBodyCellSelectMenu(columnIndex, column, onChange, options) {
            var _this = _super.call(this, options) || this;
            _this._rowIndex = -1;
            _this._columnIndex = columnIndex;
            _this._column = column;
            _this._onChange = onChange;
            return _this;
        }
        DTableBodyCellSelectMenu.prototype.onValueChange = function (newValue, oldValue, item) {
            var row = this._row;
            if (row !== undefined) {
                var rowIndex = this._rowIndex;
                var columnIndex = this._columnIndex;
                var column = this._column;
                column.setter(row, columnIndex, newValue);
                _super.prototype.onValueChange.call(this, newValue, oldValue, item);
                this._onChange(newValue, oldValue, row, rowIndex, columnIndex, column, this);
            }
        };
        DTableBodyCellSelectMenu.prototype.onKeyDownArrowDown = function (e) {
            return false;
        };
        Object.defineProperty(DTableBodyCellSelectMenu.prototype, "row", {
            get: function () {
                return this._row;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellSelectMenu.prototype, "rowIndex", {
            get: function () {
                return this._rowIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellSelectMenu.prototype, "columnIndex", {
            get: function () {
                return this._columnIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellSelectMenu.prototype, "column", {
            get: function () {
                return this._column;
            },
            enumerable: false,
            configurable: true
        });
        DTableBodyCellSelectMenu.prototype.set = function (value, row, supplimental, rowIndex, columnIndex, forcibly) {
            this._row = row;
            this._rowIndex = rowIndex;
            this.value = value;
            DTableBodyCells.set(this, row, columnIndex, this._column);
        };
        DTableBodyCellSelectMenu.prototype.unset = function () {
            this._row = undefined;
            this._rowIndex = -1;
        };
        DTableBodyCellSelectMenu.prototype.getType = function () {
            return "DTableBodyCellSelectMenu";
        };
        return DTableBodyCellSelectMenu;
    }(DSelect));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableBodyCellSelectMultiple = /** @class */ (function (_super) {
        __extends(DTableBodyCellSelectMultiple, _super);
        function DTableBodyCellSelectMultiple(columnIndex, column, onChange, options) {
            var _this = _super.call(this, options) || this;
            _this._rowIndex = -1;
            _this._columnIndex = columnIndex;
            _this._column = column;
            _this._onChange = onChange;
            return _this;
        }
        DTableBodyCellSelectMultiple.prototype.onValueChange = function (newValues, oldValues, items) {
            var row = this._row;
            if (row !== undefined) {
                var rowIndex = this._rowIndex;
                var columnIndex = this._columnIndex;
                var column = this._column;
                column.setter(row, columnIndex, newValues);
                _super.prototype.onValueChange.call(this, newValues, oldValues, items);
                this._onChange(newValues, oldValues, row, rowIndex, columnIndex, column, this);
            }
        };
        DTableBodyCellSelectMultiple.prototype.onKeyDownArrowDown = function (e) {
            return false;
        };
        Object.defineProperty(DTableBodyCellSelectMultiple.prototype, "row", {
            get: function () {
                return this._row;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellSelectMultiple.prototype, "rowIndex", {
            get: function () {
                return this._rowIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellSelectMultiple.prototype, "columnIndex", {
            get: function () {
                return this._columnIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellSelectMultiple.prototype, "column", {
            get: function () {
                return this._column;
            },
            enumerable: false,
            configurable: true
        });
        DTableBodyCellSelectMultiple.prototype.set = function (value, row, supplimental, rowIndex, columnIndex, forcibly) {
            this._row = row;
            this._rowIndex = rowIndex;
            this.values = value;
            DTableBodyCells.set(this, row, columnIndex, this._column);
        };
        DTableBodyCellSelectMultiple.prototype.unset = function () {
            this._row = undefined;
            this._rowIndex = -1;
        };
        DTableBodyCellSelectMultiple.prototype.getType = function () {
            return "DTableBodyCellSelectMultiple";
        };
        return DTableBodyCellSelectMultiple;
    }(DSelectMultiple));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableBodyCellTextArea = /** @class */ (function (_super) {
        __extends(DTableBodyCellTextArea, _super);
        function DTableBodyCellTextArea() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DTableBodyCellTextArea.prototype.getType = function () {
            return "DTableBodyCellTextArea";
        };
        return DTableBodyCellTextArea;
    }(DTableBodyCellText));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableBodyCellTime = /** @class */ (function (_super) {
        __extends(DTableBodyCellTime, _super);
        function DTableBodyCellTime(columnIndex, column, onChange, options) {
            var _this = _super.call(this, options) || this;
            _this._rowIndex = -1;
            _this._columnIndex = columnIndex;
            _this._column = column;
            _this._onChange = onChange;
            return _this;
        }
        DTableBodyCellTime.prototype.onValueChange = function (newValue, oldValue) {
            var row = this._row;
            if (row !== undefined) {
                var rowIndex = this._rowIndex;
                var columnIndex = this._columnIndex;
                var column = this._column;
                column.setter(row, columnIndex, newValue);
                _super.prototype.onValueChange.call(this, newValue, oldValue);
                this._onChange(newValue, oldValue, row, rowIndex, columnIndex, column, this);
            }
            else {
                _super.prototype.onValueChange.call(this, newValue, oldValue);
            }
        };
        Object.defineProperty(DTableBodyCellTime.prototype, "row", {
            get: function () {
                return this._row;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellTime.prototype, "rowIndex", {
            get: function () {
                return this._rowIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellTime.prototype, "columnIndex", {
            get: function () {
                return this._columnIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellTime.prototype, "column", {
            get: function () {
                return this._column;
            },
            enumerable: false,
            configurable: true
        });
        DTableBodyCellTime.prototype.set = function (value, row, supplimental, rowIndex, columnIndex, forcibly) {
            this._row = row;
            this._rowIndex = rowIndex;
            if (value instanceof Date) {
                if (forcibly) {
                    this.text.setValue(value, true);
                }
                else {
                    this.text = value;
                }
            }
            else if (isNumber(value)) {
                var text = this.text;
                var computed = text.computed;
                if (computed == null) {
                    this.text = new Date(value);
                }
                else if (computed.getTime() !== value) {
                    computed.setTime(value);
                    text.compute(true);
                }
            }
            DTableBodyCells.set(this, row, columnIndex, this._column);
        };
        DTableBodyCellTime.prototype.unset = function () {
            this._row = undefined;
            this._rowIndex = -1;
        };
        DTableBodyCellTime.prototype.getType = function () {
            return "DTableBodyCellTime";
        };
        return DTableBodyCellTime;
    }(DButtonTime));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableBodyCellTree = /** @class */ (function (_super) {
        __extends(DTableBodyCellTree, _super);
        function DTableBodyCellTree(columnIndex, column, onChange, options) {
            var _a;
            return _super.call(this, columnIndex, column, onChange, DLinks.toStateOptions((_a = options === null || options === void 0 ? void 0 : options.link) === null || _a === void 0 ? void 0 : _a.target, options)) || this;
        }
        DTableBodyCellTree.prototype.newPadding = function (theme, options, callback) {
            return new DBasePaddingAdjustable(theme, options, callback);
        };
        DTableBodyCellTree.prototype.onClick = function (e) {
            var _a;
            if (((_a = this.link) === null || _a === void 0 ? void 0 : _a.onClick(this, e)) !== true) {
                _super.prototype.onClick.call(this, e);
            }
        };
        Object.defineProperty(DTableBodyCellTree.prototype, "link", {
            get: function () {
                var result = this._link;
                if (result === undefined) {
                    result = this.newLink();
                    this._link = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DTableBodyCellTree.prototype.newLink = function () {
            var _a;
            var options = (_a = this._options) === null || _a === void 0 ? void 0 : _a.link;
            if (options) {
                return new DLink(toLinkOptions(this, options));
            }
            return null;
        };
        DTableBodyCellTree.prototype.onActivate = function (e) {
            var _a;
            _super.prototype.onActivate.call(this, e);
            if (this.state.is(DTableState.HAS_CHILDREN)) {
                this.toggle();
            }
            else {
                (_a = this.link) === null || _a === void 0 ? void 0 : _a.open(e);
            }
        };
        DTableBodyCellTree.prototype.toggle = function () {
            var row = this._row;
            if (row === undefined) {
                return;
            }
            var parent = this.parent;
            if (parent == null) {
                return;
            }
            var body = parent.parent;
            if (body == null) {
                return;
            }
            var data = body.data;
            if (data && data.toggle) {
                if (data.isExpanded(row)) {
                    if (data.collapse(row)) {
                        this.emit("collapse", this);
                        data.emit("collapse", row, this);
                    }
                }
                else {
                    if (data.expand(row)) {
                        this.emit("expand", this);
                        data.emit("expand", row, this);
                    }
                }
            }
        };
        DTableBodyCellTree.prototype.onRowSelect = function (e, local) {
            if (local.x <= this.position.x + this.padding.getLeft()) {
                this.toggle();
                return true;
            }
            return false;
        };
        DTableBodyCellTree.prototype.set = function (value, row, supplimental, rowIndex, columnIndex, forcibly) {
            this._row = row;
            this._rowIndex = rowIndex;
            this.text = value;
            DTableBodyCells.set(this, row, columnIndex, this._column, false);
            var link = this.link;
            var padding = this._padding;
            if (supplimental != null) {
                var isOpened = !!(supplimental & 0x1);
                var hasChildren = !!(supplimental & 0x2);
                var level = supplimental >> 2;
                var state = this.state;
                state.lock();
                state.set(DTableState.HAS_CHILDREN, hasChildren);
                state.set(DTableState.OPENED, isOpened);
                state.unlock();
                padding.adjLeft(this.theme.getLevelPadding(level));
                if (link) {
                    link.menu.enable = !hasChildren;
                }
            }
            else {
                this.state.removeAll(DTableState.OPENED, DTableState.HAS_CHILDREN);
                padding.adjLeft(0);
                if (link) {
                    link.menu.enable = false;
                }
            }
        };
        DTableBodyCellTree.prototype.getType = function () {
            return "DTableBodyCellTree";
        };
        return DTableBodyCellTree;
    }(DTableBodyCellButton));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * {@link DTableDataSelection} type.
     */
    var DTableDataSelectionType = {
        NONE: 0,
        SINGLE: 1,
        MULTIPLE: 2
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableRow = /** @class */ (function (_super) {
        __extends(DTableRow, _super);
        function DTableRow(columns, frozen, options) {
            var _this = _super.call(this, options) || this;
            _this._reverse = true;
            _this._frozen = frozen;
            _this._columns = columns;
            return _this;
        }
        DTableRow.prototype.initCells = function () {
            var columns = this._columns;
            var frozen = this._frozen;
            var options = this._options;
            var iend = this.toIndexEnd(columns);
            for (var i = columns.length - 1; 0 <= i; --i) {
                var cell = this.newCell(i, columns[i], columns, options);
                var cellState = cell.state;
                cellState.lock(false);
                if (i === 0) {
                    cellState.add(DTableState.START);
                }
                if (i === iend) {
                    cellState.add(DTableState.END);
                }
                if (i < frozen) {
                    cellState.add(DTableState.FROZEN);
                }
                if (i === frozen - 1) {
                    cellState.add(DTableState.FROZEN_END);
                }
                cellState.unlock();
                this.addChild(cell);
            }
        };
        DTableRow.prototype.toIndexEnd = function (columns) {
            var imax = columns.length;
            for (var i = 0; i < imax; ++i) {
                var column = columns[i];
                if (column.weight !== undefined) {
                    return imax - 1;
                }
            }
            return imax;
        };
        DTableRow.prototype.onRefit = function () {
            _super.prototype.onRefit.call(this);
            this.resetFrozenCellPosition();
        };
        DTableRow.prototype.updateFrozenCellPosition = function (x) {
            var columns = this._columns;
            var cells = this.children;
            var cellsLength = cells.length;
            var frozen = this._frozen;
            for (var i = 0; i < frozen; ++i) {
                var column = columns[i];
                var cell = cells[cellsLength - 1 - i];
                cell.position.x = -x + column.offset;
            }
        };
        DTableRow.prototype.resetFrozenCellPosition = function () {
            var columns = this._columns;
            var cells = this.children;
            var cellsLength = cells.length;
            var frozen = this._frozen;
            var x = this.getContentPositionX();
            for (var i = 0; i < frozen; ++i) {
                var column = columns[i];
                var cell = cells[cellsLength - 1 - i];
                column.offset = cell.position.x;
                cell.position.x = -x + column.offset;
            }
        };
        DTableRow.prototype.getClippingRect = function (target, result) {
            _super.prototype.getClippingRect.call(this, target, result);
            var frozen = this._frozen;
            if (0 < frozen) {
                var cell = target;
                if (cell && cell.parent === this) {
                    var cells = this.children;
                    var cellIndex = cells.indexOf(cell);
                    if (0 <= cellIndex) {
                        var columnIndex = cells.length - 1 - cellIndex;
                        if (frozen <= columnIndex) {
                            var previous = cells[cellIndex + 1];
                            var shiftX = previous.position.x + previous.width;
                            result.x += shiftX;
                            result.width -= shiftX;
                        }
                    }
                }
            }
        };
        DTableRow.prototype.getType = function () {
            return "DTableRow";
        };
        return DTableRow;
    }(DLayoutHorizontal));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableBodyRow = /** @class */ (function (_super) {
        __extends(DTableBodyRow, _super);
        function DTableBodyRow(onChange, isEven, columnIndexToCellOptions, columns, frozen, options) {
            var _this = _super.call(this, columns, frozen, options) || this;
            _this._index = -1;
            _this._onChange = onChange;
            _this._onCellChangeBound = function (newValue, oldValue, row, rowIndex, columnIndex, column) {
                _this.onCellChange(newValue, oldValue, row, rowIndex, columnIndex, column);
            };
            _this._columnIndexToCellOptions = columnIndexToCellOptions;
            _this.state.isAlternated = !isEven;
            _this.initCells();
            return _this;
        }
        DTableBodyRow.prototype.onCellChange = function (newValue, oldValue, row, rowIndex, columnIndex, column) {
            this.emit("change", newValue, oldValue, row, rowIndex, columnIndex, this);
            if (column.update === DTableColumnUpdate.ROW) {
                var value = this._value;
                var supplimental = this._supplimental;
                var index = this._index;
                if (value !== undefined && supplimental !== undefined) {
                    this.set(value, supplimental, index, true);
                }
            }
            this._onChange(newValue, oldValue, row, rowIndex, columnIndex, column, this);
        };
        DTableBodyRow.prototype.newCell = function (columnIndex, column, columns, options) {
            var onChange = this._onCellChangeBound;
            var columnIndexToCellOptions = this._columnIndexToCellOptions;
            var cellOptions = columnIndexToCellOptions.get(columnIndex);
            if (cellOptions == null) {
                cellOptions = this.toCellOptions(columnIndex, column, options);
                columnIndexToCellOptions.set(columnIndex, cellOptions);
            }
            if (column.editing.enable !== false) {
                return this.newCellEditable(columnIndex, column, onChange, cellOptions);
            }
            else {
                var cell = this.newCellUnediable(columnIndex, column, onChange, cellOptions);
                if (column.type !== DTableColumnType.TREE) {
                    cell.state.isReadOnly = true;
                }
                return cell;
            }
        };
        DTableBodyRow.prototype.newCellEditable = function (columnIndex, column, onChange, options) {
            switch (column.type) {
                case DTableColumnType.INDEX:
                    return new DTableBodyCellIndex(columnIndex, column, onChange, options);
                case DTableColumnType.TEXT:
                    return new DTableBodyCellInputText(columnIndex, column, onChange, options);
                case DTableColumnType.TEXT_AREA:
                    return new DTableBodyCellInputTextArea(columnIndex, column, onChange, options);
                case DTableColumnType.TREE:
                    return new DTableBodyCellInputTree(columnIndex, column, onChange, options);
                case DTableColumnType.INTEGER:
                    return new DTableBodyCellInputInteger(columnIndex, column, onChange, options);
                case DTableColumnType.REAL:
                    return new DTableBodyCellInputReal(columnIndex, column, onChange, options);
                case DTableColumnType.CHECK:
                case DTableColumnType.CHECK_SINGLE:
                    return new DTableBodyCellCheck(columnIndex, column, onChange, options);
                case DTableColumnType.COLOR:
                    return new DTableBodyCellColor(columnIndex, column, onChange, options);
                case DTableColumnType.BUTTON:
                    return new DTableBodyCellButton(columnIndex, column, onChange, options);
                case DTableColumnType.LINK:
                    return new DTableBodyCellLink(columnIndex, column, onChange, options);
                case DTableColumnType.SELECT:
                    return this.newCellSelect(columnIndex, column, onChange, options);
                case DTableColumnType.ACTION:
                    return this.newCellAction(columnIndex, column, onChange, options);
                case DTableColumnType.DATE:
                    return new DTableBodyCellDate(columnIndex, column, onChange, options);
                case DTableColumnType.DATETIME:
                    return new DTableBodyCellDatetime(columnIndex, column, onChange, options);
                case DTableColumnType.TIME:
                    return new DTableBodyCellTime(columnIndex, column, onChange, options);
                default:
                    return new DTableBodyCellText(columnIndex, column, onChange, options);
            }
        };
        DTableBodyRow.prototype.newCellUnediable = function (columnIndex, column, onChange, options) {
            switch (column.type) {
                case DTableColumnType.INDEX:
                    return new DTableBodyCellIndex(columnIndex, column, onChange, options);
                case DTableColumnType.TEXT:
                    return new DTableBodyCellText(columnIndex, column, onChange, options);
                case DTableColumnType.TEXT_AREA:
                    return new DTableBodyCellTextArea(columnIndex, column, onChange, options);
                case DTableColumnType.TREE:
                    return new DTableBodyCellTree(columnIndex, column, onChange, options);
                case DTableColumnType.INTEGER:
                    return new DTableBodyCellText(columnIndex, column, onChange, options);
                case DTableColumnType.REAL:
                    return new DTableBodyCellText(columnIndex, column, onChange, options);
                case DTableColumnType.CHECK:
                case DTableColumnType.CHECK_SINGLE:
                    return new DTableBodyCellCheck(columnIndex, column, onChange, options);
                case DTableColumnType.COLOR:
                    return new DTableBodyCellColor(columnIndex, column, onChange, options);
                case DTableColumnType.BUTTON:
                    return new DTableBodyCellButton(columnIndex, column, onChange, options);
                case DTableColumnType.LINK:
                    return new DTableBodyCellLink(columnIndex, column, onChange, options);
                case DTableColumnType.SELECT:
                    return this.newCellSelect(columnIndex, column, onChange, options);
                case DTableColumnType.ACTION:
                    return this.newCellAction(columnIndex, column, onChange, options);
                case DTableColumnType.DATE:
                    return new DTableBodyCellDate(columnIndex, column, onChange, options);
                case DTableColumnType.DATETIME:
                    return new DTableBodyCellDatetime(columnIndex, column, onChange, options);
                case DTableColumnType.TIME:
                    return new DTableBodyCellTime(columnIndex, column, onChange, options);
                default:
                    return new DTableBodyCellText(columnIndex, column, onChange, options);
            }
        };
        DTableBodyRow.prototype.newCellSelect = function (columnIndex, column, onChange, options) {
            var selecting = column.selecting;
            if (selecting.menu != null) {
                return new DTableBodyCellSelectMenu(columnIndex, column, onChange, options);
            }
            else if (selecting.multiple != null) {
                return new DTableBodyCellSelectMultiple(columnIndex, column, onChange, options);
            }
            else if (selecting.dialog != null) {
                return new DTableBodyCellSelectDialog(columnIndex, column, onChange, options);
            }
            else if (selecting.promise != null) {
                return new DTableBodyCellSelectPromise(columnIndex, column, onChange, options);
            }
            else {
                return new DTableBodyCellText(columnIndex, column, onChange, options);
            }
        };
        DTableBodyRow.prototype.newCellAction = function (columnIndex, column, onChange, options) {
            var selecting = column.selecting;
            if (selecting.menu != null) {
                return new DTableBodyCellActionMenu(columnIndex, column, onChange, options);
            }
            else if (selecting.dialog != null) {
                return new DTableBodyCellActionDialog(columnIndex, column, onChange, options);
            }
            else if (selecting.promise != null) {
                return new DTableBodyCellActionPromise(columnIndex, column, onChange, options);
            }
            else {
                return new DTableBodyCellText(columnIndex, column, onChange, options);
            }
        };
        DTableBodyRow.prototype.toCellOptions = function (columnIndex, column, options) {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
            var _p;
            var result = toMerged(column.body, options === null || options === void 0 ? void 0 : options.cell);
            // Weight
            result.weight = column.weight;
            // Width
            result.width = column.width;
            // State
            (_a = result.state) !== null && _a !== void 0 ? _a : (result.state = column.state.initial);
            // Text formatter
            var columnFormatter = column.formatter;
            if (columnFormatter != null) {
                var text = ((_b = result.text) !== null && _b !== void 0 ? _b : (result.text = {}));
                (_c = text.formatter) !== null && _c !== void 0 ? _c : (text.formatter = columnFormatter);
            }
            // Text align horizontal
            var columnAlign = column.align;
            if (columnAlign != null) {
                var text = ((_d = result.text) !== null && _d !== void 0 ? _d : (result.text = {}));
                var textAlign = ((_e = text.align) !== null && _e !== void 0 ? _e : (text.align = {}));
                (_f = textAlign.horizontal) !== null && _f !== void 0 ? _f : (textAlign.horizontal = columnAlign);
            }
            // Editing
            var columnEditing = column.editing;
            if (columnEditing.enable !== false) {
                var editing = ((_g = (_p = result).editing) !== null && _g !== void 0 ? _g : (_p.editing = {}));
                (_h = editing.formatter) !== null && _h !== void 0 ? _h : (editing.formatter = columnEditing.formatter);
                (_j = editing.unformatter) !== null && _j !== void 0 ? _j : (editing.unformatter = columnEditing.unformatter);
                (_k = editing.validator) !== null && _k !== void 0 ? _k : (editing.validator = columnEditing.validator);
            }
            // Link
            var columnLink = column.link;
            if (columnLink !== undefined) {
                result.link = columnLink;
            }
            // Selecting
            var columnSelecting = column.selecting;
            var columnSelectingMenu = (_l = columnSelecting.menu) !== null && _l !== void 0 ? _l : columnSelecting.multiple;
            if (columnSelectingMenu !== undefined) {
                result.menu = columnSelectingMenu;
            }
            var selectionType = (_o = (_m = options === null || options === void 0 ? void 0 : options.selection) === null || _m === void 0 ? void 0 : _m.type) !== null && _o !== void 0 ? _o : DTableDataSelectionType.NONE;
            if (selectionType !== DTableDataSelectionType.NONE) {
                result.when = "DOUBLE_CLICKED";
                result.cursor = function (state) {
                    if (state.in(DTableState.SELECTABLE)) {
                        return "pointer";
                    }
                    return undefined;
                };
            }
            return result;
        };
        DTableBodyRow.prototype.getType = function () {
            return "DTableBodyRow";
        };
        Object.defineProperty(DTableBodyRow.prototype, "value", {
            /**
             * Returns a row data if exists.
             * Returns undefined if a row data does not exit.
             *
             * @returns a row data or undefined.
             */
            get: function () {
                return this._value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyRow.prototype, "index", {
            /**
             * Returns a row index if a row data exists.
             * Returns -1 if a row data does not exit.
             *
             * @returns a row index or -1.
             */
            get: function () {
                return this._index;
            },
            enumerable: false,
            configurable: true
        });
        DTableBodyRow.prototype.isCell = function (target) {
            return target != null && "set" in target;
        };
        DTableBodyRow.prototype.set = function (value, supplimental, rowIndex, forcibly) {
            if (forcibly ||
                this._value !== value ||
                this._supplimental !== supplimental ||
                this._index !== rowIndex) {
                this._value = value;
                this._supplimental = supplimental;
                this._index = rowIndex;
                var cells = this.children;
                var cellsLength = cells.length;
                var columns = this._columns;
                var columnsLength = columns.length;
                for (var i = 0; i < cellsLength; ++i) {
                    var cell = cells[i];
                    var columnIndex = columnsLength - 1 - i;
                    var column = columns[columnIndex];
                    if (this.isCell(cell)) {
                        cell.set(column.getter(value, columnIndex), value, supplimental, rowIndex, columnIndex, forcibly);
                    }
                }
                this.onSet(value, rowIndex);
            }
        };
        DTableBodyRow.prototype.onSet = function (value, rowIndex) {
            this.emit("set", value, rowIndex, this);
        };
        DTableBodyRow.prototype.unset = function () {
            if (this._value !== undefined) {
                this._value = undefined;
                this._index = -1;
                var cells = this.children;
                var cellsLength = cells.length;
                for (var i = 0; i < cellsLength; ++i) {
                    var cell = cells[i];
                    if (this.isCell(cell)) {
                        cell.unset();
                    }
                }
                this.onUnset();
            }
        };
        DTableBodyRow.prototype.onUnset = function () {
            this.emit("unset", this);
        };
        DTableBodyRow.prototype.getContentPositionX = function () {
            var parent = this.parent;
            if (parent) {
                var content = parent.parent;
                if (content) {
                    return content.position.x;
                }
            }
            return 0;
        };
        return DTableBodyRow;
    }(DTableRow));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableDataListFilter = /** @class */ (function (_super) {
        __extends(DTableDataListFilter, _super);
        function DTableDataListFilter(parent) {
            var _this = _super.call(this) || this;
            _this._id = 0;
            _this._idUpdated = -1;
            _this._isApplied = false;
            _this._sorterId = -1;
            _this._parent = parent;
            _this._filter = null;
            _this._filtered = null;
            return _this;
        }
        Object.defineProperty(DTableDataListFilter.prototype, "id", {
            get: function () {
                return this._id;
            },
            enumerable: false,
            configurable: true
        });
        DTableDataListFilter.prototype.apply = function () {
            this._isApplied = true;
            this._id += 1;
            this._parent.update();
        };
        DTableDataListFilter.prototype.unapply = function () {
            if (this._isApplied) {
                this._isApplied = false;
                this._id += 1;
                this._parent.update();
            }
        };
        DTableDataListFilter.prototype.isApplied = function () {
            return this._isApplied;
        };
        DTableDataListFilter.prototype.newFiltered = function () {
            var filter = this._filter;
            if (filter != null) {
                var filtered = [];
                var parent_1 = this._parent;
                var sorter = parent_1.sorter;
                var rows = parent_1.rows;
                if (isFunction(filter)) {
                    var indicesSorted = sorter.indices;
                    if (indicesSorted) {
                        for (var i = 0, imax = indicesSorted.length; i < imax; ++i) {
                            var indexSorted = indicesSorted[i];
                            if (filter(rows[indexSorted], indexSorted)) {
                                filtered.push(i);
                            }
                        }
                    }
                    else {
                        for (var i = 0, imax = rows.length; i < imax; ++i) {
                            if (filter(rows[i], i)) {
                                filtered.push(i);
                            }
                        }
                    }
                }
                else {
                    var indicesSorted = sorter.indices;
                    if (indicesSorted) {
                        for (var i = 0, imax = indicesSorted.length; i < imax; ++i) {
                            var indexSorted = indicesSorted[i];
                            if (filter.test(rows[indexSorted], indexSorted)) {
                                filtered.push(i);
                            }
                        }
                    }
                    else {
                        for (var i = 0, imax = rows.length; i < imax; ++i) {
                            if (filter.test(rows[i], i)) {
                                filtered.push(i);
                            }
                        }
                    }
                }
                return filtered;
            }
            else {
                return null;
            }
        };
        DTableDataListFilter.prototype.get = function () {
            return this._filter;
        };
        DTableDataListFilter.prototype.set = function (filter) {
            if (this._filter !== filter) {
                this._filter = filter;
            }
        };
        DTableDataListFilter.prototype.toDirty = function () {
            this._id += 1;
        };
        DTableDataListFilter.prototype.update = function () {
            if (this._id !== this._idUpdated || this._parent.sorter.id !== this._sorterId) {
                this._idUpdated = this._id;
                this._sorterId = this._parent.sorter.id;
                if (this._isApplied) {
                    this._filtered = this.newFiltered();
                    this.emit("change", this);
                }
                else if (this._filtered != null) {
                    this._filtered = null;
                    this.emit("change", this);
                }
            }
        };
        Object.defineProperty(DTableDataListFilter.prototype, "indices", {
            get: function () {
                this.update();
                return this._filtered;
            },
            enumerable: false,
            configurable: true
        });
        DTableDataListFilter.prototype.map = function (sortedIndex) {
            var result = sortedIndex;
            var indicesFiltered = this.indices;
            if (indicesFiltered) {
                var index = indicesFiltered.indexOf(result);
                if (0 <= index) {
                    result = index;
                }
                else {
                    return null;
                }
            }
            return result;
        };
        DTableDataListFilter.prototype.unmap = function (index) {
            var result = index;
            var indicesFiltered = this.indices;
            if (indicesFiltered) {
                result = indicesFiltered[result];
            }
            return result;
        };
        return DTableDataListFilter;
    }(pixi_js.utils.EventEmitter));

    var DTableDataListMapped = /** @class */ (function () {
        function DTableDataListMapped(parent) {
            this._parent = parent;
        }
        Object.defineProperty(DTableDataListMapped.prototype, "rows", {
            get: function () {
                var result = [];
                this.each(function (row) {
                    result.push(row);
                });
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DTableDataListMapped.prototype.map = function (unmappedIndex) {
            var parent = this._parent;
            var sortedIndex = parent.sorter.map(unmappedIndex);
            if (sortedIndex != null) {
                return parent.filter.map(sortedIndex);
            }
            return null;
        };
        DTableDataListMapped.prototype.unmap = function (index) {
            var parent = this._parent;
            return parent.sorter.unmap(parent.filter.unmap(index));
        };
        DTableDataListMapped.prototype.size = function () {
            var parent = this._parent;
            var indicesFiltered = parent.filter.indices;
            return indicesFiltered != null ? indicesFiltered.length : parent.size();
        };
        DTableDataListMapped.prototype.get = function (index) {
            var parent = this._parent;
            return parent.get(this.unmap(index));
        };
        DTableDataListMapped.prototype.each = function (iteratee, ifrom, ito) {
            var parent = this._parent;
            var rows = parent.rows;
            var supplimentals = parent.supplimentals;
            var indicesFiltered = parent.filter.indices;
            var indicesSorted = parent.sorter.indices;
            ifrom = ifrom != null ? Math.max(0, ifrom) : 0;
            if (indicesFiltered) {
                var size = indicesFiltered.length;
                ito = ito != null ? Math.min(size, ito) : size;
                if (indicesSorted) {
                    for (var i = ifrom; i < ito; ++i) {
                        var unmappedIndex = indicesSorted[indicesFiltered[i]];
                        var row = rows[unmappedIndex];
                        var supplimental = supplimentals ? supplimentals[unmappedIndex] : null;
                        if (iteratee(row, supplimental, i, unmappedIndex) === false) {
                            break;
                        }
                    }
                }
                else {
                    for (var i = ifrom; i < ito; ++i) {
                        var unmappedIndex = indicesFiltered[i];
                        var row = rows[unmappedIndex];
                        var supplimental = supplimentals ? supplimentals[unmappedIndex] : null;
                        if (iteratee(row, supplimental, i, unmappedIndex) === false) {
                            break;
                        }
                    }
                }
            }
            else {
                var size = rows.length;
                ito = ito != null ? Math.min(size, ito) : size;
                if (indicesSorted) {
                    for (var i = ifrom; i < ito; ++i) {
                        var unmappedIndex = indicesSorted[i];
                        var row = rows[unmappedIndex];
                        var supplimental = supplimentals ? supplimentals[unmappedIndex] : null;
                        if (iteratee(row, supplimental, i, unmappedIndex) === false) {
                            break;
                        }
                    }
                }
                else {
                    for (var i = ifrom; i < ito; ++i) {
                        var row = rows[i];
                        var supplimental = supplimentals ? supplimentals[i] : null;
                        if (iteratee(row, supplimental, i, i) === false) {
                            break;
                        }
                    }
                }
            }
        };
        return DTableDataListMapped;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var COMPARATOR$1 = function (a, b) {
        return a[0] - b[0];
    };
    var DTableDataListSelection = /** @class */ (function (_super) {
        __extends(DTableDataListSelection, _super);
        function DTableDataListSelection(parent, options) {
            var _a;
            var _this = _super.call(this) || this;
            _this._parent = parent;
            _this._type = toEnum((_a = options === null || options === void 0 ? void 0 : options.type) !== null && _a !== void 0 ? _a : DTableDataSelectionType.NONE, DTableDataSelectionType);
            _this._indices = new Set();
            // Events
            var on = options === null || options === void 0 ? void 0 : options.on;
            if (on) {
                for (var name_1 in on) {
                    var handler = on[name_1];
                    if (handler) {
                        _this.on(name_1, handler);
                    }
                }
            }
            return _this;
        }
        Object.defineProperty(DTableDataListSelection.prototype, "parent", {
            get: function () {
                return this._parent;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableDataListSelection.prototype, "type", {
            get: function () {
                return this._type;
            },
            enumerable: false,
            configurable: true
        });
        DTableDataListSelection.prototype.onChange = function () {
            this._parent.update();
            this.emit("change", this);
        };
        DTableDataListSelection.prototype.toggle = function (rowIndex) {
            var indices = this._indices;
            if (indices.has(rowIndex)) {
                indices.delete(rowIndex);
            }
            else {
                indices.add(rowIndex);
            }
            this.onChange();
        };
        DTableDataListSelection.prototype.add = function (rowIndex) {
            var indices = this._indices;
            var oldSize = indices.size;
            indices.add(rowIndex);
            var newSize = indices.size;
            if (oldSize !== newSize) {
                this.onChange();
            }
        };
        Object.defineProperty(DTableDataListSelection.prototype, "first", {
            get: function () {
                var indices = this._indices;
                if (0 < indices.size) {
                    var result_1 = -1;
                    indices.forEach(function (index) {
                        if (result_1 < 0) {
                            result_1 = index;
                        }
                    });
                    return result_1;
                }
                return null;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableDataListSelection.prototype, "last", {
            get: function () {
                var indices = this._indices;
                if (0 < indices.size) {
                    var result_2 = 0;
                    indices.forEach(function (index) {
                        result_2 = index;
                    });
                    return result_2;
                }
                return null;
            },
            enumerable: false,
            configurable: true
        });
        DTableDataListSelection.prototype.addTo = function (rowIndex) {
            var lastRowIndex = this.last;
            if (lastRowIndex != null) {
                this.addRange(lastRowIndex, false, rowIndex, true);
            }
        };
        DTableDataListSelection.prototype.addRange = function (from, includeFrom, to, includeTo) {
            var indices = this._indices;
            var oldSize = indices.size;
            if (from < to) {
                var ifrom = from + (includeFrom ? 0 : 1);
                var ito = to + (includeTo ? 1 : 0);
                for (var i = ifrom; i < ito; ++i) {
                    indices.add(i);
                }
            }
            else {
                var ifrom = to + (includeTo ? 0 : 1);
                var ito = from + (includeFrom ? 1 : 0);
                for (var i = ifrom; i < ito; ++i) {
                    indices.add(i);
                }
            }
            var newSize = indices.size;
            if (oldSize !== newSize) {
                this.onChange();
            }
        };
        DTableDataListSelection.prototype.addAll = function (rowIndices) {
            var indices = this._indices;
            var oldSize = indices.size;
            for (var i = 0, imax = rowIndices.length; i < imax; ++i) {
                indices.add(rowIndices[i]);
            }
            var newSize = indices.size;
            if (oldSize !== newSize) {
                this.onChange();
            }
        };
        DTableDataListSelection.prototype.contains = function (rowIndex) {
            return this._indices.has(rowIndex);
        };
        DTableDataListSelection.prototype.remove = function (rowIndex) {
            if (this._indices.delete(rowIndex)) {
                this.onChange();
            }
        };
        DTableDataListSelection.prototype.clear = function () {
            var indices = this._indices;
            if (0 < indices.size) {
                indices.clear();
                this.onChange();
            }
        };
        DTableDataListSelection.prototype.clearAndAdd = function (rowIndex) {
            var indices = this._indices;
            if (!indices.has(rowIndex) || indices.size !== 1) {
                indices.clear();
                indices.add(rowIndex);
                this.onChange();
            }
        };
        DTableDataListSelection.prototype.clearAndAddAll = function (rowIndices) {
            var indices = this._indices;
            if (0 < indices.size || 0 < rowIndices.length) {
                indices.clear();
                for (var i = 0, imax = rowIndices.length; i < imax; ++i) {
                    indices.add(rowIndices[i]);
                }
                this.onChange();
            }
        };
        DTableDataListSelection.prototype.shift = function (rowIndex, amount) {
            var shifted = [];
            var indices = this._indices;
            indices.forEach(function (index) {
                if (rowIndex <= index) {
                    shifted.push(index);
                }
            });
            var shiftedLength = shifted.length;
            if (0 < shiftedLength) {
                for (var i = 0, imax = shifted.length; i < imax; ++i) {
                    indices.delete(shifted[i]);
                }
                for (var i = 0, imax = shifted.length; i < imax; ++i) {
                    indices.add(shifted[i] + amount);
                }
                this.onChange();
            }
        };
        DTableDataListSelection.prototype.size = function () {
            return this._indices.size;
        };
        DTableDataListSelection.prototype.isEmpty = function () {
            return this._indices.size === 0;
        };
        DTableDataListSelection.prototype.each = function (iteratee) {
            var isCanceled = false;
            this._indices.forEach(function (index) {
                if (!isCanceled) {
                    if (iteratee(index) === false) {
                        isCanceled = true;
                    }
                }
            });
        };
        Object.defineProperty(DTableDataListSelection.prototype, "indices", {
            /**
             * Returns a copy of an index array of selected rows.
             * The order of indices is an insertion order.
             */
            get: function () {
                var result = [];
                this._indices.forEach(function (index) {
                    result.push(index);
                });
                return result;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableDataListSelection.prototype, "rows", {
            /**
             * Returns a copy of an array of selected row value.
             * The order is an insertion order.
             */
            get: function () {
                var result = [];
                var parent = this._parent;
                this._indices.forEach(function (index) {
                    result.push(parent.get(index));
                });
                return result;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Returns an array of the (index, row value) pairs of selected rows.
         * The order of pairs is an insertion order.
         */
        DTableDataListSelection.prototype.toArray = function () {
            var result = [];
            var parent = this._parent;
            this._indices.forEach(function (index) {
                result.push([index, parent.get(index)]);
            });
            return result;
        };
        /**
         * Returns an sorted array of the (index, row value) pairs of selected rows.
         */
        DTableDataListSelection.prototype.toSortedArray = function () {
            return this.toArray().sort(COMPARATOR$1);
        };
        DTableDataListSelection.prototype.toObject = function () {
            var result = {};
            var parent = this._parent;
            this._indices.forEach(function (index) {
                result[index] = parent.get(index);
            });
            return result;
        };
        DTableDataListSelection.prototype.toMap = function () {
            var result = new Map();
            var parent = this._parent;
            this._indices.forEach(function (index) {
                result.set(index, parent.get(index));
            });
            return result;
        };
        return DTableDataListSelection;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A sort order.
     */
    var DTableDataOrder = {
        ASCENDING: 0,
        DESCENDING: 1
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableDataListSorter = /** @class */ (function (_super) {
        __extends(DTableDataListSorter, _super);
        function DTableDataListSorter(parent) {
            var _this = _super.call(this) || this;
            _this._id = 0;
            _this._idUpdated = -1;
            _this._isApplied = false;
            _this._parent = parent;
            _this._comparator = null;
            _this._sorted = null;
            _this._order = DTableDataOrder.ASCENDING;
            return _this;
        }
        Object.defineProperty(DTableDataListSorter.prototype, "id", {
            get: function () {
                return this._id;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableDataListSorter.prototype, "order", {
            get: function () {
                return this._order;
            },
            set: function (order) {
                this._order = order;
            },
            enumerable: false,
            configurable: true
        });
        DTableDataListSorter.prototype.apply = function () {
            this._isApplied = true;
            this._id += 1;
            this._parent.update();
        };
        DTableDataListSorter.prototype.unapply = function () {
            if (this._isApplied) {
                this._isApplied = false;
                this._id += 1;
                this._parent.update();
            }
        };
        DTableDataListSorter.prototype.isApplied = function () {
            return this._isApplied;
        };
        DTableDataListSorter.prototype.newSorted = function () {
            var comparator = this._comparator;
            if (comparator != null) {
                var parent_1 = this._parent;
                var sorted = [];
                var rows = parent_1.rows;
                for (var i = 0, imax = rows.length; i < imax; ++i) {
                    sorted.push(i);
                }
                sorted.sort(this.toComparator(rows, comparator));
                return sorted;
            }
            else {
                return null;
            }
        };
        DTableDataListSorter.prototype.toComparator = function (rows, comparator) {
            var order = this._order;
            if (isFunction(comparator)) {
                if (order === DTableDataOrder.ASCENDING) {
                    return function (indexA, indexB) {
                        return comparator(rows[indexA], rows[indexB], indexA, indexB);
                    };
                }
                else {
                    return function (indexA, indexB) {
                        return comparator(rows[indexB], rows[indexA], indexB, indexA);
                    };
                }
            }
            else {
                if (order === DTableDataOrder.ASCENDING) {
                    return function (indexA, indexB) {
                        return comparator.compare(rows[indexA], rows[indexB], indexA, indexB);
                    };
                }
                else {
                    return function (indexA, indexB) {
                        return comparator.compare(rows[indexB], rows[indexA], indexB, indexA);
                    };
                }
            }
        };
        DTableDataListSorter.prototype.get = function () {
            return this._comparator;
        };
        DTableDataListSorter.prototype.set = function (comparator) {
            if (this._comparator !== comparator) {
                this._comparator = comparator;
            }
        };
        DTableDataListSorter.prototype.toDirty = function () {
            this._id += 1;
        };
        DTableDataListSorter.prototype.update = function () {
            if (this._id !== this._idUpdated) {
                this._idUpdated = this._id;
                if (this._isApplied) {
                    this._sorted = this.newSorted();
                    this.emit("change", this);
                }
                else if (this._sorted != null) {
                    this._sorted = null;
                    this.emit("change", this);
                }
            }
        };
        Object.defineProperty(DTableDataListSorter.prototype, "indices", {
            get: function () {
                this.update();
                return this._sorted;
            },
            enumerable: false,
            configurable: true
        });
        DTableDataListSorter.prototype.map = function (unmappedIndex) {
            var result = unmappedIndex;
            var indicesSorted = this.indices;
            if (indicesSorted) {
                var index = indicesSorted.indexOf(result);
                if (0 <= index) {
                    result = index;
                }
                else {
                    return null;
                }
            }
            return result;
        };
        DTableDataListSorter.prototype.unmap = function (index) {
            var result = index;
            var indicesSorted = this.indices;
            if (indicesSorted) {
                result = indicesSorted[result];
            }
            return result;
        };
        return DTableDataListSorter;
    }(pixi_js.utils.EventEmitter));

    var DTableDataList = /** @class */ (function (_super) {
        __extends(DTableDataList, _super);
        function DTableDataList(options) {
            var _this = _super.call(this) || this;
            _this._parent = null;
            _this._rows = _this.toRows(options === null || options === void 0 ? void 0 : options.rows);
            _this._mapped = new DTableDataListMapped(_this);
            _this._selection = _this.toSelection(options === null || options === void 0 ? void 0 : options.selection);
            _this._filter = new DTableDataListFilter(_this);
            _this._sorter = new DTableDataListSorter(_this);
            if (options) {
                // Filter
                var filter = options.filter;
                if (filter) {
                    _this._filter.set(filter);
                }
                // Comparator
                var comparator = options.comparator;
                if (comparator) {
                    _this._sorter.set(comparator);
                }
                // Events
                var on = options.on;
                if (on) {
                    for (var name_1 in on) {
                        var handler = on[name_1];
                        if (handler) {
                            _this.on(name_1, handler);
                        }
                    }
                }
            }
            return _this;
        }
        DTableDataList.prototype.toSelection = function (options) {
            if (options instanceof pixi_js.utils.EventEmitter) {
                return options;
            }
            else if (isFunction(options)) {
                return options(this);
            }
            return this.newSelection(options);
        };
        DTableDataList.prototype.newSelection = function (options) {
            return new DTableDataListSelection(this, options);
        };
        DTableDataList.prototype.bind = function (parent) {
            this._parent = parent;
        };
        DTableDataList.prototype.toRows = function (row) {
            var result = [];
            if (row != null) {
                for (var i = 0, imax = row.length; i < imax; ++i) {
                    result.push(row[i]);
                }
            }
            return result;
        };
        Object.defineProperty(DTableDataList.prototype, "rows", {
            get: function () {
                return this._rows;
            },
            enumerable: false,
            configurable: true
        });
        DTableDataList.prototype.update = function (forcibly) {
            var parent = this._parent;
            if (parent) {
                parent.update(forcibly);
            }
        };
        DTableDataList.prototype.lock = function () {
            var parent = this._parent;
            if (parent) {
                parent.lock();
            }
        };
        DTableDataList.prototype.unlock = function (callIfNeeded) {
            var parent = this._parent;
            if (parent) {
                parent.unlock(callIfNeeded);
            }
        };
        DTableDataList.prototype.size = function () {
            return this._rows.length;
        };
        DTableDataList.prototype.clear = function () {
            var rows = this._rows;
            if (0 < rows.length) {
                rows.length = 0;
                this.lock();
                this._selection.clear();
                this._sorter.toDirty();
                this._filter.toDirty();
                this.update();
                this.unlock(true);
            }
        };
        DTableDataList.prototype.clearAndAdd = function (row) {
            var rows = this._rows;
            rows.length = 0;
            rows.push(row);
            this.lock();
            this._selection.clear();
            this._sorter.toDirty();
            this._filter.toDirty();
            this.update();
            this.unlock(true);
        };
        DTableDataList.prototype.clearAndAddAll = function (newRows) {
            var rows = this._rows;
            rows.length = 0;
            for (var i = 0, imax = newRows.length; i < imax; ++i) {
                rows.push(newRows[i]);
            }
            this.lock();
            this._selection.clear();
            this._sorter.toDirty();
            this._filter.toDirty();
            this.update();
            this.unlock(true);
        };
        DTableDataList.prototype.add = function (row, index) {
            var rows = this._rows;
            var selection = this._selection;
            var sorter = this._sorter;
            var filter = this._filter;
            if (index == null) {
                rows.push(row);
                this.lock();
                sorter.toDirty();
                filter.toDirty();
                this.update();
                this.unlock(true);
            }
            else if (0 <= index && index < rows.length) {
                rows.splice(index, 0, row);
                this.lock();
                selection.shift(index, 1);
                sorter.toDirty();
                filter.toDirty();
                this.update();
                this.unlock(true);
            }
        };
        DTableDataList.prototype.addAll = function (newRows, index) {
            var rows = this._rows;
            var rowsLength = rows.length;
            var selection = this._selection;
            var sorter = this._sorter;
            var filter = this._filter;
            if (index == null) {
                var newRowsLength = newRows.length;
                for (var i = 0, imax = newRowsLength; i < imax; ++i) {
                    rows.push(newRows[i]);
                }
                this.lock();
                sorter.toDirty();
                filter.toDirty();
                this.update();
                this.unlock(true);
            }
            else if (0 <= index && index < rowsLength) {
                var newRowsLength = newRows.length;
                for (var i = 0; i < newRowsLength; ++i) {
                    rows.splice(index + i, 0, newRows[i]);
                }
                this.lock();
                selection.shift(index, newRowsLength);
                sorter.toDirty();
                filter.toDirty();
                this.update();
                this.unlock(true);
            }
        };
        DTableDataList.prototype.get = function (index) {
            var rows = this._rows;
            if (0 <= index && index < rows.length) {
                return rows[index];
            }
            return null;
        };
        DTableDataList.prototype.set = function (index, row) {
            var rows = this._rows;
            if (0 <= index && index < rows.length) {
                var result = rows[index];
                rows[index] = row;
                this.lock();
                this._sorter.toDirty();
                this._filter.toDirty();
                this.update();
                this.unlock(true);
                return result;
            }
            return null;
        };
        DTableDataList.prototype.remove = function (index) {
            var rows = this._rows;
            if (0 <= index && index < rows.length) {
                var result = rows.splice(index, 1)[0];
                this.lock();
                this._selection.remove(index);
                this._sorter.toDirty();
                this._filter.toDirty();
                this.update();
                this.unlock(true);
                return result;
            }
            return null;
        };
        DTableDataList.prototype.each = function (iteratee, ifrom, ito) {
            var rows = this._rows;
            ifrom = ifrom != null ? Math.max(0, ifrom) : 0;
            ito = ito != null ? Math.min(rows.length, ito) : rows.length;
            for (var i = ifrom; i < ito; ++i) {
                var row = rows[i];
                if (iteratee(row, i) === false) {
                    break;
                }
            }
        };
        Object.defineProperty(DTableDataList.prototype, "selection", {
            get: function () {
                return this._selection;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableDataList.prototype, "filter", {
            get: function () {
                return this._filter;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableDataList.prototype, "sorter", {
            get: function () {
                return this._sorter;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableDataList.prototype, "mapped", {
            get: function () {
                return this._mapped;
            },
            enumerable: false,
            configurable: true
        });
        return DTableDataList;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var toRowOptions = function (theme, options, selectionType) {
        var result = options.row;
        if (result != null) {
            if (result.height == null) {
                result.height = theme.getRowHeight();
            }
            if (result.selection === undefined) {
                result.selection = {
                    type: selectionType
                };
            }
            else if (result.selection.type === undefined) {
                result.selection.type = selectionType;
            }
        }
        else {
            result = {
                height: theme.getRowHeight(),
                selection: {
                    type: selectionType
                }
            };
        }
        return result;
    };
    var DTableBody = /** @class */ (function (_super) {
        __extends(DTableBody, _super);
        function DTableBody(columns, frozen, offset, options) {
            var _this = _super.call(this, options) || this;
            _this.transform.position.y = offset;
            var data = _this.toData(options.data);
            _this._data = data;
            data.bind(_this);
            var theme = _this.theme;
            _this._columns = columns;
            _this._frozen = frozen;
            var rowOptions = toRowOptions(theme, options, data.selection.type);
            _this._rowOptions = rowOptions;
            _this._rowHeight = rowOptions.height != null ? rowOptions.height : theme.getRowHeight();
            _this._rowIndexMappedStart = 0;
            _this._rowIndexMappedEnd = 0;
            _this._updateRowsCount = 0;
            _this._isUpdateRowsCalled = false;
            _this._isUpdateRowsCalledForcibly = false;
            _this._workRows = [];
            _this._onRowChangeBound = function (newValue, oldValue, row, rowIndex, columnIndex, column) {
                _this.onRowChange(newValue, oldValue, row, rowIndex, columnIndex, column);
            };
            _this._columnIndexToCellOptions = new Map();
            _this._data.emit("init", _this._data);
            return _this;
        }
        DTableBody.prototype.onRowChange = function (newValue, oldValue, row, rowIndex, columnIndex, column) {
            var data = this._data;
            data.emit("change", newValue, oldValue, row, rowIndex, columnIndex, data);
            if (column.update === DTableColumnUpdate.ALL) {
                this.update(true);
            }
        };
        DTableBody.prototype.toData = function (options) {
            if (this.isData(options)) {
                return options;
            }
            return new DTableDataList(options);
        };
        DTableBody.prototype.isData = function (target) {
            return target != null && "mapped" in target;
        };
        DTableBody.prototype.onResize = function (newWidth, newHeight, oldWidth, oldHeight) {
            _super.prototype.onResize.call(this, newWidth, newHeight, oldWidth, oldHeight);
            this.update();
        };
        Object.defineProperty(DTableBody.prototype, "selection", {
            get: function () {
                return this._data.selection;
            },
            enumerable: false,
            configurable: true
        });
        DTableBody.prototype.lock = function () {
            this._updateRowsCount += 1;
            if (this._updateRowsCount === 1) {
                this._isUpdateRowsCalled = false;
                this._isUpdateRowsCalledForcibly = false;
            }
        };
        DTableBody.prototype.unlock = function (callIfNeeded) {
            this._updateRowsCount -= 1;
            if (this._updateRowsCount === 0) {
                if (callIfNeeded && this._isUpdateRowsCalled) {
                    this.update(this._isUpdateRowsCalledForcibly);
                }
                this._isUpdateRowsCalled = false;
                this._isUpdateRowsCalledForcibly = false;
            }
        };
        /**
         * Updates rows. If the `forcibly` is true, some dirty checkings for
         * avoiding unnecessary state changes are skipped.
         *
         * @param forcibly true to update forcibly
         */
        DTableBody.prototype.update = function (forcibly) {
            if (0 < this._updateRowsCount) {
                this._isUpdateRowsCalled = true;
                if (forcibly) {
                    this._isUpdateRowsCalledForcibly = true;
                }
                return;
            }
            var content = this.parent;
            if (content == null) {
                return;
            }
            var contentParent = content.parent;
            if (contentParent == null) {
                return;
            }
            var rows = this.children;
            var height = contentParent.height;
            var rowHeight = this._rowHeight;
            var data = this._data;
            var dataMappedSize = data.mapped.size();
            var oldRowIndexMappedStart = this._rowIndexMappedStart;
            var oldRowIndexMappedEnd = this._rowIndexMappedEnd;
            var oldRowCount = oldRowIndexMappedEnd - oldRowIndexMappedStart;
            var y = this.transform.position.y;
            var newHeight = y + dataMappedSize * rowHeight;
            var newContentHeight = Math.max(height, newHeight);
            var newContentY = Math.max(height - newContentHeight, content.position.y);
            var newRowIndexMappedLowerBound = -newContentY / rowHeight;
            var newRowIndexMappedUpperBound = (height - (newContentY + y)) / rowHeight;
            var newRowIndexMappedStart = Math.floor(newRowIndexMappedLowerBound);
            newRowIndexMappedStart -= newRowIndexMappedStart % 2 === 0 ? 2 : 1;
            var newRowIndexMappedEnd = Math.floor(newRowIndexMappedUpperBound);
            newRowIndexMappedEnd += (newRowIndexMappedEnd - newRowIndexMappedStart) % 2 === 1 ? 3 : 2;
            var newRowCount = newRowIndexMappedEnd - newRowIndexMappedStart;
            if (newRowCount < oldRowCount) {
                newRowCount = oldRowCount;
                newRowIndexMappedEnd = newRowIndexMappedStart + newRowCount;
            }
            if (oldRowCount < newRowCount) {
                for (var i = oldRowCount; i < newRowCount; ++i) {
                    var oldRowIndexMapped = oldRowIndexMappedStart + i;
                    var newRow = this.newRow(oldRowIndexMapped % 2 === 0);
                    this.addChild(newRow);
                }
                oldRowCount = newRowCount;
                oldRowIndexMappedEnd = oldRowIndexMappedStart + oldRowCount;
            }
            else if (newRowCount < oldRowCount) {
                for (var i = oldRowCount - 1; newRowCount <= i; --i) {
                    this.removeChild(rows[i]);
                }
                oldRowCount = newRowCount;
                oldRowIndexMappedEnd = oldRowIndexMappedStart + oldRowCount;
            }
            this._rowIndexMappedStart = newRowIndexMappedStart;
            this._rowIndexMappedEnd = newRowIndexMappedEnd;
            var rowIndexMappedStartDelta = newRowIndexMappedStart - oldRowIndexMappedStart;
            var rowIndexMappedStartDeltaAbs = Math.abs(rowIndexMappedStartDelta);
            var rowsLength = rows.length;
            if (0 < rowIndexMappedStartDeltaAbs && rowIndexMappedStartDeltaAbs < rowsLength) {
                var work = this._workRows;
                if (0 < rowIndexMappedStartDelta) {
                    for (var i = 0; i < rowIndexMappedStartDeltaAbs; ++i) {
                        work.push(this.resetRow(rows[i]));
                    }
                    for (var i = rowIndexMappedStartDeltaAbs; i < rowsLength; ++i) {
                        rows[i - rowIndexMappedStartDeltaAbs] = rows[i];
                    }
                    for (var i = 0; i < rowIndexMappedStartDeltaAbs; ++i) {
                        rows[rowsLength - rowIndexMappedStartDeltaAbs + i] = work[i];
                    }
                }
                else {
                    for (var i = 0; i < rowIndexMappedStartDeltaAbs; ++i) {
                        work.push(this.resetRow(rows[rowsLength - rowIndexMappedStartDeltaAbs + i]));
                    }
                    for (var i = rowsLength - rowIndexMappedStartDeltaAbs - 1; 0 <= i; --i) {
                        rows[i + rowIndexMappedStartDeltaAbs] = rows[i];
                    }
                    for (var i = 0; i < rowIndexMappedStartDeltaAbs; ++i) {
                        rows[i] = work[i];
                    }
                }
                work.length = 0;
            }
            var selection = data.selection;
            var isRowSelectable = selection.type !== DTableDataSelectionType.NONE;
            data.mapped.each(function (datum, supplimental, index, unmappedIndex) {
                var row = rows[index - newRowIndexMappedStart];
                // Position
                row.position.y = index * rowHeight;
                // State
                var rowState = row.state;
                rowState.lock();
                rowState.add(DTableState.HAS_DATA);
                rowState.set(DTableState.SELECTABLE, isRowSelectable);
                rowState.set(DBaseState.ACTIVE, selection.contains(unmappedIndex));
                rowState.remove(DBaseState.DISABLED);
                rowState.unlock();
                // Data
                row.set(datum, supplimental, unmappedIndex, forcibly);
            }, newRowIndexMappedStart, newRowIndexMappedStart + rowsLength);
            for (var i = 0; newRowIndexMappedStart + i < 0 && i < rowsLength; ++i) {
                var row = rows[i];
                // Position
                row.position.y = (newRowIndexMappedStart + i) * rowHeight;
                // State
                var rowState = row.state;
                rowState.lock();
                rowState.add(DBaseState.DISABLED);
                rowState.removeAll(DTableState.HAS_DATA, DTableState.SELECTABLE, DBaseState.ACTIVE);
                rowState.unlock();
                // Data
                row.unset();
            }
            for (var i = rowsLength - 1; dataMappedSize <= newRowIndexMappedStart + i && 0 <= i; --i) {
                var row = rows[i];
                // Position
                row.position.y = (newRowIndexMappedStart + i) * rowHeight;
                // State
                var rowState = row.state;
                rowState.lock();
                rowState.add(DBaseState.DISABLED);
                rowState.removeAll(DTableState.HAS_DATA, DTableState.SELECTABLE, DBaseState.ACTIVE);
                rowState.unlock();
                // Data
                row.unset();
            }
            this.lock();
            content.position.y = newContentY;
            content.height = newContentHeight;
            this.height = newHeight;
            this.unlock(false);
            this.emit("update", newRowIndexMappedLowerBound, newRowIndexMappedUpperBound, this);
        };
        DTableBody.prototype.resetRow = function (row) {
            row.blur(true);
            var cells = row.children;
            for (var i = 0, imax = cells.length; i < imax; ++i) {
                var cell = cells[i];
                if (cell instanceof DBase) {
                    cell.state.isPressed = false;
                }
            }
            return row;
        };
        DTableBody.prototype.newRow = function (isEven) {
            return new DTableBodyRow(this._onRowChangeBound, isEven, this._columnIndexToCellOptions, this._columns, this._frozen, this._rowOptions);
        };
        DTableBody.prototype.onParentMove = function (newX, newY, oldX, oldY) {
            _super.prototype.onParentMove.call(this, newX, newY, oldX, oldY);
            this.updateFrozenCellPosition(newX);
        };
        DTableBody.prototype.updateFrozenCellPosition = function (x) {
            var frozen = this._frozen;
            if (frozen != null && 0 < frozen) {
                var rows = this.children;
                for (var i = 0, imax = rows.length; i < imax; ++i) {
                    rows[i].updateFrozenCellPosition(x);
                }
            }
        };
        DTableBody.prototype.getClippingRect = function (target, result) {
            _super.prototype.getClippingRect.call(this, target, result);
            var parent = this.parent;
            if (parent) {
                var dy = -parent.transform.position.y;
                result.y += dy;
                result.height -= dy;
            }
        };
        /**
         * Scroll to the given row or row index.
         *
         * @param target a row or an row index to which the body scrolls to.
         * @returns true if succeeded
         */
        DTableBody.prototype.scrollTo = function (target) {
            var parent = this.parent;
            if (parent == null) {
                return false;
            }
            var parentParent = parent.parent;
            if (parentParent == null) {
                return false;
            }
            var rowIndexMapped = -1;
            if (isNumber(target)) {
                if (0 <= target && target < this.data.mapped.size()) {
                    rowIndexMapped = target;
                }
            }
            else {
                this.data.mapped.each(function (row, _, index) {
                    if (row === target) {
                        rowIndexMapped = index;
                        return false;
                    }
                    return true;
                });
            }
            if (rowIndexMapped < 0) {
                return false;
            }
            parent.position.y = Math.max(Math.min(0, parentParent.height - parent.height), -rowIndexMapped * this._rowHeight);
            DApplications.update(this);
            return true;
        };
        /**
         * Returns a mapped row index at the given local Y position or -1.
         *
         * @param localY a local Y position
         * @returns a mapped row index at the given local Y position or -1.
         */
        DTableBody.prototype.toRowIndexMapped = function (localY) {
            if (0 <= this.parent.position.y + localY) {
                var result = Math.floor(localY / this._rowHeight);
                if (0 <= result && result < this._data.mapped.size()) {
                    return result;
                }
            }
            return -1;
        };
        /**
         * Returns a row at the given mapped row index or null if not exits.
         *
         * @param rowIndexMapped a mapped row index
         * @returns a row at the given mapped row index or null if not exists.
         */
        DTableBody.prototype.toRow = function (rowIndexMapped) {
            var index = rowIndexMapped - this._rowIndexMappedStart;
            var rows = this.children;
            if (0 <= index && index < rows.length) {
                return rows[index];
            }
            return null;
        };
        /**
         * Returns a cell at the given local X position or null if not exits.
         * This method assumes the given local X position is on the given row.
         *
         * @param row a row
         * @param localX a local X position
         * @returns a cell at the given local X position or null if not exits
         */
        DTableBody.prototype.toCell = function (row, localX) {
            var cells = row.children;
            var cellsLength = cells.length;
            var columns = this._columns;
            var columnsLength = columns.length;
            for (var i = 0, imax = Math.min(cellsLength, columnsLength); i < imax; ++i) {
                var cell = cells[cellsLength - i - 1];
                var x = localX - cell.position.x;
                if (0 <= x && x <= cell.width) {
                    return cell;
                }
            }
            return null;
        };
        DTableBody.prototype.onRowClick = function (e) {
            if (this.state.isActionable) {
                var local = DTableBody.WORK_ON_CLICK;
                local.copyFrom(e.data.global);
                this.toLocal(local, undefined, local, false);
                var rowIndexMapped = this.toRowIndexMapped(local.y);
                if (0 <= rowIndexMapped) {
                    // Delegate to the cell at first
                    var row = this.toRow(rowIndexMapped);
                    if (row) {
                        var cell = this.toCell(row, local.x);
                        if (cell && cell.onRowSelect && cell.onRowSelect(e, local)) {
                            return;
                        }
                    }
                    // Fallback to the default
                    this.onRowSelect(e, rowIndexMapped);
                }
            }
        };
        DTableBody.prototype.onRowSelect = function (e, rowIndexMapped) {
            var data = this._data;
            var selection = data.selection;
            var isSingle = selection.type === DTableDataSelectionType.SINGLE;
            var isNotSingle = !isSingle;
            var rowIndex = data.mapped.unmap(rowIndexMapped);
            var originalEvent = e.data.originalEvent;
            var ctrlKey = originalEvent.ctrlKey;
            var shiftKey = originalEvent.shiftKey;
            if (isSingle || selection.isEmpty() || !(isNotSingle && (ctrlKey || shiftKey))) {
                selection.clearAndAdd(rowIndex);
            }
            else if (ctrlKey) {
                selection.toggle(rowIndex);
            }
            else if (shiftKey) {
                var lastRowIndex = selection.last;
                if (lastRowIndex != null) {
                    var sorter = data.sorter;
                    var filter = data.filter;
                    var rowIndexSorted = sorter.map(rowIndex);
                    var lastRowIndexSorted = sorter.map(lastRowIndex);
                    if (rowIndexSorted != null && lastRowIndexSorted != null) {
                        var istart = lastRowIndexSorted + 1;
                        var iend = rowIndexSorted + 1;
                        if (rowIndexSorted < lastRowIndexSorted) {
                            istart = rowIndexSorted;
                            iend = lastRowIndexSorted;
                        }
                        if (istart < iend) {
                            var rowIndices = [];
                            var indicesFiltered = filter.indices;
                            var indicesSorted = sorter.indices;
                            if (indicesFiltered) {
                                if (indicesSorted) {
                                    for (var i = 0, imax = indicesFiltered.length; i < imax; ++i) {
                                        var indexFiltered = indicesFiltered[i];
                                        if (istart <= indexFiltered && indexFiltered < iend) {
                                            rowIndices.push(indicesSorted[indexFiltered]);
                                        }
                                    }
                                }
                                else {
                                    for (var i = 0, imax = indicesFiltered.length; i < imax; ++i) {
                                        var indexFiltered = indicesFiltered[i];
                                        if (istart <= indexFiltered && indexFiltered < iend) {
                                            rowIndices.push(indexFiltered);
                                        }
                                    }
                                }
                            }
                            else {
                                if (indicesSorted) {
                                    for (var i = istart; i < iend; ++i) {
                                        rowIndices.push(indicesSorted[i]);
                                    }
                                }
                                else {
                                    for (var i = istart; i < iend; ++i) {
                                        rowIndices.push(i);
                                    }
                                }
                            }
                            selection.addAll(rowIndices);
                        }
                    }
                }
            }
        };
        DTableBody.prototype.onDblClick = function (e, interactionManager) {
            return _super.prototype.onDblClick.call(this, e, interactionManager);
        };
        DTableBody.prototype.getType = function () {
            return "DTableBody";
        };
        Object.defineProperty(DTableBody.prototype, "data", {
            get: function () {
                return this._data;
            },
            enumerable: false,
            configurable: true
        });
        DTableBody.WORK_ON_CLICK = new pixi_js.Point();
        return DTableBody;
    }(DBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableCellEdgeHovered = {
        NONE: 0,
        LEFT: 1,
        RIGHT: 2,
        BOTH: 3
    };
    var DTableCellEdge = /** @class */ (function () {
        function DTableCellEdge(row, cell, columnIndex, size) {
            this._row = row;
            this._cell = cell;
            this._columnIndex = columnIndex;
            this._size = size;
            this._dragged = false;
            this._minWidth = 8;
        }
        DTableCellEdge.prototype.findResizableCell = function (columnIndex, direction, weight) {
            var children = this._row.children;
            var childrenLength = children.length;
            if (direction) {
                for (var i = columnIndex; i < childrenLength; ++i) {
                    var child = children[childrenLength - i - 1];
                    var childColumn = child.column;
                    if (childColumn.resizable) {
                        if (weight == null) {
                            return child;
                        }
                        else if (weight === true) {
                            if (childColumn.weight != null) {
                                return child;
                            }
                        }
                        else {
                            if (childColumn.weight == null) {
                                return child;
                            }
                        }
                    }
                }
            }
            else {
                for (var i = columnIndex; 0 <= i; --i) {
                    var child = children[childrenLength - i - 1];
                    var childColumn = child.column;
                    if (childColumn.resizable) {
                        if (weight == null) {
                            return child;
                        }
                        else if (weight === true) {
                            if (childColumn.weight != null) {
                                return child;
                            }
                        }
                        else {
                            if (childColumn.weight == null) {
                                return child;
                            }
                        }
                    }
                }
            }
            return null;
        };
        DTableCellEdge.prototype.findCells = function (columnIndex, direction, weight) {
            var result = [];
            var children = this._row.children;
            var childrenLength = children.length;
            if (direction) {
                for (var i = columnIndex; i < childrenLength; ++i) {
                    var child = children[childrenLength - i - 1];
                    if (weight) {
                        if (child.column.weight != null) {
                            result.push(child);
                        }
                    }
                    else {
                        if (child.column.weight == null) {
                            result.push(child);
                        }
                    }
                }
            }
            else {
                for (var i = columnIndex; 0 <= i; --i) {
                    var child = children[childrenLength - i - 1];
                    if (weight) {
                        if (child.column.weight != null) {
                            result.push(child);
                        }
                    }
                    else {
                        if (child.column.weight == null) {
                            result.push(child);
                        }
                    }
                }
            }
            return result;
        };
        DTableCellEdge.prototype.calcData = function (columnIndex) {
            var left = this.findResizableCell(columnIndex, false, null);
            if (left != null) {
                var leftColumn = left.column;
                var right = this.findResizableCell(columnIndex + 1, true, null);
                if (right != null) {
                    var rightColumn = right.column;
                    if (leftColumn.weight == null) {
                        if (rightColumn.weight == null) {
                            // Width - Width
                            return [1, left, right];
                        }
                        else {
                            // Width - Weight
                            var others = this.findCells(0, true, true);
                            return [2, left, right, others];
                        }
                    }
                    else {
                        if (rightColumn.weight == null) {
                            // Weight - Width
                            var others = this.findCells(0, true, true);
                            return [3, left, right, others];
                        }
                        else {
                            // Weight - Weight
                            return [1, left, right];
                        }
                    }
                }
                else {
                    if (leftColumn.weight == null) {
                        // Width
                        var ls = this.findCells(left.columnIndex - 1, false, true);
                        if (ls.length <= 0) {
                            return [0, left];
                        }
                        // Not resizable
                        return null;
                    }
                    else {
                        // Not resizable
                        return null;
                    }
                }
            }
            // Not resizable
            return null;
        };
        Object.defineProperty(DTableCellEdge.prototype, "left", {
            get: function () {
                var result = this._left;
                if (result === undefined) {
                    result = this.calcData(this._columnIndex - 1);
                    this._left = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableCellEdge.prototype, "right", {
            get: function () {
                var result = this._right;
                if (result === undefined) {
                    result = this.calcData(this._columnIndex);
                    this._right = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DTableCellEdge.prototype.onDown = function (e) {
            var cell = this._cell;
            var hoveredOnEdge = cell.state.valueOf(DTableState.HOVERED_ON_EDGE);
            if (hoveredOnEdge != null) {
                this._dragged = true;
                var layer = DApplications.getLayer(cell);
                if (layer != null) {
                    var interactionManager = layer.renderer.plugins.interaction;
                    if (hoveredOnEdge === DTableCellEdgeHovered.LEFT) {
                        var left = this.left;
                        if (left != null) {
                            this.onDown_(e.data.global.x, left, interactionManager);
                        }
                    }
                    else {
                        var right = this.right;
                        if (right != null) {
                            this.onDown_(e.data.global.x, right, interactionManager);
                        }
                    }
                }
                return true;
            }
            else {
                this._dragged = false;
                return false;
            }
        };
        DTableCellEdge.prototype.onDown_ = function (onDownPoint, data, interactionManager) {
            switch (data[0]) {
                case 0:
                    this.onDown0(onDownPoint, data, interactionManager);
                    break;
                case 1:
                    this.onDown1(onDownPoint, data, interactionManager);
                    break;
                case 2:
                    this.onDown2(onDownPoint, data, interactionManager);
                    break;
                case 3:
                    this.onDown3(onDownPoint, data, interactionManager);
                    break;
            }
        };
        DTableCellEdge.prototype.onOver = function (e) {
            var _this = this;
            var _a;
            if (this.left != null || this.right != null) {
                var onHoveredBound = ((_a = this._onHoveredBound) !== null && _a !== void 0 ? _a : (this._onHoveredBound = function (event) {
                    _this.onHovered(event);
                }));
                var cell = this._cell;
                cell.off(UtilPointerEvent.move, onHoveredBound);
                cell.on(UtilPointerEvent.move, onHoveredBound);
                // Since the cursor is set by InteractionManager before this method is called,
                // the cursor need to be overriden.
                this.onHovered(e);
                var layer = DApplications.getLayer(cell);
                if (layer != null) {
                    layer.renderer.plugins.interaction.cursor = cell.cursor;
                }
            }
        };
        DTableCellEdge.prototype.onOut = function (e) {
            var onHoveredBound = this._onHoveredBound;
            if (onHoveredBound != null) {
                var cell = this._cell;
                cell.state.remove(DTableState.HOVERED_ON_EDGE);
                cell.off(UtilPointerEvent.move, onHoveredBound);
            }
        };
        DTableCellEdge.prototype.onHovered = function (e) {
            var cell = this._cell;
            var width = cell.width;
            var x = this.toX(e);
            var size = this._size;
            var onLeft = 0 <= x && x <= size;
            var onRight = width - size <= x && x <= width;
            if (onLeft && onRight) {
                if (x <= width - x) {
                    onRight = false;
                }
                else {
                    onLeft = false;
                }
            }
            if (onLeft) {
                if (this.left != null) {
                    cell.state.add(DTableState.HOVERED_ON_EDGE, DTableCellEdgeHovered.LEFT);
                }
                else {
                    cell.state.remove(DTableState.HOVERED_ON_EDGE);
                }
            }
            else if (onRight) {
                if (this.right != null) {
                    cell.state.add(DTableState.HOVERED_ON_EDGE, DTableCellEdgeHovered.RIGHT);
                }
                else {
                    cell.state.remove(DTableState.HOVERED_ON_EDGE);
                }
            }
            else {
                cell.state.remove(DTableState.HOVERED_ON_EDGE);
            }
        };
        DTableCellEdge.prototype.toX = function (e) {
            var _a;
            var checkWork = ((_a = this._checkWork) !== null && _a !== void 0 ? _a : (this._checkWork = new pixi_js.Point()));
            return this._cell.toLocal(e.data.global, undefined, checkWork, true).x;
        };
        DTableCellEdge.prototype.onDown0 = function (onDownPoint, data, interactionManager) {
            var left = data[1];
            var leftColumn = left.column;
            var leftOldWidth = left.width;
            var leftMinWidth = Math.max(this._minWidth, leftColumn.minWidth);
            var onMove = function (e) {
                leftColumn.width = Math.max(leftMinWidth, leftOldWidth + e.data.global.x - onDownPoint);
            };
            this.newOnUp(onMove, interactionManager);
        };
        DTableCellEdge.prototype.onDown1 = function (onDownPoint, data, interactionManager) {
            var minWidth = this._minWidth;
            var left = data[1];
            var leftColumn = left.column;
            var leftOldWidth = left.width;
            var right = data[2];
            var rightColumn = right.column;
            var rightOldWidth = right.width;
            var totalWidth = leftOldWidth + rightOldWidth;
            if (leftColumn.weight == null) {
                var leftMinWidth_1 = Math.max(minWidth, leftColumn.minWidth);
                var rightMinWidth = Math.max(minWidth, rightColumn.minWidth);
                var leftMaxWidth_1 = totalWidth - rightMinWidth;
                if (totalWidth <= 0 || leftMaxWidth_1 <= leftMinWidth_1) {
                    // The left and right resizable cells doesn't have enough width
                    return;
                }
                var onMove = function (e) {
                    var leftNewWidth = Math.max(leftMinWidth_1, Math.min(leftMaxWidth_1, leftOldWidth + e.data.global.x - onDownPoint));
                    leftColumn.width = leftNewWidth;
                    rightColumn.width = totalWidth - leftNewWidth;
                };
                this.newOnUp(onMove, interactionManager);
            }
            else {
                var leftOldWeight = left.weight;
                var rightOldWeight = right.weight;
                var totalWeight_1 = leftOldWeight + rightOldWeight;
                var leftMinWeight_1 = leftColumn.minWeight;
                var rightMinWeight = rightColumn.minWeight;
                var leftMaxWeight_1 = totalWeight_1 - rightMinWeight;
                var leftMinWidth_2 = minWidth;
                var rightMinWidth = minWidth;
                var leftMaxWidth_2 = totalWidth - rightMinWidth;
                if (totalWidth <= 0 || leftMaxWidth_2 <= leftMinWidth_2 || leftMaxWeight_1 <= leftMinWeight_1) {
                    // The left and right resizable cells doesn't have enough width
                    return;
                }
                var onMove = function (e) {
                    var leftNewWidth = Math.max(leftMinWidth_2, Math.min(leftMaxWidth_2, leftOldWidth + e.data.global.x - onDownPoint));
                    var leftNewWeight = Math.max(leftMinWeight_1, Math.min(leftMaxWeight_1, totalWeight_1 * (leftNewWidth / totalWidth)));
                    leftColumn.weight = leftNewWeight;
                    rightColumn.weight = totalWeight_1 - leftNewWeight;
                };
                this.newOnUp(onMove, interactionManager);
            }
        };
        DTableCellEdge.prototype.onDown2 = function (onDownPoint, data, interactionManager) {
            if (data[3].length <= 1) {
                this.onDown2a(onDownPoint, data, interactionManager);
            }
            else {
                this.onDown2b(onDownPoint, data, interactionManager);
            }
        };
        DTableCellEdge.prototype.onDown2a = function (onDownPoint, data, interactionManager) {
            var minWidth = this._minWidth;
            var left = data[1];
            var leftColumn = left.column;
            var leftOldWidth = left.width;
            var leftMinWidth = Math.max(minWidth, leftColumn.minWidth);
            var right = data[2];
            var rightOldWidth = right.width;
            var rightMinWidth = minWidth;
            var totalWidth = leftOldWidth + rightOldWidth;
            var leftMaxWidth = totalWidth - rightMinWidth;
            if (totalWidth <= 0 || leftMaxWidth <= leftMinWidth) {
                // The left and right resizable cells doesn't have enough width
                return;
            }
            var onMove = function (e) {
                leftColumn.width = Math.max(leftMinWidth, Math.min(leftMaxWidth, leftOldWidth + e.data.global.x - onDownPoint));
            };
            this.newOnUp(onMove, interactionManager);
        };
        DTableCellEdge.prototype.onDown2b = function (onDownPoint, data, interactionManager) {
            var minWidth = this._minWidth;
            var left = data[1];
            var leftColumn = left.column;
            var leftOldWidth = left.width;
            var leftMinWidth = Math.max(minWidth, leftColumn.minWidth);
            var right = data[2];
            var rightColumn = right.column;
            var rightOldWidth = right.width;
            var rightMinWeight = rightColumn.minWeight;
            var totalWidth = leftOldWidth + rightOldWidth;
            var others = data[3];
            var totalWeight = 0;
            var totalSpace = 0;
            for (var i = 0, imax = others.length; i < imax; ++i) {
                var other = others[i];
                totalWeight += other.weight;
                totalSpace += other.width;
            }
            if (totalWeight <= 0 || totalSpace <= 0) {
                var rightMinWidth = minWidth;
                var leftMaxWidth_3 = totalWidth - rightMinWidth;
                if (totalWidth <= 0 || leftMaxWidth_3 <= leftMinWidth) {
                    // The left and right resizable cells doesn't have enough width
                    return;
                }
                if (totalWeight <= 0) {
                    totalWeight = 0;
                    for (var i = 0, imax = others.length; i < imax; ++i) {
                        var other = others[i];
                        var otherColumn = other.column;
                        if (other !== right) {
                            var otherNewWeight = otherColumn.minWeight;
                            otherColumn.weight = otherNewWeight;
                            totalWeight += otherNewWeight;
                        }
                        else {
                            var rightNewWeight = Math.max(1, rightMinWeight);
                            otherColumn.weight = rightNewWeight;
                            totalWeight += rightNewWeight;
                        }
                    }
                }
                var onMove = function (e) {
                    leftColumn.width = Math.max(leftMinWidth, Math.min(leftMaxWidth_3, leftOldWidth + e.data.global.x - onDownPoint));
                };
                this.newOnUp(onMove, interactionManager);
            }
            else {
                var rightMinWidth = Math.max(minWidth, totalSpace * (rightMinWeight / totalWeight));
                var leftMaxWidth_4 = totalWidth - rightMinWidth;
                if (totalWidth <= 0 || leftMaxWidth_4 <= leftMinWidth) {
                    // The left and right resizable cells doesn't have enough width
                    return;
                }
                var onMove = function (e) {
                    var leftNewWidth = Math.max(leftMinWidth, Math.min(leftMaxWidth_4, leftOldWidth + e.data.global.x - onDownPoint));
                    var rightNewWidth = totalWidth - leftNewWidth;
                    var rightNewWeight = Math.max(rightMinWeight, totalWeight * (rightNewWidth / totalSpace));
                    leftColumn.width = leftNewWidth;
                    rightColumn.weight = rightNewWeight;
                };
                this.newOnUp(onMove, interactionManager);
            }
        };
        DTableCellEdge.prototype.onDown3 = function (onDownPoint, data, interactionManager) {
            if (data[3].length <= 1) {
                this.onDown3a(onDownPoint, data, interactionManager);
            }
            else {
                this.onDown3b(onDownPoint, data, interactionManager);
            }
        };
        DTableCellEdge.prototype.onDown3a = function (onDownPoint, data, interactionManager) {
            var minWidth = this._minWidth;
            var left = data[1];
            var leftOldWidth = left.width;
            var leftMinWidth = minWidth;
            var right = data[2];
            var rightColumn = right.column;
            var rightOldWidth = right.width;
            var rightMinWidth = Math.max(minWidth, rightColumn.minWidth);
            var totalWidth = leftOldWidth + rightOldWidth;
            var rightMaxWidth = totalWidth - leftMinWidth;
            if (totalWidth <= 0 || rightMaxWidth <= rightMinWidth) {
                // The left and right resizable cells doesn't have enough width
                return;
            }
            var onMove = function (e) {
                rightColumn.width = Math.max(rightMinWidth, Math.min(rightMaxWidth, rightOldWidth + onDownPoint - e.data.global.x));
            };
            this.newOnUp(onMove, interactionManager);
        };
        DTableCellEdge.prototype.onDown3b = function (onDownPoint, data, interactionManager) {
            var minWidth = this._minWidth;
            var left = data[1];
            var leftColumn = left.column;
            var leftOldWidth = left.width;
            var leftMinWeight = leftColumn.minWeight;
            var right = data[2];
            var rightColumn = right.column;
            var rightOldWidth = right.width;
            var rightMinWidth = Math.max(minWidth, rightColumn.minWidth);
            var totalWidth = leftOldWidth + rightOldWidth;
            var others = data[3];
            var totalWeight = 0;
            var totalSpace = 0;
            for (var i = 0, imax = others.length; i < imax; ++i) {
                var other = others[i];
                totalWeight += other.weight;
                totalSpace += other.width;
            }
            if (totalWeight <= 0 || totalSpace <= 0) {
                var leftMinWidth = minWidth;
                var rightMaxWidth_1 = totalWidth - leftMinWidth;
                if (totalWidth <= 0 || rightMaxWidth_1 <= rightMinWidth) {
                    // The left and right resizable cells doesn't have enough width
                    return;
                }
                if (totalWeight <= 0) {
                    totalWeight = 0;
                    for (var i = 0, imax = others.length; i < imax; ++i) {
                        var other = others[i];
                        var otherColumn = other.column;
                        if (other !== left) {
                            var otherNewWeight = otherColumn.minWeight;
                            otherColumn.weight = otherNewWeight;
                            totalWeight += otherNewWeight;
                        }
                        else {
                            var leftNewWeight = Math.max(1, leftMinWeight);
                            otherColumn.weight = leftNewWeight;
                            totalWeight += leftNewWeight;
                        }
                    }
                }
                var onMove = function (e) {
                    rightColumn.width = Math.max(rightMinWidth, Math.min(rightMaxWidth_1, rightOldWidth + onDownPoint - e.data.global.x));
                };
                this.newOnUp(onMove, interactionManager);
            }
            else {
                var leftMinWidth = Math.max(minWidth, totalSpace * (leftMinWeight / totalWeight));
                var rightMaxWidth_2 = totalWidth - leftMinWidth;
                if (totalWidth <= 0 || rightMaxWidth_2 <= rightMinWidth) {
                    // The left and right resizable cells doesn't have enough width
                    return;
                }
                var onMove = function (e) {
                    var rightNewWidth = Math.max(rightMinWidth, Math.min(rightMaxWidth_2, rightOldWidth + onDownPoint - e.data.global.x));
                    var leftNewWidth = totalWidth - rightNewWidth;
                    var leftNewWeight = Math.max(leftMinWeight, totalWeight * (leftNewWidth / totalSpace));
                    rightColumn.width = rightNewWidth;
                    leftColumn.weight = leftNewWeight;
                };
                this.newOnUp(onMove, interactionManager);
            }
        };
        DTableCellEdge.prototype.newOnUp = function (onMove, interactionManager) {
            var row = this._row;
            row.state.add(DTableState.RESIZING);
            var onUp = function () {
                row.state.remove(DTableState.RESIZING);
                interactionManager.off(UtilPointerEvent.move, onMove);
                interactionManager.off(UtilPointerEvent.up, onUp);
                interactionManager.off(UtilPointerEvent.upoutside, onUp);
                interactionManager.off(UtilPointerEvent.cancel, onUp);
            };
            interactionManager.on(UtilPointerEvent.move, onMove);
            interactionManager.on(UtilPointerEvent.up, onUp);
            interactionManager.on(UtilPointerEvent.upoutside, onUp);
            interactionManager.on(UtilPointerEvent.cancel, onUp);
            return onUp;
        };
        DTableCellEdge.prototype.isClicked = function (e) {
            return (e instanceof pixi_js.InteractionEvent &&
                (this._cell.state.is(DTableState.HOVERED_ON_EDGE) || this._dragged));
        };
        return DTableCellEdge;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableCategoryCell = /** @class */ (function (_super) {
        __extends(DTableCategoryCell, _super);
        function DTableCategoryCell(category, columnIndex, column, options) {
            var _this = _super.call(this, options) || this;
            _this._category = category;
            _this._columnIndex = columnIndex;
            _this._column = column;
            _this._edge = new DTableCellEdge(_this._category, _this, columnIndex, _this.theme.getEdgeWidth());
            return _this;
        }
        Object.defineProperty(DTableCategoryCell.prototype, "column", {
            get: function () {
                return this._column;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableCategoryCell.prototype, "columnIndex", {
            get: function () {
                return this._columnIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableCategoryCell.prototype, "category", {
            get: function () {
                return this._category;
            },
            enumerable: false,
            configurable: true
        });
        DTableCategoryCell.prototype.onDown = function (e) {
            if (!this._edge.onDown(e)) {
                _super.prototype.onDown.call(this, e);
            }
        };
        DTableCategoryCell.prototype.onOver = function (e) {
            _super.prototype.onOver.call(this, e);
            this._edge.onOver(e);
        };
        DTableCategoryCell.prototype.onOut = function (e) {
            _super.prototype.onOut.call(this, e);
            this._edge.onOut(e);
        };
        DTableCategoryCell.prototype.getType = function () {
            return "DTableCategoryCell";
        };
        return DTableCategoryCell;
    }(DImage));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableCategoryColumnImpl = /** @class */ (function (_super) {
        __extends(DTableCategoryColumnImpl, _super);
        function DTableCategoryColumnImpl(index, column) {
            var _this = _super.call(this) || this;
            // Label
            var category = column.category;
            if (category) {
                if (isString(category)) {
                    if (index === 0) {
                        _this.label = category;
                    }
                }
                else {
                    if (index < category.length) {
                        _this.label = category[index];
                    }
                }
            }
            _this._weight = column.weight;
            _this._width = column.width;
            _this._isLocked = false;
            _this.offset = 0.0;
            _this._columns = [column];
            _this.resizable = column.resizable;
            var onResizeBound = function () {
                _this.onResize();
            };
            _this._onResizeBound = onResizeBound;
            column.on("resize", onResizeBound);
            return _this;
        }
        DTableCategoryColumnImpl.prototype.onResize = function () {
            if (this._isLocked) {
                return;
            }
            var columns = this._columns;
            if (this._weight != null) {
                var newWeight = 0;
                for (var i = 0, imax = columns.length; i < imax; ++i) {
                    var weight = columns[i].weight;
                    if (weight != null) {
                        newWeight += weight;
                    }
                }
                if (this._weight !== newWeight) {
                    this._weight = newWeight;
                    this.emit("resize", this);
                }
            }
            else {
                var newWidth = 0;
                for (var i = 0, imax = columns.length; i < imax; ++i) {
                    var width = columns[i].width;
                    if (width != null) {
                        newWidth += width;
                    }
                }
                if (this._width !== newWidth) {
                    this._width = newWidth;
                    this.emit("resize", this);
                }
            }
        };
        Object.defineProperty(DTableCategoryColumnImpl.prototype, "weight", {
            get: function () {
                return this._weight;
            },
            set: function (weight) {
                var oldWeight = this._weight;
                if (oldWeight != null && oldWeight !== weight) {
                    var columns = this._columns;
                    var columnsLength = columns.length;
                    var minWeight = this.minWeight;
                    var newWeight = Math.max(minWeight, weight);
                    if (this._weight !== newWeight) {
                        this._isLocked = true;
                        if (minWeight < oldWeight) {
                            // TODO: IMPROVE THIS
                            var columnWeightRatio = newWeight / oldWeight;
                            for (var i = 0; i < columnsLength; ++i) {
                                var column = columns[i];
                                var columnWeight = column.weight;
                                if (columnWeight != null) {
                                    column.weight = Math.max(column.minWeight, columnWeight * columnWeightRatio);
                                }
                            }
                        }
                        else {
                            for (var i = 0; i < columnsLength; ++i) {
                                var column = columns[i];
                                var columnWeight = column.weight;
                                if (columnWeight != null) {
                                    column.weight = column.minWeight;
                                }
                            }
                        }
                        this._isLocked = false;
                        this.onResize();
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableCategoryColumnImpl.prototype, "minWeight", {
            get: function () {
                var result = 0;
                var columns = this._columns;
                var columnsLength = columns.length;
                for (var i = 0; i < columnsLength; ++i) {
                    var column = columns[i];
                    var columnWeight = column.weight;
                    if (columnWeight != null) {
                        result += column.minWeight;
                    }
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableCategoryColumnImpl.prototype, "width", {
            get: function () {
                return this._width;
            },
            set: function (width) {
                var oldWidth = this._width;
                if (oldWidth != null && oldWidth !== width) {
                    var columns = this._columns;
                    var columnsLength = columns.length;
                    var minWidth = this.minWidth;
                    var newWidth = Math.max(minWidth, width);
                    if (oldWidth !== newWidth) {
                        this._isLocked = true;
                        if (minWidth < oldWidth) {
                            // TODO: IMPROVE THIS
                            var columnWidthRatio = newWidth / oldWidth;
                            for (var i = 0; i < columnsLength; ++i) {
                                var column = columns[i];
                                var columnWidth = column.width;
                                if (columnWidth != null) {
                                    column.width = Math.max(column.minWidth, columnWidth * columnWidthRatio);
                                }
                            }
                        }
                        else {
                            for (var i = 0; i < columnsLength; ++i) {
                                var column = columns[i];
                                var columnWidth = column.width;
                                if (columnWidth != null) {
                                    column.width = column.minWidth;
                                }
                            }
                        }
                        this._isLocked = false;
                        this.onResize();
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableCategoryColumnImpl.prototype, "minWidth", {
            get: function () {
                var result = 0;
                var columns = this._columns;
                var columnsLength = columns.length;
                for (var i = 0; i < columnsLength; ++i) {
                    var column = columns[i];
                    var columnWidth = column.width;
                    if (columnWidth != null) {
                        result += column.minWidth;
                    }
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DTableCategoryColumnImpl.prototype.add = function (column) {
            this._columns.push(column);
            if (this._weight != null) {
                var weight = column.weight;
                if (weight != null) {
                    this._weight += weight;
                    column.on("resize", this._onResizeBound);
                }
            }
            else if (this._width != null) {
                var width = column.width;
                if (width != null) {
                    this._width += width;
                    column.on("resize", this._onResizeBound);
                }
            }
        };
        return DTableCategoryColumnImpl;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableCategory = /** @class */ (function (_super) {
        __extends(DTableCategory, _super);
        function DTableCategory(columns, frozen, offset, options) {
            var _this = _super.call(this, columns, frozen, options) || this;
            _this._columns = columns;
            _this._frozen = frozen;
            _this._offset = offset;
            _this.transform.position.y = offset;
            _this.initCells();
            for (var i = 0, imax = columns.length; i < imax; ++i) {
                var column = columns[i];
                column.on("resize", _this.newOnColumnResize(i, column));
            }
            return _this;
        }
        DTableCategory.prototype.newOnColumnResize = function (index, column) {
            var _this = this;
            return function () {
                _this.onColumnResize(index, column);
            };
        };
        DTableCategory.prototype.onColumnResize = function (index, column) {
            var columnWeight = column.weight;
            if (columnWeight != null) {
                this.onColumnResizeWeight(this, index, columnWeight);
            }
            else {
                var columnWidth = column.width;
                if (columnWidth != null) {
                    this.onColumnResizeWidth(this, index, columnWidth);
                }
            }
        };
        DTableCategory.prototype.onColumnResizeWeight = function (row, index, columnWeight) {
            var cells = row.children;
            var cellsLength = cells.length;
            var cellsIndex = cellsLength - index - 1;
            if (0 <= cellsIndex && cellsIndex < cellsLength) {
                cells[cellsIndex].weight = columnWeight;
            }
        };
        DTableCategory.prototype.onColumnResizeWidth = function (row, index, columnWidth) {
            var cells = row.children;
            var cellsLength = cells.length;
            var cellsIndex = cellsLength - index - 1;
            if (0 <= cellsIndex && cellsIndex < cellsLength) {
                cells[cellsIndex].width = columnWidth;
            }
        };
        DTableCategory.prototype.onParentMove = function (newX, newY, oldX, oldY) {
            _super.prototype.onParentMove.call(this, newX, newY, oldX, oldY);
            this.transform.position.y = -newY + this._offset;
            this.updateFrozenCellPosition(newX);
        };
        DTableCategory.prototype.getContentPositionX = function () {
            var content = this.parent;
            if (content) {
                return content.position.x;
            }
            return 0;
        };
        DTableCategory.prototype.newCell = function (columnIndex, column, columns, options) {
            return new DTableCategoryCell(this, columnIndex, column, this.toCellOptions(columnIndex, column, options));
        };
        DTableCategory.prototype.toCellOptions = function (columnIndex, column, options) {
            var result = options === null || options === void 0 ? void 0 : options.cell;
            if (result) {
                // Weight
                result.weight = column.weight;
                // Width
                result.width = column.width;
                // Label
                var text = result.text || {};
                result.text = text;
                text.value = text.value || column.label;
                // Done
                return result;
            }
            else {
                return {
                    weight: column.weight,
                    width: column.width,
                    text: {
                        value: column.label
                    }
                };
            }
        };
        DTableCategory.prototype.getType = function () {
            return "DTableCategory";
        };
        return DTableCategory;
    }(DTableRow));

    var DTableCategoryContainerImpl = /** @class */ (function () {
        function DTableCategoryContainerImpl(columns, frozen, options) {
            var count = this.toCount(columns);
            var items = [];
            var offset = 0;
            for (var i = count - 1; 0 <= i; --i) {
                var item = new DTableCategory(this.toColumns(i, columns, frozen), frozen, offset, options);
                items.push(item);
                offset += item.height;
            }
            this.items = items;
        }
        DTableCategoryContainerImpl.prototype.toCount = function (columns) {
            var result = 0;
            for (var i = 0, imax = columns.length; i < imax; ++i) {
                var category = columns[i].category;
                if (category != null) {
                    var count = isString(category) ? 1 : category.length;
                    result = Math.max(result, count);
                }
            }
            return result;
        };
        DTableCategoryContainerImpl.prototype.isEqual = function (index, a, b) {
            if (a != null) {
                if (b != null) {
                    if (isString(a)) {
                        if (isString(b)) {
                            if (0 < index) {
                                return true;
                            }
                            else {
                                return a === b;
                            }
                        }
                        else {
                            if (0 < index) {
                                return b.length <= index;
                            }
                            else {
                                return b.length === 1 && a === b[0];
                            }
                        }
                    }
                    else {
                        if (isString(b)) {
                            if (0 < index) {
                                return a.length <= index;
                            }
                            else {
                                return a.length === 1 && a[0] === b;
                            }
                        }
                        else {
                            if (a.length <= index && b.length <= index) {
                                return true;
                            }
                            else if (b.length === a.length) {
                                for (var i = index, imax = a.length; i < imax; ++i) {
                                    if (a[i] !== b[i]) {
                                        return false;
                                    }
                                }
                                return true;
                            }
                            return false;
                        }
                    }
                }
                else {
                    if (isString(a)) {
                        if (0 < index) {
                            return true;
                        }
                        else {
                            return false;
                        }
                    }
                    else {
                        if (a.length <= index) {
                            return true;
                        }
                        else {
                            return false;
                        }
                    }
                }
            }
            else {
                if (b != null) {
                    if (isString(b)) {
                        if (0 < index) {
                            return true;
                        }
                        else {
                            return false;
                        }
                    }
                    else {
                        if (b.length <= index) {
                            return true;
                        }
                        else {
                            return false;
                        }
                    }
                }
                else {
                    return true;
                }
            }
        };
        DTableCategoryContainerImpl.prototype.toColumns = function (index, columns, frozen) {
            var result = [];
            var tcolumn = null;
            var ccolumn = null;
            for (var i = 0, imax = columns.length; i < imax; ++i) {
                var column = columns[i];
                if (i !== frozen &&
                    ccolumn &&
                    tcolumn &&
                    this.isEqual(index, tcolumn.category, column.category)) {
                    if (ccolumn.resizable === column.resizable) {
                        if (ccolumn.weight != null && column.weight != null) {
                            ccolumn.add(column);
                        }
                        else if (ccolumn.width != null && column.width != null) {
                            ccolumn.add(column);
                        }
                        else {
                            tcolumn = column;
                            ccolumn = new DTableCategoryColumnImpl(index, column);
                            result.push(ccolumn);
                        }
                    }
                    else {
                        tcolumn = column;
                        ccolumn = new DTableCategoryColumnImpl(index, column);
                        result.push(ccolumn);
                    }
                }
                else {
                    tcolumn = column;
                    ccolumn = new DTableCategoryColumnImpl(index, column);
                    result.push(ccolumn);
                }
            }
            return result;
        };
        return DTableCategoryContainerImpl;
    }());

    var defaultGetter = function (row, columnIndex) {
        return row[columnIndex];
    };
    var defaultSetter = function (row, columnIndex, cell) {
        row[columnIndex] = cell;
    };
    var defaultGetterEmpty = function () { return ""; };
    var defaultSetterEmpty = function () {
        // DO NOTHING
    };
    var toPathGetter = function (path, def) {
        if (path.length <= 1) {
            var key_1 = path[0];
            if (def === undefined) {
                return function (row) {
                    return row[key_1];
                };
            }
            else {
                return function (row) {
                    return Object.prototype.hasOwnProperty.call(row, key_1) ? row[key_1] : def;
                };
            }
        }
        else {
            if (def === undefined) {
                return function (row) {
                    for (var i = 0, imax = path.length - 1; i < imax; ++i) {
                        row = row[path[i]];
                    }
                    return row[path[path.length - 1]];
                };
            }
            else {
                return function (row) {
                    for (var i = 0, imax = path.length - 1; i < imax; ++i) {
                        row = row[path[i]];
                    }
                    var key = path[path.length - 1];
                    return Object.prototype.hasOwnProperty.call(row, key) ? row[key] : def;
                };
            }
        }
    };
    var toPathSetter = function (path) {
        if (path.length <= 1) {
            var key_2 = path[0];
            return function (row, columnIndex, cell) {
                row[key_2] = cell;
            };
        }
        else {
            return function (row, columnIndex, cell) {
                for (var i = 0, imax = path.length - 1; i < imax; ++i) {
                    row = row[path[i]] || {};
                }
                row[path[path.length - 1]] = cell;
            };
        }
    };
    var toAlign = function (options, type) {
        var align = options.align;
        if (align != null) {
            if (isString(align)) {
                return DAlignHorizontal[align];
            }
            else {
                return align;
            }
        }
        switch (type) {
            case DTableColumnType.TEXT:
            case DTableColumnType.TEXT_AREA:
                return DAlignHorizontal.LEFT;
            case DTableColumnType.REAL:
            case DTableColumnType.INTEGER:
                return DAlignHorizontal.RIGHT;
            case DTableColumnType.BUTTON:
            case DTableColumnType.INDEX:
            case DTableColumnType.SELECT:
            case DTableColumnType.ACTION:
            case DTableColumnType.LINK:
            case DTableColumnType.CHECK:
            case DTableColumnType.CHECK_SINGLE:
            case DTableColumnType.COLOR:
                return DAlignHorizontal.CENTER;
            default:
                return DAlignHorizontal.LEFT;
        }
    };
    var toDataChecker = function (path) {
        if (path != null) {
            var pathLength_1 = path.length;
            if (pathLength_1 <= 1) {
                var key_3 = path[0];
                return function (row) {
                    return Object.prototype.hasOwnProperty.call(row, key_3);
                };
            }
            else {
                return function (row) {
                    for (var i = 0; i < pathLength_1; ++i) {
                        var part = path[i];
                        if (part in row) {
                            row = row[part];
                        }
                        else {
                            return false;
                        }
                    }
                    return true;
                };
            }
        }
        return function (row, columnIndex) {
            return columnIndex < row.length;
        };
    };
    var toEditingEnable = function (enable, path) {
        if (isString(enable)) {
            return toDataChecker(path);
        }
        else if (enable != null) {
            return enable;
        }
        else {
            return false;
        }
    };
    var toEditing = function (options, path) {
        var _a;
        var editing = options.editing;
        var editable = options.editable;
        if (editing) {
            return {
                enable: toEditingEnable((_a = editing.enable) !== null && _a !== void 0 ? _a : editable, path),
                formatter: editing.formatter,
                unformatter: editing.unformatter,
                validator: editing.validator
            };
        }
        return {
            enable: toEditingEnable(editable, path)
        };
    };
    var toComparator = function (getter, index) {
        return function (rowA, rowB) {
            var valueA = getter(rowA, index);
            var valueB = getter(rowB, index);
            return valueA < valueB ? -1 : valueB < valueA ? +1 : 0;
        };
    };
    var toSorting = function (getter, index, options) {
        var sorting = options.sorting;
        var sortable = options.sortable;
        if (sorting) {
            if (sorting.enable || sortable) {
                return {
                    enable: true,
                    comparator: sorting.comparator || toComparator(getter, index)
                };
            }
            return {
                enable: false
            };
        }
        if (sortable) {
            return {
                enable: true,
                comparator: toComparator(getter, index)
            };
        }
        return {
            enable: false
        };
    };
    var toMenu = function (options) {
        if (options == null) {
            return undefined;
        }
        else if (options instanceof DMenu) {
            return options;
        }
        else {
            return new DMenu(options);
        }
    };
    var toDialog = function (options) {
        if (options == null) {
            return undefined;
        }
        else if ("open" in options) {
            return options;
        }
        else {
            return new DDialogSelect(options);
        }
    };
    var defaultSelectingGetter = function (dialog) {
        return dialog.value;
    };
    var defaultSelectingSetter = function () {
        // DO NOTHING
    };
    var toSelecting = function (options) {
        if (options) {
            return {
                getter: options.getter || defaultSelectingGetter,
                setter: options.setter || defaultSelectingSetter,
                menu: toMenu(options.menu),
                multiple: toMenu(options.multiple),
                dialog: toDialog(options.dialog),
                promise: options.promise
            };
        }
        return {
            getter: defaultSelectingGetter,
            setter: defaultSelectingSetter
        };
    };
    var toGetter = function (options, type, parts) {
        var getter = options.getter;
        if (getter) {
            return getter;
        }
        switch (type) {
            case DTableColumnType.ACTION:
            case DTableColumnType.LINK:
                return defaultGetterEmpty;
            default:
                if (parts == null) {
                    return defaultGetter;
                }
                else {
                    return toPathGetter(parts, options.default);
                }
        }
    };
    var toSetter = function (options, type, path) {
        var setter = options.setter;
        if (setter) {
            return setter;
        }
        switch (type) {
            case DTableColumnType.BUTTON:
            case DTableColumnType.ACTION:
            case DTableColumnType.LINK:
                return defaultSetterEmpty;
            default:
                if (path == null) {
                    return defaultSetter;
                }
                else {
                    return toPathSetter(path);
                }
        }
    };
    var toState = function (options) {
        var state = options.state;
        if (state != null) {
            if (isString(state) || isArray(state)) {
                return {
                    initial: state,
                    modifier: undefined
                };
            }
            else {
                return {
                    initial: undefined,
                    modifier: state
                };
            }
        }
        return {
            initial: undefined,
            modifier: undefined
        };
    };
    var toPath = function (options) {
        return options.path != null ? options.path.split(".") : null;
    };
    var toRenderable = function (options, path) {
        var renderable = options.renderable;
        if (isString(renderable)) {
            return toDataChecker(path);
        }
        else if (renderable != null) {
            return renderable;
        }
        return true;
    };
    var DTableColumnImpl = /** @class */ (function (_super) {
        __extends(DTableColumnImpl, _super);
        function DTableColumnImpl(index, options) {
            var _a, _b, _c;
            var _this = _super.call(this) || this;
            var weight = options.weight;
            var width = options.width;
            if (weight != null) {
                if (width != null) {
                    width = undefined;
                }
            }
            else if (width == null) {
                weight = 1;
            }
            var type = toEnum((_a = options.type) !== null && _a !== void 0 ? _a : DTableColumnType.TEXT, DTableColumnType);
            var align = toAlign(options, type);
            var label = options.label || "";
            var path = toPath(options);
            var getter = toGetter(options, type, path);
            var setter = toSetter(options, type, path);
            _this._weight = weight;
            _this.minWeight = 0;
            _this._width = width;
            _this.minWidth = 0;
            _this.resizable = (_b = options.resizable) !== null && _b !== void 0 ? _b : false;
            _this.type = type;
            _this.label = label;
            _this.getter = getter;
            _this.setter = setter;
            _this.formatter = options.formatter;
            _this.renderable = toRenderable(options, path);
            _this.align = align;
            _this.state = toState(options);
            _this.editing = toEditing(options, path);
            _this.sorting = toSorting(getter, index, options);
            _this.header = options.header;
            _this.body = options.body;
            _this.selecting = toSelecting(options.selecting);
            _this.category = options.category;
            _this.frozen = options.frozen;
            _this.offset = 0.0;
            _this.link = options.link;
            _this.update = toEnum((_c = options.update) !== null && _c !== void 0 ? _c : DTableColumnUpdate.CELL, DTableColumnUpdate);
            return _this;
        }
        Object.defineProperty(DTableColumnImpl.prototype, "weight", {
            get: function () {
                return this._weight;
            },
            set: function (weight) {
                if (this._weight != null && this._weight !== weight) {
                    this._weight = weight;
                    this.emit("resize", this);
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableColumnImpl.prototype, "width", {
            get: function () {
                return this._width;
            },
            set: function (width) {
                if (this._width != null && this._width !== width) {
                    this._width = width;
                    this.emit("resize", this);
                }
            },
            enumerable: false,
            configurable: true
        });
        return DTableColumnImpl;
    }(pixi_js.utils.EventEmitter));

    var DTableColumnContainerImpl = /** @class */ (function (_super) {
        __extends(DTableColumnContainerImpl, _super);
        function DTableColumnContainerImpl(parent, options) {
            var _this = _super.call(this) || this;
            _this.parent = parent;
            var columns = [];
            if (options != null) {
                for (var i = 0, imax = options.length; i < imax; ++i) {
                    var column = new DTableColumnImpl(i, options[i]);
                    columns.push(column);
                    column.on("resize", _this.newOnColumnResize(i, column));
                }
            }
            _this.items = columns;
            var frozen = 0;
            for (var i = columns.length - 1; 0 <= i; --i) {
                if (columns[i].frozen === true) {
                    frozen = i + 1;
                    break;
                }
            }
            _this.frozen = frozen;
            return _this;
        }
        DTableColumnContainerImpl.prototype.newOnColumnResize = function (index, column) {
            var _this = this;
            return function () {
                _this.onColumnResize(index, column);
            };
        };
        DTableColumnContainerImpl.prototype.onColumnResize = function (index, column) {
            this.onColumnResizeHeader(index, column);
            this.onColumnResizeBody(index, column);
            this.emit("resize", index, column, this);
        };
        DTableColumnContainerImpl.prototype.onColumnResizeHeader = function (index, column) {
            var header = this.parent.header;
            if (header != null) {
                var columnWeight = column.weight;
                if (columnWeight != null) {
                    this.onColumnResizeWeight(header, index, columnWeight);
                }
                else {
                    var columnWidth = column.width;
                    if (columnWidth != null) {
                        this.onColumnResizeWidth(header, index, columnWidth);
                    }
                }
            }
        };
        DTableColumnContainerImpl.prototype.onColumnResizeBody = function (index, column) {
            var rows = this.parent.body.children;
            var columnWeight = column.weight;
            if (columnWeight != null) {
                for (var i = 0, imax = rows.length; i < imax; ++i) {
                    this.onColumnResizeWeight(rows[i], index, columnWeight);
                }
            }
            else {
                var columnWidth = column.width;
                if (columnWidth != null) {
                    for (var i = 0, imax = rows.length; i < imax; ++i) {
                        this.onColumnResizeWidth(rows[i], index, columnWidth);
                    }
                }
            }
        };
        DTableColumnContainerImpl.prototype.onColumnResizeWeight = function (row, index, columnWeight) {
            var cells = row.children;
            var cellsLength = cells.length;
            var cellsIndex = cellsLength - index - 1;
            if (0 <= cellsIndex && cellsIndex < cellsLength) {
                cells[cellsIndex].weight = columnWeight;
            }
        };
        DTableColumnContainerImpl.prototype.onColumnResizeWidth = function (row, index, columnWidth) {
            var cells = row.children;
            var cellsLength = cells.length;
            var cellsIndex = cellsLength - index - 1;
            if (0 <= cellsIndex && cellsIndex < cellsLength) {
                cells[cellsIndex].width = columnWidth;
            }
        };
        Object.defineProperty(DTableColumnContainerImpl.prototype, "width", {
            get: function () {
                var result = 0;
                var items = this.items;
                var length = items.length;
                for (var i = 0; i < length; ++i) {
                    var item = items[i];
                    var itemWidth = item.width;
                    if (itemWidth != null) {
                        result += itemWidth;
                    }
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DTableColumnContainerImpl.prototype.get = function (index) {
            var columns = this.items;
            if (0 <= index && index < columns.length) {
                return columns[index];
            }
            return null;
        };
        DTableColumnContainerImpl.prototype.each = function (iteratee) {
            var columns = this.items;
            for (var i = 0, imax = columns.length; i < imax; ++i) {
                if (iteratee(columns[i], i) === false) {
                    break;
                }
            }
            return this;
        };
        DTableColumnContainerImpl.prototype.size = function () {
            return this.items.length;
        };
        return DTableColumnContainerImpl;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableDataTreeFilter = /** @class */ (function (_super) {
        __extends(DTableDataTreeFilter, _super);
        function DTableDataTreeFilter(parent) {
            var _this = _super.call(this) || this;
            _this._id = 0;
            _this._idUpdated = -1;
            _this._isApplied = false;
            _this._parent = parent;
            _this._filter = null;
            _this._filtered = null;
            return _this;
        }
        Object.defineProperty(DTableDataTreeFilter.prototype, "id", {
            get: function () {
                return this._id;
            },
            enumerable: false,
            configurable: true
        });
        DTableDataTreeFilter.prototype.apply = function () {
            this._isApplied = true;
            this._id += 1;
            this._parent.update();
        };
        DTableDataTreeFilter.prototype.unapply = function () {
            if (this._isApplied) {
                this._isApplied = false;
                this._id += 1;
                this._parent.update();
            }
        };
        DTableDataTreeFilter.prototype.isApplied = function () {
            return this._isApplied;
        };
        DTableDataTreeFilter.prototype.isFiltered = function (node, index, filter) {
            if (isFunction(filter)) {
                return filter(node, index);
            }
            else {
                return filter.test(node, index);
            }
        };
        DTableDataTreeFilter.prototype.hasFiltered = function (parent, nodes, filter) {
            var accessor = this._parent.accessor;
            var toChildren = accessor.toChildren;
            var hasChildren = accessor.hasChildren;
            for (var i = 0, imax = nodes.length; i < imax; ++i) {
                var node = nodes[i];
                if (this.isFiltered(node, -1, filter)) {
                    return true;
                }
                var children = toChildren(node);
                if (hasChildren(node, children) && this.hasFiltered(parent, children, filter)) {
                    return true;
                }
            }
            return false;
        };
        DTableDataTreeFilter.prototype.addAllToFiltered = function (parent, nodes, filtered, cursor) {
            var accessor = this._parent.accessor;
            var toChildren = accessor.toChildren;
            var hasChildren = accessor.hasChildren;
            for (var i = 0, imax = nodes.length; i < imax; ++i) {
                var node = nodes[i];
                filtered.push(cursor[0]);
                cursor[0] += 1;
                var children = toChildren(node);
                if (hasChildren(node, children) && parent.isOpened(node)) {
                    this.addAllToFiltered(parent, children, filtered, cursor);
                }
            }
        };
        DTableDataTreeFilter.prototype.newFilteredSub = function (parent, nodes, filter, filtered, cursor) {
            var result = false;
            var accessor = this._parent.accessor;
            var toChildren = accessor.toChildren;
            var hasChildren = accessor.hasChildren;
            for (var i = 0, imax = nodes.length; i < imax; ++i) {
                var node = nodes[i];
                var index = cursor[0];
                cursor[0] += 1;
                var isFiltered = this.isFiltered(node, index, filter);
                var children = toChildren(node);
                if (hasChildren(node, children)) {
                    if (parent.isOpened(node)) {
                        if (isFiltered) {
                            filtered.push(index);
                            result = true;
                            this.addAllToFiltered(parent, children, filtered, cursor);
                        }
                        else {
                            var position = filtered.length;
                            if (this.newFilteredSub(parent, children, filter, filtered, cursor)) {
                                filtered.splice(position, 0, index);
                                result = true;
                            }
                        }
                    }
                    else if (isFiltered || this.hasFiltered(parent, children, filter)) {
                        filtered.push(index);
                        result = true;
                    }
                }
                else if (isFiltered) {
                    filtered.push(index);
                    result = true;
                }
            }
            return result;
        };
        DTableDataTreeFilter.prototype.newFiltered = function () {
            var filter = this._filter;
            if (filter != null) {
                var filtered = [];
                var parent_1 = this._parent;
                var nodes = parent_1.nodes;
                if (nodes) {
                    var cursor = [0];
                    this.newFilteredSub(parent_1, nodes, filter, filtered, cursor);
                }
                return filtered;
            }
            return null;
        };
        DTableDataTreeFilter.prototype.get = function () {
            return this._filter;
        };
        DTableDataTreeFilter.prototype.set = function (filter) {
            if (this._filter !== filter) {
                this._filter = filter;
            }
        };
        DTableDataTreeFilter.prototype.toDirty = function () {
            this._id += 1;
        };
        DTableDataTreeFilter.prototype.update = function () {
            if (this._id !== this._idUpdated) {
                this._idUpdated = this._id;
                if (this._isApplied) {
                    this._filtered = this.newFiltered();
                    this.emit("change", this);
                }
                else if (this._filtered != null) {
                    this._filtered = null;
                    this.emit("change", this);
                }
            }
        };
        Object.defineProperty(DTableDataTreeFilter.prototype, "indices", {
            get: function () {
                this.update();
                return this._filtered;
            },
            enumerable: false,
            configurable: true
        });
        DTableDataTreeFilter.prototype.map = function (sortedIndex) {
            var result = sortedIndex;
            var indices = this.indices;
            if (indices) {
                var index = indices.indexOf(result);
                if (0 <= index) {
                    result = index;
                }
                else {
                    return null;
                }
            }
            return result;
        };
        DTableDataTreeFilter.prototype.unmap = function (index) {
            var result = index;
            var indices = this.indices;
            if (indices) {
                result = indices[result];
            }
            return result;
        };
        return DTableDataTreeFilter;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2021 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var toParent = function (node) {
        return node.parent;
    };
    var toChildren$1 = function (node) {
        return node.children;
    };
    var hasChildren = function (node, children) {
        return children != null && 0 < children.length;
    };
    var DTableDataTreeItemAccessor = /** @class */ (function () {
        function DTableDataTreeItemAccessor(options) {
            if (options != null) {
                this.toParent = options.toParent || toParent;
                this.toChildren = options.toChildren || toChildren$1;
                this.hasChildren = options.hasChildren || hasChildren;
            }
            else {
                this.toParent = toParent;
                this.toChildren = toChildren$1;
                this.hasChildren = hasChildren;
            }
        }
        return DTableDataTreeItemAccessor;
    }());

    /*
     * Copyright (C) 2021 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var COMPARATOR = function (a, b) {
        return a[0] - b[0];
    };
    var DTableDataTreeSelectionImpl = /** @class */ (function (_super) {
        __extends(DTableDataTreeSelectionImpl, _super);
        function DTableDataTreeSelectionImpl(parent, options) {
            var _a;
            var _this = _super.call(this) || this;
            _this._parent = parent;
            _this._type = toEnum((_a = options === null || options === void 0 ? void 0 : options.type) !== null && _a !== void 0 ? _a : DTableDataSelectionType.NONE, DTableDataSelectionType);
            _this._rows = new Set();
            // Events
            var on = options === null || options === void 0 ? void 0 : options.on;
            if (on) {
                for (var name_1 in on) {
                    var handler = on[name_1];
                    if (handler) {
                        _this.on(name_1, handler);
                    }
                }
            }
            return _this;
        }
        Object.defineProperty(DTableDataTreeSelectionImpl.prototype, "parent", {
            get: function () {
                return this._parent;
            },
            enumerable: false,
            configurable: true
        });
        DTableDataTreeSelectionImpl.prototype.onNodeChange = function (nodes) {
            if (nodes != null) {
                var accessor = this._parent.accessor;
                var toChildren = accessor.toChildren;
                var hasChildren = accessor.hasChildren;
                var oldRows = this._rows;
                var newRows = this.newRows(nodes, toChildren, hasChildren, oldRows, new Set());
                if (oldRows.size !== newRows.size) {
                    this._rows = newRows;
                    this.onChange();
                }
            }
            else {
                var rows = this._rows;
                if (0 < rows.size) {
                    rows.clear();
                    this.onChange();
                }
            }
        };
        DTableDataTreeSelectionImpl.prototype.newRows = function (nodes, toChildren, hasChildren, rows, result) {
            for (var i = 0, imax = nodes.length; i < imax; ++i) {
                var node = nodes[i];
                if (rows.has(node)) {
                    result.add(node);
                }
                var children = toChildren(node);
                if (hasChildren(node, children)) {
                    this.newRows(children, toChildren, hasChildren, rows, result);
                }
            }
            return result;
        };
        Object.defineProperty(DTableDataTreeSelectionImpl.prototype, "indices", {
            get: function () {
                var rows = this._rows;
                var result = [];
                this._parent.each(function (row, index) {
                    if (rows.has(row)) {
                        result.push(index);
                    }
                });
                return result;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableDataTreeSelectionImpl.prototype, "rows", {
            get: function () {
                var result = [];
                this._rows.forEach(function (row) {
                    result.push(row);
                });
                return result;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableDataTreeSelectionImpl.prototype, "type", {
            get: function () {
                return this._type;
            },
            enumerable: false,
            configurable: true
        });
        DTableDataTreeSelectionImpl.prototype.getFirst = function () {
            var rows = this._rows;
            if (0 < rows.size) {
                var result_1 = null;
                rows.forEach(function (row) {
                    if (result_1 == null) {
                        result_1 = row;
                    }
                });
                return result_1;
            }
            return null;
        };
        DTableDataTreeSelectionImpl.prototype.getLast = function () {
            var rows = this._rows;
            if (0 < rows.size) {
                var result_2 = null;
                rows.forEach(function (row) {
                    result_2 = row;
                });
                return result_2;
            }
            return null;
        };
        DTableDataTreeSelectionImpl.prototype.toIndex = function (target) {
            var result = null;
            this._parent.each(function (row, index) {
                if (target === row) {
                    result = index;
                    return false;
                }
                return true;
            });
            return result;
        };
        Object.defineProperty(DTableDataTreeSelectionImpl.prototype, "first", {
            get: function () {
                var row = this.getFirst();
                if (row) {
                    return this.toIndex(row);
                }
                return null;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableDataTreeSelectionImpl.prototype, "last", {
            get: function () {
                var row = this.getLast();
                if (row) {
                    return this.toIndex(row);
                }
                return null;
            },
            enumerable: false,
            configurable: true
        });
        DTableDataTreeSelectionImpl.prototype.onChange = function () {
            this._parent.update();
            this.emit("change", this);
        };
        DTableDataTreeSelectionImpl.prototype.toggle = function (rowIndex) {
            var row = this._parent.get(rowIndex);
            if (row) {
                var rows = this._rows;
                if (rows.has(row)) {
                    rows.delete(row);
                }
                else {
                    rows.add(row);
                }
                this.onChange();
            }
        };
        DTableDataTreeSelectionImpl.prototype.add = function (rowIndex) {
            var row = this._parent.get(rowIndex);
            if (row) {
                var rows = this._rows;
                if (!rows.has(row)) {
                    rows.add(row);
                    this.onChange();
                }
            }
        };
        DTableDataTreeSelectionImpl.prototype.addTo = function (rowIndex) {
            var lastRowIndex = this.last;
            if (lastRowIndex != null) {
                this.addRange(lastRowIndex, false, rowIndex, true);
            }
        };
        DTableDataTreeSelectionImpl.prototype.addRange = function (from, includeFrom, to, includeTo) {
            var rows = this._rows;
            var oldSize = rows.size;
            var parent = this._parent;
            if (from < to) {
                parent.each(function (row) {
                    rows.add(row);
                }, from + (includeFrom ? 0 : 1), to + (includeTo ? 1 : 0));
            }
            else {
                parent.each(function (row) {
                    rows.add(row);
                }, to + (includeTo ? 0 : 1), from + (includeFrom ? 1 : 0));
            }
            var newSize = rows.size;
            if (oldSize !== newSize) {
                this.onChange();
            }
        };
        DTableDataTreeSelectionImpl.prototype.addAll = function (rowIndices) {
            if (0 < rowIndices.length) {
                var rows = this._rows;
                var parent_1 = this._parent;
                for (var i = 0, imax = rowIndices.length; i < imax; ++i) {
                    var row = parent_1.get(rowIndices[i]);
                    if (row) {
                        rows.add(row);
                    }
                }
                this.onChange();
            }
        };
        DTableDataTreeSelectionImpl.prototype.contains = function (rowIndex) {
            var row = this._parent.get(rowIndex);
            if (row) {
                return this._rows.has(row);
            }
            return false;
        };
        DTableDataTreeSelectionImpl.prototype.remove = function (rowIndex) {
            var row = this._parent.get(rowIndex);
            if (row) {
                var rows = this._rows;
                if (rows.has(row)) {
                    rows.delete(row);
                    this.onChange();
                }
            }
        };
        DTableDataTreeSelectionImpl.prototype.clear = function () {
            var rows = this._rows;
            if (0 < rows.size) {
                rows.clear();
                this.onChange();
            }
        };
        DTableDataTreeSelectionImpl.prototype.clearAndAdd = function (rowIndex) {
            var row = this._parent.get(rowIndex);
            if (row) {
                var rows = this._rows;
                if (rows.has(row)) {
                    if (1 < rows.size) {
                        rows.clear();
                        rows.add(row);
                        this.onChange();
                    }
                }
                else {
                    rows.clear();
                    rows.add(row);
                    this.onChange();
                }
            }
        };
        DTableDataTreeSelectionImpl.prototype.clearAndAddAll = function (rowIndices) {
            var rows = this._rows;
            if (0 < rows.size || 0 < rowIndices.length) {
                rows.clear();
                var parent_2 = this._parent;
                for (var i = 0, imax = rowIndices.length; i < imax; ++i) {
                    var row = parent_2.get(rowIndices[i]);
                    if (row) {
                        rows.add(row);
                    }
                }
                this.onChange();
            }
        };
        DTableDataTreeSelectionImpl.prototype.shift = function (rowIndex, amount) {
            // DO NOTHING
        };
        DTableDataTreeSelectionImpl.prototype.size = function () {
            return this._rows.size;
        };
        DTableDataTreeSelectionImpl.prototype.isEmpty = function () {
            return this._rows.size <= 0;
        };
        DTableDataTreeSelectionImpl.prototype.each = function (iteratee) {
            var rows = this._rows;
            this._parent.each(function (row, index) {
                if (rows.has(row)) {
                    if (iteratee(index) === false) {
                        return false;
                    }
                }
                return true;
            });
        };
        DTableDataTreeSelectionImpl.prototype.toArray = function () {
            var rows = this._rows;
            var result = [];
            this._parent.each(function (row, index) {
                if (rows.has(row)) {
                    result.push([index, row]);
                }
            });
            return result;
        };
        DTableDataTreeSelectionImpl.prototype.toSortedArray = function () {
            return this.toArray().sort(COMPARATOR);
        };
        DTableDataTreeSelectionImpl.prototype.toObject = function () {
            var rows = this._rows;
            var result = {};
            this._parent.each(function (row, index) {
                if (rows.has(row)) {
                    result[index] = row;
                }
            });
            return result;
        };
        DTableDataTreeSelectionImpl.prototype.toMap = function () {
            var rows = this._rows;
            var result = new Map();
            this._parent.each(function (row, index) {
                if (rows.has(row)) {
                    result.set(index, row);
                }
            });
            return result;
        };
        return DTableDataTreeSelectionImpl;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableDataTreeSorter = /** @class */ (function (_super) {
        __extends(DTableDataTreeSorter, _super);
        function DTableDataTreeSorter() {
            return _super.call(this) || this;
        }
        Object.defineProperty(DTableDataTreeSorter.prototype, "id", {
            get: function () {
                return 0;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableDataTreeSorter.prototype, "order", {
            get: function () {
                return DTableDataOrder.ASCENDING;
            },
            set: function (order) {
                // DO NOTHING
            },
            enumerable: false,
            configurable: true
        });
        DTableDataTreeSorter.prototype.apply = function () {
            // DO NOTHING
        };
        DTableDataTreeSorter.prototype.unapply = function () {
            // DO NOTHING
        };
        DTableDataTreeSorter.prototype.isApplied = function () {
            return false;
        };
        DTableDataTreeSorter.prototype.get = function () {
            return null;
        };
        DTableDataTreeSorter.prototype.set = function (comparator) {
            // DO NOTHING
        };
        DTableDataTreeSorter.prototype.toDirty = function () {
            // DO NOTHING
        };
        DTableDataTreeSorter.prototype.update = function () {
            // DO NOTHING
        };
        Object.defineProperty(DTableDataTreeSorter.prototype, "indices", {
            get: function () {
                return null;
            },
            enumerable: false,
            configurable: true
        });
        DTableDataTreeSorter.prototype.map = function (unmappedIndex) {
            return unmappedIndex;
        };
        DTableDataTreeSorter.prototype.unmap = function (index) {
            return index;
        };
        return DTableDataTreeSorter;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2021 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * Please note that this data class does not support the sorter.
     */
    var DTableDataTree = /** @class */ (function (_super) {
        __extends(DTableDataTree, _super);
        function DTableDataTree(options) {
            var _this = _super.call(this) || this;
            _this._parent = null;
            _this._accessor = _this.toAccessor(options);
            _this._mapped = new DTableDataListMapped(_this);
            _this._rows = [];
            _this._isRowsDirty = false;
            _this._supplimentals = [];
            _this._flags = new WeakMap();
            _this._reverse = !!(options === null || options === void 0 ? void 0 : options.reverse);
            _this._selection = _this.toSelection(options === null || options === void 0 ? void 0 : options.selection);
            _this._filter = new DTableDataTreeFilter(_this);
            _this._sorter = new DTableDataTreeSorter();
            if (options) {
                // Filter
                var filter = options.filter;
                if (filter) {
                    _this._filter.set(filter);
                }
                // Events
                var on = options.on;
                if (on) {
                    for (var name_1 in on) {
                        var handler = on[name_1];
                        if (handler) {
                            _this.on(name_1, handler);
                        }
                    }
                }
            }
            // Update rows
            _this.nodes = options === null || options === void 0 ? void 0 : options.nodes;
            return _this;
        }
        DTableDataTree.prototype.toSelection = function (options) {
            if (options instanceof pixi_js.utils.EventEmitter) {
                return options;
            }
            else if (isFunction(options)) {
                return options(this);
            }
            return this.newSelection(options);
        };
        DTableDataTree.prototype.newSelection = function (options) {
            return new DTableDataTreeSelectionImpl(this, options);
        };
        DTableDataTree.prototype.toAccessor = function (options) {
            return new DTableDataTreeItemAccessor(options);
        };
        DTableDataTree.prototype.bind = function (parent) {
            this._parent = parent;
        };
        Object.defineProperty(DTableDataTree.prototype, "nodes", {
            get: function () {
                return this._nodes;
            },
            set: function (nodes) {
                this._nodes = nodes;
                this._isRowsDirty = true;
                this._selection.onNodeChange(nodes);
                this._filter.toDirty();
                this.update(true);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableDataTree.prototype, "rows", {
            get: function () {
                if (this._isRowsDirty) {
                    this._isRowsDirty = false;
                    this.updateRows(this._nodes);
                }
                return this._rows;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableDataTree.prototype, "supplimentals", {
            get: function () {
                return this._supplimentals;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableDataTree.prototype, "accessor", {
            get: function () {
                return this._accessor;
            },
            enumerable: false,
            configurable: true
        });
        DTableDataTree.prototype.updateRows = function (nodes) {
            var rows = this._rows;
            var supplimentals = this._supplimentals;
            var flags = this._flags;
            if (nodes != null) {
                var accessor = this._accessor;
                var irows = this.newRows(nodes, 0, 0, rows, supplimentals, flags, this._reverse, accessor.toChildren, accessor.hasChildren);
                if (irows !== rows.length) {
                    rows.length = irows;
                    supplimentals.length = irows;
                }
            }
            else {
                rows.length = 0;
                supplimentals.length = 0;
            }
        };
        DTableDataTree.prototype.toSupplimental = function (ilevel, hasChildren, isOpened) {
            return (ilevel << 2) | (hasChildren ? 2 : 0) | (isOpened ? 1 : 0);
        };
        DTableDataTree.prototype.newRows = function (nodes, irows, ilevel, rows, supplimentals, flags, reverse, toChildren, hasChildren) {
            var nodesLength = nodes.length;
            var istart = reverse ? nodesLength - 1 : 0;
            var idelta = reverse ? -1 : +1;
            for (var i = istart; 0 <= i && i < nodesLength; i += idelta) {
                var node = nodes[i];
                var children = toChildren(node);
                var isOpened = flags.has(node);
                var supplimental = this.toSupplimental(ilevel, hasChildren(node, children), isOpened);
                if (irows < rows.length) {
                    rows[irows] = node;
                    supplimentals[irows] = supplimental;
                }
                else {
                    rows.push(node);
                    supplimentals.push(supplimental);
                }
                irows += 1;
                if (isOpened && children) {
                    irows = this.newRows(children, irows, ilevel + 1, rows, supplimentals, flags, reverse, toChildren, hasChildren);
                }
            }
            return irows;
        };
        DTableDataTree.prototype.update = function (forcibly) {
            var parent = this._parent;
            if (parent) {
                parent.update(forcibly);
            }
        };
        DTableDataTree.prototype.lock = function () {
            var parent = this._parent;
            if (parent) {
                parent.lock();
            }
        };
        DTableDataTree.prototype.unlock = function (callIfNeeded) {
            var parent = this._parent;
            if (parent) {
                parent.unlock(callIfNeeded);
            }
        };
        DTableDataTree.prototype.size = function () {
            return this.rows.length;
        };
        DTableDataTree.prototype.get = function (index) {
            var rows = this.rows;
            if (0 <= index && index < rows.length) {
                return rows[index];
            }
            return null;
        };
        DTableDataTree.prototype.expand = function (node) {
            var flags = this._flags;
            if (!flags.has(node)) {
                flags.set(node, 1);
                this._isRowsDirty = true;
                this._filter.toDirty();
                this.update(true);
                return true;
            }
            return false;
        };
        DTableDataTree.prototype.collapse = function (node) {
            var flags = this._flags;
            if (flags.has(node)) {
                flags.delete(node);
                this._isRowsDirty = true;
                this._filter.toDirty();
                this.update(true);
                return true;
            }
            return false;
        };
        DTableDataTree.prototype.isCollapsed = function (node) {
            return !this._flags.has(node);
        };
        DTableDataTree.prototype.isExpanded = function (node) {
            return this._flags.has(node);
        };
        DTableDataTree.prototype.toggle = function (node) {
            if (this.isExpanded(node)) {
                return this.collapse(node);
            }
            else {
                return this.expand(node);
            }
        };
        /** @deprecated in favor of {@link expand}. */
        DTableDataTree.prototype.open = function (node) {
            return this.expand(node);
        };
        /** @deprecated in favor of {@link collapse}. */
        DTableDataTree.prototype.close = function (node) {
            return this.collapse(node);
        };
        /** @deprecated in favor of {@link isExpanded}. */
        DTableDataTree.prototype.isOpened = function (node) {
            return this.isExpanded(node);
        };
        DTableDataTree.prototype.each = function (iteratee, ifrom, ito) {
            var rows = this.rows;
            ifrom = ifrom != null ? Math.max(0, ifrom) : 0;
            ito = ito != null ? Math.min(rows.length, ito) : rows.length;
            for (var i = ifrom; i < ito; ++i) {
                var row = rows[i];
                if (iteratee(row, i) === false) {
                    break;
                }
            }
        };
        Object.defineProperty(DTableDataTree.prototype, "selection", {
            get: function () {
                return this._selection;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableDataTree.prototype, "filter", {
            get: function () {
                return this._filter;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableDataTree.prototype, "sorter", {
            get: function () {
                return this._sorter;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableDataTree.prototype, "mapped", {
            get: function () {
                return this._mapped;
            },
            enumerable: false,
            configurable: true
        });
        return DTableDataTree;
    }(pixi_js.utils.EventEmitter));

    var DTableHeaderCellCheck = /** @class */ (function () {
        function DTableHeaderCellCheck(parent, options) {
            var _a, _b, _c;
            this._parent = parent;
            this._isEnabled = (_a = options === null || options === void 0 ? void 0 : options.enable) !== null && _a !== void 0 ? _a : false;
            this._isFilterable = (_b = options === null || options === void 0 ? void 0 : options.filterable) !== null && _b !== void 0 ? _b : true;
            this._isEmittable = (_c = options === null || options === void 0 ? void 0 : options.emittable) !== null && _c !== void 0 ? _c : true;
        }
        Object.defineProperty(DTableHeaderCellCheck.prototype, "isEnabled", {
            get: function () {
                return this._isEnabled;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableHeaderCellCheck.prototype, "isFilterable", {
            get: function () {
                return this._isFilterable;
            },
            set: function (isFilterable) {
                this._isFilterable = isFilterable;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableHeaderCellCheck.prototype, "isEmittable", {
            get: function () {
                return this._isEmittable;
            },
            set: function (isEmittable) {
                this._isEmittable = isEmittable;
            },
            enumerable: false,
            configurable: true
        });
        DTableHeaderCellCheck.prototype.newIteratee = function (table, isChecked) {
            var parent = this._parent;
            var column = parent.column;
            var columnIndex = parent.columnIndex;
            if (column != null && columnIndex != null) {
                var getter_1 = column.getter;
                var setter_1 = column.setter;
                if (this._isEmittable) {
                    var data_1 = table.data;
                    return function (row, rowIndex) {
                        if (getter_1(row, columnIndex) !== isChecked) {
                            setter_1(row, columnIndex, isChecked);
                            data_1.emit("change", isChecked, !isChecked, row, rowIndex, columnIndex, data_1);
                            return true;
                        }
                        return false;
                    };
                }
                else {
                    return function (row) {
                        if (getter_1(row, columnIndex) !== isChecked) {
                            setter_1(row, columnIndex, isChecked);
                            return true;
                        }
                        return false;
                    };
                }
            }
            return null;
        };
        DTableHeaderCellCheck.prototype.execute = function (isChecked) {
            var _a;
            var table = (_a = this._parent.header) === null || _a === void 0 ? void 0 : _a.table;
            if (table) {
                var iteratee_1 = this.newIteratee(table, isChecked);
                if (iteratee_1) {
                    var isChanged_1 = false;
                    if (this._isFilterable) {
                        table.data.mapped.each(function (row, supplimental, index, unmappedIndex) {
                            if (iteratee_1(row, unmappedIndex)) {
                                isChanged_1 = true;
                            }
                        });
                    }
                    else {
                        table.data.each(function (row, index) {
                            if (iteratee_1(row, index)) {
                                isChanged_1 = true;
                            }
                        });
                    }
                    if (isChanged_1) {
                        table.body.update(true);
                    }
                }
            }
        };
        return DTableHeaderCellCheck;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableHeaderCell = /** @class */ (function (_super) {
        __extends(DTableHeaderCell, _super);
        function DTableHeaderCell(header, columnIndex, column, options) {
            var _this = _super.call(this, options) || this;
            _this._header = header;
            _this._column = column;
            _this._columnIndex = columnIndex;
            var check = new DTableHeaderCellCheck(_this, options === null || options === void 0 ? void 0 : options.check);
            _this._check = check;
            _this._edge = new DTableCellEdge(_this._header, _this, columnIndex, _this.theme.getEdgeWidth());
            var sortable = column.sorting.enable;
            var checkable = check.isEnabled;
            if (checkable || sortable) {
                _this.on(UtilPointerEvent.tap, function (e) {
                    _this.onClick(e);
                });
                var state = _this.state;
                state.lock();
                state.set(DTableState.SORTABLE, sortable);
                state.set(DTableState.CHECKABLE, checkable);
                state.unlock();
            }
            return _this;
        }
        Object.defineProperty(DTableHeaderCell.prototype, "column", {
            get: function () {
                return this._column;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableHeaderCell.prototype, "columnIndex", {
            get: function () {
                return this._columnIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableHeaderCell.prototype, "header", {
            get: function () {
                return this._header;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableHeaderCell.prototype, "check", {
            get: function () {
                return this._check;
            },
            enumerable: false,
            configurable: true
        });
        DTableHeaderCell.prototype.onDown = function (e) {
            if (!this._edge.onDown(e)) {
                _super.prototype.onDown.call(this, e);
            }
        };
        DTableHeaderCell.prototype.onOver = function (e) {
            _super.prototype.onOver.call(this, e);
            this._edge.onOver(e);
        };
        DTableHeaderCell.prototype.onOut = function (e) {
            _super.prototype.onOut.call(this, e);
            this._edge.onOut(e);
        };
        Object.defineProperty(DTableHeaderCell.prototype, "sorter", {
            get: function () {
                var _this = this;
                var sorter = this._sorter;
                if (sorter == null) {
                    var header = this._header;
                    if (header) {
                        var table = header.table;
                        if (table) {
                            sorter = table.data.sorter;
                            this._sorter = sorter;
                            this._onSorterChangeBound =
                                this._onSorterChangeBound ||
                                    (function () {
                                        _this.onSorterChange();
                                    });
                            sorter.on("change", this._onSorterChangeBound);
                        }
                        else {
                            return null;
                        }
                    }
                    else {
                        return null;
                    }
                }
                return sorter;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableHeaderCell.prototype, "comparator", {
            get: function () {
                return this._column.sorting.comparator || null;
            },
            enumerable: false,
            configurable: true
        });
        DTableHeaderCell.prototype.onSorterChange = function () {
            var comparator = this.comparator;
            if (comparator) {
                var sorter = this._sorter;
                if (sorter) {
                    var SORTED_ASCENDING = DTableState.SORTED_ASCENDING;
                    var SORTED_DESCENDING = DTableState.SORTED_DESCENDING;
                    if (sorter.isApplied() && sorter.get() === comparator) {
                        if (sorter.order === DTableDataOrder.ASCENDING) {
                            this.state.set(SORTED_ASCENDING, SORTED_DESCENDING);
                        }
                        else {
                            this.state.set(SORTED_DESCENDING, SORTED_ASCENDING);
                        }
                    }
                    else {
                        this.state.removeAll(SORTED_ASCENDING, SORTED_DESCENDING);
                    }
                }
            }
        };
        DTableHeaderCell.prototype.toClickPosition = function (e) {
            var _a;
            var checkWork = ((_a = this._checkWork) !== null && _a !== void 0 ? _a : (this._checkWork = new pixi_js.Point()));
            return e.data.getLocalPosition(this, checkWork).x;
        };
        DTableHeaderCell.prototype.isCheckClicked = function (e) {
            if (e instanceof pixi_js.InteractionEvent && this._check.isEnabled) {
                if (this.isSortable) {
                    var image = this.image.get(1);
                    if (image) {
                        var position = this.toClickPosition(e);
                        var object = image.object;
                        if (object != null) {
                            var bound = object.getLocalBounds();
                            var margin = image.margin.horizontal;
                            var x = object.x;
                            return (x + bound.left - margin <= position &&
                                position <= x + bound.right + margin);
                        }
                    }
                }
                else {
                    return true;
                }
            }
            return false;
        };
        DTableHeaderCell.prototype.onClick = function (e) {
            if (this.state.isActionable) {
                this.activate(e);
            }
        };
        DTableHeaderCell.prototype.activate = function (e) {
            this.onActivate(e);
        };
        DTableHeaderCell.prototype.onActivate = function (e) {
            if (!this._edge.isClicked(e)) {
                if (this.isCheckClicked(e)) {
                    this.onToggleStart();
                    this.onToggleEnd();
                }
                else {
                    this.doSort(e);
                    this.emit("active", this);
                }
            }
        };
        DTableHeaderCell.prototype.doSort = function (e) {
            if (this.isSortable) {
                var comparator = this.comparator;
                if (comparator) {
                    var sorter = this.sorter;
                    if (sorter) {
                        if (sorter.get() === comparator) {
                            if (sorter.order === DTableDataOrder.ASCENDING) {
                                sorter.order = DTableDataOrder.DESCENDING;
                                sorter.apply();
                            }
                            else {
                                sorter.set(null);
                                sorter.apply();
                            }
                        }
                        else {
                            sorter.set(comparator);
                            sorter.order = DTableDataOrder.ASCENDING;
                            sorter.apply();
                        }
                    }
                }
            }
        };
        Object.defineProperty(DTableHeaderCell.prototype, "isSortable", {
            get: function () {
                return this._column.sorting.enable;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableHeaderCell.prototype, "isResizable", {
            get: function () {
                return this._column.resizable;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableHeaderCell.prototype, "isToggle", {
            get: function () {
                return this._check.isEnabled;
            },
            enumerable: false,
            configurable: true
        });
        DTableHeaderCell.prototype.toggle = function () {
            if (this.state.isActionable) {
                if (this.isToggle) {
                    this.onToggleStart();
                    this.onToggleEnd();
                }
            }
        };
        DTableHeaderCell.prototype.onToggleStart = function () {
            this.state.isActive = !this.state.isActive;
        };
        DTableHeaderCell.prototype.onToggleEnd = function () {
            if (this.state.isActive) {
                this._check.execute(true);
                this.emit("active", this);
            }
            else {
                this._check.execute(false);
                this.emit("inactive", this);
            }
        };
        DTableHeaderCell.prototype.onActivateKeyDown = function (e) {
            if (this.state.isActionable) {
                if (this.isToggle) {
                    this.onToggleStart();
                }
                else {
                    this.state.isPressed = true;
                }
            }
        };
        DTableHeaderCell.prototype.onActivateKeyUp = function (e) {
            if (this.state.isActionable) {
                if (this.isToggle) {
                    this.onToggleEnd();
                }
                else {
                    if (this.state.isPressed) {
                        this.activate(e);
                    }
                    this.state.isPressed = false;
                }
            }
        };
        DTableHeaderCell.prototype.onKeyDown = function (e) {
            if (UtilKeyboardEvent.isActivateKey(e)) {
                this.onActivateKeyDown(e);
            }
            return _super.prototype.onKeyDown.call(this, e);
        };
        DTableHeaderCell.prototype.onKeyUp = function (e) {
            if (UtilKeyboardEvent.isActivateKey(e)) {
                this.onActivateKeyUp(e);
            }
            return _super.prototype.onKeyUp.call(this, e);
        };
        DTableHeaderCell.prototype.getType = function () {
            return "DTableHeaderCell";
        };
        DTableHeaderCell.prototype.destroy = function () {
            var sorter = this._sorter;
            var onSorterChangeBound = this._onSorterChangeBound;
            if (sorter && onSorterChangeBound) {
                sorter.off("change", onSorterChangeBound);
            }
            this._sorter = undefined;
            this._onSorterChangeBound = undefined;
            _super.prototype.destroy.call(this);
        };
        return DTableHeaderCell;
    }(DImage));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableHeader = /** @class */ (function (_super) {
        __extends(DTableHeader, _super);
        function DTableHeader(table, columns, frozen, offset, options) {
            var _this = _super.call(this, columns, frozen, options) || this;
            _this._table = table;
            _this._offset = offset;
            _this.transform.position.y = offset;
            _this.initCells();
            return _this;
        }
        Object.defineProperty(DTableHeader.prototype, "table", {
            get: function () {
                return this._table;
            },
            enumerable: false,
            configurable: true
        });
        DTableHeader.prototype.onParentMove = function (newX, newY, oldX, oldY) {
            _super.prototype.onParentMove.call(this, newX, newY, oldX, oldY);
            this.transform.position.y = -newY + this._offset;
            this.updateFrozenCellPosition(newX);
        };
        DTableHeader.prototype.getContentPositionX = function () {
            var content = this.parent;
            if (content) {
                return content.position.x;
            }
            return 0;
        };
        DTableHeader.prototype.newCell = function (columnIndex, column, columns, options) {
            return new DTableHeaderCell(this, columnIndex, column, this.toCellOptions(column, options));
        };
        DTableHeader.prototype.toCellOptions = function (column, options) {
            var result = column.header || (options === null || options === void 0 ? void 0 : options.cell);
            if (result != null) {
                if (result.weight === undefined) {
                    result.weight = column.weight;
                }
                if (result.width === undefined) {
                    result.width = column.width;
                }
                if (result.text === undefined) {
                    result.text = {
                        value: column.label
                    };
                }
                else if (result.text.value === undefined) {
                    result.text.value = column.label;
                }
                return result;
            }
            else {
                return {
                    weight: column.weight,
                    width: column.width,
                    text: {
                        value: column.label
                    }
                };
            }
        };
        DTableHeader.prototype.getType = function () {
            return "DTableHeader";
        };
        return DTableHeader;
    }(DTableRow));

    var DTableScrollBar = /** @class */ (function (_super) {
        __extends(DTableScrollBar, _super);
        function DTableScrollBar() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DTableScrollBar.prototype.getOffsetVerticalStart = function (size) {
            return size * 0.5 + this._parent.body.position.y;
        };
        return DTableScrollBar;
    }(DPaneScrollBar));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTable = /** @class */ (function (_super) {
        __extends(DTable, _super);
        function DTable(options) {
            var _this = _super.call(this, options) || this;
            var content = _this.content;
            var body = _this.body;
            content.addChild(body);
            if (body.data.selection.type !== DTableDataSelectionType.NONE) {
                _this.on(UtilPointerEvent.tap, function (e) {
                    body.onRowClick(e);
                });
            }
            var header = _this.header;
            if (header) {
                content.addChild(header);
            }
            var categories = _this.categories;
            for (var i = categories.length - 1; 0 <= i; --i) {
                content.addChild(categories[i]);
            }
            body.update();
            return _this;
        }
        Object.defineProperty(DTable.prototype, "column", {
            get: function () {
                var _a;
                return ((_a = this._column) !== null && _a !== void 0 ? _a : (this._column = this.newColumn()));
            },
            enumerable: false,
            configurable: true
        });
        DTable.prototype.newColumn = function () {
            var _a;
            return new DTableColumnContainerImpl(this, (_a = this._options) === null || _a === void 0 ? void 0 : _a.columns);
        };
        Object.defineProperty(DTable.prototype, "columns", {
            get: function () {
                return this.column.items;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTable.prototype, "frozen", {
            get: function () {
                return this.column.frozen;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTable.prototype, "category", {
            get: function () {
                var _a;
                return ((_a = this._category) !== null && _a !== void 0 ? _a : (this._category = this.newCategory()));
            },
            enumerable: false,
            configurable: true
        });
        DTable.prototype.newCategory = function () {
            var _a;
            var column = this.column;
            return new DTableCategoryContainerImpl(column.items, column.frozen, (_a = this._options) === null || _a === void 0 ? void 0 : _a.category);
        };
        Object.defineProperty(DTable.prototype, "categories", {
            get: function () {
                return this.category.items;
            },
            enumerable: false,
            configurable: true
        });
        DTable.prototype.initContent = function (content) {
            _super.prototype.initContent.call(this, content);
            content.state.isFocusReverse = true;
        };
        DTable.prototype.onContentChange = function () {
            _super.prototype.onContentChange.call(this);
            this.body.update();
        };
        DTable.prototype.onResize = function (newWidth, newHeight, oldWidth, oldHeight) {
            var scrollbar = this.scrollbar;
            scrollbar.lock();
            var body = this.body;
            body.lock();
            _super.prototype.onResize.call(this, newWidth, newHeight, oldWidth, oldHeight);
            body.update();
            body.unlock(true);
            scrollbar.unlock(true);
        };
        DTable.prototype.onDblClick = function (e, interactionManager) {
            var result = this.body.onDblClick(e, interactionManager);
            return _super.prototype.onDblClick.call(this, e, interactionManager) || result;
        };
        DTable.prototype.newScrollBar = function (options) {
            var _this = this;
            return new DTableScrollBar(this, options, function (isRegionVisible) {
                _this.onScrollBarUpdate(isRegionVisible);
            });
        };
        DTable.prototype.newContent = function (options) {
            var _this = this;
            var result = _super.prototype.newContent.call(this, options);
            // X & Width
            var column = this.column;
            var columnWidth = column.width;
            if (0 < columnWidth) {
                column.on("resize", function () {
                    columnWidth = column.width;
                    var parentWidth = _this.width;
                    var parentHeight = _this.height;
                    var newWidth = Math.max(parentWidth, columnWidth);
                    var newXMin = parentWidth - newWidth;
                    // The X position must be in [newXMin, 0].
                    if (result.x < newXMin) {
                        result.x = newXMin;
                    }
                    // Force the with reevaluated
                    result.onParentResize(parentWidth, parentHeight, _this.padding);
                });
                result.setWidth(function (p) {
                    return Math.max(p, columnWidth);
                });
            }
            else {
                result.setWidth("100%");
            }
            // Done
            return result;
        };
        DTable.prototype.getHeaderOffset = function () {
            var result = this._headerOffset;
            if (result == null) {
                result = this.newHeaderOffset();
                this._headerOffset = result;
            }
            return result;
        };
        DTable.prototype.newHeaderOffset = function () {
            var result = 0;
            var categories = this.categories;
            for (var i = 0, imax = categories.length; i < imax; ++i) {
                result += categories[i].height;
            }
            return result;
        };
        Object.defineProperty(DTable.prototype, "header", {
            get: function () {
                var result = this._header;
                if (result === undefined) {
                    result = this.newHeader();
                    this._header = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DTable.prototype.hasHeader = function (options) {
            if (options) {
                var columns = options.columns;
                for (var i = 0, imax = columns.length; i < imax; ++i) {
                    if (columns[i].label != null) {
                        return true;
                    }
                }
            }
            return false;
        };
        DTable.prototype.newHeader = function () {
            var options = this._options;
            if (this.hasHeader(options)) {
                var column = this.column;
                return new DTableHeader(this, column.items, column.frozen, this.getHeaderOffset(), options === null || options === void 0 ? void 0 : options.header);
            }
            return null;
        };
        DTable.prototype.getBodyOffset = function () {
            var _a;
            return ((_a = this._bodyOffset) !== null && _a !== void 0 ? _a : (this._bodyOffset = this.newBodyOffset()));
        };
        DTable.prototype.newBodyOffset = function () {
            var _a, _b;
            return this.getHeaderOffset() + ((_b = (_a = this.header) === null || _a === void 0 ? void 0 : _a.height) !== null && _b !== void 0 ? _b : 0);
        };
        Object.defineProperty(DTable.prototype, "body", {
            get: function () {
                var _a;
                return ((_a = this._body) !== null && _a !== void 0 ? _a : (this._body = this.newBody()));
            },
            enumerable: false,
            configurable: true
        });
        DTable.prototype.newBody = function () {
            var options = this._options;
            var column = this.column;
            return new DTableBody(column.items, column.frozen, this.getBodyOffset(), this.toBodyOptions(options === null || options === void 0 ? void 0 : options.body, options === null || options === void 0 ? void 0 : options.data));
        };
        DTable.prototype.toBodyOptions = function (options, data) {
            if (options != null) {
                if (options.data === undefined && data !== undefined) {
                    if (isArray(data)) {
                        options.data = {
                            rows: data
                        };
                    }
                    else {
                        options.data = data;
                    }
                }
                if (options.height === undefined && options.weight === undefined) {
                    options.weight = 1;
                }
                return options;
            }
            if (isArray(data)) {
                return {
                    data: {
                        rows: data
                    },
                    weight: 1
                };
            }
            else {
                return {
                    data: data,
                    weight: 1
                };
            }
        };
        Object.defineProperty(DTable.prototype, "data", {
            get: function () {
                return this.body.data;
            },
            enumerable: false,
            configurable: true
        });
        DTable.prototype.getFocusedChildClippingRect = function (focused, contentX, contentY, contentWidth, contentHeight, width, height, result) {
            _super.prototype.getFocusedChildClippingRect.call(this, focused, contentX, contentY, contentWidth, contentHeight, width, height, result);
            var cell = this.toCell(focused);
            if (cell) {
                // X
                var dx = contentX + this.toFrozenCellX(cell) - result.x;
                if (0 < dx) {
                    result.x += dx;
                    result.width -= dx;
                }
                // Y
                if (cell.parent.parent === this.body) {
                    var dy = this.getBodyOffset();
                    result.y += dy;
                    result.height -= dy;
                }
            }
            // Done
            return result;
        };
        DTable.prototype.toFrozenCellX = function (cell) {
            var frozen = this.frozen;
            if (0 < frozen) {
                var cells = cell.parent.children;
                var cellIndex = cells.indexOf(cell);
                if (0 <= cellIndex) {
                    var cellsLength = cells.length;
                    var columnIndex = cellsLength - 1 - cellIndex;
                    if (frozen <= columnIndex) {
                        var cellFrozen = cells[cellsLength - frozen];
                        return cellFrozen.position.x + cellFrozen.width;
                    }
                }
            }
            return 0;
        };
        DTable.prototype.onKeyDown = function (e) {
            UtilKeyboardEvent.moveFocusHorizontally(e, this);
            var isArrowUpKey = UtilKeyboardEvent.isArrowUpKey(e);
            var isArrowDownKey = UtilKeyboardEvent.isArrowDownKey(e);
            if (isArrowUpKey || isArrowDownKey) {
                this.onKeyDownArrowUpOrDown(e, isArrowDownKey);
            }
            return _super.prototype.onKeyDown.call(this, e);
        };
        DTable.prototype.onKeyDownArrowUpOrDown = function (e, isDown) {
            var layer = DApplications.getLayer(this);
            if (layer == null) {
                return false;
            }
            var focusController = layer.getFocusController();
            var oldFocusable = focusController.get();
            if (oldFocusable == null) {
                return false;
            }
            var oldCell = this.toCell(oldFocusable);
            if (oldCell == null) {
                return false;
            }
            var oldRow = oldCell.parent;
            if (oldRow == null) {
                return false;
            }
            var newRowChild = focusController.find(oldRow, false, false, isDown, this);
            if (newRowChild == null) {
                return false;
            }
            var newCellSibling = this.toCell(newRowChild);
            if (newCellSibling == null) {
                return false;
            }
            var newRow = newCellSibling.parent;
            if (newRow == null) {
                return false;
            }
            var oldCellIndex = oldRow.children.indexOf(oldCell);
            if (oldCellIndex < 0) {
                return false;
            }
            var newCell = newRow.children[oldCellIndex];
            if (newCell == null || newCell === oldCell || !("state" in newCell)) {
                return false;
            }
            var newFocusable = focusController.find(newCell, true, true, isDown, this);
            if (newFocusable == null) {
                return false;
            }
            focusController.focus(newFocusable);
            return true;
        };
        DTable.prototype.toCell = function (focused) {
            var current = focused;
            while (current != null) {
                var parent_1 = current.parent;
                if (parent_1 instanceof DTableRow) {
                    if (current instanceof DBase) {
                        return current;
                    }
                    return null;
                }
                current = parent_1;
            }
            return null;
        };
        DTable.prototype.getType = function () {
            return "DTable";
        };
        return DTable;
    }(DPane));

    /*
     * Copyright (C) 2021 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var toLabel = function (item) {
        var text = item.text;
        if (isString(text)) {
            return text;
        }
        var label = item.label;
        if (isString(label)) {
            return label;
        }
        var name = item.name;
        if (isString(name)) {
            return name;
        }
        return undefined;
    };
    var toTitle = function (item) {
        var title = item.title;
        if (isString(title)) {
            return title;
        }
        return undefined;
    };
    var toImage = function (item) {
        return item.image;
    };
    var toChildren = function (item) {
        return item.children;
    };
    var newChildren = function (item) {
        return (item.children = []);
    };
    var DTreeNodeAccessorImpl = /** @class */ (function () {
        function DTreeNodeAccessorImpl(options) {
            var _a, _b, _c, _d, _e;
            this.toLabel = (_a = options === null || options === void 0 ? void 0 : options.toLabel) !== null && _a !== void 0 ? _a : toLabel;
            this.toTitle = (_b = options === null || options === void 0 ? void 0 : options.toTitle) !== null && _b !== void 0 ? _b : toTitle;
            this.toImage = (_c = options === null || options === void 0 ? void 0 : options.toImage) !== null && _c !== void 0 ? _c : toImage;
            this.toChildren = (_d = options === null || options === void 0 ? void 0 : options.toChildren) !== null && _d !== void 0 ? _d : toChildren;
            this.newChildren = (_e = options === null || options === void 0 ? void 0 : options.newChildren) !== null && _e !== void 0 ? _e : newChildren;
        }
        return DTreeNodeAccessorImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * {@link DTreeDataSelection} type.
     */
    var DTreeDataSelectionType = {
        NONE: 0,
        SINGLE: 1,
        MULTIPLE: 2
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTreeDataMappedImpl = /** @class */ (function () {
        function DTreeDataMappedImpl(parent, reverse) {
            this._parent = parent;
            this._nodes = [];
            this._levels = [];
            this._reverse = reverse;
            this._isDirty = false;
        }
        Object.defineProperty(DTreeDataMappedImpl.prototype, "nodes", {
            get: function () {
                this.update();
                return this._nodes;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTreeDataMappedImpl.prototype, "levels", {
            get: function () {
                this.update();
                return this._levels;
            },
            enumerable: false,
            configurable: true
        });
        DTreeDataMappedImpl.prototype.toDirty = function () {
            this._isDirty = true;
        };
        DTreeDataMappedImpl.prototype.size = function () {
            this.update();
            return this._nodes.length;
        };
        DTreeDataMappedImpl.prototype.each = function (iteratee, from, to) {
            this.update();
            var nodes = this._nodes;
            var ifrom = from != null ? Math.max(0, from) : 0;
            var ito = to != null ? Math.min(nodes.length, to) : nodes.length;
            for (var i = ifrom; i < ito; ++i) {
                if (iteratee(nodes[i], i) === false) {
                    break;
                }
            }
        };
        DTreeDataMappedImpl.prototype.update = function () {
            if (this._isDirty) {
                this._isDirty = false;
                var parent_1 = this._parent;
                var parentNodes = parent_1.nodes;
                var toChildren = parent_1.accessor.toChildren;
                var nodes = this._nodes;
                var levels = this._levels;
                var size = this.newNodes(parent_1, parentNodes, 0, 0, nodes, levels, this._reverse, toChildren);
                if (nodes.length !== size) {
                    nodes.length = size;
                    levels.length = size;
                }
            }
        };
        DTreeDataMappedImpl.prototype.newNodes = function (parent, parentNodes, index, level, nodes, levels, reverse, toChildren) {
            var parentNodesLength = parentNodes.length;
            var istart = reverse ? parentNodesLength - 1 : 0;
            var idelta = reverse ? -1 : +1;
            for (var i = istart; 0 <= i && i < parentNodesLength; i += idelta) {
                var parentNode = parentNodes[i];
                if (index < nodes.length) {
                    nodes[index] = parentNode;
                    levels[index] = level;
                }
                else {
                    nodes.push(parentNode);
                    levels.push(level);
                }
                index += 1;
                var children = toChildren(parentNode);
                if (children && parent.isExpanded(parentNode)) {
                    index = this.newNodes(parent, children, index, level + 1, nodes, levels, reverse, toChildren);
                }
            }
            return index;
        };
        return DTreeDataMappedImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTreeDataSelectionMultiple = /** @class */ (function (_super) {
        __extends(DTreeDataSelectionMultiple, _super);
        function DTreeDataSelectionMultiple(parent, options) {
            var _this = _super.call(this) || this;
            _this._parent = parent;
            _this._nodes = new Set();
            // Events
            var on = options === null || options === void 0 ? void 0 : options.on;
            if (on) {
                for (var name_1 in on) {
                    var handler = on[name_1];
                    if (handler) {
                        _this.on(name_1, handler);
                    }
                }
            }
            return _this;
        }
        Object.defineProperty(DTreeDataSelectionMultiple.prototype, "type", {
            get: function () {
                return DTreeDataSelectionType.MULTIPLE;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTreeDataSelectionMultiple.prototype, "first", {
            get: function () {
                var nodes = this._nodes;
                if (0 < nodes.size) {
                    var result_1 = null;
                    nodes.forEach(function (item) {
                        if (result_1 == null) {
                            result_1 = item;
                        }
                    });
                    return result_1;
                }
                return null;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTreeDataSelectionMultiple.prototype, "last", {
            get: function () {
                var nodes = this._nodes;
                if (0 < nodes.size) {
                    var result_2 = null;
                    nodes.forEach(function (row) {
                        result_2 = row;
                    });
                    return result_2;
                }
                return null;
            },
            enumerable: false,
            configurable: true
        });
        DTreeDataSelectionMultiple.prototype.get = function (index) {
            var nodes = this._nodes;
            if (0 <= index && index < nodes.size) {
                var counter_1 = 0;
                var result_3 = null;
                nodes.forEach(function (node) {
                    if (counter_1 === index) {
                        result_3 = node;
                    }
                    counter_1 += 1;
                });
                return result_3;
            }
            return null;
        };
        DTreeDataSelectionMultiple.prototype.add = function (target) {
            var nodes = this._nodes;
            if (!nodes.has(target)) {
                nodes.add(target);
                this.onChange();
                return true;
            }
            return false;
        };
        DTreeDataSelectionMultiple.prototype.remove = function (target) {
            var nodes = this._nodes;
            if (nodes.has(target)) {
                nodes.delete(target);
                this.onChange();
                return true;
            }
            return false;
        };
        DTreeDataSelectionMultiple.prototype.toggle = function (target) {
            var nodes = this._nodes;
            if (nodes.has(target)) {
                nodes.delete(target);
            }
            else {
                nodes.add(target);
            }
            this.onChange();
            return true;
        };
        DTreeDataSelectionMultiple.prototype.clear = function () {
            var nodes = this._nodes;
            if (0 < nodes.size) {
                nodes.clear();
                this.onChange();
                return true;
            }
            return false;
        };
        DTreeDataSelectionMultiple.prototype.clearAndAdd = function (target) {
            var nodes = this._nodes;
            var size = nodes.size;
            if (size === 1) {
                if (nodes.has(target)) {
                    return false;
                }
                else {
                    nodes.clear();
                    nodes.add(target);
                    this.onChange();
                    return true;
                }
            }
            else {
                nodes.clear();
                nodes.add(target);
                this.onChange();
                return true;
            }
        };
        DTreeDataSelectionMultiple.prototype.clearAndAddAll = function (targets) {
            var isDirty = false;
            var newNodes = new Set();
            var oldNodes = this._nodes;
            for (var i = 0, imax = targets.length; i < imax; ++i) {
                var target = targets[i];
                if (!oldNodes.has(target)) {
                    isDirty = true;
                }
                newNodes.add(target);
            }
            if (!isDirty) {
                oldNodes.forEach(function (oldItem) {
                    if (!newNodes.has(oldItem)) {
                        isDirty = true;
                    }
                });
            }
            if (isDirty) {
                this._nodes = newNodes;
                this.onChange();
            }
            return isDirty;
        };
        DTreeDataSelectionMultiple.prototype.contains = function (target) {
            return this._nodes.has(target);
        };
        DTreeDataSelectionMultiple.prototype.size = function () {
            return this._nodes.size;
        };
        DTreeDataSelectionMultiple.prototype.isEmpty = function () {
            return this._nodes.size <= 0;
        };
        DTreeDataSelectionMultiple.prototype.each = function (iteratee) {
            var isCanceled = false;
            this._nodes.forEach(function (item) {
                if (!isCanceled) {
                    if (iteratee(item) === false) {
                        isCanceled = true;
                    }
                }
            });
        };
        DTreeDataSelectionMultiple.prototype.toArray = function () {
            var result = [];
            this._nodes.forEach(function (item) {
                result.push(item);
            });
            return result;
        };
        DTreeDataSelectionMultiple.prototype.onChange = function () {
            this._parent.update();
            this.emit("change", this);
        };
        DTreeDataSelectionMultiple.prototype.onNodeChange = function (nodes) {
            var oldNodes = this._nodes;
            if (0 < oldNodes.size) {
                var newNodes = this.newNodes(nodes, oldNodes, new Set());
                if (oldNodes.size !== newNodes.size) {
                    this._nodes = newNodes;
                    this.onChange();
                }
            }
        };
        DTreeDataSelectionMultiple.prototype.newNodes = function (items, existing, result) {
            var toChildren = this._parent.accessor.toChildren;
            for (var i = 0, imax = items.length; i < imax; ++i) {
                var item = items[i];
                if (existing.has(item)) {
                    result.add(item);
                }
                var children = toChildren(item);
                if (children) {
                    this.newNodes(children, existing, result);
                }
            }
            return result;
        };
        return DTreeDataSelectionMultiple;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTreeDataSelectionSingle = /** @class */ (function (_super) {
        __extends(DTreeDataSelectionSingle, _super);
        function DTreeDataSelectionSingle(parent, options) {
            var _this = _super.call(this) || this;
            _this._parent = parent;
            _this._node = null;
            // Events
            var on = options === null || options === void 0 ? void 0 : options.on;
            if (on) {
                for (var name_1 in on) {
                    var handler = on[name_1];
                    if (handler) {
                        _this.on(name_1, handler);
                    }
                }
            }
            return _this;
        }
        Object.defineProperty(DTreeDataSelectionSingle.prototype, "type", {
            get: function () {
                return DTreeDataSelectionType.SINGLE;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTreeDataSelectionSingle.prototype, "first", {
            get: function () {
                return this._node;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTreeDataSelectionSingle.prototype, "last", {
            get: function () {
                return this._node;
            },
            enumerable: false,
            configurable: true
        });
        DTreeDataSelectionSingle.prototype.get = function (index) {
            if (index === 0) {
                return this._node;
            }
            return null;
        };
        DTreeDataSelectionSingle.prototype.add = function (target) {
            if (this._node !== target) {
                this._node = target;
                this.onChange();
                return true;
            }
            return false;
        };
        DTreeDataSelectionSingle.prototype.remove = function (target) {
            if (this._node === target) {
                this._node = null;
                this.onChange();
                return true;
            }
            return false;
        };
        DTreeDataSelectionSingle.prototype.toggle = function (target) {
            if (this._node === target) {
                this._node = null;
            }
            else {
                this._node = target;
            }
            this.onChange();
            return true;
        };
        DTreeDataSelectionSingle.prototype.clear = function () {
            if (this._node != null) {
                this._node = null;
                this.onChange();
                return true;
            }
            return false;
        };
        DTreeDataSelectionSingle.prototype.clearAndAdd = function (target) {
            if (this._node === target) {
                return false;
            }
            else {
                this._node = target;
                this.onChange();
                return true;
            }
        };
        DTreeDataSelectionSingle.prototype.clearAndAddAll = function (targets) {
            if (0 < targets.length) {
                var last = targets[targets.length - 1];
                return this.clearAndAdd(last);
            }
            else {
                return this.clear();
            }
        };
        DTreeDataSelectionSingle.prototype.contains = function (target) {
            return this._node === target;
        };
        DTreeDataSelectionSingle.prototype.size = function () {
            return this._node != null ? 1 : 0;
        };
        DTreeDataSelectionSingle.prototype.isEmpty = function () {
            return this._node == null;
        };
        DTreeDataSelectionSingle.prototype.each = function (iteratee) {
            var node = this._node;
            if (node != null) {
                iteratee(node);
            }
        };
        DTreeDataSelectionSingle.prototype.toArray = function () {
            var node = this._node;
            if (node != null) {
                return [node];
            }
            return [];
        };
        DTreeDataSelectionSingle.prototype.onChange = function () {
            this._parent.update();
            this.emit("change", this);
        };
        DTreeDataSelectionSingle.prototype.onNodeChange = function (nodes) {
            var oldNode = this._node;
            if (oldNode != null) {
                var newNode = this.newNode(nodes, oldNode);
                if (oldNode !== newNode) {
                    this._node = newNode;
                    this.onChange();
                }
            }
        };
        DTreeDataSelectionSingle.prototype.newNode = function (items, existing) {
            var toChildren = this._parent.accessor.toChildren;
            for (var i = 0, imax = items.length; i < imax; ++i) {
                var item = items[i];
                if (existing === item) {
                    return item;
                }
                var children = toChildren(item);
                if (children) {
                    var result = this.newNode(children, existing);
                    if (result != null) {
                        return result;
                    }
                }
            }
            return null;
        };
        return DTreeDataSelectionSingle;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTreeDataSelectionNone = /** @class */ (function (_super) {
        __extends(DTreeDataSelectionNone, _super);
        function DTreeDataSelectionNone(parent, options) {
            var _this = _super.call(this) || this;
            _this._parent = parent;
            // Events
            var on = options === null || options === void 0 ? void 0 : options.on;
            if (on) {
                for (var name_1 in on) {
                    var handler = on[name_1];
                    if (handler) {
                        _this.on(name_1, handler);
                    }
                }
            }
            return _this;
        }
        Object.defineProperty(DTreeDataSelectionNone.prototype, "type", {
            get: function () {
                return DTreeDataSelectionType.NONE;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTreeDataSelectionNone.prototype, "first", {
            get: function () {
                return null;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTreeDataSelectionNone.prototype, "last", {
            get: function () {
                return null;
            },
            enumerable: false,
            configurable: true
        });
        DTreeDataSelectionNone.prototype.get = function (index) {
            return null;
        };
        DTreeDataSelectionNone.prototype.add = function (target) {
            return false;
        };
        DTreeDataSelectionNone.prototype.remove = function (target) {
            return false;
        };
        DTreeDataSelectionNone.prototype.toggle = function (target) {
            return false;
        };
        DTreeDataSelectionNone.prototype.clear = function () {
            return false;
        };
        DTreeDataSelectionNone.prototype.clearAndAdd = function (target) {
            return false;
        };
        DTreeDataSelectionNone.prototype.clearAndAddAll = function (targets) {
            return false;
        };
        DTreeDataSelectionNone.prototype.contains = function (target) {
            return false;
        };
        DTreeDataSelectionNone.prototype.size = function () {
            return 0;
        };
        DTreeDataSelectionNone.prototype.isEmpty = function () {
            return true;
        };
        DTreeDataSelectionNone.prototype.each = function (iteratee) {
            // DO NOTHING
        };
        DTreeDataSelectionNone.prototype.toArray = function () {
            return [];
        };
        DTreeDataSelectionNone.prototype.onNodeChange = function (nodes) {
            // DO NOTHING
        };
        return DTreeDataSelectionNone;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTreeDataImpl = /** @class */ (function () {
        function DTreeDataImpl(parent, options) {
            this._parent = parent;
            this._nodeToFlag = new WeakMap();
            this._selection = this.toSelection(options);
            this._accessor = new DTreeNodeAccessorImpl(options);
            var mapped = new DTreeDataMappedImpl(this, !!(options === null || options === void 0 ? void 0 : options.reverse));
            this._mapped = mapped;
            var nodes = options === null || options === void 0 ? void 0 : options.nodes;
            if (nodes != null) {
                this._nodes = nodes;
                mapped.toDirty();
            }
            else {
                this._nodes = [];
            }
        }
        DTreeDataImpl.prototype.toSelection = function (options) {
            var selection = options === null || options === void 0 ? void 0 : options.selection;
            switch (selection === null || selection === void 0 ? void 0 : selection.type) {
                case DTreeDataSelectionType.NONE:
                case "NONE":
                    return new DTreeDataSelectionNone(this, selection);
                case DTreeDataSelectionType.MULTIPLE:
                case "MULTIPLE":
                    return new DTreeDataSelectionMultiple(this, selection);
                default:
                    return new DTreeDataSelectionSingle(this, selection);
            }
        };
        Object.defineProperty(DTreeDataImpl.prototype, "nodes", {
            get: function () {
                return this._nodes;
            },
            set: function (nodes) {
                this._nodes = nodes;
                this.update(true);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTreeDataImpl.prototype, "mapped", {
            get: function () {
                return this._mapped;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTreeDataImpl.prototype, "accessor", {
            get: function () {
                return this._accessor;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTreeDataImpl.prototype, "selection", {
            get: function () {
                return this._selection;
            },
            enumerable: false,
            configurable: true
        });
        DTreeDataImpl.prototype.update = function (forcibly) {
            if (forcibly) {
                this._mapped.toDirty();
                this._selection.onNodeChange(this._nodes);
            }
            this._parent.update(forcibly);
        };
        DTreeDataImpl.prototype.toggle = function (target) {
            var nodeToFlag = this._nodeToFlag;
            if (nodeToFlag.has(target)) {
                nodeToFlag.delete(target);
            }
            else {
                nodeToFlag.set(target, 1);
            }
            this._mapped.toDirty();
            this.update();
            return true;
        };
        DTreeDataImpl.prototype.expand = function (target) {
            var nodeToFlag = this._nodeToFlag;
            if (!nodeToFlag.has(target)) {
                nodeToFlag.set(target, 1);
                this._mapped.toDirty();
                this.update();
                return true;
            }
            return false;
        };
        DTreeDataImpl.prototype.collapse = function (target) {
            var nodeToFlag = this._nodeToFlag;
            if (nodeToFlag.has(target)) {
                nodeToFlag.delete(target);
                this._mapped.toDirty();
                this.update();
                return true;
            }
            return false;
        };
        DTreeDataImpl.prototype.expandAll = function () {
            var isDirty = false;
            var nodeToFlag = this._nodeToFlag;
            this.each(function (node) {
                if (!nodeToFlag.has(node)) {
                    nodeToFlag.set(node, 1);
                    isDirty = true;
                }
            });
            if (isDirty) {
                this._mapped.toDirty();
                this.update();
                return true;
            }
            return false;
        };
        DTreeDataImpl.prototype.collapseAll = function () {
            var isDirty = false;
            var nodeToFlag = this._nodeToFlag;
            this.each(function (node) {
                if (nodeToFlag.has(node)) {
                    nodeToFlag.delete(node);
                    isDirty = true;
                }
            });
            if (isDirty) {
                this._mapped.toDirty();
                this.update();
                return true;
            }
            return false;
        };
        DTreeDataImpl.prototype.isCollapsed = function (target) {
            return !this.isExpanded(target);
        };
        DTreeDataImpl.prototype.isExpanded = function (target) {
            return this._nodeToFlag.has(target);
        };
        DTreeDataImpl.prototype.clear = function () {
            var nodes = this._nodes;
            if (0 < nodes.length) {
                nodes.length = 0;
                this._mapped.toDirty();
                this._selection.clear();
                this.update();
                return true;
            }
            return false;
        };
        DTreeDataImpl.prototype.remove = function (target) {
            var isDirty = false;
            this.each(function (node, index, nodes) {
                if (node === target) {
                    nodes.splice(index, 1);
                    isDirty = true;
                    return false;
                }
                return true;
            });
            if (isDirty) {
                this._mapped.toDirty();
                this._selection.remove(target);
                this.update();
                return true;
            }
            return false;
        };
        DTreeDataImpl.prototype.add = function (target, parent) {
            var isDirty = false;
            if (parent) {
                var accessor = this._accessor;
                var children = accessor.toChildren(parent);
                if (children) {
                    children.push(target);
                    isDirty = true;
                }
                else {
                    var newChildren = accessor.newChildren(parent);
                    if (newChildren) {
                        newChildren.push(target);
                        isDirty = true;
                    }
                }
            }
            else {
                var nodes = this._nodes;
                if (nodes) {
                    nodes.push(target);
                }
                else {
                    this._nodes = [target];
                }
                isDirty = true;
            }
            if (isDirty) {
                this._mapped.toDirty();
                this.update();
            }
            return true;
        };
        DTreeDataImpl.prototype.addBefore = function (target, sibling) {
            var isDirty = false;
            this.each(function (node, index, nodes) {
                if (node === sibling) {
                    nodes.splice(index, 0, target);
                    isDirty = true;
                    return false;
                }
                return true;
            });
            if (isDirty) {
                this._mapped.toDirty();
                this.update();
            }
            return isDirty;
        };
        DTreeDataImpl.prototype.addAfter = function (target, sibling) {
            var isDirty = false;
            this.each(function (node, index, nodes) {
                if (node === sibling) {
                    nodes.splice(index + 1, 0, target);
                    isDirty = true;
                    return false;
                }
                return true;
            });
            if (isDirty) {
                this._mapped.toDirty();
                this.update();
            }
            return isDirty;
        };
        DTreeDataImpl.prototype.each = function (iteratee) {
            var value = this._nodes;
            if (value) {
                this.each_(value, null, iteratee);
            }
        };
        DTreeDataImpl.prototype.each_ = function (nodes, parent, iteratee) {
            var toChildren = this._accessor.toChildren;
            for (var i = 0, imax = nodes.length; i < imax; ++i) {
                var node = nodes[i];
                if (iteratee(node, i, nodes, parent) === false) {
                    return;
                }
                var children = toChildren(node);
                if (children) {
                    this.each_(children, node, iteratee);
                }
            }
        };
        return DTreeDataImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * Tree item states.
     */
    var DTreeItemState = {
        /**
         * A node has children.
         */
        HAS_CHILDREN: "HAS_CHILDREN",
        /**
         * A node is opened.
         */
        OPENED: "OPENED"
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTreeItemText = /** @class */ (function (_super) {
        __extends(DTreeItemText, _super);
        function DTreeItemText(data, options) {
            var _this = _super.call(this, options) || this;
            _this._data = data;
            return _this;
        }
        DTreeItemText.prototype.newPadding = function (theme, options, callback) {
            return new DBasePaddingAdjustable(theme, options, callback);
        };
        Object.defineProperty(DTreeItemText.prototype, "node", {
            get: function () {
                return this._node;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTreeItemText.prototype, "value", {
            get: function () {
                return this._node;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTreeItemText.prototype, "index", {
            get: function () {
                return this._index;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTreeItemText.prototype, "data", {
            get: function () {
                return this._data;
            },
            enumerable: false,
            configurable: true
        });
        DTreeItemText.prototype.toggle = function () {
            var node = this._node;
            if (node !== undefined) {
                this._data.toggle(node);
            }
        };
        DTreeItemText.prototype.set = function (node, index, forcibly) {
            var _a;
            var data = this._data;
            var isNodeChanged = forcibly || this._node !== node;
            if (isNodeChanged) {
                this._node = node;
                this._index = index;
                var accessor = data.accessor;
                this.text = accessor.toLabel(node);
                this.title = (_a = accessor.toTitle(node)) !== null && _a !== void 0 ? _a : "";
                this.image = accessor.toImage(node);
            }
            var level = data.mapped.levels[index];
            this._padding.adjLeft(this.theme.getLevelPadding(level));
            var children = data.accessor.toChildren(node);
            var hasChildren = !!(children && 0 < children.length);
            var state = this.state;
            state.lock();
            state.set(DBaseState.ACTIVE, data.selection.contains(node));
            state.remove(DBaseState.DISABLED);
            state.set(DTreeItemState.HAS_CHILDREN, hasChildren);
            state.set(DTreeItemState.OPENED, data.isExpanded(node));
            state.unlock();
            if (isNodeChanged) {
                this.emit("set", node, index, this);
            }
        };
        DTreeItemText.prototype.unset = function () {
            if (this._node !== undefined) {
                this._node = undefined;
                this._index = undefined;
                this.text = undefined;
                this.title = "";
                this.image = undefined;
                var state = this.state;
                state.lock();
                state.add(DBaseState.DISABLED);
                state.remove(DBaseState.ACTIVE);
                state.unlock();
                this.emit("unset", this);
            }
        };
        DTreeItemText.prototype.onSelect = function (e, value) {
            var data = this._data;
            var selection = data.selection;
            if (selection.type !== DTreeDataSelectionType.MULTIPLE) {
                selection.clearAndAdd(value);
            }
            else {
                var originalEvent = e && "data" in e ? e.data.originalEvent : e;
                if (originalEvent === null || originalEvent === void 0 ? void 0 : originalEvent.ctrlKey) {
                    selection.toggle(value);
                }
                else if (originalEvent === null || originalEvent === void 0 ? void 0 : originalEvent.shiftKey) {
                    var mapped = data.mapped;
                    var last_1 = selection.last;
                    if (value === last_1) {
                        selection.clearAndAdd(value);
                    }
                    else {
                        var isFound_1 = false;
                        var isReverse_1 = false;
                        var newSelection_1 = [];
                        mapped.each(function (node) {
                            if (isFound_1) {
                                if (isReverse_1) {
                                    newSelection_1.unshift(node);
                                    if (node === value) {
                                        return false;
                                    }
                                }
                                else {
                                    newSelection_1.push(node);
                                    if (node === last_1) {
                                        return false;
                                    }
                                }
                            }
                            else {
                                if (node === value) {
                                    isFound_1 = true;
                                    isReverse_1 = false;
                                    newSelection_1.push(node);
                                }
                                else if (node === last_1) {
                                    isFound_1 = true;
                                    isReverse_1 = true;
                                    newSelection_1.push(node);
                                }
                            }
                        });
                        selection.clearAndAddAll(newSelection_1);
                    }
                }
                else {
                    selection.clearAndAdd(value);
                }
            }
        };
        DTreeItemText.prototype.onKeyDown = function (e) {
            if (UtilKeyboardEvent.isActivateKey(e)) {
                this.onKeyDownActivate(e);
            }
            if (UtilKeyboardEvent.isArrowRightKey(e)) {
                var node = this._node;
                if (node !== undefined) {
                    if (this.state.is(DTreeItemState.HAS_CHILDREN)) {
                        this._data.expand(node);
                    }
                }
            }
            if (UtilKeyboardEvent.isArrowLeftKey(e)) {
                var node = this._node;
                if (node !== undefined) {
                    if (this.state.is(DTreeItemState.HAS_CHILDREN)) {
                        this._data.collapse(node);
                    }
                }
            }
            return _super.prototype.onKeyDown.call(this, e);
        };
        DTreeItemText.prototype.onKeyDownActivate = function (e) {
            if (this.state.isActionable && this.state.isFocused) {
                var node = this._node;
                if (node !== undefined) {
                    this.onSelect(e, node);
                }
                return true;
            }
            return false;
        };
        DTreeItemText.prototype.getType = function () {
            return "DTreeItemText";
        };
        return DTreeItemText;
    }(DImageBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTreeItemButton = /** @class */ (function (_super) {
        __extends(DTreeItemButton, _super);
        function DTreeItemButton(data, options) {
            var _a;
            var _this = _super.call(this, data, options) || this;
            _this._when = toEnum((_a = options === null || options === void 0 ? void 0 : options.when) !== null && _a !== void 0 ? _a : DButtonBaseWhen.CLICKED, DButtonBaseWhen);
            _this.on(UtilPointerEvent.tap, function (e) {
                _this.onClick(e);
            });
            return _this;
        }
        DTreeItemButton.prototype.onClick = function (e) {
            if (this._when === DButtonBaseWhen.CLICKED && this.state.isActionable) {
                this.activate(e);
            }
        };
        DTreeItemButton.prototype.onDblClick = function (e, interactionManager) {
            if (this._when === DButtonBaseWhen.DOUBLE_CLICKED) {
                this.activate(e);
            }
            return _super.prototype.onDblClick.call(this, e, interactionManager);
        };
        DTreeItemButton.prototype.activate = function (e) {
            this.onActivate(e);
        };
        DTreeItemButton.prototype.onActivate = function (e) {
            this.emit("active", this);
        };
        DTreeItemButton.prototype.onActivateKeyDown = function (e) {
            if (this.state.isActionable) {
                this.state.isPressed = true;
            }
        };
        DTreeItemButton.prototype.onActivateKeyUp = function (e) {
            if (this.state.isActionable) {
                if (this.state.isPressed) {
                    this.activate(e);
                }
                this.state.isPressed = false;
            }
        };
        DTreeItemButton.prototype.onKeyDown = function (e) {
            if (UtilKeyboardEvent.isActivateKey(e)) {
                this.onActivateKeyDown(e);
            }
            return _super.prototype.onKeyDown.call(this, e);
        };
        DTreeItemButton.prototype.onKeyUp = function (e) {
            if (UtilKeyboardEvent.isActivateKey(e)) {
                this.onActivateKeyUp(e);
            }
            return _super.prototype.onKeyUp.call(this, e);
        };
        DTreeItemButton.prototype.getType = function () {
            return "DTreeItemButton";
        };
        return DTreeItemButton;
    }(DTreeItemText));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTreeItemNonEditable = /** @class */ (function (_super) {
        __extends(DTreeItemNonEditable, _super);
        function DTreeItemNonEditable() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DTreeItemNonEditable.prototype.onActivate = function (e) {
            _super.prototype.onActivate.call(this, e);
            var node = this._node;
            if (node !== undefined) {
                if (this.state.is(DTreeItemState.HAS_CHILDREN)) {
                    if (e && "data" in e) {
                        var local = this.toLocal(e.data.global, undefined, DTreeItemNonEditable.WORK_CONTAINS_POINT);
                        if (local.x <= this.padding.getLeft()) {
                            this.toggle();
                        }
                        else {
                            this.onSelect(e, node);
                        }
                    }
                }
                else {
                    this.onSelect(e, node);
                }
            }
        };
        DTreeItemNonEditable.prototype.getType = function () {
            return "DTreeItemNonEditable";
        };
        return DTreeItemNonEditable;
    }(DTreeItemButton));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTreeItemUpdater = /** @class */ (function (_super) {
        __extends(DTreeItemUpdater, _super);
        function DTreeItemUpdater() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DTreeItemUpdater.prototype.toMapped = function (data) {
            return data.mapped;
        };
        DTreeItemUpdater.prototype.newItem = function (data) {
            return new DTreeItemNonEditable(data);
        };
        return DTreeItemUpdater;
    }(DItemUpdater));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTree = /** @class */ (function (_super) {
        __extends(DTree, _super);
        function DTree(options) {
            var _this = _super.call(this, options) || this;
            _this.update();
            return _this;
        }
        DTree.prototype.onContentChange = function () {
            _super.prototype.onContentChange.call(this);
            this.update();
        };
        DTree.prototype.onResize = function (newWidth, newHeight, oldWidth, oldHeight) {
            var updater = this.updater;
            updater.lock();
            _super.prototype.onResize.call(this, newWidth, newHeight, oldWidth, oldHeight);
            updater.update();
            updater.unlock(true);
        };
        Object.defineProperty(DTree.prototype, "updater", {
            get: function () {
                var result = this._updater;
                if (result == null) {
                    result = this.newUpdater(this.data, this.content, this._options);
                    this._updater = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DTree.prototype.newUpdater = function (data, content, options) {
            return new DTreeItemUpdater(data, content, content, options === null || options === void 0 ? void 0 : options.updater);
        };
        Object.defineProperty(DTree.prototype, "data", {
            get: function () {
                var result = this._data;
                if (result == null) {
                    result = this.toData(this._options);
                    this._data = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DTree.prototype.toData = function (options) {
            var data = (options && (options.data || options.nodes || options.value)) || [];
            if (isArray(data)) {
                return new DTreeDataImpl(this, {
                    nodes: data
                });
            }
            else if ("add" in data) {
                return data;
            }
            else {
                return new DTreeDataImpl(this, data);
            }
        };
        DTree.prototype.update = function (forcibly) {
            this.updater.update(forcibly);
        };
        DTree.prototype.lock = function () {
            this.updater.lock();
        };
        DTree.prototype.unlock = function (callIfNeeded) {
            this.updater.unlock(callIfNeeded);
        };
        Object.defineProperty(DTree.prototype, "selection", {
            get: function () {
                return this.data.selection;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTree.prototype, "value", {
            get: function () {
                return this.data.nodes;
            },
            set: function (value) {
                this.data.nodes = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTree.prototype, "nodes", {
            get: function () {
                return this.data.nodes;
            },
            set: function (nodes) {
                this.data.nodes = nodes;
            },
            enumerable: false,
            configurable: true
        });
        DTree.prototype.toggle = function (target) {
            return this.data.toggle(target);
        };
        DTree.prototype.expand = function (target) {
            return this.data.expand(target);
        };
        DTree.prototype.collapse = function (target) {
            return this.data.collapse(target);
        };
        DTree.prototype.expandAll = function () {
            return this.data.expandAll();
        };
        DTree.prototype.collapseAll = function () {
            return this.data.collapseAll();
        };
        DTree.prototype.isCollapsed = function (target) {
            return this.data.isCollapsed(target);
        };
        DTree.prototype.isExpanded = function (target) {
            return this.data.isExpanded(target);
        };
        DTree.prototype.clear = function () {
            return this.data.clear();
        };
        DTree.prototype.remove = function (target) {
            return this.data.remove(target);
        };
        DTree.prototype.add = function (target, parent) {
            return this.data.add(target, parent);
        };
        DTree.prototype.addBefore = function (target, sibling) {
            return this.data.addBefore(target, sibling);
        };
        DTree.prototype.addAfter = function (target, sibling) {
            return this.data.addAfter(target, sibling);
        };
        DTree.prototype.each = function (iteratee) {
            return this.data.each(iteratee);
        };
        DTree.prototype.onKeyDown = function (e) {
            this.updater.moveFocus(e, this, true, false);
            return _super.prototype.onKeyDown.call(this, e);
        };
        DTree.prototype.getType = function () {
            return "DTree";
        };
        return DTree;
    }(DPane));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */

    var ui = {
        __proto__: null,
        loadAll: loadAll,
        loadMenuItemAll: loadMenuItemAll,
        loadMenuItemExpandable: loadMenuItemExpandable,
        loadMenuItem: loadMenuItem,
        loadMenuSidedItemExpandable: loadMenuSidedItemExpandable,
        loadMenuSidedItem: loadMenuSidedItem,
        deserializeActionValue: deserializeActionValue,
        EShapeActionBases: EShapeActionBases,
        EShapeActionEnvironment: EShapeActionEnvironment,
        EShapeActionExpressions: EShapeActionExpressions,
        EShapeActionMiscExtensions: EShapeActionMiscExtensions,
        EShapeActionOpenDialogExtensions: EShapeActionOpenDialogExtensions,
        EShapeActionOpenExtensions: EShapeActionOpenExtensions,
        EShapeActionOpenOpeners: EShapeActionOpenOpeners,
        EShapeActionRuntimeBase: EShapeActionRuntimeBase,
        EShapeActionRuntimeBlinkBrighten: EShapeActionRuntimeBlinkBrighten,
        EShapeActionRuntimeBlinkColorFill: EShapeActionRuntimeBlinkColorFill,
        EShapeActionRuntimeBlinkColorStroke: EShapeActionRuntimeBlinkColorStroke,
        EShapeActionRuntimeBlinkDarken: EShapeActionRuntimeBlinkDarken,
        EShapeActionRuntimeBlinkOpacity: EShapeActionRuntimeBlinkOpacity,
        EShapeActionRuntimeBlinkVisibility: EShapeActionRuntimeBlinkVisibility,
        EShapeActionRuntimeBlink: EShapeActionRuntimeBlink,
        EShapeActionRuntimeChangeColorBrightness: EShapeActionRuntimeChangeColorBrightness,
        EShapeActionRuntimeChangeColorCode: EShapeActionRuntimeChangeColorCode,
        EShapeActionRuntimeChangeColor: EShapeActionRuntimeChangeColor,
        EShapeActionRuntimeChangeCursor: EShapeActionRuntimeChangeCursor,
        EShapeActionRuntimeChangeTextNumber: EShapeActionRuntimeChangeTextNumber,
        EShapeActionRuntimeChangeTextText: EShapeActionRuntimeChangeTextText,
        EShapeActionRuntimeConditional: EShapeActionRuntimeConditional,
        EShapeActionRuntimeEmitEvent: EShapeActionRuntimeEmitEvent,
        EShapeActionRuntimeGestureLayer: EShapeActionRuntimeGestureLayer,
        EShapeActionRuntimeGestureShape: EShapeActionRuntimeGestureShape,
        EShapeActionRuntimeMiscEmitEvent: EShapeActionRuntimeMiscEmitEvent,
        EShapeActionRuntimeMiscExecute: EShapeActionRuntimeMiscExecute,
        EShapeActionRuntimeMiscExtension: EShapeActionRuntimeMiscExtension,
        EShapeActionRuntimeMiscHtmlElement: EShapeActionRuntimeMiscHtmlElement,
        EShapeActionRuntimeMiscInputInput: EShapeActionRuntimeMiscInputInput,
        EShapeActionRuntimeMiscInputInteger: EShapeActionRuntimeMiscInputInteger,
        EShapeActionRuntimeMiscInputNumber: EShapeActionRuntimeMiscInputNumber,
        EShapeActionRuntimeMiscInputReal: EShapeActionRuntimeMiscInputReal,
        EShapeActionRuntimeMiscInputText: EShapeActionRuntimeMiscInputText,
        EShapeActionRuntimeMiscInput: EShapeActionRuntimeMiscInput,
        EShapeActionRuntimeMiscWriteBoth: EShapeActionRuntimeMiscWriteBoth,
        EShapeActionRuntimeMiscWriteLocal: EShapeActionRuntimeMiscWriteLocal,
        EShapeActionRuntimeMiscWriteRemote: EShapeActionRuntimeMiscWriteRemote,
        EShapeActionRuntimeMiscWrite: EShapeActionRuntimeMiscWrite,
        EShapeActionRuntimeOpenDialogBoolean: EShapeActionRuntimeOpenDialogBoolean,
        EShapeActionRuntimeOpenDialogDate: EShapeActionRuntimeOpenDialogDate,
        EShapeActionRuntimeOpenDialogDatetime: EShapeActionRuntimeOpenDialogDatetime,
        EShapeActionRuntimeOpenDialogExtension: EShapeActionRuntimeOpenDialogExtension,
        EShapeActionRuntimeOpenDialogInteger: EShapeActionRuntimeOpenDialogInteger,
        EShapeActionRuntimeOpenDialogReal: EShapeActionRuntimeOpenDialogReal,
        EShapeActionRuntimeOpenDialogText: EShapeActionRuntimeOpenDialogText,
        EShapeActionRuntimeOpenDialogTime: EShapeActionRuntimeOpenDialogTime,
        EShapeActionRuntimeOpenDialog: EShapeActionRuntimeOpenDialog,
        EShapeActionRuntimeOpen: EShapeActionRuntimeOpen,
        EShapeActionRuntimeShowHideLayer: EShapeActionRuntimeShowHideLayer,
        EShapeActionRuntimeShowHideShape: EShapeActionRuntimeShowHideShape,
        EShapeActionRuntimeShowHide: EShapeActionRuntimeShowHide,
        EShapeActionRuntimeTransformMoveAbsoluteX: EShapeActionRuntimeTransformMoveAbsoluteX,
        EShapeActionRuntimeTransformMoveAbsoluteY: EShapeActionRuntimeTransformMoveAbsoluteY,
        EShapeActionRuntimeTransformMoveForwardOrBackward: EShapeActionRuntimeTransformMoveForwardOrBackward,
        EShapeActionRuntimeTransformMoveLeftOrRight: EShapeActionRuntimeTransformMoveLeftOrRight,
        EShapeActionRuntimeTransformMoveRelativeX: EShapeActionRuntimeTransformMoveRelativeX,
        EShapeActionRuntimeTransformMoveRelativeY: EShapeActionRuntimeTransformMoveRelativeY,
        EShapeActionRuntimeTransformMove: EShapeActionRuntimeTransformMove,
        EShapeActionRuntimeTransformResizeHeightAbsolute: EShapeActionRuntimeTransformResizeHeightAbsolute,
        EShapeActionRuntimeTransformResizeHeightRelative: EShapeActionRuntimeTransformResizeHeightRelative,
        EShapeActionRuntimeTransformResizeSizeAbsolute: EShapeActionRuntimeTransformResizeSizeAbsolute,
        EShapeActionRuntimeTransformResizeSizeRelative: EShapeActionRuntimeTransformResizeSizeRelative,
        EShapeActionRuntimeTransformResizeWidthAbsolute: EShapeActionRuntimeTransformResizeWidthAbsolute,
        EShapeActionRuntimeTransformResizeWidthRelative: EShapeActionRuntimeTransformResizeWidthRelative,
        EShapeActionRuntimeTransformResize: EShapeActionRuntimeTransformResize,
        EShapeActionRuntimeTransformRotateAbsolute: EShapeActionRuntimeTransformRotateAbsolute,
        EShapeActionRuntimeTransformRotateRelative: EShapeActionRuntimeTransformRotateRelative,
        EShapeActionRuntimeTransformRotate: EShapeActionRuntimeTransformRotate,
        EShapeActionRuntimes: EShapeActionRuntimes,
        EShapeActionValueBase: EShapeActionValueBase,
        EShapeActionValueBlinkType: EShapeActionValueBlinkType,
        EShapeActionValueBlink: EShapeActionValueBlink,
        EShapeActionValueChangeColorBrightness: EShapeActionValueChangeColorBrightness,
        EShapeActionValueChangeColorCode: EShapeActionValueChangeColorCode,
        EShapeActionValueChangeColorTarget: EShapeActionValueChangeColorTarget,
        EShapeActionValueChangeColorTypeLegacy: EShapeActionValueChangeColorTypeLegacy,
        EShapeActionValueChangeColorType: EShapeActionValueChangeColorType,
        EShapeActionValueChangeColorTypes: EShapeActionValueChangeColorTypes,
        EShapeActionValueChangeColor: EShapeActionValueChangeColor,
        EShapeActionValueChangeCursor: EShapeActionValueChangeCursor,
        EShapeActionValueChangeTextType: EShapeActionValueChangeTextType,
        EShapeActionValueChangeText: EShapeActionValueChangeText,
        EShapeActionValueDeserializers: EShapeActionValueDeserializers,
        EShapeActionValueEmitEvent: EShapeActionValueEmitEvent,
        EShapeActionValueGestureOperationType: EShapeActionValueGestureOperationType,
        EShapeActionValueGestureType: EShapeActionValueGestureType,
        EShapeActionValueGesture: EShapeActionValueGesture,
        EShapeActionValueMiscEmitEvent: EShapeActionValueMiscEmitEvent,
        EShapeActionValueMiscExecute: EShapeActionValueMiscExecute,
        EShapeActionValueMiscExtension: EShapeActionValueMiscExtension,
        EShapeActionValueMiscHtmlElement: EShapeActionValueMiscHtmlElement,
        EShapeActionValueMiscInput: EShapeActionValueMiscInput,
        EShapeActionValueMiscType: EShapeActionValueMiscType,
        EShapeActionValueMiscWrite: EShapeActionValueMiscWrite,
        EShapeActionValueMisc: EShapeActionValueMisc,
        EShapeActionValueOnInputAction: EShapeActionValueOnInputAction,
        EShapeActionValueOnInputActions: EShapeActionValueOnInputActions,
        EShapeActionValueOpenDialogExtension: EShapeActionValueOpenDialogExtension,
        EShapeActionValueOpenDialogType: EShapeActionValueOpenDialogType,
        EShapeActionValueOpenDialog: EShapeActionValueOpenDialog,
        EShapeActionValueOpenExtension: EShapeActionValueOpenExtension,
        EShapeActionValueOpenType: EShapeActionValueOpenType,
        EShapeActionValueOpen: EShapeActionValueOpen,
        EShapeActionValueOpetyped: EShapeActionValueOpetyped,
        EShapeActionValueShowHideLayer: EShapeActionValueShowHideLayer,
        EShapeActionValueShowHideShape: EShapeActionValueShowHideShape,
        EShapeActionValueShowHideType: EShapeActionValueShowHideType,
        EShapeActionValueShowHide: EShapeActionValueShowHide,
        EShapeActionValueSubtyped: EShapeActionValueSubtyped,
        EShapeActionValueTransformMoveType: EShapeActionValueTransformMoveType,
        EShapeActionValueTransformMove: EShapeActionValueTransformMove,
        EShapeActionValueTransformResizeType: EShapeActionValueTransformResizeType,
        EShapeActionValueTransformResize: EShapeActionValueTransformResize,
        EShapeActionValueTransformRotateType: EShapeActionValueTransformRotateType,
        EShapeActionValueTransformRotate: EShapeActionValueTransformRotate,
        EShapeActionValueTransformType: EShapeActionValueTransformType,
        EShapeActionValueType: EShapeActionValueType,
        EShapeActionValues: EShapeActionValues,
        EShapeAction: EShapeAction,
        EShapeActions: EShapeActions,
        loadShapeAll: loadShapeAll,
        loadShapeBar: loadShapeBar,
        loadShapeButton: loadShapeButton,
        loadShapeCircle: loadShapeCircle,
        loadShapeClipperEx: loadShapeClipperEx,
        isShapeClipperExLoaded: isShapeClipperExLoaded,
        loadShapeConnectorElbow: loadShapeConnectorElbow,
        loadShapeConnectorLine: loadShapeConnectorLine,
        loadShapeEmbedded: loadShapeEmbedded,
        loadShapeGroupShadowed: loadShapeGroupShadowed,
        loadShapeGroup: loadShapeGroup,
        loadShapeImage: loadShapeImage,
        loadShapeLabel: loadShapeLabel,
        loadShapeLineOfCircles: loadShapeLineOfCircles,
        loadShapeLineOfRectangleRoundeds: loadShapeLineOfRectangleRoundeds,
        loadShapeLineOfRectangles: loadShapeLineOfRectangles,
        loadShapeLineOfTriangleRoundeds: loadShapeLineOfTriangleRoundeds,
        loadShapeLineOfTriangles: loadShapeLineOfTriangles,
        loadShapeLine: loadShapeLine,
        loadShapeNull: loadShapeNull,
        loadShapeRectangleRounded: loadShapeRectangleRounded,
        loadShapeRectangle: loadShapeRectangle,
        loadShapeSemicircle: loadShapeSemicircle,
        loadShapeTriangleRounded: loadShapeTriangleRounded,
        loadShapeTriangle: loadShapeTriangle,
        BAR_VERTEX_COUNT: BAR_VERTEX_COUNT,
        BAR_INDEX_COUNT: BAR_INDEX_COUNT,
        buildBarIndex: buildBarIndex,
        buildBarVertexStep: buildBarVertexStep,
        buildBarUv: buildBarUv,
        CIRCLE_VERTEX_COUNT: CIRCLE_VERTEX_COUNT,
        CIRCLE_INDEX_COUNT: CIRCLE_INDEX_COUNT,
        CIRCLE_WORLD_SIZE: CIRCLE_WORLD_SIZE,
        buildCircleIndex: buildCircleIndex,
        buildCircleVertex: buildCircleVertex,
        buildCircleStep: buildCircleStep,
        buildCircleUv: buildCircleUv,
        buildColor: buildColor,
        IMAGE_SDF_VERTEX_COUNT: IMAGE_SDF_VERTEX_COUNT,
        IMAGE_SDF_INDEX_COUNT: IMAGE_SDF_INDEX_COUNT,
        IMAGE_SDF_WORLD_SIZE: IMAGE_SDF_WORLD_SIZE,
        buildImageSdfIndex: buildImageSdfIndex,
        buildImageSdfStep: buildImageSdfStep,
        buildImageSdfVertex: buildImageSdfVertex,
        buildImageSdfUv: buildImageSdfUv,
        toLineOfAnyPointCount: toLineOfAnyPointCount,
        buildLineOfAnyColor: buildLineOfAnyColor,
        toPointCount: toPointCount,
        toLinePointCount: toLinePointCount,
        toLineVertexCount: toLineVertexCount,
        toLineIndexCount: toLineIndexCount,
        buildLineIndex: buildLineIndex,
        buildLineUv: buildLineUv,
        buildLineVertexStep: buildLineVertexStep,
        buildNullIndex: buildNullIndex,
        buildNullVertex: buildNullVertex,
        buildNullStep: buildNullStep,
        buildNullUv: buildNullUv,
        RECTANGLE_ROUNDED_VERTEX_COUNT: RECTANGLE_ROUNDED_VERTEX_COUNT,
        RECTANGLE_ROUNDED_INDEX_COUNT: RECTANGLE_ROUNDED_INDEX_COUNT,
        RECTANGLE_ROUNDED_WORLD_SIZE: RECTANGLE_ROUNDED_WORLD_SIZE,
        buildRectangleRoundedIndex: buildRectangleRoundedIndex,
        buildRectangleRoundedVertex: buildRectangleRoundedVertex,
        buildRectangleRoundedStep: buildRectangleRoundedStep,
        buildRectangleRoundedUv: buildRectangleRoundedUv,
        RECTANGLE_VERTEX_COUNT: RECTANGLE_VERTEX_COUNT,
        RECTANGLE_INDEX_COUNT: RECTANGLE_INDEX_COUNT,
        RECTANGLE_WORLD_SIZE: RECTANGLE_WORLD_SIZE,
        buildRectangleIndex: buildRectangleIndex,
        buildRectangleVertex: buildRectangleVertex,
        buildRectangleStep: buildRectangleStep,
        buildRectangleUv: buildRectangleUv,
        SEMICIRCLE_VERTEX_COUNT: SEMICIRCLE_VERTEX_COUNT,
        SEMICIRCLE_INDEX_COUNT: SEMICIRCLE_INDEX_COUNT,
        SEMICIRCLE_WORLD_SIZE: SEMICIRCLE_WORLD_SIZE,
        buildSemicircleIndex: buildSemicircleIndex,
        buildSemicircleVertex: buildSemicircleVertex,
        buildSemicircleStep: buildSemicircleStep,
        buildSemicircleUv: buildSemicircleUv,
        TEXT_VERTEX_COUNT: TEXT_VERTEX_COUNT,
        TEXT_VERTEX_COUNT_SHIFT: TEXT_VERTEX_COUNT_SHIFT,
        TEXT_INDEX_COUNT: TEXT_INDEX_COUNT,
        TEXT_INDEX_COUNT_SHIFT: TEXT_INDEX_COUNT_SHIFT,
        TEXT_FMIN: TEXT_FMIN,
        toTextBufferCount: toTextBufferCount,
        buildTextIndex: buildTextIndex,
        buildTextStep: buildTextStep,
        buildTextVertex: buildTextVertex,
        TRIANGLE_ROUNDED_VERTEX_COUNT: TRIANGLE_ROUNDED_VERTEX_COUNT,
        TRIANGLE_ROUNDED_INDEX_COUNT: TRIANGLE_ROUNDED_INDEX_COUNT,
        TRIANGLE_ROUNDED_WORLD_SIZE: TRIANGLE_ROUNDED_WORLD_SIZE,
        buildTriangleRoundedIndex: buildTriangleRoundedIndex,
        buildTriangleRoundedVertex: buildTriangleRoundedVertex,
        buildTriangleRoundedStep: buildTriangleRoundedStep,
        buildTriangleRoundedUv: buildTriangleRoundedUv,
        TRIANGLE_VERTEX_COUNT: TRIANGLE_VERTEX_COUNT,
        TRIANGLE_INDEX_COUNT: TRIANGLE_INDEX_COUNT,
        TRIANGLE_WORLD_SIZE: TRIANGLE_WORLD_SIZE,
        buildTriangleIndex: buildTriangleIndex,
        buildTriangleVertex: buildTriangleVertex,
        buildTriangleStep: buildTriangleStep,
        buildTriangleUv: buildTriangleUv,
        BuilderBar: BuilderBar,
        BuilderBase: BuilderBase,
        BuilderCircle: BuilderCircle,
        BuilderImageSdf: BuilderImageSdf,
        BuilderLabel: BuilderLabel,
        BuilderLineOfAny: BuilderLineOfAny,
        BuilderLineOfCircles: BuilderLineOfCircles,
        BuilderLineOfRectangleRoundeds: BuilderLineOfRectangleRoundeds,
        BuilderLineOfRectangles: BuilderLineOfRectangles,
        BuilderLineOfTriangleRoundeds: BuilderLineOfTriangleRoundeds,
        BuilderLineOfTriangles: BuilderLineOfTriangles,
        BuilderLine: BuilderLine,
        BuilderMarkerCircleHead: BuilderMarkerCircleHead,
        BuilderMarkerCircleTail: BuilderMarkerCircleTail,
        BuilderMarkerCircle: BuilderMarkerCircle,
        BuilderMarkerRectangleHead: BuilderMarkerRectangleHead,
        BuilderMarkerRectangleTail: BuilderMarkerRectangleTail,
        BuilderMarkerRectangle: BuilderMarkerRectangle,
        BuilderMarkerTriangleHead: BuilderMarkerTriangleHead,
        BuilderMarkerTriangleTail: BuilderMarkerTriangleTail,
        BuilderMarkerTriangle: BuilderMarkerTriangle,
        BuilderNull: BuilderNull,
        BuilderRectanglePivoted: BuilderRectanglePivoted,
        BuilderRectangleRounded: BuilderRectangleRounded,
        BuilderRectangle: BuilderRectangle,
        BuilderSemicircle: BuilderSemicircle,
        BuilderText: BuilderText,
        BuilderTriangleRounded: BuilderTriangleRounded,
        BuilderTriangle: BuilderTriangle,
        BuilderFlag: BuilderFlag,
        toTransformLocalId: toTransformLocalId,
        toTexture: toTexture,
        toTextureTransformId: toTextureTransformId,
        toTextureUvs: toTextureUvs,
        copyIndex: copyIndex,
        copyStep: copyStep,
        copyUvs: copyUvs,
        copyVertex: copyVertex,
        createBarUploaded: createBarUploaded,
        createButtonUploaded: createButtonUploaded,
        createCircleUploaded: createCircleUploaded,
        createRectanglePivotedUploaded: createRectanglePivotedUploaded,
        createGroupUploaded: createGroupUploaded,
        createImageSdfUploaded: createImageSdfUploaded,
        createImageSdf: createImageSdf,
        createImage: createImage,
        createLabelUploaded: createLabelUploaded,
        createLineOfAnyUploaded: createLineOfAnyUploaded,
        createLineOfCirclesUploaded: createLineOfCirclesUploaded,
        createLineOfRectangleRoundedsUploaded: createLineOfRectangleRoundedsUploaded,
        createLineOfRectanglesUploaded: createLineOfRectanglesUploaded,
        createLineOfTriangleRoundedsUploaded: createLineOfTriangleRoundedsUploaded,
        createLineOfTrianglesUploaded: createLineOfTrianglesUploaded,
        createLineUploaded: createLineUploaded,
        createLine: createLine,
        createNullUploaded: createNullUploaded,
        createRectangleRoundedUploaded: createRectangleRoundedUploaded,
        createRectangleUploaded: createRectangleUploaded,
        createSemicircleUploaded: createSemicircleUploaded,
        createTriangleRoundedUploaded: createTriangleRoundedUploaded,
        createTriangleUploaded: createTriangleUploaded,
        deserializeAll: deserializeAll,
        deserializeBar: deserializeBar,
        deserializeBase: deserializeBase,
        deserializeButton: deserializeButton,
        deserializeCircle: deserializeCircle,
        deserializeConnectorElbow: deserializeConnectorElbow,
        deserializeConnectorLine: deserializeConnectorLine,
        onDeserializedConnectorLine: onDeserializedConnectorLine,
        deserializeEmbeddedAcceptorEdge: deserializeEmbeddedAcceptorEdge,
        deserializeEmbeddedLayer: deserializeEmbeddedLayer,
        deserializeEmbedded: deserializeEmbedded,
        deserializeGradient: deserializeGradient,
        deserializeGroupShadowed: deserializeGroupShadowed,
        deserializeGroup: deserializeGroup,
        deserializeImageSdf: deserializeImageSdf,
        deserializeImage: deserializeImage,
        deserializeLabel: deserializeLabel,
        deserializeLineOfCircles: deserializeLineOfCircles,
        deserializeLineOfRectangleRoundeds: deserializeLineOfRectangleRoundeds,
        deserializeLineOfRectangles: deserializeLineOfRectangles,
        deserializeLineOfTriangleRoundeds: deserializeLineOfTriangleRoundeds,
        deserializeLineOfTriangles: deserializeLineOfTriangles,
        deserializeLine: deserializeLine,
        deserializeNull: deserializeNull,
        deserializeRectanglePivoted: deserializeRectanglePivoted,
        deserializeRectangleRounded: deserializeRectangleRounded,
        deserializeRectangle: deserializeRectangle,
        deserializeSemicircle: deserializeSemicircle,
        deserializeTriangleRounded: deserializeTriangleRounded,
        deserializeTriangle: deserializeTriangle,
        deserialize: deserialize,
        EShapeBarPoints: EShapeBarPoints,
        EShapeBarPosition: EShapeBarPosition,
        EShapeBar: EShapeBar,
        EShapeBaseHitTestData: EShapeBaseHitTestData,
        EShapeBase: EShapeBase,
        EShapeButtonRuntimeActionToggle: EShapeButtonRuntimeActionToggle,
        EShapeButtonRuntimeAction: EShapeButtonRuntimeAction,
        EShapeButtonRuntime: EShapeButtonRuntime,
        EShapeButton: EShapeButton,
        EShapeCircle: EShapeCircle,
        EShapeConnectorElbowPointsFiller: EShapeConnectorElbowPointsFiller,
        EShapeConnectorElbow: EShapeConnectorElbow,
        EShapeConnectorLine: EShapeConnectorLine,
        EShapeEmbeddedAcceptorEdge: EShapeEmbeddedAcceptorEdge,
        EShapeEmbeddedAcceptor: EShapeEmbeddedAcceptor,
        EShapeEmbeddedDatum: EShapeEmbeddedDatum,
        EShapeEmbeddedLayerContainer: EShapeEmbeddedLayerContainer,
        EShapeEmbeddedLayer: EShapeEmbeddedLayer,
        EShapeEmbedded: EShapeEmbedded,
        EShapeEmbeddeds: EShapeEmbeddeds,
        EShapeFillImpl: EShapeFillImpl,
        EShapeGroupFillEditor: EShapeGroupFillEditor,
        EShapeGroupFillViewer: EShapeGroupFillViewer,
        EShapeGroupPoints: EShapeGroupPoints,
        EShapeGroupShadowed: EShapeGroupShadowed,
        EShapeGroupSizeEditor: EShapeGroupSizeEditor,
        EShapeGroupSizeLayout: EShapeGroupSizeLayout,
        EShapeGroupSizeShadowed: EShapeGroupSizeShadowed,
        EShapeGroupSizeViewer: EShapeGroupSizeViewer,
        EShapeGroupStrokeEditor: EShapeGroupStrokeEditor,
        EShapeGroupStrokeViewer: EShapeGroupStrokeViewer,
        EShapeGroupViewer: EShapeGroupViewer,
        EShapeGroup: EShapeGroup,
        EShapeImageSdf: EShapeImageSdf,
        EShapeImage: EShapeImage,
        EShapeLabel: EShapeLabel,
        EShapeLineBaseHitPart: EShapeLineBaseHitPart,
        EShapeLineBase: EShapeLineBase,
        EShapeLineOfAnyPointsFillImpl: EShapeLineOfAnyPointsFillImpl,
        EShapeLineOfAnyPointsImpl: EShapeLineOfAnyPointsImpl,
        EShapeLineOfAnyPointsPointImpl: EShapeLineOfAnyPointsPointImpl,
        EShapeLineOfAnyPointsStrokeImpl: EShapeLineOfAnyPointsStrokeImpl,
        EShapeLineOfCircles: EShapeLineOfCircles,
        EShapeLineOfRectangleRoundeds: EShapeLineOfRectangleRoundeds,
        EShapeLineOfRectangles: EShapeLineOfRectangles,
        EShapeLineOfTriangleRoundeds: EShapeLineOfTriangleRoundeds,
        EShapeLineOfTriangles: EShapeLineOfTriangles,
        EShapeLinePoints: EShapeLinePoints,
        EShapeLine: EShapeLine,
        EShapeLockPart: EShapeLockPart,
        EShapeLock: EShapeLock,
        EShapeNull: EShapeNull,
        EShapePrimitive: EShapePrimitive,
        EShapeRectanglePivoted: EShapeRectanglePivoted,
        EShapeRectangleRounded: EShapeRectangleRounded,
        EShapeRectangle: EShapeRectangle,
        EShapeSemicircle: EShapeSemicircle,
        EShapeStrokeImpl: EShapeStrokeImpl,
        EShapeTextAlignImpl: EShapeTextAlignImpl,
        EShapeTextImpl: EShapeTextImpl,
        EShapeTextOffsetImpl: EShapeTextOffsetImpl,
        EShapeTextOutlineImpl: EShapeTextOutlineImpl,
        EShapeTriangleRounded: EShapeTriangleRounded,
        EShapeTriangle: EShapeTriangle,
        hitTestBBox: hitTestBBox,
        hitTestCircle: hitTestCircle,
        hitTestSemicircle: hitTestSemicircle,
        hitTestRectangleRounded: hitTestRectangleRounded,
        hitTestRectangle: hitTestRectangle,
        hitTestTriangleRounded: hitTestTriangleRounded,
        hitTestTriangleFilled: hitTestTriangleFilled,
        hitTestTriangle: hitTestTriangle,
        isStatic: isStatic,
        toComputed: toComputed,
        toDash: toDash,
        toGradientImageUrl: toGradientImageUrl,
        toGradientSerialized: toGradientSerialized,
        toImageElement: toImageElement,
        toLength: toLength,
        toResized: toResized,
        toScaleInvariant: toScaleInvariant,
        toSizeNormalized: toSizeNormalized,
        toSizeRounded: toSizeRounded,
        toThresholdDefault: toThresholdDefault,
        EShapeAcceptorEdgeSide: EShapeAcceptorEdgeSide,
        EShapeAcceptorEdgeType: EShapeAcceptorEdgeType,
        EShapeAcceptorImpl: EShapeAcceptorImpl,
        EShapeAcceptorType: EShapeAcceptorType,
        EShapeAcceptors: EShapeAcceptors,
        EShapeBufferUnitBuilder: EShapeBufferUnitBuilder,
        EShapeBufferUnit: EShapeBufferUnit,
        EShapeBuffer: EShapeBuffer,
        EShapeCapabilities: EShapeCapabilities,
        EShapeCapabilityContainerImpl: EShapeCapabilityContainerImpl,
        EShapeCapability: EShapeCapability,
        EShapeConnectorBodies: EShapeConnectorBodies,
        EShapeConnectorBodyImpl: EShapeConnectorBodyImpl,
        EShapeConnectorContainerImpl: EShapeConnectorContainerImpl,
        EShapeConnectorEdgeAcceptorImpl: EShapeConnectorEdgeAcceptorImpl,
        EShapeConnectorEdgeContainerImpl: EShapeConnectorEdgeContainerImpl,
        EShapeConnectorEdgeImpl: EShapeConnectorEdgeImpl,
        EShapeConnectors: EShapeConnectors,
        EShapeContainer: EShapeContainer,
        EShapeCopyPart: EShapeCopyPart,
        EShapeCorner: EShapeCorner,
        EShapeDataImpl: EShapeDataImpl,
        EShapeDataMapperImpl: EShapeDataMapperImpl,
        EShapeDataMappingImpl: EShapeDataMappingImpl,
        EShapeDataScopedImpl: EShapeDataScopedImpl,
        EShapeDataSystemImpl: EShapeDataSystemImpl,
        EShapeDataValueExtensions: EShapeDataValueExtensions,
        EShapeDataValueImpl: EShapeDataValueImpl,
        EShapeDataValueOrder: EShapeDataValueOrder,
        EShapeDataValueRangeImpl: EShapeDataValueRangeImpl,
        EShapeDataValueRangeType: EShapeDataValueRangeType,
        EShapeDataValueScope: EShapeDataValueScope,
        EShapeDataValueState: EShapeDataValueState,
        EShapeDataValueType: EShapeDataValueType,
        EShapeDefaults: EShapeDefaults,
        EShapeDeserializers: EShapeDeserializers,
        EShapeOnDeserializeds: EShapeOnDeserializeds,
        EShapeEditor: EShapeEditor,
        EShapeLayerState: EShapeLayerState,
        toPointsBoundary: toPointsBoundary,
        eShapePointsFormatterCurveBezierQuadratic: eShapePointsFormatterCurveBezierQuadratic,
        eShapePointsFormatterCurve: eShapePointsFormatterCurve,
        EShapePointsFormatters: EShapePointsFormatters,
        EShapePointsMarkerBase: EShapePointsMarkerBase,
        EShapePointsMarkerContainerImplNoop: EShapePointsMarkerContainerImplNoop,
        EShapePointsMarkerContainerImpl: EShapePointsMarkerContainerImpl,
        EShapePointsMarkerHead: EShapePointsMarkerHead,
        EShapePointsMarkerNoop: EShapePointsMarkerNoop,
        EShapePointsMarkerTail: EShapePointsMarkerTail,
        EShapePointsMarkerType: EShapePointsMarkerType,
        EShapePointsStyle: EShapePointsStyle,
        EShapePointsStyles: EShapePointsStyles,
        EShapeRendererIteratorDatum: EShapeRendererIteratorDatum,
        EShapeRendererIterator: EShapeRendererIterator,
        EShapeRenderer: EShapeRenderer,
        EShapeResourceManagerDeserializationMode: EShapeResourceManagerDeserializationMode,
        EShapeResourceManagerDeserialization: EShapeResourceManagerDeserialization,
        EShapeResourceManagerSerialization: EShapeResourceManagerSerialization,
        EShapeRuntimeImpl: EShapeRuntimeImpl,
        EShapeRuntimeReset: EShapeRuntimeReset,
        EShapeRuntimes: EShapeRuntimes,
        EShapeStateSetImplObservable: EShapeStateSetImplObservable,
        EShapeState: EShapeState,
        EShapeStrokeSide: EShapeStrokeSide,
        EShapeStrokeStyle: EShapeStrokeStyle,
        EShapeTextAlignHorizontal: EShapeTextAlignHorizontal,
        EShapeTextAlignVertical: EShapeTextAlignVertical,
        EShapeTextDirection: EShapeTextDirection,
        EShapeTextWeight: EShapeTextWeight,
        EShapeTextStyle: EShapeTextStyle,
        EShapeTransformImpl: EShapeTransformImpl,
        EShapeType: EShapeType,
        EShapeUploadedImpl: EShapeUploadedImpl,
        EShapeUploadeds: EShapeUploadeds,
        EShapeUuidMappingImpl: EShapeUuidMappingImpl,
        ESnapperGrid: ESnapperGrid,
        ESnapperResultScale: ESnapperResultScale,
        ESnapperResult: ESnapperResult,
        ESnapperTargetValueType: ESnapperTargetValueType,
        ESnapperTargetValue: ESnapperTargetValue,
        ESnapperTarget: ESnapperTarget,
        ESnapperModifierAnchor: ESnapperModifierAnchor,
        ESnapper: ESnapper,
        DThemes: DThemes,
        FormatNodeA: FormatNodeA,
        FormatNodea: FormatNodea,
        FormatNodeD: FormatNodeD,
        FormatNoded: FormatNoded,
        FormatNodee: FormatNodee,
        FormatNodef: FormatNodef,
        FormatNodefsi: FormatNodefsi,
        FormatNodeg: FormatNodeg,
        FormatNodeH: FormatNodeH,
        FormatNodeh: FormatNodeh,
        FormatNodeM: FormatNodeM,
        FormatNodem: FormatNodem,
        FormatNodemi: FormatNodemi,
        FormatNodeP: FormatNodeP,
        FormatNodep: FormatNodep,
        FormatNodePadding: FormatNodePadding,
        FormatNodeParenthesis: FormatNodeParenthesis,
        FormatNodePlus: FormatNodePlus,
        FormatNodePrecision: FormatNodePrecision,
        FormatNoderd: FormatNoderd,
        FormatNodeRP: FormatNodeRP,
        FormatNoderp: FormatNoderp,
        FormatNodesdt: FormatNodesdt,
        FormatNodeSpace: FormatNodeSpace,
        FormatNodessi: FormatNodessi,
        FormatNodeString: FormatNodeString,
        FormatNodeY: FormatNodeY,
        FormatNodey: FormatNodey,
        FormatNodez: FormatNodez,
        FormatNodes: FormatNodes,
        Character: Character,
        DynamicAtlasItemEmpty: DynamicAtlasItemEmpty,
        DynamicAtlasItemFontAtlas: DynamicAtlasItemFontAtlas,
        DynamicAtlasItemImage: DynamicAtlasItemImage,
        DynamicAtlasItemText: DynamicAtlasItemText,
        DynamicAtlasItemWhite: DynamicAtlasItemWhite,
        DynamicAtlasItem: DynamicAtlasItem,
        DynamicAtlas: DynamicAtlas,
        DynamicFontAtlasCharacterOrigin: DynamicFontAtlasCharacterOrigin,
        DynamicFontAtlasCharacterType: DynamicFontAtlasCharacterType,
        DynamicFontAtlasCharacter: DynamicFontAtlasCharacter,
        DynamicFontAtlasFont: DynamicFontAtlasFont,
        DynamicFontAtlas: DynamicFontAtlas,
        DynamicFontAtlases: DynamicFontAtlases,
        DynamicSDFFontAtlasFont: DynamicSDFFontAtlasFont,
        DynamicSDFFontAtlas: DynamicSDFFontAtlas,
        DynamicSDFFontAtlases: DynamicSDFFontAtlases,
        DynamicSDFFontGenerator: DynamicSDFFontGenerator,
        isArray: isArray,
        isFunction: isFunction,
        isNaN: isNaN$1,
        isNumber: isNumber,
        isObject: isObject,
        isString: isString,
        Lazy: Lazy,
        NumberFormatterImpl: NumberFormatterImpl,
        NumberFormatters: NumberFormatters,
        toCeilingIndex: toCeilingIndex,
        toCloned: toCloned,
        toEnum: toEnum,
        toId: toId,
        toIndexOf: toIndexOf,
        toLabel: toLabel$1,
        toMerged: toMerged,
        toPadded: toPadded,
        toString: toString,
        toSvgTexture: toSvgTexture,
        toSvgUrl: toSvgUrl,
        UtilAlpha: UtilAlpha,
        UtilSvgAtlasBuilder: UtilSvgAtlasBuilder,
        UtilAttachAlign: UtilAttachAlign,
        UtilAttach: UtilAttach,
        UtilCharacterIterator: UtilCharacterIterator,
        UtilClickOutside: UtilClickOutside,
        UtilClipboard: UtilClipboard,
        UtilGestureData: UtilGestureData,
        UtilGestureEasingHistory: UtilGestureEasingHistory,
        UtilGestureEasing: UtilGestureEasing,
        UtilGestureMode: UtilGestureMode,
        UtilGestureModifier: UtilGestureModifier,
        UtilGestureModifiers: UtilGestureModifiers,
        UtilGestureTap: UtilGestureTap,
        UtilGesture: UtilGesture,
        UtilExtract: UtilExtract,
        UtilExtractorCanvas: UtilExtractorCanvas,
        UtilExtractor: UtilExtractor,
        UtilFileDownloader: UtilFileDownloader,
        UtilFileAs: UtilFileAs,
        UtilFileOpener: UtilFileOpener,
        UtilFont: UtilFont,
        UtilHsv: UtilHsv,
        UtilHtmlElementClipperExImpl: UtilHtmlElementClipperExImpl,
        UtilHtmlElementClipperExRectsImpl: UtilHtmlElementClipperExRectsImpl,
        UtilHtmlElementWhen: UtilHtmlElementWhen,
        UtilHtmlElement: UtilHtmlElement,
        UtilInputInput: UtilInputInput,
        UtilInputNumber: UtilInputNumber,
        UtilInputTextArea: UtilInputTextArea,
        UtilInputText: UtilInputText,
        UtilInput: UtilInput,
        UtilKeyboardEvent: UtilKeyboardEvent,
        UtilName: UtilName,
        UtilOverlay: UtilOverlay,
        UtilPointerEvent: UtilPointerEvent,
        UtilRgb: UtilRgb,
        UtilRgba: UtilRgba,
        UtilStateBlinker: UtilStateBlinker,
        UtilTransition: UtilTransition,
        UtilWheelEvent: UtilWheelEvent,
        DAlignHorizontal: DAlignHorizontal,
        DAlignVertical: DAlignVertical,
        DAlignWith: DAlignWith,
        DAnimationBase: DAnimationBase,
        DAnimationEmpty: DAnimationEmpty,
        DAnimationFadeIn: DAnimationFadeIn,
        DAnimationTimings: DAnimationTimings,
        DApplicationLayerOptions: DApplicationLayerOptions,
        DApplicationLayer: DApplicationLayer,
        DApplicationPadding: DApplicationPadding,
        DApplication: DApplication,
        DApplications: DApplications,
        DBaseAutoSet: DBaseAutoSet,
        DBaseAuto: DBaseAuto,
        DBaseBackgroundMeshGeometry: DBaseBackgroundMeshGeometry,
        DBaseBackgroundMesh: DBaseBackgroundMesh,
        DBaseBackgroundSnippet: DBaseBackgroundSnippet,
        DBaseBackground: DBaseBackground,
        DBaseBorderMeshGeometry: DBaseBorderMeshGeometry,
        DBaseBorderMesh: DBaseBorderMesh,
        DBaseBorderSnippet: DBaseBorderSnippet,
        DBaseBorder: DBaseBorder,
        DBaseCorner: DBaseCorner,
        DBaseInteractive: DBaseInteractive,
        DBaseMeshGeometry: DBaseMeshGeometry,
        DBaseOutlineSnippet: DBaseOutlineSnippet,
        DBaseOutline: DBaseOutline,
        DBaseOverflowMaskSimple: DBaseOverflowMaskSimple,
        DBaseOverflowMask: DBaseOverflowMask,
        DBasePaddingAdjustable: DBasePaddingAdjustable,
        DBasePadding: DBasePadding,
        DBasePoint: DBasePoint,
        DBaseReflowableContainer: DBaseReflowableContainer,
        DBaseReflowableImpl: DBaseReflowableImpl,
        DBaseSnippetContainer: DBaseSnippetContainer,
        DBaseStateSetBlinkerDatumImpl: DBaseStateSetBlinkerDatumImpl,
        DBaseStateSetBlinkerImpl: DBaseStateSetBlinkerImpl,
        DBaseStateSetImplObservable: DBaseStateSetImplObservable,
        DBaseStateSetImpl: DBaseStateSetImpl,
        DBaseStateSetSubDatumImp: DBaseStateSetSubDatumImp,
        DBaseStateSetSubImpl: DBaseStateSetSubImpl,
        DBaseStateSetTickerDatumImpl: DBaseStateSetTickerDatumImpl,
        DBaseStateSetTickerImpl: DBaseStateSetTickerImpl,
        DBaseState: DBaseState,
        DBase: DBase,
        DBoard: DBoard,
        DBorderMask: DBorderMask,
        DButtonAmbient: DButtonAmbient,
        DButtonBaseWhen: DButtonBaseWhen,
        DButtonBase: DButtonBase,
        DButtonCheckRight: DButtonCheckRight,
        DButtonCheck: DButtonCheck,
        DButtonColorGradient: DButtonColorGradient,
        DButtonColor: DButtonColor,
        DButtonDanger: DButtonDanger,
        DButtonDate: DButtonDate,
        DButtonDatetime: DButtonDatetime,
        DButtonFileAs: UtilFileAs,
        DButtonFile: DButtonFile,
        DButtonGroup: DButtonGroup,
        DButtonLink: DButtonLink,
        DButtonPrimary: DButtonPrimary,
        DButtonRadioRight: DButtonRadioRight,
        DButtonRadio: DButtonRadio,
        DButtonRedo: DButtonRedo,
        DButtonSecondary: DButtonSecondary,
        DButtonSelect: DButtonSelect,
        DButtonTime: DButtonTime,
        DButtonUndo: DButtonUndo,
        DButton: DButton,
        DCanvasContainer: DCanvasContainer,
        DCanvas: DCanvas,
        DChartAxisBaseBar: DChartAxisBaseBar,
        DChartAxisBaseGuideContainer: DChartAxisBaseGuideContainer,
        DChartAxisBaseOptionParser: DChartAxisBaseOptionParser,
        DChartAxisBaseTickContainer: DChartAxisBaseTickContainer,
        DChartAxisBaseTickMajorGridline: DChartAxisBaseTickMajorGridline,
        DChartAxisBaseTickMajor: DChartAxisBaseTickMajor,
        DChartAxisBaseTickMinor: DChartAxisBaseTickMinor,
        DChartAxisBase: DChartAxisBase,
        DChartAxisContainerImpl: DChartAxisContainerImpl,
        DChartAxisGuideSimpleShapeImpl: DChartAxisGuideSimpleShapeImpl,
        DChartAxisGuideSimple: DChartAxisGuideSimple,
        DChartAxisPosition: DChartAxisPosition,
        DChartAxisTickPosition: DChartAxisTickPosition,
        DChartAxisXDatetime: DChartAxisXDatetime,
        DChartAxisX: DChartAxisX,
        DChartAxisY: DChartAxisY,
        DChartColorSet1: DChartColorSet1,
        DChartColorSet2: DChartColorSet2,
        DChartCoordinateBase: DChartCoordinateBase,
        DChartCoordinateContainerImpl: DChartCoordinateContainerImpl,
        DChartCoordinateContainerSubImpl: DChartCoordinateContainerSubImpl,
        DChartCoordinateDirection: DChartCoordinateDirection,
        DChartCoordinateLinearTick: DChartCoordinateLinearTick,
        DChartCoordinateLinear: DChartCoordinateLinear,
        DChartCoordinateLogTick: DChartCoordinateLogTick,
        DChartCoordinateLog: DChartCoordinateLog,
        DChartCoordinateTransformImpl: DChartCoordinateTransformImpl,
        DChartCoordinateTransformMarkImpl: DChartCoordinateTransformMarkImpl,
        DChartLegendItem: DChartLegendItem,
        DChartLegend: DChartLegend,
        DChartOverview: DChartOverview,
        DChartPlotAreaBase: DChartPlotAreaBase,
        DChartPlotAreaContainer: DChartPlotAreaContainer,
        DChartPlotAreaOnefold: DChartPlotAreaOnefold,
        DChartPlotAreaTwofoldAxisContainer: DChartPlotAreaTwofoldAxisContainer,
        DChartPlotAreaTwofoldCoorinateContainerSub: DChartPlotAreaTwofoldCoorinateContainerSub,
        DChartPlotAreaTwofoldCoorinateContainer: DChartPlotAreaTwofoldCoorinateContainer,
        DChartPlotAreaTwofoldOverflowMaskPrimary: DChartPlotAreaTwofoldOverflowMaskPrimary,
        DChartPlotAreaTwofoldOverflowMaskSecondary: DChartPlotAreaTwofoldOverflowMaskSecondary,
        DChartPlotAreaTwofoldSeriesContainer: DChartPlotAreaTwofoldSeriesContainer,
        DChartPlotAreaTwofoldSubBase: DChartPlotAreaTwofoldSubBase,
        DChartPlotAreaTwofoldSubPrimary: DChartPlotAreaTwofoldSubPrimary,
        DChartPlotAreaTwofoldSubSecondary: DChartPlotAreaTwofoldSubSecondary,
        DChartPlotAreaTwofoldViewTargetPoint: DChartPlotAreaTwofoldViewTargetPoint,
        DChartPlotAreaTwofoldViewTarget: DChartPlotAreaTwofoldViewTarget,
        DChartPlotAreaTwofold: DChartPlotAreaTwofold,
        DChartRegionImplObservable: DChartRegionImplObservable,
        DChartRegionImpl: DChartRegionImpl,
        DChartSelectionContainerImpl: DChartSelectionContainerImpl,
        DChartSelectionGridlineX: DChartSelectionGridlineX,
        DChartSelectionGridlineY: DChartSelectionGridlineY,
        DChartSelectionMarker: DChartSelectionMarker,
        DChartSelectionShapeBase: DChartSelectionShapeBase,
        DChartSelectionSimple: DChartSelectionSimple,
        DChartSelectionSubImpl: DChartSelectionSubImpl,
        DChartSelectionPoint: DChartSelectionPoint,
        DChartSeriesBar: DChartSeriesBar,
        DChartSeriesBaseCoordinateContainer: DChartSeriesBaseCoordinateContainer,
        DChartSeriesBase: DChartSeriesBase,
        DChartSeriesContainerImpl: DChartSeriesContainerImpl,
        DChartSeriesFillComputedImpl: DChartSeriesFillComputedImpl,
        DChartSeriesFillImpl: DChartSeriesFillImpl,
        DChartSeriesLineOfAny: DChartSeriesLineOfAny,
        DChartSeriesLineOfCircles: DChartSeriesLineOfCircles,
        DChartSeriesLineOfRectangleRoundeds: DChartSeriesLineOfRectangleRoundeds,
        DChartSeriesLineOfRectangles: DChartSeriesLineOfRectangles,
        DChartSeriesLineOfTriangleRoundeds: DChartSeriesLineOfTriangleRoundeds,
        DChartSeriesLineOfTriangles: DChartSeriesLineOfTriangles,
        DChartSeriesLine: DChartSeriesLine,
        DChartSeriesExpressionParametersImpl: DChartSeriesExpressionParametersImpl,
        DChartSeriesLinear: DChartSeriesLinear,
        DChartSeriesPaddingComputedImpl: DChartSeriesPaddingComputedImpl,
        DChartSeriesPaddingImpl: DChartSeriesPaddingImpl,
        DChartSeriesPointComputedImpl: DChartSeriesPointComputedImpl,
        DChartSeriesPointImpl: DChartSeriesPointImpl,
        DChartSeriesScalars: DChartSeriesScalars,
        DChartSeriesStrokeComputedImpl: DChartSeriesStrokeComputedImpl,
        DChartSeriesStrokeImpl: DChartSeriesStrokeImpl,
        DChartSeriesHitResult: DChartSeriesHitResult,
        DChart: DChart,
        DColorGradientObservable: DColorGradientObservable,
        DColorGradientPointObservable: DColorGradientPointObservable,
        DColorRecent: DColorRecent,
        DColorRecents: DColorRecents,
        DColorStandard: DColorStandard,
        DColorStandards: DColorStandards,
        DColorType: DColorType,
        DCommandBase: DCommandBase,
        DCommandClear: DCommandClear,
        DCommandCreate: DCommandCreate,
        DCommandSaveAs: DCommandSaveAs,
        DCommandSave: DCommandSave,
        DContent: DContent,
        DControllerCommandImpl: DControllerCommandImpl,
        DControllerFocusImpl: DControllerFocusImpl,
        DControllerKeyboardImpl: DControllerKeyboardImpl,
        DControllers: DControllers,
        DCornerMask: DCornerMask,
        DDiagramBaseControllerOpenType: DDiagramBaseControllerOpenType,
        DDiagramBase: DDiagramBase,
        DDiagramCanvasBase: DDiagramCanvasBase,
        DDiagramCanvasBaseShapeImpl: DDiagramCanvasBaseShapeImpl,
        DDiagramCanvasDataImpl: DDiagramCanvasDataImpl,
        DDiagramCanvasEditorBackground: DDiagramCanvasEditorBackground,
        DDiagramCanvasEditorShapeImpl: DDiagramCanvasEditorShapeImpl,
        DDiagramCanvasEditorSnap: DDiagramCanvasEditorSnap,
        DDiagramCanvasEditor: DDiagramCanvasEditor,
        DDiagramCanvasTileMappingImpl: DDiagramCanvasTileMappingImpl,
        DDiagramCanvasTileMappingPointImpl: DDiagramCanvasTileMappingPointImpl,
        DDiagramCanvasShapeImpl: DDiagramCanvasShapeImpl,
        DDiagramCanvasTickerImpl: DDiagramCanvasTickerImpl,
        DDiagramCanvasTile: DDiagramCanvasTile,
        DDiagramCanvas: DDiagramCanvas,
        DDiagramDataImpl: DDiagramDataImpl,
        DDiagramDataPrivateImpl: DDiagramDataPrivateImpl,
        DDiagramDataRemoteImpl: DDiagramDataRemoteImpl,
        DDiagramEditorThumbnail: DDiagramEditorThumbnail,
        DDiagramEditor: DDiagramEditor,
        DDiagramLayerContainer: DDiagramLayerContainer,
        DDiagramLayer: DDiagramLayer,
        DDiagramLayers: DDiagramLayers,
        DDiagramSerializedVersion: DDiagramSerializedVersion,
        DDiagramShape: DDiagramShape,
        DDiagramSnapshot: DDiagramSnapshot,
        DDiagramTicker: DDiagramTicker,
        DDiagram: DDiagram,
        DDiagrams: DDiagrams,
        DDialogAlign: UtilAttachAlign,
        DDialogCloseOn: DDialogCloseOn,
        DDialogColorGradient: DDialogColorGradient,
        DDialogColor: DDialogColor,
        DDialogConfirmDelete: DDialogConfirmDelete,
        DDialogConfirmDiscard: DDialogConfirmDiscard,
        DDialogConfirmMessage: DDialogConfirmMessage,
        DDialogConfirm: DDialogConfirm,
        DDialogDate: DDialogDate,
        DDialogDatetime: DDialogDatetime,
        DDialogFittedContent: DDialogFittedContent,
        DDialogFitted: DDialogFitted,
        DDialogGestureImpl: DDialogGestureImpl,
        DDialogGestureMode: DDialogGestureMode,
        DDialogInputBoolean: DDialogInputBoolean,
        DDialogInputInteger: DDialogInputInteger,
        DDialogInputReal: DDialogInputReal,
        DDialogInputText: DDialogInputText,
        DDialogInput: DDialogInput,
        DDialogLayeredContent: DDialogLayeredContent,
        DDialogLayeredFooter: DDialogLayeredFooter,
        DDialogLayeredHeaderButtonClose: DDialogLayeredHeaderButtonClose,
        DDialogLayeredHeaderSeparator: DDialogLayeredHeaderSeparator,
        DDialogLayeredHeader: DDialogLayeredHeader,
        DDialogLayered: DDialogLayered,
        DDialogMessage: DDialogMessage,
        DDialogMode: DDialogMode,
        DDialogProcessingMessage: DDialogProcessingMessage,
        DDialogProcessing: DDialogProcessing,
        DDialogSaveAs: DDialogSaveAs,
        DDialogSelectListItemUpdater: DDialogSelectListItemUpdater,
        DDialogSelectListItem: DDialogSelectListItem,
        DDialogSelectList: DDialogSelectList,
        DDialogSelectSearhImpl: DDialogSelectSearhImpl,
        DDialogSelect: DDialogSelect,
        DDialogState: DDialogState,
        DDialogTime: DDialogTime,
        DDialog: DDialog,
        DDropdownBase: DDropdownBase,
        DDropdown: DDropdown,
        DDynamicTextGeometry: DDynamicTextGeometry,
        DDynamicTextMeasureResultCharacter: DDynamicTextMeasureResultCharacter,
        DDynamicTextMeasureResult: DDynamicTextMeasureResult,
        DDynamicTextMeasure: DDynamicTextMeasure,
        DDynamicTextStyleWordWrap: DDynamicTextStyleWordWrap,
        DDynamicTextStyle: DDynamicTextStyle,
        DDynamicText: DDynamicText,
        DExpandableHeader: DExpandableHeader,
        DExpandable: DExpandable,
        DHtmlElementState: DHtmlElementState,
        DHtmlElement: DHtmlElement,
        DImageBaseThemeWrapperOther: DImageBaseThemeWrapperOther,
        DImageBaseThemeWrapperSecondary: DImageBaseThemeWrapperSecondary,
        DImageBaseThemeWrapperTertiary: DImageBaseThemeWrapperTertiary,
        DImageBase: DImageBase,
        DImagePieceAlignImpl: DImagePieceAlignImpl,
        DImagePieceContainerImpl: DImagePieceContainerImpl,
        DImagePieceImpl: DImagePieceImpl,
        DImagePieceLayouterPartBottom: DImagePieceLayouterPartBottom,
        DImagePieceLayouterPartCenter: DImagePieceLayouterPartCenter,
        DImagePieceLayouterPartContainer: DImagePieceLayouterPartContainer,
        DImagePieceLayouterPartLeft: DImagePieceLayouterPartLeft,
        DImagePieceLayouterPartMiddle: DImagePieceLayouterPartMiddle,
        DImagePieceLayouterPartRight: DImagePieceLayouterPartRight,
        DImagePieceLayouterPartTop: DImagePieceLayouterPartTop,
        DImagePieceLayouterPart: DImagePieceLayouterPart,
        DImagePieceLayouter: DImagePieceLayouter,
        DImagePieceMarginImpl: DImagePieceMarginImpl,
        DImagePieceTintImpl: DImagePieceTintImpl,
        DImage: DImage,
        DIndicatorProcessingState: DIndicatorProcessingState,
        DIndicatorProcessing: DIndicatorProcessing,
        DInputAndLabel: DInputAndLabel,
        DInputBooleanButtonOff: DInputBooleanButtonOff,
        DInputBooleanButtonOn: DInputBooleanButtonOn,
        DInputBoolean: DInputBoolean,
        DInputInput: DInputInput,
        DInputIntegerAndLabel: DInputIntegerAndLabel,
        DInputInteger: DInputInteger,
        DInputLabel: DInputLabel,
        DInputNumber: DInputNumber,
        DInputRealAndLabel: DInputRealAndLabel,
        DInputReal: DInputReal,
        DInputSearch: DInputSearch,
        DInputTextAndLabel: DInputTextAndLabel,
        DInputTextArea: DInputTextArea,
        DInputText: DInputText,
        DInput: DInput,
        DItemUpdater: DItemUpdater,
        DLayoutBoard: DLayoutBoard,
        DLayoutClearType: DLayoutClearType,
        DLayoutDirection: DLayoutDirection,
        DLayoutHorizontal: DLayoutHorizontal,
        DLayoutSpace: DLayoutSpace,
        DLayoutVertical: DLayoutVertical,
        DLayout: DLayout,
        DLinkMenuItemId: DLinkMenuItemId,
        DLinkMenu: DLinkMenu,
        DLinkTarget: DLinkTarget,
        DLink: DLink,
        DLinks: DLinks,
        DListDataImpl: DListDataImpl,
        DListDataMappedImpl: DListDataMappedImpl,
        DListDataSelectionMultiple: DListDataSelectionMultiple,
        DListDataSelectionNone: DListDataSelectionNone,
        DListDataSelectionSingle: DListDataSelectionSingle,
        DListDataSelectionType: DListDataSelectionType,
        DListItemAccessorImpl: DListItemAccessorImpl,
        DListItemAmbient: DListItemAmbient,
        DListItemUpdater: DListItemUpdater,
        DListItem: DListItem,
        DList: DList,
        DMapCoordinateEPSG3857: DMapCoordinateEPSG3857,
        DMapCoordinates: DMapCoordinates,
        DMapTilePlane: DMapTilePlane,
        DMapTilePyramidImpl: DMapTilePyramidImpl,
        DMapTileUrlBuilderKokudo: DMapTileUrlBuilderKokudo,
        DMapTileUrlBuilderOsm: DMapTileUrlBuilderOsm,
        DMapTileUrlBuilderOsmfj: DMapTileUrlBuilderOsmfj,
        DMapTilePyramids: DMapTilePyramids,
        DMapTile: DMapTile,
        DMenuAlign: UtilAttachAlign,
        DMenuBarItem: DMenuBarItem,
        DMenuBar: DMenuBar,
        DMenuContext: DMenuContext,
        DMenuItemBase: DMenuItemBase,
        DMenuItemCheckIsCompatible: DMenuItemCheckIsCompatible,
        DMenuItemCheck: DMenuItemCheck,
        DMenuItemExpandableBody: DMenuItemExpandableBody,
        DMenuItemExpandableHeader: DMenuItemExpandableHeader,
        DMenuItemExpandableIsCompatible: DMenuItemExpandableIsCompatible,
        DMenuItemExpandableItemCheck: DMenuItemExpandableItemCheck,
        DMenuItemExpandableItemLink: DMenuItemExpandableItemLink,
        DMenuItemExpandableItemMenu: DMenuItemExpandableItemMenu,
        DMenuItemExpandableItemSeparator: DMenuItemExpandableItemSeparator,
        DMenuItemExpandableItemSpace: DMenuItemExpandableItemSpace,
        DMenuItemExpandableItemText: DMenuItemExpandableItemText,
        DMenuItemExpandable: DMenuItemExpandable,
        DMenuItemExpandables: DMenuItemExpandables,
        DMenuItemLinkIsCompatible: DMenuItemLinkIsCompatible,
        DMenuItemLink: DMenuItemLink,
        DMenuItemMenuIsCompatible: DMenuItemMenuIsCompatible,
        DMenuItemMenuToSubMenuOptions: DMenuItemMenuToSubMenuOptions,
        DMenuItemMenu: DMenuItemMenu,
        DMenuItemSeparatorReflowable: DMenuItemSeparatorReflowable,
        DMenuItemSeparatorIsCompatible: DMenuItemSeparatorIsCompatible,
        DMenuItemSeparator: DMenuItemSeparator,
        DMenuItemSpaceIsCompatible: DMenuItemSpaceIsCompatible,
        DMenuItemSpace: DMenuItemSpace,
        DMenuItemText: DMenuItemText,
        DMenuItem: DMenuItem,
        DMenuItems: DMenuItems,
        DMenuSidedContent: DMenuSidedContent,
        DMenuSidedItemCheck: DMenuSidedItemCheck,
        DMenuSidedItemExpandableItemCheck: DMenuSidedItemExpandableItemCheck,
        DMenuSidedItemExpandableItemLink: DMenuSidedItemExpandableItemLink,
        DMenuSidedItemExpandableItemMenu: DMenuSidedItemExpandableItemMenu,
        DMenuSidedItemExpandableItemSeparator: DMenuSidedItemExpandableItemSeparator,
        DMenuSidedItemExpandableItemSpace: DMenuSidedItemExpandableItemSpace,
        DMenuSidedItemExpandableItemText: DMenuSidedItemExpandableItemText,
        DMenuSidedItemExpandable: DMenuSidedItemExpandable,
        DMenuSidedItemExpandables: DMenuSidedItemExpandables,
        DMenuSidedItemLink: DMenuSidedItemLink,
        DMenuSidedItemMenu: DMenuSidedItemMenu,
        DMenuSidedItemSeparator: DMenuSidedItemSeparator,
        DMenuSidedItemSpace: DMenuSidedItemSpace,
        DMenuSidedItemText: DMenuSidedItemText,
        DMenuSidedSelectionType: DMenuSidedSelectionType,
        DMenuSidedSelection: DMenuSidedSelection,
        DMenuSided: DMenuSided,
        DMenuSideds: DMenuSideds,
        DMenu: DMenu,
        DMenus: DMenus,
        DNoteError: DNoteError,
        DNoteNoItemsFound: DNoteNoItemsFound,
        DNoteSearching: DNoteSearching,
        DNoteSmallError: DNoteSmallError,
        DNoteSmallNoItemsFound: DNoteSmallNoItemsFound,
        DNoteSmallSearching: DNoteSmallSearching,
        DNoteSmall: DNoteSmall,
        DNote: DNote,
        DNotification: DNotification,
        DPaginationButtonLast: DPaginationButtonLast,
        DPaginationButtonNext: DPaginationButtonNext,
        DPaginationButtonPage: DPaginationButtonPage,
        DPaginationButtonPrevious: DPaginationButtonPrevious,
        DPaginationButtonTop: DPaginationButtonTop,
        DPaginationDots: DPaginationDots,
        DPaginationPage: DPaginationPage,
        DPagination: DPagination,
        DPaneScrollBar: DPaneScrollBar,
        DPane: DPane,
        DPickerColorAndAlpha: DPickerColorAndAlpha,
        DPickerColorGradientRecent: DPickerColorGradientRecent,
        DPickerColorGradientView: DPickerColorGradientView,
        DPickerColorGradient: DPickerColorGradient,
        DPickerColor: DPickerColor,
        DPickerDate: DPickerDate,
        DPickerDates: DPickerDates,
        DPickerDatetimeButtonBack: DPickerDatetimeButtonBack,
        DPickerDatetimeButtonDate: DPickerDatetimeButtonDate,
        DPickerDatetimeButtonNext: DPickerDatetimeButtonNext,
        DPickerDatetimeLabelDate: DPickerDatetimeLabelDate,
        DPickerDatetimeLabel: DPickerDatetimeLabel,
        DPickerDatetimeMask: DPickerDatetimeMask,
        DPickerDatetimeMasks: DPickerDatetimeMasks,
        DPickerDatetimeRange: DPickerDatetimeRange,
        DPickerDatetimeSpace: DPickerDatetimeSpace,
        DPickerDatetime: DPickerDatetime,
        DPickerDatetimes: DPickerDatetimes,
        DPickerTimeBoundHours: DPickerTimeBoundHours,
        DPickerTimeBoundMinutes: DPickerTimeBoundMinutes,
        DPickerTimeBoundSeconds: DPickerTimeBoundSeconds,
        DPickerTimeBound: DPickerTimeBound,
        DPickerTimeBounds: DPickerTimeBounds,
        DPickerTimeRange: DPickerTimeRange,
        DPickerTime: DPickerTime,
        DPickerTimes: DPickerTimes,
        DScalarExpressionNodeType: DScalarExpressionNodeType,
        DScalarExpression: DScalarExpression,
        DScalarFunctions: DScalarFunctions,
        DScrollBarHorizontal: DScrollBarHorizontal,
        DScrollBarThumbHorizontal: DScrollBarThumbHorizontal,
        DScrollBarThumbReflowableHorizontal: DScrollBarThumbReflowableHorizontal,
        DScrollBarThumbReflowableVertical: DScrollBarThumbReflowableVertical,
        DScrollBarThumbVertical: DScrollBarThumbVertical,
        DScrollBarThumb: DScrollBarThumb,
        DScrollBarVertical: DScrollBarVertical,
        DScrollBar: DScrollBar,
        DSelectMultiple: DSelectMultiple,
        DSelect: DSelect,
        DShadowImpl: DShadowImpl,
        DSliderHorizontal: DSliderHorizontal,
        DSliderLabel: DSliderLabel,
        DSliderThumb: DSliderThumb,
        DSliderTrackHorizontal: DSliderTrackHorizontal,
        DSliderTrackVertical: DSliderTrackVertical,
        DSliderTrack: DSliderTrack,
        DSliderValue: DSliderValue,
        DSliderVertical: DSliderVertical,
        DSlider: DSlider,
        DTableBodyCellActionDialog: DTableBodyCellActionDialog,
        DTableBodyCellActionMenu: DTableBodyCellActionMenu,
        DTableBodyCellActionPromise: DTableBodyCellActionPromise,
        DTableBodyCellButton: DTableBodyCellButton,
        DTableBodyCellCheck: DTableBodyCellCheck,
        DTableBodyCellColor: DTableBodyCellColor,
        DTableBodyCellDate: DTableBodyCellDate,
        DTableBodyCellDatetime: DTableBodyCellDatetime,
        DTableBodyCellIndex: DTableBodyCellIndex,
        DTableBodyCellInputInteger: DTableBodyCellInputInteger,
        DTableBodyCellInputReal: DTableBodyCellInputReal,
        DTableBodyCellInputTextArea: DTableBodyCellInputTextArea,
        DTableBodyCellInputText: DTableBodyCellInputText,
        DTableBodyCellInputTreeInput: DTableBodyCellInputTreeInput,
        DTableBodyCellInputTreeMarker: DTableBodyCellInputTreeMarker,
        DTableBodyCellInputTree: DTableBodyCellInputTree,
        toLinkOptions: toLinkOptions,
        toUrl: toUrl,
        toChecker: toChecker,
        DTableBodyCellLink: DTableBodyCellLink,
        DTableBodyCellSelectDialog: DTableBodyCellSelectDialog,
        DTableBodyCellSelectMenu: DTableBodyCellSelectMenu,
        DTableBodyCellSelectMultiple: DTableBodyCellSelectMultiple,
        DTableBodyCellSelectPromise: DTableBodyCellSelectPromise,
        DTableBodyCellTextArea: DTableBodyCellTextArea,
        DTableBodyCellText: DTableBodyCellText,
        DTableBodyCellTime: DTableBodyCellTime,
        DTableBodyCellTree: DTableBodyCellTree,
        DTableBodyCells: DTableBodyCells,
        DTableBodyRow: DTableBodyRow,
        DTableBody: DTableBody,
        DTableCategoryCell: DTableCategoryCell,
        DTableCategoryColumnImpl: DTableCategoryColumnImpl,
        DTableCategoryContainerImpl: DTableCategoryContainerImpl,
        DTableCategory: DTableCategory,
        DTableCellEdgeHovered: DTableCellEdgeHovered,
        DTableCellEdge: DTableCellEdge,
        DTableColumnContainerImpl: DTableColumnContainerImpl,
        DTableColumnImpl: DTableColumnImpl,
        DTableColumnType: DTableColumnType,
        DTableColumnUpdate: DTableColumnUpdate,
        DTableDataListFilter: DTableDataListFilter,
        DTableDataListMapped: DTableDataListMapped,
        DTableDataListSelection: DTableDataListSelection,
        DTableDataListSorter: DTableDataListSorter,
        DTableDataList: DTableDataList,
        DTableDataSelectionType: DTableDataSelectionType,
        DTableDataOrder: DTableDataOrder,
        DTableDataTreeFilter: DTableDataTreeFilter,
        DTableDataTreeItemAccessor: DTableDataTreeItemAccessor,
        DTableDataTreeSelectionImpl: DTableDataTreeSelectionImpl,
        DTableDataTreeSorter: DTableDataTreeSorter,
        DTableDataTree: DTableDataTree,
        DTableHeaderCellCheck: DTableHeaderCellCheck,
        DTableHeaderCell: DTableHeaderCell,
        DTableHeader: DTableHeader,
        DTableRow: DTableRow,
        DTableScrollBar: DTableScrollBar,
        DTableState: DTableState,
        DTable: DTable,
        DTextBase: DTextBase,
        DTextPieceAlignImpl: DTextPieceAlignImpl,
        DTextPieceImpl: DTextPieceImpl,
        DTextPieceStyleImpl: DTextPieceStyleImpl,
        DText: DText,
        DTreeDataImpl: DTreeDataImpl,
        DTreeDataMappedImpl: DTreeDataMappedImpl,
        DTreeDataSelectionMultiple: DTreeDataSelectionMultiple,
        DTreeDataSelectionNone: DTreeDataSelectionNone,
        DTreeDataSelectionSingle: DTreeDataSelectionSingle,
        DTreeDataSelectionType: DTreeDataSelectionType,
        DTreeItemButton: DTreeItemButton,
        DTreeItemNonEditable: DTreeItemNonEditable,
        DTreeItemState: DTreeItemState,
        DTreeItemText: DTreeItemText,
        DTreeItemUpdater: DTreeItemUpdater,
        DTreeNodeAccessorImpl: DTreeNodeAccessorImpl,
        DTree: DTree,
        DViewGestureImpl: DViewGestureImpl,
        DViewImpl: DViewImpl,
        DViewTransformImpl: DViewTransformImpl
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    loadAll();
    var global = window;
    global.wcardinal = global.wcardinal || {};
    global.wcardinal.ui = ui;

})(PIXI);
