<!--
 Copyright (C) 2019 Toshiba Corporation
 SPDX-License-Identifier: Apache-2.0
-->

<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Straight Skeleton Buffer</title>
	<style>
	html, body {
		display: flex;
		flex-direction: column;
		width: 100%;
		height: 100%;
		margin: 0;
		padding: 0;
		background-color: #eeeeee;
	}

	canvas {
		display: block;
		padding: 0;
		margin: 0;
		width: 100%;
		height: 100%;
	}

	hit-point {
		display: block;
		position: absolute;
		x: 0;
		y: 0;
		width: 24px;
		height: 24px;
		background: #3388ff99;
		border: none;
		padding: 0;
		margin: 0;
		border-radius: 50%;
		cursor: pointer;
	}

	hit-point.hidden {
		display: none;
	}
	</style>
</head>
<body>
	<canvas></canvas>
	<hit-point class="hidden"></hit-point>
	<script src="../../js/pixi/latest/pixi.min.js"></script>
	<script src="../../js/wcardinal-ui/latest/wcardinal-ui.min.js"></script>
	<script src="../../js/wcardinal-ui/latest/wcardinal-ui-theme-white.min.js"></script>
	<script>
	(() => {
		"use strict";

		const EDGE_COLOR = "#666";
		const EDGE_STROKE_WIDTH = 1;
		const EDGE_STROKE_JOIN = "round";
		const EDGE_STROKE_DASH = [];
		const VERTEX_COLOR = "#3388ff99";
		const VERTEX_SIZE = 4;
		const VERTEX_HIT_AREA = 12 * 12;
		const LEVEL = -1;

		const renderBuffer = (settings, buffer) => {
			const ctx = settings.ctx;
			ctx.save();
			ctx.translate(settings.cx, settings.cy);
			ctx.scale(settings.dpr, settings.dpr);

			const vertices = buffer.vertices;
			const verticesLength = vertices.length;
			const indices = buffer.indices;
			const indicesLength = indices.length;
			if (3 <= indicesLength) {
				ctx.lineWidth = EDGE_STROKE_WIDTH;
				ctx.lineJoin = EDGE_STROKE_JOIN;
				ctx.strokeStyle = EDGE_COLOR;
				ctx.setLineDash(EDGE_STROKE_DASH);
				for (let i = 0; i < indicesLength; i += 3) {
					ctx.beginPath();
					const i0 = indices[i];
					const i1 = indices[i + 1];
					const i2 = indices[i + 2];
					const iv0 = i0 << 1;
					const iv1 = i1 << 1;
					const iv2 = i2 << 1;
					ctx.moveTo(vertices[iv0], vertices[iv0 + 1]);
					ctx.lineTo(vertices[iv1], vertices[iv1 + 1]);
					ctx.lineTo(vertices[iv2], vertices[iv2 + 1]);
					ctx.closePath();
					ctx.stroke();
				}
			}

			// Vertices
			const distances = buffer.distances;
			let mdistance = 0;
			for (let i = 0; i < verticesLength; i += 2) {
				mdistance = Math.max(mdistance, distances[i]);
			}
			let fdistance = 0 < mdistance ? 1 / mdistance : 1;
			for (let i = 0; i < verticesLength; i += 2) {
				const rdistance = distances[i] * fdistance;
				const size = VERTEX_SIZE * rdistance;
				ctx.fillStyle = VERTEX_COLOR;
				ctx.beginPath();
				ctx.ellipse(vertices[i], vertices[i + 1], size, size, 0, 0, 2 * Math.PI);
				ctx.fill();
			}

			// Done
			ctx.restore();
		};

		const render = (settings, buffer) => {
			const canvas = settings.canvas;
			const bbox = canvas.getBoundingClientRect();
			const dpr = window.devicePixelRatio;
			settings.dpr = dpr;
			const w = bbox.width * dpr;
			const h = bbox.height * dpr;
			settings.x = bbox.x;
			settings.y = bbox.y;
			settings.w = w;
			settings.h = h;
			settings.cx = w * 0.5;
			settings.cy = h * 0.5;
			canvas.setAttribute("width", `${w}px`);
			canvas.setAttribute("height", `${h}px`);
			settings.ctx.clearRect(0, 0, w, h);
			renderBuffer(settings, buffer);
		};

		const hitTest = (x, y, points, result) => {
			const p = points;
			const pl = p.length;
			for (let i = 0; i < pl; i += 2) {
				const dx = x - p[i];
				const dy = y - p[i + 1];
				const d = dx * dx + dy * dy;
				if (d <= VERTEX_HIT_AREA) {
					if (result.points == null || d < result.d) {
						result.d = d;
						result.points = points;
						result.i = i;
						result.x = p[i];
						result.y = p[i + 1];
					}
				}
			}
		};

		const canvas = document.querySelector("canvas");
		const hitPoint = document.querySelector("hit-point");
		const ctx = canvas.getContext("2d");
		const points = [0, -100, -100, -50, -50, 0, -100, 50, 0, 100, 100, 50, 50, 0, 155.333, -52];
		let buffer = wcardinal.ui.UtilStraightSkeletonBuffer.from(wcardinal.ui.UtilStraightSkeleton.from(points, LEVEL));
		const hitTestResult = {
			d: 0,
			points: null,
			i: -1,
			x: 0,
			y: 0,
			tx: 0,
			ty: 0
		};

		const settings = {
			canvas: canvas,
			ctx: ctx,
			x: 0,
			y: 0,
			w: 0,
			h: 0,
			cx: 0,
			cy: 0,
			dpr: 1
		};

		canvas.addEventListener("mousemove", (e) => {
			const s = settings.dpr;
			const x = ((e.clientX - settings.x) * s - settings.cx) / s;
			const y = ((e.clientY - settings.y) * s - settings.cy) / s;
			hitTestResult.points = null;
			hitTest(x, y, points, hitTestResult);
			if (hitTestResult.points != null) {
				const tx = (settings.cx + hitTestResult.x * s) / s + settings.x;
				const ty = (settings.cy + hitTestResult.y * s) / s + settings.y;
				hitTestResult.tx = tx;
				hitTestResult.ty = ty;
				hitPoint.style.transform = `translate(${tx}px,${ty}px) translate(-50%,-50%)`;
				hitPoint.classList.remove("hidden");
			} else {
				hitPoint.classList.add("hidden");
			}
		});

		const dragging = {
			isExecuting: false,
			pointerId: null,
			x: 0,
			y: 0
		};
		const move = (tx, ty) => {
			const i = hitTestResult.i;
			const s = settings.dpr;
			const x = ((tx - settings.x) * s - settings.cx) / s;
			const y = ((ty - settings.y) * s - settings.cy) / s;
			points[i] = x;
			points[i + 1] = y;
			console.log("points", points);
			buffer = wcardinal.ui.UtilStraightSkeletonBuffer.from(wcardinal.ui.UtilStraightSkeleton.from(points, LEVEL));
			render(settings, buffer);
		};
		const onPointerMove = (e) => {
			if (dragging.isExecuting) {
				const tx = hitTestResult.tx + (e.clientX - dragging.x);
				const ty = hitTestResult.ty + (e.clientY - dragging.y);
				hitPoint.style.transform = `translate(${tx}px,${ty}px) translate(-50%,-50%)`;
				setTimeout(() => {
					move(tx, ty);
				}, 0);
			}
		};
		const onPointerUp = (e) => {
			if (dragging.isExecuting) {
				dragging.isExecuting = false;
				const tx = hitTestResult.tx + (e.clientX - dragging.x);
				const ty = hitTestResult.ty + (e.clientY - dragging.y);
				hitPoint.style.transform = `translate(${tx}px,${ty}px) translate(-50%,-50%)`;
				hitPoint.classList.add("hidden");
				hitPoint.releasePointerCapture(dragging.pointerId);
				hitPoint.removeEventListener("pointermove", onPointerMove);
				hitPoint.removeEventListener("pointerup", onPointerUp);
				hitPoint.removeEventListener("pointercancel", onPointerUp);
				setTimeout(() => {
					move(tx, ty);
				}, 0);
			}
		};
		hitPoint.addEventListener("pointerdown", (e) => {
			if (!dragging.isExecuting && hitTestResult.points != null) {
				dragging.isExecuting = true;
				dragging.pointerId = e.pointerId;
				dragging.x = e.clientX;
				dragging.y = e.clientY;
				const tx = hitTestResult.tx;
				const ty = hitTestResult.ty;
				hitPoint.style.transform = `translate(${tx}px,${ty}px) translate(-50%,-50%)`;
				hitPoint.classList.remove("hidden");
				hitPoint.setPointerCapture(e.pointerId);
				hitPoint.addEventListener("pointermove", onPointerMove);
				hitPoint.addEventListener("pointerup", onPointerUp);
				hitPoint.addEventListener("pointercancel", onPointerUp);
			}
		});

		render(settings, buffer);
		new ResizeObserver(() => {
			setTimeout(() => {
				render(settings, buffer);
			}, 0);
		}).observe(canvas);
	})();
	</script>
</body>
</html>
